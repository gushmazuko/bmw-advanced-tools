ecu      : Antriebselektronik;
origin   : BMW EA-412 Flach;
revision : 0.518;
author   : MicroNovaAG EA-412 Flach, IST RD-51 Thoma;
comment  : AE [6];

// *******************************************************************
// SGBD-Info:
// SGBD-Erstellung: SGBD-Generator, Version 5.5.2
// Muster-SGBD: Muster_UDS.xml, Version 5.1.6
// BEST-Runtime-Library: B2Runtim.lib, Version 2.14
// BEST-BMW-Library: B2BMW.lib, Version 2.25
// Standard-Includes: UDS_PACKAGE.b2s, Version: 1.25
// ODX-Daten: ODX-Konverter, Version 3.3.0_b01
// -------------------------------------------------------------------
// allgemeine Lastenhefte:
// Lastenheft Diagnose Ausgabe 08
// -------------------------------------------------------------------
// SG-spezifische Lastenhefte:
// -------------------------------------------------------------------
// History: 
// 10.02.2010 mf  V0.001 Ersterstellung
// 27.05.2010 mf  V0.002 +Montagemodus, +_Status_Build_Id
// 08.06.2010 mf  V0.003 bugfix fs_lesen_detail, UWD für Parksperre-Jobs, +_status_build_id
// 10.06.2010 mf  V0.004 +_status_build_id (jobHeaderFormat)
// 17.06.2010 mf  V0.005 change UWD für Parksperre
// 25.06.2010 mf  V0.006 DTCs für DAQ
// 28.06.2010 mf  V0.007 neuer Export von Zedis (DiagJobs)
// 01.07.2010 mf  V0.008 DTCs für DCDC
// 07.07.2010 mf  V0.009 DTCs++ CAN
// 14.07.2010 mf  V0.010 DTCs++ ELUP, FUSI, CAN
// 27.07.2010 mf  V0.011 Energiesparmode DTC vom SC
// 06.08.2010 mf  V0.012 DTCs++ DAQ
// 12.08.2010 mf  V0.013 DTCs++ DAQ; Änderung MontageModus
// 25.08.2010 mf  V0.014 DTCs++ HVSM
// 16.09.2010 mf  V0.015 DTCs++ DAQ
// 04.10.2010 mf  V0.016 DTCs++ Ebende3 + PS
// 08.10.2010 mf  V0.017 DTCs++ HVSM
// 10.11.2010 mf  V0.018 ++Parksperren-Jobs, Anpassung Rohsignal-Jobs, ++REN-DTC, Beschreibungsänderung für DAQ-DTCs
// 24.11.2010 mf  V0.019 ++AEPH
// 08.12.1010 mf  V0.020 ++EM-Fehler
// 09.12.2010 mf  V0.021 Umweltdatensaetze angepasst
// 21.12.2010 mf  V0.200 DTCs B2-Muster
// 17.01.2011 mf  V0.201 ++Bauteilschutz-DTCs; ++DAQ-SPI; --B1-Muster DAQ-DTCs
// 18.01.2011 mf  V0.202 ++DAQ-SPI
// 20.01.2011 mf  V0.203 ++status_ews
// 21.01.2011 mf  V0.204 ++DTCs Sammel DAQ, SPI DCDC/SLE, EWS
// 24.01.2011 mf  V0.205 ++bugfix status_ews, ++hwcal-jobs
// 26.01.2011 mf  V0.206 ++Qual-DTCs, bugfix hwcal-jobs
// 25.02.2011 mf  V0.207 ++DTCs; cahnge status_elup etc.
// 03.03.2011 mf  V0.208 change _status_build_id
// 03.03.2011 mf  V0.209 bugifx "removeJob"-Fehlermeldung eliminiert
// 04.03.2011 mf  V0.210 +_status_hwcal_lesen
// 14.03.2011 mf  V0.211 anpassung hwcal_jobs
// 21.03.2011 mf  V0.212 +HVIL-DTCs, + ELUP-DTC
// 28.03.2011 mf  V0.213 +DiagJobs (Klassierung, dcdcHistogramm, RLS, CPLD-Version
// 31.03.2011 mf  V0.214 +DTCs Inverter, dcdc, DAQ, HVIL angepasst
// 01.04.2011 mf  V0.215 anpassung _steuern_sn_setzen
// 08.04.2011 mf  V0.216 +DTCs sle, Freilaufmodus + job
// 12.04.2011 mf  V0.300 Umstieg auf REV3 Board, Entfall von DTCs MC6/MC5
// 28.04.2011 mf  V0.301 +DTCsFUSI etc.
// 03.05.2011 mf  V0.302 +DTCs PWR, Reset
// 05.05.2011 mf  V0.303 bugfix Rotorlagesensor Job
// 12.05.2011 mf  V0.304 bugfix Rotorlagesensor Job2
// 19.05.2011 mf  V0.305 +DTCs DCDC, AEPH, -AE_SPANNUNG_12V_POWERBOARD
// 24.05.2011 mf  V0.306 +DTCs HVSM_ZKU
// 26.05.2011 mf  V0.307 +DTCs +Steuern_Aks_Emk - Status_Aks_Emk
// 30.05.2011 mf  V0.308 entfernen der Tabellen *_DOP
// 07.06.2011 mf  V0.309 +DTCs +status_ctrl_lesen
// 20.06.2011 mf  V0.310 bugfix rotorlagesensoranlernen; DTCs vom B1-Muster rausgeworfen
// 27.06.2011 mf  V0.311 +/- HVSM-DTCs, +HWCAL-DTCs, +QualUeberwachung-DTCs
// 06.07.2011 mf  V0.312 change Parksperre_Anlernen (steuern, status)
// 13.07.2011 mf  V0.313 Entschlackung DTCs, new Jobs bzgl. Lebensdauer/BandendeTests
// 18.07.2011 mf  V0.314 +DTCs Parksperre FUSI Infospeicher
// 26.07.2011 mf  V0.315 Erweiterung Job Rotorlagesensor_Anlernen 0x03
// 01.08.2011 mf  V0.500 Branch von 82e -> i01
// 21.09.2011 mf  V0.501 ++REX_ON_OFF
// 28.09.2011 mf  V0.502 ++ HVPM-Jobs, ++DTCs EME_ELUP
// 11.10.2011 mf  V0.503 bugfix STATUS_EWS
// 17.10.2011 mf  V0.504 +FA-CAN Diagnosen
// 25.10.2011 mf  V0.505 +HVPM-DTCs
// 26.10.2011 mf  V0.506 +FIS_PWR_UDQ_CHECK
// 15.11.2011 mf  V0.507 --Umrichter-Jobs, --Crash-Jobs, --einige Kom-Dtcs
// 16.11.2011 mf  V0.508 ++FIS_EM_T2_THRSHLD, FIS_EM_T2_RANGE_H, FIS_EM_T2_RANGE_L
// 09.12.2011 mf  V0.509 ++FIS_HVPM..., FIS_HVSM...
// 14.12.2011 mf  V0.510 ++C0 Fise DAQ
// 16.01.2012 mf  V0.511 ++FIS_FACAN
// 17.01.2012 mf  V0.512 ++Status_fahrstufe
// 02.02.2012 mt  V0.513 ++DTCs Notlaufkonzept, --Histogramm-Jobs
// 02.02.2012 mt  V0.514 ++ HVPM-Jobs, DCDC_Ansteuerung, System_ON_OFF, Spannungsfreiheit
// 21.02.2012 mt  V0.515 bugfix DIAGJobs; SLE_LEISTUNG; SLE_SPANNUNG; BETRIEBSZUSTAND_SLE; CONNECTED_DRIVE
// 01.03.2012 mt  V0.516 Bugfix DiagJobs; SLE, CONNECTED DRIVE, TSR LADEN
// 06.03.2012 mt  V0.517 ++ HVPM-Job, LSC_LADEN
// 12.03.2012 mt  V0.518 Bufix EWS_STATUS
// *******************************************************************

// *******************************************************************
// Konstanten
// *******************************************************************

#pragma best2_type ( win32 )

// Eigene SG-Adresse (Target-Address)
unsigned char TA = 0x1A;

// Anzahl der Argumente für JOB STATUS_LESEN
unsigned char MAX_ARGUMENT_STATUS_LESEN = 5;

// Anzahl der Argumente für JOB STATUS_BLOCK_LESEN
unsigned char MAX_ARGUMENT_STATUS_BLOCK_LESEN = 5;

// Keine Laengenueberpruefung
unsigned int UNCHECK_LEN_IDENTIFIER_LIST[] = {0};



// *******************************************************************
// Includes für Job-Tabellen
// *******************************************************************

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\Tabellen.UDS"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Standardtabellen Unified Diagnostic Services (UDS) nach ISO 14229
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 22.03.2005 gh V0.001 Erstellung
// 28.07.2005 gh V0.002 Entfernung UDS_DID: Tabelle DataIdentifier
// 18.11.2005 gr V0.003 Anpassungen Dateinamen; Erweiterungen fuer SVK
// 18.11.2005 gr V0.003 BMW_PARA, BMW_AUTH entfernt             
// 28.11.2005 rd V0.005 UDS_PARAMETER hinzu
// 08.12.2005 tm V0.005 UDS_TAB_FKLASSE hinzu
// 02.02.2006 gr V0.006 UDS_TAB_FKLASSE entfernt
// 02.02.2006 gr V0.006 STD_DIGI ersetzt UDS_TAB_DIGITAL_ARGUMENT
// 02.02.2006 gh V0.006 Include-Name geändert (wie Tabellen-Name)
// 28.06.2006 gh V0.007 UDS_TAB_Fehlerklasse hinzu
// *******************************************************************
// TABELLEN.UDS @(#)@ V0.007 @(#)@
// *******************************************************************
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_PARAMETER.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Globale Variable   : PARAMETER_BMW_FAST, PARAMETER_BMW_KWP2000
//                      PARAMETER_DS2, PARAMETER_KWP2000_STERN
//                      AWLEN_BMW_FAST, AWLEN_BMW_KWP2000
//                      AWLEN_DS2, AWLEN_KWP2000_STERN
// -------------------------------------------------------------------
// Globale Tabelle    : KONZEPT_TABELLE
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 28.11.2005  rd  V0.01 Erstellung
// 08.08.2006  rd  V0.02 BMW-KWP2000-CAN Timeout und TP-Layer angepasst
// *******************************************************************
// UDS_PARAMETER.B2S @(#)@ V0.02 @(#)@
// *******************************************************************
#define INCLUDE_UDS_PARAMETER_B2S_NOT_FOUND

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_CONSTANTS.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 28.11.2005  rd  V0.01 Erstellung
// 08.08.2006  rd  V0.02 REPAET_COUNTER von 2 auf 1 reduziert
//             rd  V0.02 wegen Einsatz parallele Diagnose am D-CAN
// *******************************************************************
// UDS_CONSTANTS.B2S @(#)@ V0.02 @(#)@
// *******************************************************************
#define INCLUDE_UDS_CONSTANTS_B2S_NOT_FOUND

#define REPEAT_COUNTER              1

#define TRUE                        1
#define FALSE                       0


// ISO14229-1.2 Source Address Type: unsigned char Range 0x00-0xFF
#define SA                          0xF1

// ISO14229-1.2 Type: enumeration Range: physical, functional
#define TA_TYPE_PHYSICAL            0x00
#define TA_TYPE_FUNCTIONAL          0x01

// end of : #include "UDS_CONSTANTS.B2S"

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
INCLUDE_UDS_CONSTANTS_B2S_NOT_FOUND

int      AWLEN_BMW_KWP2000_CAN[] = {0, 0};
long PARAMETER_BMW_KWP2000_CAN[] = {
  0x110,      // Konzept
  500000,     // Baudrate
  1000,       // Timeout receive FC after FF / CF    Bs
  0,          // Tmin send FC after FF / CF          Br
  0,          // Tmin send CF after FC               Cs
  1000,       // Timeout receive CF after FC         Cr
  1000,       // Timeout receive CF after CF         Dr
  1200,       // Timeout receive response P2max
  0,          // Tmin send request P3min
  5000,       // Timeout receive response after $78
  2,          // Maximum number of negative response $78

  1000,       // Timeout receive FC after FC.wait    Es
  0,          // Tmin send FC.wait                   Er
  10,         // Maximum number of wait frames

  0,          // ST min send StminUsedByInterface
  0,          // ST min Handling
              // 0: 'disabled' (ST min from ECU FC)
              // 1: 'enabled' (StminUsedByInterface)

  0,          // Tester Present time TimeTesterPresent in ms
              // 0: 'disabled'
  0,          // Tester Present length LenTesterPresent maximum 11
              // 0: 'disabled'
              // Tester Present message TesterPresentMessage 11 Bytes
              // unused bytes 0x00
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  1           // Tester Present wait for response
              // 0: 'disabled'
              // 1: 'enabled'
};

// end of : #include "UDS_PARAMETER.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_JobResult.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Statusbyte <-> Statustext'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// History:
// 18.11.2005  rd  V0.001 Ersterstellung
// 14.12.2005  gr  V0.002 Erweiterung für Standard-Jobs FS_LESEN_DETAIL, SVK_LESEN
// 17.02.2006  gh  V0.003 Erweiterung für Standard-Jobs IS_LESEN_DETAIL
// 31.05.2006  rd  V0.004 Erweiterung für Standard-Jobs
//                 V0.004 STEUERN, STEUERN_IO, STEUERN_ROUTINE
//                 V0.004 STATUS_LESEN
// 21.06.2006  rd  V0.005 Erweiterung für Standard-Job STATUS_BLOCK_LESEN
// 19.01.2009  gr  V0.006 Erweiterung der JobResult um die Antwort 0x25 ERROR_ECU_NO_RESPONSE_FROM_SUBNET_COMPONENT
// 20.01.2009  gr  V0.007 Erweiterung der JobResult um die Antwort 0x26 ERROR_ECU_FAILURE_PREVENTS_EXECUTION_OF_REQUESTED_ACTION
// *******************************************************************
// UDS_TAB_JOBRESULT.B2S @(#)@ V0.007 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_JOBRESULT_B2S_NOT_FOUND

  table JobResult[2][] = {
  { "SB"   , "STATUS_TEXT"                                            },
// Standard SG Fehlermeldungen
  { "0x10" , "ERROR_ECU_GENERAL_REJECT"                               },
  { "0x11" , "ERROR_ECU_SERVICE_NOT_SUPPORTED"                        },
  { "0x12" , "ERROR_ECU_SUB_FUNCTION_NOT_SUPPORTED"                   },
  { "0x13" , "ERROR_ECU_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT"   },
  { "0x14" , "ERROR_ECU_RESPONSE_TOO_LONG"                            },
  { "0x21" , "ERROR_ECU_BUSY_REPEAT_REQUEST"                          },
  { "0x22" , "ERROR_ECU_CONDITIONS_NOT_CORRECT"                       },
  { "0x24" , "ERROR_ECU_REQUEST_SEQUENCE_ERROR"                       },
  { "0x25" , "ERROR_ECU_NO_RESPONSE_FROM_SUBNET_COMPONENT"            },
  { "0x26" , "ERROR_ECU_FAILURE_PREVENTS_EXECUTION_OF_REQUESTED_ACTION"},
  { "0x31" , "ERROR_ECU_REQUEST_OUT_OF_RANGE"                         },
  { "0x33" , "ERROR_ECU_SECURITY_ACCESS_DENIED"                       },
  { "0x35" , "ERROR_ECU_INVALID_KEY"                                  },
  { "0x36" , "ERROR_ECU_EXCEED_NUMBER_OF_ATTEMPTS"                    },
  { "0x37" , "ERROR_ECU_REQUIRED_TIME_DELAY_NOT_EXPIRED"              },
  { "0x70" , "ERROR_ECU_UPLOAD_DOWNLOAD_NOT_ACCEPTED"                 },
  { "0x71" , "ERROR_ECU_TRANSFER_DATA_SUSPENDED"                      },
  { "0x72" , "ERROR_ECU_GENERAL_PROGRAMMING_FAILURE"                  },
  { "0x73" , "ERROR_ECU_WRONG_BLOCK_SEQUENCE_COUNTER"                 },
  { "0x78" , "ERROR_ECU_REQUEST_CORRECTLY_RECEIVED__RESPONSE_PENDING" },
  { "0x7E" , "ERROR_ECU_SUB_FUNCTION_NOT_SUPPORTED_IN_ACTIVE_SESSION" },
  { "0x7F" , "ERROR_ECU_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION"      },
  { "0x81" , "ERROR_ECU_RPM_TOO_HIGH"                                 },
  { "0x82" , "ERROR_ECU_RPM_TOO_LOW"                                  },
  { "0x83" , "ERROR_ECU_ENGINE_IS_RUNNING"                            },
  { "0x84" , "ERROR_ECU_ENGINE_IS_NOT_RUNNING"                        },
  { "0x85" , "ERROR_ECU_ENGINE_RUN_TIME_TOO_LOW"                      },
  { "0x86" , "ERROR_ECU_TEMPERATURE_TOO_HIGH"                         },
  { "0x87" , "ERROR_ECU_TEMPERATURE_TOO_LOW"                          },
  { "0x88" , "ERROR_ECU_VEHICLE_SPEED_TOO_HIGH"                       },
  { "0x89" , "ERROR_ECU_VEHICLE_SPEED_TOO_LOW"                        },
  { "0x8A" , "ERROR_ECU_THROTTLE_PEDAL_TOO_HIGH"                      },
  { "0x8B" , "ERROR_ECU_THROTTLE_PEDAL_TOO_LOW"                       },
  { "0x8C" , "ERROR_ECU_TRANSMISSION_RANGE_NOT_IN_NEUTRAL"            },
  { "0x8D" , "ERROR_ECU_TRANSMISSION_RANGE_NOT_IN_GEAR"               },
  { "0x8F" , "ERROR_ECU_BRAKE_SWITCH_NOT_CLOSED"                      },
  { "0x90" , "ERROR_ECU_SHIFTER_LEVER_NOT_IN_PARK"                    },
  { "0x91" , "ERROR_ECU_TORQUE_CONVERTER_CLUTCH_LOCKED"               },
  { "0x92" , "ERROR_ECU_VOLTAGE_TOO_HIGH"                             },
  { "0x93" , "ERROR_ECU_VOLTAGE_TOO_LOW"                              },

// Standard JOB Okaymeldung
  { "?00?" , "OKAY"                                                   },

// Standard JOB Fehlermeldungen
  { "?01?" , "ERROR_ECU_NO_RESPONSE"                                  },
  { "?02?" , "ERROR_ECU_INCORRECT_LEN"                                },
  { "?03?" , "ERROR_ECU_INCORRECT_RESPONSE_ID"                        },
  { "?04?" , "ERROR_ECU_TA_RESPONSE_NOT_SA_REQUEST"                   },
  { "?05?" , "ERROR_ECU_SA_RESPONSE_NOT_TA_REQUEST"                   },
  { "?06?" , "ERROR_ECU_RESPONSE_INCORRECT_DATA_IDENTIFIER"           },
  { "?07?" , "ERROR_ECU_RESPONSE_TOO_MUCH_DATA"                       },
  { "?08?" , "ERROR_ECU_RESPONSE_TOO_LESS_DATA"                       },
  { "?09?" , "ERROR_ECU_RESPONSE_VALUE_OUT_OF_RANGE"                  },
  { "?0A?" , "ERROR_TABLE"                                            },
  { "?10?" , "ERROR_F_CODE"                                           },
  { "?12?" , "ERROR_INTERPRETATION"                                   },
  { "?13?" , "ERROR_F_POS"                                            },
  { "?14?" , "ERROR_ECU_RESPONSE_INCORRECT_IO_CONTROL_PARAMETER"      },
  { "?15?" , "ERROR_ECU_RESPONSE_INCORRECT_ROUTINE_CONTROL_TYPE"      },
  { "?16?" , "ERROR_ECU_RESPONSE_INCORRECT_SUB_FUNCTION"              },
  { "?17?" , "ERROR_ECU_RESPONSE_INCORRECT_DYNAMICALLY_DEFINED_DATA_IDENTIFIER"},
  { "?18?" , "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR"                  },
  
// Fehlermeldung bei Standard Job PRUEFSTEMPEL_SCHREIBEN
  { "?50?" , "ERROR_BYTE1"                                            },
  { "?51?" , "ERROR_BYTE2"                                            },
  { "?52?" , "ERROR_BYTE3"                                            },

// Fehlermeldung bei Standard Job SVK_LESEN
  { "?80?" , "ERROR_SVK_INCORRECT_LEN"                                },
  { "?81?" , "ERROR_SVK_INCORRECT_FINGERPRINT"                        },

// Fehlermeldung bei sonstigen Standard-Jobs
  { "?F0?" , "ERROR_ARGUMENT"                                         },

// keine gueltige Antwort
  { "0xXY" , "ERROR_ECU_UNKNOWN_NEGATIVE_RESPONSE"                    }
};
// end of : #include "UDS_TAB_JobResult.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_Lieferanten.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Lieferantennummer <-> Lieferantentext'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005 gr V0.001 Ersterstellung auf Basis STD_LIEF.B2S
// 13.12.2005 rd V0.002 0x76 neu hinzu
// 02.02.2006 gh V0.003 Include-Name geändert (wie Tabellen-Name)
// 27.06.2006 rd V0.004 0x77 bis 0x80 neu hinzu
// 14.09.2006 rd V0.005 0x81 bis 0x84 neu hinzu
// 23.10.2006 rd V0.006 0x85 neu hinzu
// 15.11.2006 rd V0.007 0x86 bis 0x88 neu hinzu
// 24.11.2006 rd V1.000 0x000072 Rechtschreibfehler behoben
//               V1.000 Freigabe
// 31.01.2007 rd V1.001 0x89 neu hinzu
// 02.02.2007 rd V1.002 0x90 neu hinzu
// 19.02.2007 rd V1.003 0x91, 0x92 neu hinzu
// 13.03.2007 rd V1.004 0x93 neu hinzu
// 14.03.2007 rd V1.005 0x94 - 0x96 neu hinzu
// 18.06.2007 rd V1.006 0x97 - 0x99 neu hinzu
// 22.11.2007 rd V1.007 0x9A - 0x9E neu hinzu
// 03.12.2007 as V1.008 0x9F neu hinzu
// 25.01.2008 rd V1.009 0xA0 neu hinzu
// 07.02.2008 rd V1.010 0xA1 neu hinzu
// 04.06.2008 rd V1.029 A2,A3 neu hinzu
// 17.06.2008 rd V1.030 A4 neu hinzu
// 21.10.2008 rd V1.031 A5 neu hinzu
// 17.11.2008 rd V1.032 A6, A7 neu hinzu
// 04.12.2008 rd V1.033 A8 neu hinzu
// 17.02.2009 rd V1.034 A9 neu hinzu
// 30.07.2009 rd V1.035 AA, AB neu hinzu
// 29.04.2010 rd V1.036 AC-AE neu hinzu
// 01.03.2011 rd V1.037 AF neu hinzu
// 02.03.2011 rd V1.038 B0 neu hinzu
// 02.05.2011 rd V1.039 B1, B2 neu hinzu
// 30.11.2011 rd V1.040 B3 neu hinzu
// 25.01.2012 rd V1.041 B4 neu hinzu
// *******************************************************************
// UDS_TAB_Lieferanten.B2S @(#)@ V1.041@(#)@
// *******************************************************************
#define INCLUDE_UDS_Lieferanten_B2S_NOT_FOUND

  table Lieferanten[2][] = {
  { "LIEF_NR"     , "LIEF_TEXT"                            },

  { "0x000001"    , "Reinshagen => Delphi"                 },
  { "0x000002"    , "Kostal"                               },
  { "0x000003"    , "Hella"                                },
  { "0x000004"    , "Siemens"                              },
  { "0x000005"    , "Eaton"                                },
  { "0x000006"    , "UTA"                                  },
  { "0x000007"    , "Helbako"                              },
  { "0x000008"    , "Bosch"                                },
  { "0x000009"    , "Loewe => Lear"                        },
  { "0x000010"    , "VDO"                                  },
  { "0x000011"    , "Valeo"                                },
  { "0x000012"    , "MBB"                                  },
  { "0x000013"    , "Kammerer"                             },
  { "0x000014"    , "SWF"                                  },
  { "0x000015"    , "Blaupunkt"                            },
  { "0x000016"    , "Philips"                              },
  { "0x000017"    , "Alpine"                               },
  { "0x000018"    , "Continental Teves"                    },
  { "0x000019"    , "Elektromatik Suedafrika"            },
  { "0x000020"    , "Becker"                               },
  { "0x000021"    , "Preh"                                 },
  { "0x000022"    , "Alps"                                 },
  { "0x000023"    , "Motorola"                             },
  { "0x000024"    , "Temic"                                },
  { "0x000025"    , "Webasto"                              },
  { "0x000026"    , "MotoMeter"                            },
  { "0x000027"    , "Delphi PHI"                           },
  { "0x000028"    , "DODUCO => BERU"                       },
  { "0x000029"    , "DENSO"                                },
  { "0x000030"    , "NEC"                                  },
  { "0x000031"    , "DASA"                                 },
  { "0x000032"    , "Pioneer"                              },
  { "0x000033"    , "Jatco"                                },
  { "0x000034"    , "Fuba"                                 },
  { "0x000035"    , "UK-NSI"                               },
  { "0x000036"    , "AABG"                                 },
  { "0x000037"    , "Dunlop"                               },
  { "0x000038"    , "Sachs"                                },
  { "0x000039"    , "ITT"                                  },
  { "0x000040"    , "FTE"                                  },
  { "0x000041"    , "Megamos"                              },
  { "0x000042"    , "TRW"                                  },
  { "0x000043"    , "Wabco"                                },
  { "0x000044"    , "ISAD Electronic Systems"              },
  { "0x000045"    , "HEC (Hella Electronics Corporation)"  },
  { "0x000046"    , "Gemel"                                },
  { "0x000047"    , "ZF"                                   },
  { "0x000048"    , "GMPT"                                 },
  { "0x000049"    , "Harman Kardon"                        },
  { "0x000050"    , "Remes"                                },
  { "0x000051"    , "ZF Lenksysteme"                     },
  { "0x000052"    , "Magneti Marelli"                      },
  { "0x000053"    , "Borg Instruments"                     },
  { "0x000054"    , "GETRAG"                               },
  { "0x000055"    , "BHTC (Behr Hella Thermocontrol)"      },
  { "0x000056"    , "Siemens VDO Automotive"               },
  { "0x000057"    , "Visteon"                              },
  { "0x000058"    , "Autoliv"                              },
  { "0x000059"    , "Haberl"                               },
  { "0x000060"    , "Magna Steyr"                          },
  { "0x000061"    , "Marquardt"                            },
  { "0x000062"    , "AB-Elektronik"                        },
  { "0x000063"    , "Siemens VDO Borg"                     },
  { "0x000064"    , "Hirschmann Electronics"               },
  { "0x000065"    , "Hoerbiger Electronics"                },
  { "0x000066"    , "Thyssen Krupp Automotive Mechatronics"},
  { "0x000067"    , "Gentex GmbH"                          },
  { "0x000068"    , "Atena GmbH"                           },
  { "0x000069"    , "Magna-Donelly"                        },
  { "0x000070"    , "Koyo Steering Europe"                 },
  { "0x000071"    , "NSI B.V"                              },
  { "0x000072"    , "AISIN AW CO.LTD"                      },
  { "0x000073"    , "Shorlock"                             },
  { "0x000074"    , "Schrader"                             },
  { "0x000075"    , "BERU Electronics GmbH"                },
  { "0x000076"    , "CEL"                                  },
  { "0x000077"    , "Audio Mobil"                          },
  { "0x000078"    , "rd electronic"                        },
  { "0x000079"    , "iSYS RTS GmbH"                        },
  { "0x000080"    , "Westfalia Automotive GmbH"            },
  { "0x000081"    , "Tyco Electronics"                     },
  { "0x000082"    , "Paragon AG"                           },
  { "0x000083"    , "IEE S.A"                              },
  { "0x000084"    , "TEMIC AUTOMOTIVE of NA"               },
  { "0x000085"    , "AKsys GmbH"                           },
  { "0x000086"    , "META System"                          },
  { "0x000087"    , "Hülsbeck & Fürst GmbH & Co KG"        },
  { "0x000088"    , "Mann & Hummel Automotive GmbH"        },
  { "0x000089"    , "Brose Fahrzeugteile GmbH & Co"        },
  { "0x000090"    , "Keihin"                               },
  { "0x000091"    , "Vimercati S.p.A."                     },
  { "0x000092"    , "CRH"                                  },
  { "0x000093"    , "TPO Display Corp."                    },
  { "0x000094"    , "KÜSTER Automotive Control"            },
  { "0x000095"    , "Hitachi Automotive"                   },
  { "0x000096"    , "Continental Automotive"               },
  { "0x000097"    , "TI-Automotive"                        },
  { "0x000098"    , "Hydro"                                },
  { "0x000099"    , "Johnson Controls"                     },
  { "0x00009A"    , "Takata- Petri"                        },
  { "0x00009B"    , "Mitsubishi Electric B.V. (Melco)"     },
  { "0x00009C"    , "Autokabel"                            },
  { "0x00009D"    , "GKN-Driveline"                        },
  { "0x00009E"    , "Zollner Elektronik AG"                },
  { "0x00009F"    , "PEIKER acustics GmbH"                 },
  { "0x0000A0"    , "Bosal-Oris"                           },
  { "0x0000A1"    , "Cobasys"                              },
  { "0x0000A2"    , "Lighting Reutlingen GmbH"             },
  { "0x0000A3"    , "CONTI VDO"                            },
  { "0x0000A4"    , "ADC Automotive Distance Control Systems GmbH"},
  { "0x0000A5"    , "Funkwerk Dabendorf GmbH"              },
  { "0x0000A6"    , "Lame"                                 },
  { "0x0000A7"    , "Magna/Closures"                       },
  { "0x0000A8"    , "Wanyu"                                },
  { "0x0000A9"    , "Thyssen Krupp Presta"                 },
  { "0x0000AA"    , "ArvinMeritor"                         },
  { "0x0000AB"    , "Kongsberg Automotive GmbH"            },
  { "0x0000AC"    , "SMR Automotive Mirrors"               },
  { "0x0000AD"    , "So.Ge.Mi."                            },
  { "0x0000AE"    , "MTA"                                  },
  { "0x0000AF"    , "Alfmeier"                             },
  { "0x0000B0"    , "ELTEK VALERE DEUTSCHLAND GMBH"        },
  { "0x0000B1"    , "Omron Automotive Electronics Europe Group" },
  { "0x0000B2"    , "ASK"                                  },
  { "0x0000B3"    , "CML Innovative Technologies GmbH & Co. KG" },
  { "0x0000B4"    , "APAG Elektronik AG"                   },

  { "0xFFFFFF"    , "unbekannter Hersteller"             }
};
// end of : #include "UDS_TAB_Lieferanten.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_FArtTexte.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Fehlerart-Nr -> Fehlerart-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005 gr V0.001 Ersterstellung aus Basis STD_FART.B2S
// 20.12.2005 gr V0.002 Anpassung Text bei 0x00
// 02.02.2006 gr V0.003 Anpassungen an neue DTCStatusMask 0C
// 02.02.2006 gr V0.003 Include-Name geändert (wie Tabellen-Name)
// 06.08.2007 tm V0.004 Texte geändert
// 05.05.2009 gr V0.005 0x40 "unbekannte Fehlerart" für VP-Prozess hinzu
// *******************************************************************
// UDS_TAB_FArtTexte.B2S @(#)@ V0.005 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_FArtTexte_B2S_NOT_FOUND

  table FArtTexte[2][] = {
  { "ARTNR" , "ARTTEXT"                                                      },

  { "0x00"  , "keine Fehlerart verfügbar"                                  },
  { "0x04"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x05"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x08"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x09"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x0C"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x0D"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x40"  , "unbekannte Fehlerart"                                       },
  { "0x44"  , "Fehler gespeichert"                                         },
  { "0x45"  , "Fehler gespeichert"                                         },
  { "0x48"  , "Fehler gespeichert"                                         },
  { "0x49"  , "Fehler gespeichert"                                         },
  { "0x4C"  , "Fehler gespeichert"                                         },
  { "0x4D"  , "Fehler gespeichert"                                         },
  { "0x10"  , "Testbedingungen erfüllt"                                   },
  { "0x11"  , "Testbedingungen noch nicht erfüllt"                        },
  { "0x80"  , "Fehler würde kein Aufleuchten einer Warnlampe verursachen" },
  { "0x81"  , "Fehler würde das Aufleuchten einer Warnlampe verursachen"  },

  { "0xFF"  , "unbekannte Fehlerart"                                       }
};

// end of : #include "UDS_TAB_FArtTexte.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\STD_DIGI.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Text Digitalargument <-> Wert Digitalargument'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 6
// Lastenheft Programmieren Programm/Daten 7 500 334 F
// -------------------------------------------------------------------
// History:
// 24.04.2002 gh V1.00 Namensänderung (Ursprung: BMW_DIGI.b2s)
// 22.04.2003 rd V1.01 Versionskennung hinzu
// 26.04.2004 rd V1.02 'an' neu hinzu
// *******************************************************************
// STD_DIGI.B2S @(#)@ V1.02 @(#)@
// *******************************************************************
#define INCLUDE_STD_DIGI_B2S_NOT_FOUND

  table DigitalArgument[2][] = {
  { "TEXT"  , "WERT" },

  { "ein"   , "1"    },
  { "aus"   , "0"    },
  { "ja"    , "1"    },
  { "nein"  , "0"    },
  { "auf"   , "1"    },
  { "ab"    , "0"    },

  { "an"    , "1"    },

  { "yes"   , "1"    },
  { "no"    , "0"    },
  { "on"    , "1"    },
  { "off"   , "0"    },
  { "up"    , "1"    },
  { "down"  , "0"    },

  { "true"  , "1"    },
  { "false" , "0"    },
  { "1"     , "1"    },
  { "0"     , "0"    }
};

// end of : #include "STD_DIGI.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_Prozessklassen.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Prozessklasse WERT <-> Prozessklasse BEZEICHNUNG'
// -------------------------------------------------------------------
// History:
// 14.11.2005 gr V0.001 Ersterstellung
// 02.02.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// 22.03.2007 gh V0.003 Prozessklassen geändert (teilweise INKOMPATIBEL !!!)
// 01.02.2008 gr V0.004 Prozessklassen SWUP,SWIP, BLUP und FLUP hinzu
// 25.06.2011 gh V0.005 Prozessklasse wegen BDC hinzu: 0x04, GWTB
// ***************************************************************************
// UDS_TAB_Prozessklassen.B2S @(#)@ V0.005 @(#)@
// ***************************************************************************
#define INCLUDE_UDS_TAB_Prozessklassen_B2S_NOT_FOUND

table Prozessklassen[3][] = {
  { "WERT" , "PROZESSKLASSE" , "BEZEICHNUNG"                         },

  { "0x00" , "-"             , "ungueltig"                           },

// nachfolgende Einträge blieben gleich (V0.002 => V.0.003)
  { "0x01" , "HWEL"          , "Hardware (Elektronik)"               },
  { "0x02" , "HWAP"          , "Hardwareauspraegung"                 },
  { "0x03" , "HWFR"          , "Hardwarefarbe"                       },
  { "0x05" , "CAFD"          , "Codierdaten"                         },
  { "0x06" , "BTLD"          , "Bootloader"                          },
  { "0x08" , "SWFL"          , "Software ECU Speicherimage"          },
  { "0x09" , "SWFF"          , "Flash File Software"                 },
  { "0x0A" , "SWPF"          , "Pruefsoftware"                       },
  { "0x0B" , "ONPS"          , "Onboard Programmiersystem"           },
  { "0x0F" , "FAFP"          , "FA2FP"                               },
  { "0x1A" , "TLRT"          , "Temporaere Loeschroutine"            },
  { "0x1B" , "TPRG"          , "Temporaere Programmierroutine"       },

// nachfolgende Einträge kamen neu dazu (V0.002 => V.0.003)
  { "0x07" , "FLSL"          , "Flashloader Slave"                   },
  { "0x0C" , "IBAD"          , "Interaktive Betriebsanleitung Daten" },
  { "0x10" , "FCFA"          , "Freischaltcode Fahrzeug-Auftrag"     },
  { "0x1C" , "BLUP"          , "Bootloader-Update Applikation"       },
  { "0x1D" , "FLUP"          , "Flashloader-Update Applikation"      },
 
// nachfolgende Einträge kamen neu dazu (V0.004 => V.0.005)
  { "0x04" , "GWTB"          , "Gateway-Tabelle"                     },

// nachfolgende Einträge wurden INKOMPATIBEL geändert !
// bei V0.002 (alt)
//{ "0xA0" , "VEHI"          , "Vehicle Info Spec"             },
//{ "0xA1" , "COMS"          , "Comparam Spec"                 },
//{ "0xA2" , "DIAG"          , "Diag-Layer Container"          },
//{ "0xA3" , "FLCU"          , "Flash Datei"                   },
//{ "0xA4" , "JAJO"          , "Java-Jobs"                     },
// bei V.0.003 (neu)
  { "0xA0" , "ENTD"          , "Entertainment Daten"                 },
  { "0xA1" , "NAVD"          , "Navigation Daten"                    },
  { "0xA2" , "FCFN"          , "Freischaltcode Funktion"             },

  { "0xC0" , "SWUP"          , "Software-Update Package"             },
  { "0xC1" , "SWIP"          , "Index Software-Update Package"       },

  { "0xFF" , "-"             , "ungueltig"                           }
};

// end of : #include "UDS_TAB_Prozessklassen.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_SVK_ID.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'SVK ID <-> SVK Bezeichnung'
// -------------------------------------------------------------------
// History:
// 14.11.2005 gr V0.001 Ersterstellung
// 01.02.2006 gr V0.002 Tabelle um SVK_BACKUP erweitert
// ***************************************************************************
// UDS_TAB_SVK_ID.B2S @(#)@ V0.002 @(#)@
// ***************************************************************************
#define INCLUDE_UDS_TAB_SVK_ID_B2S_NOT_FOUND

table SVK_ID[2][] = {
  { "WERT" , "BEZEICHNUNG"   },

  { "0x01" , "SVK_AKTUELL"   },
  { "0x02" , "SVK_SUPPLIER"  },
  { "0x03" , "SVK_WERK"      },
  { "0x04" , "SVK_BACKUP_01" },
  { "0x05" , "SVK_BACKUP_02" },
  { "0x06" , "SVK_BACKUP_03" },
  { "0x07" , "SVK_BACKUP_04" },
  { "0x08" , "SVK_BACKUP_05" },
  { "0x09" , "SVK_BACKUP_06" },
  { "0x0A" , "SVK_BACKUP_07" },
  { "0x0B" , "SVK_BACKUP_08" },
  { "0x0C" , "SVK_BACKUP_09" },
  { "0x0D" , "SVK_BACKUP_10" },
  { "0x0E" , "SVK_BACKUP_11" },
  { "0x0F" , "SVK_BACKUP_12" },
  { "0x10" , "SVK_BACKUP_13" },
  { "0x11" , "SVK_BACKUP_14" },
  { "0x12" , "SVK_BACKUP_15" },
  { "0x13" , "SVK_BACKUP_16" },
  { "0x14" , "SVK_BACKUP_17" },
  { "0x15" , "SVK_BACKUP_18" },
  { "0x16" , "SVK_BACKUP_19" },
  { "0x17" , "SVK_BACKUP_20" },
  { "0x18" , "SVK_BACKUP_21" },
  { "0x19" , "SVK_BACKUP_22" },
  { "0x1A" , "SVK_BACKUP_23" },
  { "0x1B" , "SVK_BACKUP_24" },
  { "0x1C" , "SVK_BACKUP_25" },
  { "0x1D" , "SVK_BACKUP_26" },
  { "0x1E" , "SVK_BACKUP_27" },
  { "0x1F" , "SVK_BACKUP_28" },
  { "0x20" , "SVK_BACKUP_29" },
  { "0x21" , "SVK_BACKUP_30" },
  { "0x22" , "SVK_BACKUP_31" },
  { "0x23" , "SVK_BACKUP_32" },
  { "0x24" , "SVK_BACKUP_33" },
  { "0x25" , "SVK_BACKUP_34" },
  { "0x26" , "SVK_BACKUP_35" },
  { "0x27" , "SVK_BACKUP_36" },
  { "0x28" , "SVK_BACKUP_37" },
  { "0x29" , "SVK_BACKUP_38" },
  { "0x2A" , "SVK_BACKUP_39" },
  { "0x2B" , "SVK_BACKUP_40" },
  { "0x2C" , "SVK_BACKUP_41" },
  { "0x2D" , "SVK_BACKUP_42" },
  { "0x2E" , "SVK_BACKUP_43" },
  { "0x2F" , "SVK_BACKUP_44" },
  { "0x30" , "SVK_BACKUP_45" },
  { "0x31" , "SVK_BACKUP_46" },
  { "0x32" , "SVK_BACKUP_47" },
  { "0x33" , "SVK_BACKUP_48" },
  { "0x34" , "SVK_BACKUP_49" },
  { "0x35" , "SVK_BACKUP_50" },
  { "0x36" , "SVK_BACKUP_51" },
  { "0x37" , "SVK_BACKUP_52" },
  { "0x38" , "SVK_BACKUP_53" },
  { "0x39" , "SVK_BACKUP_54" },
  { "0x3A" , "SVK_BACKUP_55" },
  { "0x3B" , "SVK_BACKUP_56" },
  { "0x3C" , "SVK_BACKUP_57" },
  { "0x3D" , "SVK_BACKUP_58" },
  { "0x3E" , "SVK_BACKUP_59" },
  { "0x3F" , "SVK_BACKUP_60" },
  { "0x40" , "SVK_BACKUP_61" },  

  { "0xXY" , "ERROR_UNKNOWN" }
};

// end of : #include "UDS_TAB_SVK_ID.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_DTCExtendedDataRecordNumber.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Extended Identifier -> Extended Data-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 08.12.2005 gr V0.001 Ersterstellung
// 02.02.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// *******************************************************************
// UDS_TAB_DTCExtendedDataRecordNumber.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_DTCExtendedDataRecordNumber_B2S_NOT_FOUND

 table DTCExtendedDataRecordNumber[3][] = {
  { "WERT" , "TEXT"           , "ANZ_BYTE" },

  { "0x00" , "ISO_RESERVED"   , "0"        },
  { "0x01" , "CONDITION_BYTE" , "1"        },
  { "0x02" , "HFK"            , "1"        },
  { "0x03" , "HLZ"            , "1"        },

  { "0xFF" , "RECORD_UNKNOWN" , "0"        }
};

// end of : #include "UDS_TAB_DTCExtendedDataRecordNumber.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_DTCSnapshotIdentifier.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Snapshot Identifier -> Snapshot-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 08.12.2005 gr V0.001 Ersterstellung
// 02.02.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// 21.02.2008 gr V0.003 Identifier 1731 hinzu (Anforderung S. Etessam)
// *******************************************************************
// UDS_TAB_DTCSnapshotIdentifier.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_DTCSnapshotIdentifier_B2S_NOT_FOUND

 table DTCSnapshotIdentifier[9][] = {
  { "UWNR"   , "UWTEXT"             , "UW_EINH" , "L/H" , "UWTYP"      , "NAME" , "MUL" , "DIV" , "ADD"      },

  { "0x1700" , "KM_STAND"           , "0-n"     , "-"   , "0xFFFFFF"   , "-"    , "1"   , "1"   , "0.000000" },
  { "0x1701" , "ABS_ZEIT"           , "0-n"     , "-"   , "0xFFFFFFFF" , "-"    , "1"   , "1"   , "0.000000" },
  { "0x1702" , "SAE_CODE"           , "0-n"     , "-"   , "0xFFFFFF"   , "-"    , "1"   , "1"   , "0.000000" },
  { "0x1731" , "Fehlerklasse_DTC" , "-"       , "-"   , "u char"     , "-"    , "1"   , "1"   , "0.000000" },

  { "0xFFFF" , "IDENTIFIER_UNKNOWN" , "-"       , "-"   , "0xFFFFFF"   , "-"    , "1"   , "1"   , "0.000000" }
};  

// end of : #include "UDS_TAB_DTCSnapshotIdentifier.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_Fehlerklasse.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Fehlerklasse-Nr -> Fehlerklasse-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 05.12.2005 gr V0.001 Ersterstellung
// 23.06.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// *******************************************************************
// UDS_TAB_Fehlerklasse.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_Fehlerklasse_B2S_NOT_FOUND

  table Fehlerklasse[2][] = {
  { "NR"   , "TEXT"                                          },

  { "0x00" , "Keine Fehlerklasse verfuegbar"               },
  { "0x01" , "Ueberpruefung bei naechstem Werkstattbesuch" },
  { "0x02" , "Ueberpruefung bei naechstem Halt"            },
  { "0x04" , "Ueberpruefung sofort erforderlich !"         },

  { "0xFF" , "unbekannte Fehlerklasse"                     }
};

// end of : #include "UDS_TAB_Fehlerklasse.B2S"

// end of : #include "Tabellen.UDS"
// UDS Standard Tabelle (für Job Diagnose_Mode)
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_DiagMode.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: DiagnosticMode
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// History:
// 16.12.2005 gr V0.001 Ersterstellung
// 02.02.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// 22.02.2006 gh V0.003 Korrektur: 0x03 = ECUExtendedDiagnosticSession
// 22.06.2006 gh V0.004 Integration weiterer Diagnose-Modi
// 20.01.2009 gr V0.005 Integration Diagnose-Modi 0x04 und 0x43
// *******************************************************************
// UDS_DiagMode.B2S @(#)@ V0.005 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_DiagMode_B2S_NOT_FOUND

  table DiagMode[3][] = {
  { "NR"   , "MODE"       , "MODE_TEXT"                    },

  { "0x00" , "UNGUELTIG"  , "DefaultMode"                  },

  { "0x01" , "DEFAULT"    , "DefaultMode"                  },
  { "0x02" , "ECUPM"      , "ECUProgrammingMode"           },
  { "0x03" , "ECUEXTDIAG" , "ECUExtendedDiagnosticSession" },
  { "0x04" , "ECUSSDS"    , "ECUSafetySystemDiagnosticSession" },

  { "0x40" , "ECUEOL"     , "ECUEndOfLineSession"          },
  { "0x41" , "ECUCODE"    , "ECUCodingSession"             },
  { "0x42" , "ECUSWT"     , "ECUSwtSession"                },
  { "0x43" , "ECUHDD"     , "ECUHDDDownloadSession"        },
  { "0x4F" , "ECUDEVELOP" , "ECUDevelopmentSession"        },

  { "0xXY" , "--"         , "unbekannter Diagnose-Mode"  }
};

// end of : #include "UDS_TAB_DiagMode.B2S"
// UDS Standard Tabelle (für Job Sensoren_Ident_Lesen)
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\STD_ISEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Verbauortnr <-> Verbauorttext'
// -------------------------------------------------------------------
// Gueltig:
// Lastenheft Diagnose Ausgabe 6
// für $22   ReadDataBydentifier
//     $16xx SubbusMemberSerialNumber
// -------------------------------------------------------------------
// History:
// 23.05.2003 rd V0.01 Ersterstellung
// 26.05.2003 rd V0.02 Erweiterung 0x0400, 0x500
// 07.07.2003 rd V0.03 Erweiterung 0x0350
// 22.11.2004 rd V0.04 Erweiterung 0x0600, 0x700
// 30.06.2005 rd V0.05 Erweiterung 0x0800, 0x900
// 20.10.2005 rd V1.00 Erweiterung 0x0A00
// 05.10.2006 rd V1.01 Erweiterung 0x0A00
//               V1.01 Sonderbehandlung bei DXC SG-Adresse 0x29
// 23.10.2006 rd V1.02 Erweiterung 0x0B00
// 07.12.2006 rd V1.03 Erweiterung 0x0C00
// 11.01.2007 tm V1.04 Erweiterung 0x0E00
// 15.01.2007 rd V1.05 Erweiterung 0x0F00-0x1300
// 08.02.2007 rd V1.06 Erweiterung 0x1400-0x1E00
// 15.02.2007 gr V1.07 Neue Spalte LIN_2_FORMAT zum Auslesen der zusätlichen Infos
// 29.03.2007 rd V1.08 Erweiterung 0x2000
// 17.04.2007 rd V1.09 Erweiterung 0x2100
// 16.05.2007 rd V1.10 Erweiterung für CAS4
// 25.06.2007 rd V1.11 Erweiterung FRM3, CAS4 Indizes verschoben
// 11.07.2007 rd V1.12 Erweiterung DME F01
// 13.08.2007 rd V1.13 FRM3 Aussenspiegel kein LIN_2_FORMAT
// 14.08.2007 rd V1.14 Sitzverstellschalter dazu
// 17.08.2007 rd V1.15 Sitzheizung geändert / neu
// 17.01.2008 gr V1.16 Fond-Klimaanlage hinzu
// 30.01.2008 rd V1.17 Kraftstoffpumpe hinzu
// 13.02.2008 rd V1.18 Gepäckraumschalter vorbereitet
// 20.02.2008 rd V1.19 Spurwechselradarsensor Lin 2 Format
// 25.02.2008 rd V1.20 PMA Sensoren hinzu
// 03.03.2008 rd V1.21 PMA Sensoren kein Lin 2 Format
//               V1.21 Spurwechselradarsensor kein Lin 2 Format
// 04.03.2008 rd V1.22 Gepäckraumschalter hinzu
// 07.03.2008 rd V1.23 Startergenerator, Ölqualitätsensor hinzu
// 17.03.2008 rd V1.24 Topview, Sideview, Rearview Kameras LIN_2_FORMAT
// 18.04.2008 rd V1.25 CID-Klappe dazu
// 05.06.2008 rd V1.26 Erweiterung für F25
// 09.06.2008 rd V1.27 Erweiterung für L7
// 03.07.2008 rd V1.28 Erweiterung für F12
// 01.08.2008 rd V1.29 Erweiterung für ACSM4
// 04.08.2008 rd V1.30 PMA Sensoren jetzt doch wieder Lin 2 Format
// 16.09.2008 rd V1.31 Erweiterung
// 21.10.2008 rd V1.32 Erweiterung
// 13.11.2008 rd V1.33 Erweiterung ELV Lin 2
// 18.11.2008 rd V1.34 Mirkrowellensensoren überarbeitet
// 24.11.2008 rd V1.35 Zusatzwasserpumpe und Generator am Lin neu
// 02.12.2008 rd V1.36 EKK neu
// 16.01.2009 rd V1.37 Wasserpumpen 1 und 2 neu
// 16.02.2009 rd V1.38 ACSM neue Sensoren dazu
// 22.04.2009 rd V1.39 ACSM Sensoren. Jetzt doch nicht LIN 2
// 20.05.2009 rd V1.40 Audio Bedienteil LIN 2
// 08.09.2009 as V1.41 Klimaumfänge hinzu
// 22.09.2009 rd V1.42 ACSM neue Sensoren dazu
// 07.10.2009 rd V1.43 SMO, PT-Tank dazu
// 13.10.2009 rd V1.44 LED-Module dazu
// 28.10.2009 rd V1.45 EAC-Sensor dazu
// 22.02.2010 rd V1.46 Innenlichtelektronik dazu
// 20.07.2011 rd V1.47 Zentralinstrument dazu
// 23.09.2011 rd V1.48 Nackenwärmer dazu
// 08.11.2011 rd V1.49 ELSV und HOD dazu
// 15.12.2011 rd V1.50 Standheizung, Wärmepumpe, Durchlaufheizer dazu
//            rd V1.50 BDC Innenbeleuchtung dazu
// 02.02.2012 rd V1.51 Ionisator, Bedufter dazu
// 01.03.2012 rd V1.52 DCDC Versorgung Zustartbatterie dazu
// *******************************************************************
// STD_ISEN.B2S @(#)@ V1.52 @(#)@
// *******************************************************************
#define INCLUDE_STD_ISEN_B2S_NOT_FOUND

// Zuordnung von Verbauort-Nummer zu Verbauort-Text
// intelligenter Sensoren
  table VerbauortTabelle[3][] = {
  {   "ORT"    , "ORTTEXT"                                      , "LIN_2_FORMAT"},
  {   "0x0100" , "Batteriesensor BSD"                         ,     "-"       },
  {   "0x0150" , "Ölqualitätsensor BSD"                       ,     "-"       },
  {   "0x0200" , "Elektrische Wasserpumpe BSD"                ,     "-"       },
  {   "0x0250" , "Elektrische Kraftstoffpumpe BSD"            ,     "-"       },
  {   "0x0300" , "Generator 1"                                ,     "-"       },
  {   "0x0350" , "Generator 2"                                ,     "-"       },
  {   "0x03A0" , "Druck- Temperatursensor Tank"             ,     "1"       },
  {   "0x03C0" , "EAC-Sensor"                                 ,     "-"       },

  {   "0x0400" , "Schaltzentrum Lenksäule"                    ,     "-"       },
  {   "0x0500" , "DSC Sensor-Cluster"                         ,     "-"       },
  {   "0x0600" , "Nahbereichsradarsensor links"             ,     "-"       },
  {   "0x0700" , "Nahbereichsradarsensor rechts"            ,     "-"       },
  {   "0x0800" , "Funkempfänger"                              ,     "-"       },
  {   "0x0900" , "Elektrische Lenksäulenverriegelung"         ,     "-"       },
  {   "0x0A00" , "Regen- Lichtsensor"                         ,     "-"       },
  { "0x290A00" , "DSC Hydraulikblock"                         ,     "-"       }, // Sonderbehandlung
  {   "0x0B00" , "Nightvision Kamera"                         ,     "-"       },
  {   "0x0C00" , "TLC Kamera"                                 ,     "-"       },
  {   "0x0D00" , "Spurwechselradarsensor hinten links"    ,     "-"       },
  {   "0x0E00" , "Heckklima Bedienteil rechts"            ,     "1"       },
  {   "0x0F00" , "Rearview Kamera hinten"                 ,     "1"       },
  {   "0x1000" , "Topview Kamera Außenspiegel links"    ,     "1"       },
  {   "0x1100" , "Topview Kamera Außenspiegel rechts"   ,     "1"       },
  {   "0x1200" , "Sideview Kamera Stoßfänger vorne links",  "1"       },
  {   "0x1300" , "Sideview Kamera Stoßfänger vorne rechts", "1"       },
// JBBF
  {   "0x1400" , "Wischermotor"                               ,     "1"       },
  {   "0x1500" , "Regen- Lichtsensor"                         ,     "1"       },
  {   "0x1600" , "Innenspiegel"                               ,     "1"       },
  {   "0x1700" , "Garagentoröffner"                           ,     "1"       },
  {   "0x1800" , "AUC-Sensor"                               ,     "1"       },
  {   "0x1900" , "Druck- Temperatursensor"                    ,     "1"       },
//{   "0x1A00" , "@Schalterblock@ @Sitzheizung@ @hinten@"       ,     "1"       },
  {   "0x1A20" , "Schalterblock Sitzheizung hinten links",    "1"       },
  {   "0x1A40" , "Schalterblock Sitzheizung hinten rechts",   "1"       },
  {   "0x1A60" , "Sitzheizung Fahrer"                       ,     "1"       },
  {   "0x1A80" , "Sitzheizung Beifahrer"                    ,     "1"       },
  {   "0x1AA0" , "Sitzheizung Fahrer hinten"              ,     "1"       },
  {   "0x1AC0" , "Sitzheizung Beifahrer hinten"           ,     "1"       },
  {   "0x1B00" , "Schalterblock Sitzmemory/-massage Fahrer",    "1"       },
  {   "0x1C00" , "Schalterblock Sitzmemory/-massage Beifahrer", "1"       },
  {   "0x1C80" , "Sitzverstellschalter Beifahrer über Fond"   , "1"       },
  {   "0x1D00" , "Sonnenrollo Seitenfenster Fahrer"       ,     "1"       },
  {   "0x1E00" , "Sonnenrollo Seitenfenster Beifahrer"    ,     "1"       },
  {   "0x1E40" , "Heckklappenemblem"                          ,     "1"       },

  {   "0x1F00" , "KAFAS Kamera"                               ,     "1"       },
  {   "0x2000" , "Automatische Anhängevorrichtung"            ,     "1"       },

  {   "0x2100" , "SINE"                                       ,     "1"       },
// CAN Sine
  {   "0x2110" , "DWA Mikrowellensensor vorne rechts"   ,     "1"       },
  {   "0x2120" , "DWA Mikrowellensensor hinten rechts"  ,     "1"       },
  {   "0x2130" , "DWA Mikrowellensensor hinten links"   ,     "1"       },
  {   "0x2140" , "DWA Mikrowellensensor vorne links"    ,     "1"       },
  {   "0x2150" , "DWA Mikrowellensensor hinten"           ,     "1"       },
  {   "0x2180" , "DWA Ultraschallsensor"                    ,     "1"       },

// FRM3
  {   "0x2200" , "Aussenspiegel Fahrer"                     ,     "-"       },
  {   "0x2300" , "Aussenspiegel Beifahrer"                  ,     "-"       },
  {   "0x2400" , "Schaltzentrum Tür"                        ,     "1"       },
  {   "0x2500" , "Schalterblock Sitz Fahrer"              ,     "1"       },
  {   "0x2600" , "Schalterblock Sitz Beifahrer"           ,     "1"       },
  {   "0x2700" , "Gurtbringer Fahrer"                       ,     "1"       },
  {   "0x2800" , "Gurtbringer Beifahrer"                    ,     "1"       },
  {   "0x2900" , "Treibermodul Scheinwerfer links"        ,     "1"       },
  {   "0x2A00" , "Treibermodul Scheinwerfer rechts"       ,     "1"       },
  {   "0x2B00" , "Bedieneinheit Fahrerassistenzsysteme"     ,     "1"       },
  {   "0x2C00" , "Bedieneinheit Licht"                      ,     "1"       },
  {   "0x2D00" , "Smart Opener"                               ,     "1"       },
  {   "0x2E00" , "LED-Hauptlicht-Modul links"               ,     "1"       },
  {   "0x2F00" , "LED-Hauptlicht-Modul rechts"              ,     "1"       },

// CAS4
  {   "0x0910" , "Elektrische Lenksäulenverriegelung"         ,     "1"       },
  {   "0x3200" , "Funkempfänger"                              ,     "1"       },
  {   "0x3300" , "Funkempfänger 2"                            ,     "1"       },
  {   "0x3400" , "Türgriffelektronik Fahrer"                ,     "-"       },
  {   "0x3500" , "Türgriffelektronik Beifahrer"             ,     "-"       },
  {   "0x3600" , "Türgriffelektronik Fahrer hinten"       ,     "-"       },
  {   "0x3700" , "Türgriffelektronik Beifahrer hinten"    ,     "-"       },
  {   "0x3800" , "Telestart-Handsender 1"                   ,     "-"       },
  {   "0x3900" , "Telestart-Handsender 2"                   ,     "-"       },
  {   "0x3A00" , "Fond-Fernbedienung"                       ,     "-"       },
// DME
  {   "0x3B00" , "Elektrische Wasserpumpe"                    ,     "1"       },
  {   "0x3B10" , "Elektrische Wasserpumpe 1"                  ,     "1"       },
  {   "0x3B20" , "Elektrische Wasserpumpe 2"                  ,     "1"       },
  {   "0x3B80" , "Elektrische Zusatzwasserpumpe"              ,     "1"       },
  {   "0x3C00" , "Batteriesensor LIN"                         ,     "-"       },
  {   "0x3D00" , "Aktives Kühlklappensystem"                  ,     "1"       },
  {   "0x3E00" , "PCU(DCDC)"                                    ,     "1"       },
  {   "0x3E80" , "DCDC Versorgung Zustartbatterie"            ,     "1"       },
  {   "0x3F00" , "Startergenerator"                           ,     "1"       },
  {   "0x3F80" , "Generator"                                  ,     "1"       },

// Sitzmodul
  {   "0x4000" , "Sitzverstellschalter Fahrer"              ,     "1"       },
  {   "0x4100" , "Sitzverstellschalter Beifahrer"           ,     "1"       },
  {   "0x4200" , "Sitzverstellschalter Fahrer hinten"     ,     "1"       },
  {   "0x4300" , "Sitzverstellschalter Beifahrer hinten"  ,     "1"       },
  {   "0x4400" , "Gepäckraumschalter links"                 ,     "1"       },
  {   "0x4500" , "Gepäckraumschalter rechts"                ,     "1"       },
  {   "0x4600" , "Nackenwärmer"                               ,     "1"       },
  {   "0x4700" , "Nackenwärmer Bedienschalter"              ,     "1"       },
// Klima
  {   "0x4A00" , "Fond-Klimaanlage"                           ,     "1"       },
  {   "0x4B00" , "Elektrischer Klimakompressor"               ,     "1"       },
  {   "0x4C00" , "Klimabedienteil"                            ,     "1"       },
  {   "0x4D00" , "Gebläseregler"                              ,     "1"       },
  {   "0x4E00" , "Klappenmotor"                               ,     "0"       },
  {   "0x4F00" , "Elektrischer Kältemittelverdichter eKMV"    ,     "1"       },
  {   "0x4F80" , "Elektrischer Zuheizer PTC"                  ,     "1"       },
  {   "0x6000" , "Standheizung"                               ,     "1"       },
  {   "0x6100" , "Wärmepumpe"                                 ,     "1"       },
  {   "0x6200" , "elektrischer Durchlaufheizer"               ,     "1"       },
  {   "0x6300" , "Ionisator"                                  ,     "1"       },
  {   "0x6400" , "Bedufter"                                   ,     "1"       },

// PMA
  {   "0x5000" , "PMA Sensor links"                         ,     "1"       },
  {   "0x5100" , "PMA Sensor rechts"                        ,     "1"       },
// CDM RR04
  {   "0x5200" , "CID-Klappe"                                 ,     "-"       },
// F25
  {   "0x5300" , "Schaltzentrum Lenksäule"                    ,     "1"       },
  {   "0x5400" , "Multifunktionslenkrad"                      ,     "1"       },
  {   "0x5500" , "Lenkradelektronik"                          ,     "1"       },
// CID L7
  {   "0x5600" , "CID"                                          ,     "-"       },
// ACSM 4
  {   "0x5700" , "Satellit Upfront links"                 ,     "0"       },
  {   "0x5708" , "Satellit Upfront rechts"                ,     "0"       },
  {   "0x5710" , "Satellit Tür links"                    ,     "0"       },
  {   "0x5718" , "Satellit Tür rechts"                   ,     "0"       },
  {   "0x5720" , "Satellit B-Säule links X"              ,     "0"       },
  {   "0x5728" , "Satellit B-Säule rechts X"             ,     "0"       },
  {   "0x5730" , "Satellit B-Säule links Y"              ,     "0"       },
  {   "0x5738" , "Satellit B-Säule rechts Y"             ,     "0"       },
  {   "0x5740" , "Satellit Zentralsensor X"                 ,     "0"       },
  {   "0x5748" , "Satellit Zentralsensor Y"                 ,     "0"       },
  {   "0x5750" , "Satellit Zentralsensor Low g Y"           ,     "0"       },
  {   "0x5758" , "Satellit Zentralsensor Low g Z"           ,     "0"       },
  {   "0x5760" , "Satellit Zentralsensor Roll Achse"      ,     "0"       },
  {   "0x5768" , "Fussgängerschutz Sensor links"         ,     "0"       },
  {   "0x5770" , "Fussgängerschutz Sensor rechts"        ,     "0"       },
  {   "0x5778" , "Fussgängerschutz Sensor mitte"         ,     "0"       },
  {   "0x5780" , "Fussgängerschutzsensor statisch"         ,     "0"       },
  {   "0x5788" , "Satellit C-Säule links Y"              ,     "0"       },
  {   "0x5790" , "Satellit C-Säule rechts Y"             ,     "0"       },
  {   "0x5798" , "Satellit Zentrale Körperschall"         ,     "0"       },
  {   "0x57A0" , "Kapazitive Insassen- Sensorik CIS"          ,     "1"       },
  {   "0x57A8" , "Sitzbelegungserkennung Beifahrer SBR"     ,     "1"       },
  {   "0x57B0" , "Fussgängerschutzsensor dynamisch 1"      ,     "0"       },
  {   "0x57B8" , "Fussgängerschutzsensor dynamisch 2"      ,     "0"       },

  {   "0x5800" , "HUD"                                          ,     "1"       },
  {   "0x5900" , "Audio-Bedienteil"                           ,     "1"       },
  {   "0x5A00" , "Innenlichtelektronik"                       ,     "1"       },

// Mini F56
  {   "0x5B00" , "Zentralinstrument"                          ,     "-"       },

// BDC
  {   "0x5C00" , "Elektrische Lenksäulenverstellung ELSV"                 ,     "1"       },
  {   "0x5D00" , "Hands-Off Detection HOD"                                ,     "1"       },
  {   "0x5E01" , "Innenbeleuchtung Fußraum Fahrer vorne"            ,     "1"       },
  {   "0x5E02" , "Innenbeleuchtung Fußraum Fahrer hinten"           ,     "1"       },
  {   "0x5E03" , "Innenbeleuchtung Fußraum Beifahrer vorne"         ,     "1"       },
  {   "0x5E04" , "Innenbeleuchtung Fußraum Beifahrer hinten"        ,     "1"       },
  {   "0x5E05" , "Innenbeleuchtung Fahrertür vorne oben"            ,     "1"       },
  {   "0x5E06" , "Innenbeleuchtung Fahrertür vorne Mitte"           ,     "1"       },
  {   "0x5E07" , "Innenbeleuchtung Fahrertür vorne unten"           ,     "1"       },
  {   "0x5E08" , "Innenbeleuchtung Fahrertür vorne Kartentasche"    ,     "1"       },
  {   "0x5E09" , "Innenbeleuchtung Fahrertür hinten oben"           ,     "1"       },
  {   "0x5E0A" , "Innenbeleuchtung Fahrertür hinten unten"          ,     "1"       },
  {   "0x5E0B" , "Innenbeleuchtung Fahrertür hinten Kartentasche"   ,     "1"       },
  {   "0x5E0C" , "Innenbeleuchtung Beifahrertür vorne oben"         ,     "1"       },
  {   "0x5E0D" , "Innenbeleuchtung Beifahrertür vorne Mitte"        ,     "1"       },
  {   "0x5E0E" , "Innenbeleuchtung Beifahrertür vorne unten"        ,     "1"       },
  {   "0x5E0F" , "Innenbeleuchtung Beifahrertür vorne Kartentasche" ,     "1"       },
  {   "0x5E10" , "Innenbeleuchtung Beifahrertür hinten oben"        ,     "1"       },
  {   "0x5E11" , "Innenbeleuchtung Beifahrertür hinten unten"       ,     "1"       },
  {   "0x5E12" , "Innenbeleuchtung Beifahrertür hinten Kartentasche",     "1"       },
  {   "0x5E13" , "Innenbeleuchtung I-Tafel Fahrer oben"             ,     "1"       },
  {   "0x5E14" , "Innenbeleuchtung I-Tafel Fahrer unten"            ,     "1"       },
  {   "0x5E15" , "Innenbeleuchtung I-Tafel oben Mitte"              ,     "1"       },
  {   "0x5E16" , "Innenbeleuchtung I-Tafel unten Mitte"             ,     "1"       },
  {   "0x5E17" , "Innenbeleuchtung I-Tafel oben Beifahrer"          ,     "1"       },
  {   "0x5E18" , "Innenbeleuchtung I-Tafel unten Beifahrer"         ,     "1"       },
  {   "0x5E19" , "Innenbeleuchtung B-Säule Fahrer"                    ,     "1"       },
  {   "0x5E1A" , "Innenbeleuchtung B-Säule Beifahrer"                 ,     "1"       },
  {   "0x5E1B" , "Innenbeleuchtung Lehne Fahrersitz"                  ,     "1"       },
  {   "0x5E1C" , "Innenbeleuchtung Lehne Beifahrersitz"               ,     "1"       },
  {   "0x5E1D" , "Innenbeleuchtung Centerstack"                         ,     "1"       },
  {   "0x5E1E" , "Innenbeleuchtung Mittelkonsole Ablagefach"          ,     "1"       },
  {   "0x5E1F" , "Innenbeleuchtung Gangwahlschalter links"            ,     "1"       },
  {   "0x5E20" , "Innenbeleuchtung Gangwahlschalter rechts"           ,     "1"       },

  {   "0xFFFF" , "unbekannter Verbauort"                      ,     "-"       }
};

// Zuordnung von Teilenummer zu BMW-Teilenummer
// intelligenter Sensoren
// wenn vom Sensor nicht gegeben
  table PartNrTabelle[3][] = {
  { "PART_NR"    , "BMW_NR"  , "KOMMENTAR"                },
//{ "1234567890" , "1234567" , "Lin-Sensor Schrittmotor"  },
  { "--"         , "--"      , "unbekannte Teilenummer" }
};
// end of : #include "STD_ISEN.b2s"
// UDS Standard Tabelle (für Job Sensoren_Ident_Lesen)
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_LieferantenLIN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'LIN-Lieferantennummer <-> LIN-Lieferantentext'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 07.02.2007 gr V0.001 Ersterstellung auf www.lin-subbus.org -> Consortium\Supplier Codes
// 15.02.2007 gr V1.000 Freigabe
// 12.09.2007 gr V1.001 Nummer 0x51 bis 0x55 hinzu
// 26.02.2008 gr V1.002 Nummer 0x56 und 0x57 hinzu
// 25.03.2008 gr V1.003 Nummer 0x58 und 0x59 hinzu
// 17.07.2008 gr V1.004 Nummer 0x5A bis 0x5C hinzu
// 05.03.2009 gr V1.005 Nummer 0x60 bis 0x67 hinzu
// 09.07.2009 gr V1.006 Nummer 0x68 hinzu
// 07.08.2009 gr V1.007 Nummer 0x66 hinzu
// 16.11.2009 gr V1.008 Nummer 0x69 hinzu
// 16.11.2010 ms V1.009 Nummer 0x70 bis 0x73 hinzu
// *******************************************************************
// UDS_TAB_LieferantenLIN.B2S @(#)@ V1.009@(#)@
// *******************************************************************
#define INCLUDE_UDS_LieferantenLIN_B2S_NOT_FOUND

table LieferantenLIN[2][] = {
{ "LIEF_NR"     , "LIEF_TEXT"                           },

{ "0x0001"	, "Audi"		  		},
{ "0x0002"	, "BMW"					},
{ "0x0003"	, "DaimlerChrysler" 			},			
{ "0x0004"	, "Motorola"				},
{ "0x0005"	, "VCT/Mentor Graphics" 		},
{ "0x0006"	, "VW (VW-Group)" 			},
{ "0x0007" 	, "Volvo Cars (Ford Group)"		},
{ "0x000B"	, "Freescale Semiconductor"		},
{ "0x0011"	, "NXP Semiconductors" 			},
{ "0x0012"	, "ST Microelectronics" 		},
{ "0x0013"	, "Melexis"				},
{ "0x0014"	, "Microchip"				},
{ "0x0015"	, "CRF"					},
{ "0x0016"	, "Renesas Technology Europe GmbH"	},
{ "0x0017"	, "Atmel"				},
{ "0x0018"	, "Magnet Marelli"			},
{ "0x0019"	, "NEC"					},
{ "0x001A"	, "Fujitsu"				},
{ "0x001B"	, "Opel"				},	
{ "0x001C"	, "Infineon"				},
{ "0x001D"	, "AMI Semiconductor"			},
{ "0x001E"	, "Vector Informatik"			},
{ "0x001F"	, "Brose"				},
{ "0x0020"	, "ZMD"					},
{ "0x0021"	, "ihr"					},	
{ "0x0022"	, "Visteon"				},
{ "0x0023"	, "ELMOS"				},
{ "0x0024"	, "ON Semi"				},
{ "0x0025"	, "Denso"				},
{ "0x0026"	, "c&s"					},
{ "0x0027"	, "Renault"				},
{ "0x0028"	, "Renesas Technology Europe Limited"	},
{ "0x0029"	, "Yazaki"				},
{ "0x002A"	, "Trinamic Microchips"			},
{ "0x002B"	, "Allegro Microsystems"		},
{ "0x002C"	, "Toyota"				},
{ "0x002D"	, "PSA Peugeot Citroën"			},
{ "0x002E"	, "Westsächsische Hochschule Zwickau"	},
{ "0x002F"	, "Micron AG"				},
{ "0x0030"	, "Delphi Deutschland GmbH"		},
{ "0x0031"	, "Texas Instruments Deutschland GmbH"	},
{ "0x0032"	, "Maxim Integrated Products"		},
{ "0x0033"	, "Bertrandt Ingenierbüro GmbH"		},
{ "0x0034"	, "PKC Group Oyi"			},
{ "0x0035"	, "BayTech IKs"				},
{ "0x0036"	, "Hella KGaA Hueck & Co."		},
{ "0x0037"	, "Continental Temic microelectronic GmbH"},
{ "0x0038"	, "Johnson Controls GmbH"		},
{ "0x0039"	, "Toshiba Electronics Europe GmbH"	},
{ "0x003A"	, "Analog Devices"			},
{ "0x003B"	, "TRW Automotive Electronics & Components GmbH & Co. KG"	},
{ "0x003C"	, "Advanced Data Controls, Corp."	},
{ "0x003D"	, "GÖPEL electronic GmbH"		},
{ "0x003E" 	, "Dr. Ing. h.c. F. Porsche AG"		},
{ "0x003F"	, "Marquardt GmbH"			},
{ "0x0040"	, "ETAS GmbH"				},
{ "0x0041"	, "Micronas GmbH"			},
{ "0x0042"	, "Preh GmbH"				},
{ "0x0043"	, "GENTEX CORPORATION"			},
{ "0x0044"	, "ZF Lenksysteme GmbH"			},
{ "0x0045"	, "Nagares S.A."			},
{ "0x0046"	, "MAN Nutzfahrzeuge AG"		},
{ "0x0047"	, "BITRON SpA BU Grugliasco"		},
{ "0x0048"	, "Pierburg GmbH"			},
{ "0x0049"	, "Alps Electric Co., Ltd"		},
{ "0x004A"	, "Beru Electronics GmbH"		},
{ "0x004B"	, "Paragon AG"				},
{ "0x004C"	, "Silicon Laboratories"		},
{ "0x004D"	, "Sensata Technologies Holland B.V."	},
{ "0x004E"	, "Meta System S.p.A"			},
{ "0x004F"	, "Dräxlmaier Systemtechnik GmbH"	},
{ "0x0050"	, "Grupo Antolin Ingenieria, S.A."	},
{ "0x0051"	, "MAGNA-Donnelly GmbH&Co.KG"    	},
{ "0x0052"	, "IEE S.A."				},
{ "0x0053"	, "austriamicrosystems AG"		},
{ "0x0054"	, "Agilent Technologies"		},
{ "0x0055"	, "Lear Corporation "			},
{ "0x0056"	, "KOSTAL Ireland GmbH"  		},
{ "0x0057"	, "LIPOWSKY Industrie-Elektronik GmbH "	},
{ "0x0058"	, "Sanken Electric Co.,Ltd"		},
{ "0x0059"	, "Elektrobit Automotive GmbH"		},
{ "0x005A"	, "VIMERCATI S.p.A."		        },
{ "0x005B"	, "AB Volvo"				},
{ "0x005C"	, "SMSC Europe GmbH"			},
{ "0x0060"	, "Sitronic"			       	},
{ "0x0061"	, "Flextronics / Sidler Automotive"	},
{ "0x0062"	, "EAO Automotive"			},
{ "0x0063"	, "helag-electronic"			},
{ "0x0064"	, "Magna International"			},
{ "0x0065"	, "ARVINMERITOR"			},
{ "0x0066"	, "Valeo SA"	                        },
{ "0x0067"	, "Defond Holding / BJAutomotive"	},
{ "0x0068"	, "Industrie Saleri S. p. A."	        },
{ "0x0069"	, "ROHM Semiconductor GmbH"	        },
{ "0x0070"	, "Alfmeier AG"	       			},
{ "0x0071"	, "Sanden Corporation"		        },
{ "0x0072"	, "Huf Hülsbeck & Fürst GmbH&Co KG"	},
{ "0x0073"	, "ebm-papst St. Georgen GmbH&Co. KG"	},

{ "0xFFFF"	, "unbekannter Hersteller"          }
};
 
// end of : #include "UDS_TAB_LieferantenLIN.B2S"
// UDS Standard Tabelle (für Job IS_Lesen)
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_IArtTexte.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Fehlerart-Nr -> Fehlerart-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 05.12.2005 gr V0.001 Ersterstellung aus Basis UDS_TAB_FART.B2S
// 02.02.2006 gr V0.002 Anpassungen an neue DTCStatusMask 0C
// 02.02.2006 gh V0.002 Include-Name geändert (wie Tabellen-Name)
// 01.04.2008 as V0.003 Texte geändert
// *******************************************************************
// UDS_TAB_IArtTexte.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_IArtTexte_B2S_NOT_FOUND

  table IArtTexte[2][] = {
  { "ARTNR" , "ARTTEXT"                                                      },

  { "0x00"  , "keine Fehlerart verfügbar"                                  },
  { "0x04"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x05"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x08"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x09"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x0C"  , "Fehler momentan nicht vorhanden, aber bereits gespeichert"  },
  { "0x0D"  , "Fehler momentan vorhanden und bereits gespeichert"          },
  { "0x44"  , "Fehler gespeichert"                                         },
  { "0x45"  , "Fehler gespeichert"                                         },
  { "0x48"  , "Fehler gespeichert"                                         },
  { "0x49"  , "Fehler gespeichert"                                         },
  { "0x4C"  , "Fehler gespeichert"                                         },
  { "0x4D"  , "Fehler gespeichert"                                         },
  { "0x10"  , "Testbedingungen erfüllt"                                   },
  { "0x11"  , "Testbedingungen noch nicht erfüllt"                        },
  { "0x80"  , "Fehler würde kein Aufleuchten einer Warnlampe verursachen" },
  { "0x81"  , "Fehler würde das Aufleuchten einer Warnlampe verursachen"  },

  { "0xFF"  , "unbekannte Fehlerart"                                       }
};

// end of : #include "UDS_TAB_IArtTexte.B2S"
// UDS Standard Tabelle (für Job Response_On_Event)
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_TAB_ROE_AKTIV.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'STAT_ROE_AKTIV-Nr -> STAT_ROE_AKTIV-Text'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
//
// -------------------------------------------------------------------
// History:
// 30.11.2006 aN V0.001 Ersterstellung (Albrecht Neff, EI-71)
//
// *******************************************************************
// UDS_TAB_ROE_AKTIV.B2S @(#)@ V0.001 @(#)@
// *******************************************************************
#define INCLUDE_UDS_TAB_ROE_AKTIV_B2S_NOT_FOUND

  table UDS_TAB_ROE_AKTIV[2][] =
{
  { "NR"   , "TEXT"},

  { "0x00" , "Aktive Fehlermeldung deaktiviert"},
  { "0x01" , "Aktive Fehlermeldung aktiviert"},
  { "0xFF" , "Status der aktiven Fehlermeldung nicht feststellbar"}
};

// end of : #include "UDS_TAB_ROE_AKTIV.B2S"

// *******************************************************************
// Tabellen
// *******************************************************************

table JobResultExtended[2][]={
  { "SB", "STATUS_TEXT" },
  { "0xXY", "ERROR_UNKNOWN" }
};

// Tabelle wird bei den Jobs:  STATUS_BETRIEBSMODE / STEUERN_BETRIEBSMODE  benötigt
table Betriebsmode[3][]={
  { "WERT", "TEXT", "BEDEUTUNG" },
  { "0x00", "Allgemeiner Fertigungs- und Energiesparmode", "Hier deaktivierte Funktionen gemäß FeTra-Liste festhalten" },
  { "0x01", "Spezieller Energiesparmode", "-" },
  { "0x02", "ECOS-Mode", "-" },
  { "0x03", "MOST-Mode", "-" },
  { "0x04", "Rollenmode", "-" },
  { "0xFF", "ungültiger Betriebsmode", "ungültig" }
};

table FOrtTexte[3][]={
  { "ORT", "ORTTEXT", "EREIGNIS_DTC" },
  { "0x021A00", "Energiesparmode aktiv", "0" },
  { "0x021A08", "Codierung: Steuergerät ist nicht codiert", "0" },
  { "0x021A09", "Codierung: Fehler bei Codierdatentransaktion aufgetreten", "0" },
  { "0x021A0A", "Codierung: Signatur der Codierdaten ungültig", "0" },
  { "0x021A0B", "Codierung: Codierdaten passen nicht zum Fahrzeug", "0" },
  { "0x021A0C", "Codierung: Unplausible Daten während Codierdatentransaktion", "0" },
  { "0x02FF1A", "Dummy-Fehlerspeichereintrag im Komponentenfehlerbereich nur für Testzwecke", "1" },
  { "0x21EA00", "interner Fehler, Ebene3, ROM-Fehler mc0", "0" },
  { "0x21EA01", "interner Fehler, Ebene3, RAM-Fehler mc0", "0" },
  { "0x21EA02", "interner Fehler, Ebene3, Stack-Fehler mc0", "0" },
  { "0x21EA06", "interner Fehler, FZM: Systemzustand unplausibel", "0" },
  { "0x21EA07", "ELUP: Allgemeiner Elup Fehler", "0" },
  { "0x21EA08", "ELUP: Betriebsbedingungen der Elup nicht erfüllt. Mögliche Ursachen sind Montage Mode oder Spannung außerhalb von 9 - 16 V", "0" },
  { "0x21EA09", "Parksperre, Sensor: Signal 1 Kurzschluss nach Masse", "0" },
  { "0x21EA0A", "Parksperre, Sensor: Signal 1 Kurzschluss nach Plus", "0" },
  { "0x21EA0B", "Parksperre, Sensor: Signal 2 Kurzschluss nach Masse", "0" },
  { "0x21EA0C", "Parksperre, Sensor: Signal 2 Kurzschluss nach Plus", "0" },
  { "0x21EA0D", "Parksperre, Sensor: Sensoren inkonsistent", "0" },
  { "0x21EA0E", "Parksprerre, HB-Spannung: nicht im zulässigen Bereich", "0" },
  { "0x21EA10", "Parksprerre, Aktuator: Maximalstromüberwachung", "0" },
  { "0x21EA11", "Parksperre, Aktuator: PS-Position in der zulässigen Zeit nicht erreicht", "0" },
  { "0x21EA12", "Parksperre, Aktuator: keine Änderung der PS-Position", "0" },
  { "0x21EA13", "Parksperre, Aktuator: angeforderte Position konnte nicht erreicht werden", "0" },
  { "0x21EA14", "Parksperre, Init: Keine Daten für PS offen/geschlossen im NV-Ram vorhanden", "0" },
  { "0x21EA15", "Parksperre, EWS: Abgleich nicht erfolgreich", "0" },
  { "0x21EA16", "interner Fehler, Ebene3, Doppelablage-Fehler mc0", "0" },
  { "0x21EA17", "interner Fehler, Ebene3, Interner ADC-Fehler mc0", "0" },
  { "0x21EA19", "interner Fehler, Ebene3, Programablauf-Fehler mc0", "0" },
  { "0x21EA1A", "ELUP, Sensor: Unterdrucksensor elektrischer Fehler", "0" },
  { "0x21EA1B", "ELUP, Aktuator: keine Gegeninduktion", "0" },
  { "0x21EA1C", "ELUP, Aktuator: Kurzschluss nach Plus", "0" },
  { "0x21EA1D", "ELUP, Aktuator: Kurzschluss nach Masse", "0" },
  { "0x21EA1E", "ELUP, Aktuator: Unterbrechung oder nicht angesteckt", "0" },
  { "0x21EA1F", "ELUP, Treiber: Strom zu hoch", "0" },
  { "0x21EA20", "ELUP, Treiber: Schaltet nicht durch", "0" },
  { "0x21EA21", "ELUP, Treiber: Temperatur zu hoch", "0" },
  { "0x21EA22", "ELUP, Sensor: Temperatur Sensor defekt", "0" },
  { "0x21EA23", "interner Fehler, Ebene3, Konfigregister-Fehler mc0", "0" },
  { "0x21EA24", "interner Fehler, Ebene3, Ebene2Prime-Fehler mc0", "0" },
  { "0x21EA25", "interner Fehler, Ebene3, Externer Watchdog-Fehler mc0", "0" },
  { "0x21EA27", "Interner Fehler, Montagemodus aktiv", "0" },
  { "0x21EA28", "Parksperre, FUSI: Ebene1/Ebene2 Fehler", "0" },
  { "0x21EA29", "FUSI, Längsdynamik: Quadrantenplausibilisierung", "0" },
  { "0x21EA2A", "F_M_BMW_CCM636_FAULTTYPE -> Checkcontrol 636 : Hochvoltsystem abgeschaltet", "1" },
  { "0x21EA2B", "F_M_BMW_CCM802_FAULTTYPE -> Checkcontrol 802 : Ladekabel pruefen", "1" },
  { "0x21EA2C", "F_M_BMW_CCM803_FAULTTYPE -> Checkcontrol 803 : Netzleistung zu gering", "1" },
  { "0x21EA2D", "F_M_BMW_CCM804_FAULTTYPE -> Checkcontrol 804 : Laden nicht moeglich", "1" },
  { "0x21EA2E", "F_M_BMW_CCM809_FAULTTYPE -> Checkcontrol 809 : Zum Laden P einlegen", "1" },
  { "0x21EA2F", "F_M_BMW_HVAUS_SOC_FAULTTYPE -> HV Powermanagement : HV Power Down aufgrund niedrigem Ladezustand HV Batterie", "0" },
  { "0x21EA30", "Hochvoltbatterie - Temperatur kritischer Wert", "0" },
  { "0x21EA31", "Hochvoltbatterie - Temperatur verlässt Normalbereich", "0" },
  { "0x21EA32", "Hochvoltbatterie - Temperatur wieder im Normalbereich", "0" },
  { "0x21EA33", "F_M_BMW_LADEN_AC_ABBRUCH_FAULTTYPE -> Lademanagement : AC Spannung fehlt nach Ladebeginn", "0" },
  { "0x21EA34", "F_M_BMW_LADEN_AC_INSTABIL_FAULTTYPE -> Lademanagement : AC Spannung dauerhaft instabil", "0" },
  { "0x21EA35", "F_M_BMW_LADEN_FAILSAFE_FAULTTYPE -> Lademanagement : SLE/KLE in Failsafe", "0" },
  { "0x21EA36", "F_M_BMW_LADEN_LADEFEHLER_FAULTTYPE -> Lademanagement : Ladefehler", "0" },
  { "0x21EA37", "F_M_BMW_LADEN_LADEZIEL_FAULTTYPE -> Lademanagement : Ladeziel nicht erreichbar (SLE Leistung zu gering)", "0" },
  { "0x21EA38", "F_M_BMW_LADEN_NVBN_FAULTTYPE -> Lademanagement : Ladeziel nicht erreichbar (Entladeschutz NV BN)", "0" },
  { "0x21EA39", "F_M_BMW_LADEN_STECKER_UBK_FAULTTYPE -> Lademanagement : Zustand Ladestecker unbekannt", "0" },
  { "0x21EA3A", "F_M_BMW_LADEN_STOERUNG_FAULTTYPE -> Lademanagement : Ladestoerung", "0" },
  { "0x21EA3B", "F_M_BMW_PILOT_UNGUELTIG_FAULTTYPE -> Lademanagement : Pilotsignal ungueltig", "0" },
  { "0x21EA3C", "F_M_BMW_PILOT_UNGUELTIG_LK_FAULTTYPE -> Lademanagement : Pilotsignal ungueltig ausserhalb Ladebereitschaft", "0" },
  { "0x21EA3D", "F_M_BMW_VOKO_FEHLER_FAULTTYPE -> Lademanagement : Vorkonditionierung nicht moglich", "0" },
  { "0x21EA3E", "HV-Powermanagement: Anforderung Entlastung DCDC-Wandler an AEP", "1" },
  { "0x21EA3F", "Crash: Zündpille aktiviert", "1" },
  { "0x21EA40", "HV-Powermanagement: HV Erstfreigabe erfolgt", "0" },
  { "0x21EA41", "F_M_BMW_HVBATT_ISOWARN_FAULTTYPE -> HV Batterie : Isolationswarnung", "0" },
  { "0x21EA42", "F_M_BMW_HVOFF_FAIL_FAULTTYPE -> HV Zwischenkreisentladung : HV Zwischenkreis nicht spannungsfrei trotz Anforderung", "1" },
  { "0x21EA43", "F_M_BMW_INLK_SYS_FAULTTYPE -> HV Powermanagement : Interlock unterbrochen", "0" },
  { "0x21EA44", "F_M_BMW_SCHUETZKLEBER_1_FAULTTYPE -> HV Batterie : einfacher Schuetzkleber", "0" },
  { "0x21EA45", "AE, ELUP, Unterdrucksystem, Lekage erkannt", "0" },
  { "0x21EA46", "AE, ELUP, Unterdrucksystem, Elektrische Unterdruckpumpe maximale Laufzeit überschritten (Dauerlauf)", "0" },
  { "0x21EA47", "AE, ELUP, Unterdrucksystem, Elektrische Unterdruckpumpe Förderleistung zu gering", "0" },
  { "0x21EA48", "AE, ELUP, Unterdrucksystem, Unterdruckniveau zu gering", "0" },
  { "0x21EA49", "AE, ELUP, Unterdrucksystem, Unterdrucksensor Messwert außerhalb gültigem Bereich", "0" },
  { "0x21EA4A", "AE, ELUP, Unterdrucksystem, Förderleistung mechanische Pumpe zu gering, oder Rückschlagventil defekt", "0" },
  { "0x21EA4B", "Ganghaenger in N Getriebe der elektrische Achse", "1" },
  { "0x21EA4C", "Ganghaenger im 1. Gang Getriebe der elektrische Achse", "1" },
  { "0x21EA4D", "Ganghaenger im 2. Gang Getriebe der elektrische Achse", "1" },
  { "0x21EA4E", "Gang Getriebe der elektrische Achse unbekannt", "1" },
  { "0x21EA4F", "FIS EWP Zustand unbekannt", "1" },
  { "0x21EA60", "DCDC, Messwertüberprüfung, Fataler Fehler in Messwerterfassung U_LV", "0" },
  { "0x21EA61", "DCDC, Messwertüberprüfung, Fataler Fehler in Messwerterfassung I_LV", "0" },
  { "0x21EA62", "DCDC, Messwertüberprüfung, Fehler in Messwerterfassung_Notlauf möglich", "0" },
  { "0x21EA6B", "DCDC, ProtectionHandler, Strom auf LV-Seite zu hoch", "0" },
  { "0x21EA6E", "DCDC, ProtectionHandler, Spannung auf LV-Seite zu hoch", "0" },
  { "0x21EA71", "DCDC, Überwachung, Spannung auf HV-Seite zu hoch", "0" },
  { "0x21EA72", "DCDC, Überwachung, Spannung auf HV-Seite zu niedrig", "0" },
  { "0x21EA76", "DCDC, Überwachung, Fehler Masseanbindung_Notlauf", "0" },
  { "0x21EA77", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: Crash Klemme 30C", "0" },
  { "0x21EA78", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: CY320 MC0", "0" },
  { "0x21EA79", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: CY320 MC2", "0" },
  { "0x21EA95", "interner Fehler, Ebene3, ROM-Fehler mc2", "0" },
  { "0x21EA96", "interner Fehler, Ebene3, RAM-Fehler mc2", "0" },
  { "0x21EA97", "interner Fehler, Ebene3, Stack-Fehler mc2", "0" },
  { "0x21EA98", "interner Fehler, Ebene3, Doppelablage-Fehler mc2", "0" },
  { "0x21EA99", "interner Fehler, Ebene3, Interner ADC-Fehler mc2", "0" },
  { "0x21EA9B", "interner Fehler, Ebene3, Programablauf-Fehler mc2", "0" },
  { "0x21EA9C", "interner Fehler, Ebene3, Konfigregister-Fehler mc2", "0" },
  { "0x21EA9D", "interner Fehler, Ebene3, Ebene2Prime-Fehler mc2", "0" },
  { "0x21EA9E", "interner Fehler, Ebene3, Externer Watchdog-Fehler mc2", "0" },
  { "0x21EA9F", "interner Fehler, FUSI, Abschaltpfadtest-Fehler mc2", "0" },
  { "0x21EAA1", "Sensorfehler, Messwerterfassung, Winkelgeber/Drehzahlgeber defekt", "0" },
  { "0x21EAAE", "interner Fehler, AEPH, Zwischenkreisspannung oberen Grenzwert überschritten", "0" },
  { "0x21EAAF", "interner Fehler, AEPH, Zwischenkreisspannung unteren Grenzwert unterschritten", "0" },
  { "0x21EAB2", "interner Fehler, AEPH, Gatetreiber Zwischenkreisspannung oberen Grenzwert überschritten", "0" },
  { "0x21EAB3", "interner Fehler, AEPH, Gatetreiber Zwischenkreisspannung unteren Grenzwert unterschritten", "0" },
  { "0x21EAB4", "interner Fehler, AEPH, Interne 12V-Versorgungsspannung oberen Grenzwert überschritten", "0" },
  { "0x21EAB5", "interner Fehler, AEPH, Interne 12V-Versorgungsspannung unteren Grenzwert unterschritten", "0" },
  { "0x21EAB6", "interner Fehler, AEPH, Interne 5V-Spannung vom CY320_MC0 oberen Grenzwert überschritten", "0" },
  { "0x21EAB7", "interner Fehler, AEPH, Interne 5V-Spannung vom CY320_MC0 unteren Grenzwert unterschritten", "0" },
  { "0x21EAB8", "interner Fehler, AEPH, Interne 3V3-Spannung vom CY320_MC0 oberen Grenzwert überschritten", "0" },
  { "0x21EAB9", "interner Fehler, AEPH, Interne 3V3-Spannung vom CY320_MC0 unteren Grenzwert unterschritten", "0" },
  { "0x21EABA", "interner Fehler, AEPH, Interne 1V5-Spannung vom CY320_MC0 oberen Grenzwert überschritten", "0" },
  { "0x21EABB", "interner Fehler, AEPH, Interne 1V5-Spannung vom CY320_MC0 unteren Grenzwert unterschritten", "0" },
  { "0x21EABC", "interner Fehler, AEPH, Interne 5V-Spannung vom CY320_MC2 oberen Grenzwert überschritten", "0" },
  { "0x21EABD", "interner Fehler, AEPH, Interne 5V-Spannung vom CY320_MC2 unteren Grenzwert unterschritten", "0" },
  { "0x21EABE", "interner Fehler, AEPH, interne 3V3-Spannung vom CY320_MC2 oberen Grenzwert überschritten", "0" },
  { "0x21EABF", "interner Fehler, AEPH, Interne 3V3-Spannung vom CY320_MC2 unteren Grenzwert unterschritten", "0" },
  { "0x21EAC0", "interner Fehler, AEPH, Interne 1V5-Spannung vom CY320_MC2 oberen Grenzwert überschritten", "0" },
  { "0x21EAC1", "interner Fehler, AEPH, Interne 1V5-Spannung vom CY320_MC2 unteren Grenzwert unterschritten", "0" },
  { "0x21EADA", "interner Fehler, AEPH, Temperatur auf dem Digitalbord am 320_MC0 oberen Grenzwert überschritten", "0" },
  { "0x21EADB", "interner Fehler, AEPH, Temperatur auf dem Digitalbord am 320_MC0 unteren Grenzwert unterschritten", "0" },
  { "0x21EAE0", "interner Fehler, AEPH, Temperatur auf dem Digitalbord am 320_MC2 oberen Grenzwert überschritten", "0" },
  { "0x21EAE1", "interner Fehler, AEPH, Temperatur auf dem Digitalbord am 320_MC2 unteren Grenzwert unterschritten", "0" },
  { "0x21EAE6", "interner Fehler, AEPH, Temperatur über internen Temperatursensor des MC0 oberen Grenzwert überschritten", "0" },
  { "0x21EAE7", "interner Fehler, AEPH, Temperatur über internen Temperatursensor des MC0 unteren Grenzwert unterschritten", "0" },
  { "0x21EAE8", "interner Fehler, AEPH, Temperatur über internen Temperatursensor des MC2 oberen Grenzwert überschritten", "0" },
  { "0x21EAE9", "interner Fehler, AEPH, Temperatur über internen Temperatursensor des MC2 unteren Grenzwert unterschritten", "0" },
  { "0x21EAF0", "EME, Plausibilisierung der Reglerspannungen", "0" },
  { "0x21EAF1", "EME, Hochvoltzwischenkreis: Spannungsgrenze Speicher überschritten", "0" },
  { "0x21EAF2", "EME, Hochvoltzwischenkreis: Spannungsgrenze Speicher unterschritten", "0" },
  { "0x21EAF3", "EME, Hochvoltzwischenkreis: Lade-Stromgrenze Speicher überschritten", "0" },
  { "0x21EAF4", "EME, Hochvoltzwischenkreis: Entlade-Stromgrenze Speicher überschritten", "0" },
  { "0x21EAF5", "EME, interner Fehler, Momentenpfad: Abweichung Sollmoment Fehler", "0" },
  { "0x21EAF6", "EME, Versorgungsspannung, Wertebereichsverletzung: Unterspannung 12V-Versorgung", "0" },
  { "0x21EAF7", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 1 Kurzschluss zu GND", "0" },
  { "0x21EAF8", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 1 Kurzschluss zu UBAT", "0" },
  { "0x21EAF9", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 2 Kurzschluss zu GND", "0" },
  { "0x21EAFA", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 2 Kurzschluss zu UBAT", "0" },
  { "0x21EAFB", "Sensorfehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 1 Kurzschluss zu GND", "0" },
  { "0x21EAFC", "Sensorfehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 1 Kurzschluss zu UBAT", "0" },
  { "0x21EAFD", "Sensorfehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 2 Kurzschluss zu GND", "0" },
  { "0x21EAFE", "Sensorfehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 2 Kurzschluss zu UBAT", "0" },
  { "0x21EAFF", "Sensorfehler, Messwerterfassung, Sensor: Bremsunterdrucksensorsignal Kurzschluss zu GND", "0" },
  { "0x21EB00", "Sensorfehler, Messwerterfassung, Sensor: Bremsunterdrucksensorsignal Kurzschluss zu UBAT", "0" },
  { "0x21EB03", "DCDC, Hardware, Bauteilschutz, Unplausibler DutyCycle in Tiefsetzsteller 1", "0" },
  { "0x21EB04", "DCDC, Hardware, Bauteilschutz, Unplausibler DutyCycle in Tiefsetzsteller 2", "0" },
  { "0x21EB05", "DCDC, Hardware, Bauteilschutz, Überschreitung max. LV-Spannung", "0" },
  { "0x21EB06", "DCDC, Hardware, Bauteilschutz, Überschreitung max. LV-Strom", "0" },
  { "0x21EB07", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Peak-Strom in Tiefsetzsteller Phase 1", "0" },
  { "0x21EB08", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Peak-Strom in Tiefsetzsteller Phase 2", "0" },
  { "0x21EB09", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Grenzspannung am Tiefsetzstellerausgang", "0" },
  { "0x21EB0A", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Peak-Strom im Resonanzkreis", "0" },
  { "0x21EB0B", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Temperatur am Kühlkörper des Tiefsetzstellers", "0" },
  { "0x21EB0C", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Temperatur am Kühlkörper des Gegentaktwandlers", "0" },
  { "0x21EB0D", "DCDC, Hardware, Bauteilschutz, Überschreitung max. Temperatur am Kühlkörper des Gleichrichters", "0" },
  { "0x21EB0E", "DCDC, Hardware, Bauteilschutz, Überschreitung der max. Board-Temperatur", "0" },
  { "0x21EB0F", "DCDC, Hardware, Bauteilschutz, Unplausibler Wirkungsgrad", "0" },
  { "0x21EB10", "DCDC, Überwachung, Fehler HW-Regler, Sollwerte werden nicht eingeregelt", "0" },
  { "0x21EB11", "DCDC, Hardware, Bauteilschutz, Unplausibles Übersetzungsverhältnis GTW", "0" },
  { "0x21EB12", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter TS1", "0" },
  { "0x21EB13", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter TS2", "0" },
  { "0x21EB14", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Diode TS1", "0" },
  { "0x21EB15", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Diode TS2", "0" },
  { "0x21EB16", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter GTW HS1", "0" },
  { "0x21EB17", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter GTW HS2", "0" },
  { "0x21EB18", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter GTW LS1", "0" },
  { "0x21EB19", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter GTW LS2", "0" },
  { "0x21EB1A", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp GR1", "0" },
  { "0x21EB1B", "DCDC, Hardware, Bauteilschutz, Thermalmodel, JunctionTemp Schalter GR2", "0" },
  { "0x21EB1C", "DCDC, Hardware, Bauteilschutz, Unplausibler Resonanzstrom", "0" },
  { "0x21EB1D", "Interne Getriebeüberwachung -Parkposition aktuell nicht detektierbar", "0" },
  { "0x21EB1E", "Interne Getriebeüberwachung -Parkposition aktuell eingelegt, aktuell kein Fahrerwunsch Parken vorhanden", "0" },
  { "0x21EB1F", "Interne Getriebeüberwachung -Parkposition aktuell nicht eingelegt, aktuell Fahrerwunsch Parken vorhanden", "0" },
  { "0x21EB20", "SLE, SW und HW passen nicht zusammen.", "1" },
  { "0x21EB2A", "EME durch EWS gesperrt", "0" },
  { "0x21EB2B", "Interner Fehler, Messwerterfassung, interner Sensor defekt MC0", "0" },
  { "0x21EB2C", "Interner Fehler, Messwerterfassung, interner Sensor defekt MC2", "0" },
  { "0x21EB2D", "Messwerterfassung, Hardwarekalibrationswerte, eine bzw. mehrere Werte fehlen auf dem MC0", "0" },
  { "0x21EB2E", "Messwerterfassung, Hardwarekalibrationswerte, eine bzw. mehrere Werte fehlen auf dem MC2", "0" },
  { "0x21EB2F", "DCDC, SPI Kommunikation, DCDC- nach Controller-Board fehlerhaft", "0" },
  { "0x21EB30", "DCDC, SPI Kommunikation, Controller- nach DCDC-Board fehlerhaft", "0" },
  { "0x21EB31", "SLE, SPI Kommunikation, Lader- nach Controller-Board fehlerhaft", "0" },
  { "0x21EB32", "SLE, SPI Kommunikation, Controller- nach Lader-Board fehlerhaft", "0" },
  { "0x21EB33", "interner Fehler, FUSI, aktive Entladung-Fehler", "0" },
  { "0x21EB34", "Qualfierueberwachung, Signalausfall CAN von eDME", "0" },
  { "0x21EB35", "Qualfierueberwachung, Signalausfall CAN von SME", "0" },
  { "0x21EB36", "Qualfierueberwachung, Signalausfall Intern", "0" },
  { "0x21EB37", "Qualfierueberwachung, Signalausfall Resolver", "0" },
  { "0x21EB38", "Parksperre, Strommittelwert Kabel PS-Aktuator zu hoch", "0" },
  { "0x21EB3B", "HW-AKS aktiv, Angefordert durch FUSI, BTS oder Hardwareschaltung", "1" },
  { "0x21EB3C", "HW-Freilauf aktiv, Angefordert durch FUSI, BTS oder Hardwareschaltung", "1" },
  { "0x21EB3D", "interne Fehler, Inkompatibilität zwischen TriCore/PIC Softwareversionen", "0" },
  { "0x21EB3E", "E-Maschine Resolverabgleich nicht durchgeführt oder Rotorlagesensor-Offset nicht im Toleranzband.", "0" },
  { "0x21EB40", "Interner Fehler, HVIL, KS Ausgang gegen Masse oder KS Eingang gegen B+", "0" },
  { "0x21EB41", "Interner Fehler, HVIL, KS Ausgang gegen B+ oder KS Eingang gegen Masse", "0" },
  { "0x21EB42", "Interner Fehler, HVIL, Kurzschluss Eingang gegen Ausgang oder Leitung offen", "0" },
  { "0x21EB43", "Interner Fehler, HVIL, fehlerhaftes Signal", "0" },
  { "0x21EB44", "DCDC, Hardware, Bauteilschutz, GateTreiberVersorgung", "0" },
  { "0x21EB45", "Inverter, Temperatur ungültig, nicht kompensierbar", "0" },
  { "0x21EB46", "Inverter, Temperatur ungültig, kompensierbar", "0" },
  { "0x21EB47", "Inverter, Dauerhafte Übertemperatur IGBT/Diode", "0" },
  { "0x21EB48", "Inverter, Erhöhte Temperaturspreizung Platine zu IGBT/Diode", "0" },
  { "0x21EB49", "Inverter, Dauerhafte Übertemperatur NTC", "0" },
  { "0x21EB4A", "Inverter, Dauerhafte Übertemperatur Kühlmittel", "0" },
  { "0x21EB4B", "SLE, Überstromerkennung Hochsetzer, max. Wert überschritten", "0" },
  { "0x21EB4C", "SLE, Überstromerkennung Trafo, max. Wert überschritten", "0" },
  { "0x21EB4D", "SLE, Überspannungserkennung Hochsetzer, max. Wert überschritten", "0" },
  { "0x21EB4E", "SLE, Überspannungserkennung Zwischenkreis, max. Wert überschritten", "0" },
  { "0x21EB4F", "SLE, Unterspannungserkennung Zwischenkreis, min. Wert unterschritten", "0" },
  { "0x21EB50", "SLE, Übertemperaturerkennung Kühlkörper Hochsetzer, max. Wert überschritten", "0" },
  { "0x21EB51", "SLE, Übertemperaturerkennung Kühlkörper Gegentaktwandler, max. Wert überschritten", "0" },
  { "0x21EB52", "SLE, Übertemperaturerkennung Kühlkörper Gleichrichter, max. Wert überschritten", "0" },
  { "0x21EB53", "SLE, Übertemperaturerkennung Sperrschicht MOSFET Hochsetzer, max. Wert überschritten", "0" },
  { "0x21EB54", "SLE, Übertemperaturerkennung Sperrschicht Diode Hochsetzer, max. Wert überschritten", "0" },
  { "0x21EB55", "SLE, Übertemperaturerkennung Sperrschicht MOSFET Zweig 1 Gegentaktwandler, max. Wert überschritten", "0" },
  { "0x21EB56", "SLE, Übertemperaturerkennung Sperrschicht MOSFET Zweig 2 Gegentaktwandler, max. Wert überschritten", "0" },
  { "0x21EB57", "SLE, Übertemperaturerkennung Sperrschicht Diode Gleichrichter, max. Wert überschritten", "0" },
  { "0x21EB58", "SLE, Überspannungserkennung Eingangswechselspannung, max. Wert überschritten", "0" },
  { "0x21EB59", "SLE, Übertemperaturerkennung Bord, max. Wert überschritten", "0" },
  { "0x21EB5A", "SLE, Duty-Fehler Hochsetzer, von Bauteilschutz", "0" },
  { "0x21EB5B", "SLE, SPI-Fehler, von Bauteilschutz", "0" },
  { "0x21EB5C", "Interner Fehler, Freilauf Modus aktiv", "0" },
  { "0x21EB5D", "Interner Fehler, Freilauf Modus und 6km/h überschritten", "0" },
  { "0x21EB5E", "FUSI, Radblockiererkennung: Anforderung AKS aktiv", "0" },
  { "0x21EB5F", "Leistungselektronik Pulswechselrichter, Stromregler verhindert Betrieb", "0" },
  { "0x21EB62", "FUSI, Nullmomentenplausibilisierung aktiv", "0" },
  { "0x21EB63", "Inverter, Fehlerhafter positiver Id-Strom erkannt", "0" },
  { "0x21EB64", "Inverter, DC Überstrom erkannt", "0" },
  { "0x21EB65", "Interner Fehler, Reset auf MC0", "0" },
  { "0x21EB66", "Interner Fehler, Reset auf MC2", "0" },
  { "0x21EB67", "DCDC, Bauteilschutz, Überspannung U_LV redundante Messung", "0" },
  { "0x21EB68", "DCDC, Bauteilschutz, Überstrom I_LV redundante Messung", "0" },
  { "0x21EB69", "interner Fehler, AEPH, Temperatur auf dem Digitalboard, Boardmitte oberen Grenzwert überschritten", "0" },
  { "0x21EB6A", "interner Fehler, AEPH, Temperatur auf dem Digitalboard, Boardmitte unteren Grenzwert unterschritten", "0" },
  { "0x21EB6B", "interner Fehler, HVSM, Zwischenkreisspannung oberen Grenzwert überschritten", "0" },
  { "0x21EB6C", "interner Fehler, HVSM, Zwischenkreisspannung unteren Grenzwert unterschritten", "0" },
  { "0x21EB6D", "FUSI, CPLD AKS Anforderung, CPLD FuSi/BTS Sammelfehler", "0" },
  { "0x21EB6E", "Funktionssicherheitsmanager, DCDC Gleichrichterabschaltung, Rückmeldung unplausibel", "0" },
  { "0x21EB6F", "Messwerterfassung, Hardwarekalibrationswerte, CRC Fehler MC0", "0" },
  { "0x21EB70", "Messwerterfassung, Hardwarekalibrationswerte, CRC Fehler MC2", "0" },
  { "0x21EB71", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: Crash Hardwarepin", "0" },
  { "0x21EB72", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: Crash Airbag SG MRS5", "0" },
  { "0x21EB73", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: Dual Port RAM defekt", "0" },
  { "0x21EB74", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: eDME", "0" },
  { "0x21EB75", "Sensorfehler, Messwerterfassung, Resolver Winkel", "0" },
  { "0x21EB76", "Sensorfehler, Messwerterfassung, Resolver Drehzahl", "0" },
  { "0x21EB77", "DCDC, Unzulässige MC6 Software Version", "0" },
  { "0x21EB78", "Inverter, Dauerhafte Übertemperatur am Gatetrieber", "0" },
  { "0x21EB79", "Inverter, Übertragener Kühlmittelvolumenstrom unterhalb zulässiger Schwelle", "0" },
  { "0x21EB7A", "Resolver, Fehler Plausibilisierung Winkel", "0" },
  { "0x21EB7B", "Fehler bei der Dignose des Bremspedals", "0" },
  { "0x21EB7C", "CCM 848 (China); Fehler aufgrund zu hoher Temperatur der Antriebs-E-Maschine", "0" },
  { "0x21EB7D", "DCDC deaktiviert aufgrund zu hohen Stroms", "0" },
  { "0x21EB7E", "DCDC deaktiviert aufgrund Hardwarefehler", "0" },
  { "0x21EB7F", "DCDC deaktiviert aufgrund zu hoher Temperatur", "0" },
  { "0x21EB80", "DCDC deaktiviert aufgrund Überspannung", "0" },
  { "0x21EB81", "Leistungsreduzierung Antrieb Stufe 1", "0" },
  { "0x21EB82", "Leistungsreduzierung Antrieb Stufe 2", "0" },
  { "0x21EB83", "Fehler Antriebs-E-Maschine; Maximale Drehzahl überschritten", "0" },
  { "0x21EB84", "Batterie Service Request", "0" },
  { "0x21EB85", "Batterie: 0-Stromanforderung", "0" },
  { "0x21EB86", "Batterie: Langsames Öffnen der Schütze", "0" },
  { "0x21EB87", "Batterie: Schnelles Öffnen der Schütze", "0" },
  { "0x21EB88", "Fehler im Kühlsystem der Hochvoltbatterie", "0" },
  { "0x21EB89", "Aktiver Kurzschluss, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8A", "Freilauf, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8B", "0-Momentenanforderung, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8C", "Notlauf-Betrieb, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8D", "Batterie grenzen Überschritten. Erkennung, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8E", "Momentenabweichung, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB8F", "Temperaturfehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB90", "Interlockfehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB91", "Wechselstromfehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB92", "Fehler Rotolagesensor, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB93", "CAN-Signalfehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB94", "Interner Signalfehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB95", "Wegfahrsperre Fehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB96", "Hardwarefehler, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB97", "Temperaturfehler Inverter, verbrennungsmotornahe HV E-Maschine", "0" },
  { "0x21EB98", "Aktiver Kurzschluss, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB99", "Freilauf, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9A", "0-Momentenanforderung, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9B", "Notlauf-Betrieb, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9C", "Batterie grenzen Überschritten. Erkennung, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9D", "Momentenabweichung, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9E", "Temperaturfehler, verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EB9F", "Interlockfehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA0", "Wechselstromfehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA1", "Fehler Rotolagesensor , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA2", "CAN-Signalfehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA3", "Interner Signalfehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA4", "Wegfahrsperre Fehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA5", "Hardwarefehler , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA6", "Temperaturfehler Inverter , verbrennungsmotorferne/ Traktions- HV E-Maschine", "0" },
  { "0x21EBA7", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: FUSI Längsdynamik", "0" },
  { "0x21EBA8", "Hochvoltsicherheitsmanager, HW AKS aktiv, Anforderer: Phasenüberstrom", "0" },
  { "0x21EBA9", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Drahtspulenende Kurzschluss zu GND", "0" },
  { "0x21EBAA", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Drahtspulenende Kurzschluss zu UBAT", "0" },
  { "0x21EBAB", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Stator Kurzschluss zu GND", "0" },
  { "0x21EBAC", "Sensorfehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Stator Kurzschluss zu UBAT", "0" },
  { "0x21EE0B", "HV-Powermanagement: HV-batterieloser Betrieb wird verhindert aufgrund Schützkleber", "0" },
  { "0x21EE0C", "HV-Powermanagement: wichtige Signale der Antriebselektronik ungültig oder nicht empfangen", "0" },
  { "0x21EE0D", "HV-Powermanagement: wichtige Signale der HV-Batterie ungültig oder nicht empfangen", "0" },
  { "0x21EE80", "EME, Stromplausibilisierung der drei Phasen: Summe der Phasenströme außerhalb des erlaubten Bereichs", "0" },
  { "0x21EEC5", "Externer Temperatursensor E-Maschine Signal Wertebereichsverletzung : Untere Schwelle", "0" },
  { "0x21EEC6", "Externer Temperatursensor E-Maschine Signal Wertebereichsverletzung: Obere Schwelle", "0" },
  { "0x21EF09", "Interne EME-Temperatur Leistungselektronik Pulswechselrichter: Obere Temperaturschwelle überschritten", "0" },
  { "0x21EF10", "EME, Stromsensor Phase U: Überstrom oder Sensor defekt", "0" },
  { "0x21EF18", "EME, Stromsemnsor Phase V: Überstrom oder Sensor defekt", "0" },
  { "0x21EF20", "EME, Stromsemnsor Phase W: Überstrom oder Sensor defekt", "0" },
  { "0x21EF41", "EME, E-Maschinenregelung, E-Maschine: Temperatur über 1. Schwelle", "0" },
  { "0x21EF42", "EME, E-Maschinenregelung, E-Maschine: Temperatur über 2. Schwelle", "0" },
  { "0x21EF43", "EME, E-Maschinenregelung, E-Maschine: Überdrehzahl erkannt", "0" },
  { "0x21EF44", "Externer Temperatursensor2 E-Maschine Signal Wertebereichsverletzung : Untere Schwelle", "0" },
  { "0x21EF45", "Externer Temperatursensor2 E-Maschine Signal Wertebereichsverletzung: Obere Schwelle", "0" },
  { "0x21EF46", "EME, E-Maschinenregelung, E-Maschine: Temperatursensor2 über 2. Schwelle", "0" },
  { "0x21EF55", "HV-Powermanagement: Unterversorgung 12V-Bordnetz (Ladekontrollleuchte aktiv)", "1" },
  { "0x21EF90", "Externer Crashsensor über CAN: Crash detektiert (wird von BMW-Funktion HVPM eingetragen)", "1" },
  { "0x21EF96", "EME, HV-Kommunikation: Schützkleber 2 von SME über CAN gemeldet (B_schuetzkleber_2)", "1" },
  { "0x21EFAA", "HV-Powermanagement: Anforderung 12V-Verbraucherreduzierung an AEP", "0" },
  { "0x21EFAE", "HV-Powermanagement: HV-Power-Down aufgrund niedrigem Ladezustand HV-Batterie", "0" },
  { "0x21EFD8", "HV-Powermanagement: keine HV-Freigabe trotz Anforderung", "1" },
  { "0x21EFEF", "HV-Powermanagement: Systembedingte Degradation des DCDC-Wandlers", "1" },
  { "0xCF840A", "FA-CAN Control Module Bus OFF", "0" },
  { "0xCF8486", "A-CAN Control Module Bus OFF", "0" },
  { "0xCF8BFF", "Dummy-Fehlerspeichereintrag im Netzwerkfehlerbereich nur für Testzwecke", "1" },
  { "0xCF9402", "A-CAN, Botschaft ausgefallenl DEGR_MOT_TRCT", "1" },
  { "0xCF9403", "A-CAN, Botschaft ausgefallen ENERG_COSP_ERR_ST_KLE", "1" },
  { "0xCF9404", "A-CAN, Botschaft ausgefallen KLEMMEN", "1" },
  { "0xCF9405", "A-CAN, Botschaft ausgefallen LIM_CHG_DCHG_HVSTO", "1" },
  { "0xCF9406", "A-CAN, Botschaft ausgefallen LIM_KLE", "1" },
  { "0xCF9407", "A-CAN, Botschaft ausgefallen ST_CHG_HVSTO_3", "1" },
  { "0xCF9411", "A-CAN, Botschaft ausgefallen SPEC_MOT_TRCT", "1" },
  { "0xCF9413", "A-CAN, Botschaft ausgefallen ST_HYB_2", "1" },
  { "0xCF9414", "A-CAN, Botschaft ausgefallen STAT_HVSTO_2", "1" },
  { "0xCF9415", "A-CAN, Botschaft ausgefallen AVL_DT_KLE", "1" },
  { "0xCF9416", "A-CAN, Botschaft ausgefallen AVL_DT_KLE_LT", "1" },
  { "0xCF9419", "A-CAN, CRC Fehler, SPEC_MOT_TRCT", "1" },
  { "0xCF941A", "A-CAN, Alive-Counter Fehler SPEC-MOT_TRCT", "1" },
  { "0xCF941D", "A-CAN, CAN_Signal ungültig RQ_ELUP, Botschaft ELUP_SPEC", "1" },
  { "0xCF941F", "A-CAN, Botschaft ausgefallen CTR_CRASH_SWO_EKP", "1" },
  { "0xCF9420", "A-CAN, Botschaft ausgefallen FZZSTD", "1" },
  { "0xCF9421", "A-CAN, Botschaft ausgefallen KILOMETERSTAND", "1" },
  { "0xCF9422", "A-CAN, Botschaft ausgefallen RELATIVZEIT", "1" },
  { "0xCF9423", "A-CAN, Botschaft ausgefallen V_VEH", "1" },
  { "0xCF9424", "A-CAN, CRC Fehler V_VEH", "1" },
  { "0xCF9425", "A-CAN, Alive-Counter Fehler V_VEH", "1" },
  { "0xCF9426", "A-CAN, Botschaft ausgefallen FAHRGESTELLNUMMER", "1" },
  { "0xCF942A", "A-CAN, Botschaft ausgefallen A_TEMP", "1" },
  { "0xCF942B", "A-CAN, Botschaft ausgefallen AVL_DT_SRT_MOT_1", "1" },
  { "0xCF942C", "A-CAN, Botschaft ausgefallen CTR_PRTNT", "1" },
  { "0xCF942D", "A-CAN, Botschaft ausgefallen DT_EL_GEY", "1" },
  { "0xCF942E", "A-CAN, Botschaft ausgefallen DT_HVSTO", "1" },
  { "0xCF942F", "A-CAN, Botschaft ausgefallen DT_PT_1", "1" },
  { "0xCF9430", "A-CAN, Botschaft ausgefallen DT_PT_2", "1" },
  { "0xCF9431", "A-CAN, Botschaft ausgefallen DT_PT_3", "1" },
  { "0xCF9432", "A-CAN, Botschaft ausgefallen FRC_OPRNG_MOT_1", "1" },
  { "0xCF9433", "A-CAN, Botschaft ausgefallen HYB_SPEC", "1" },
  { "0xCF9434", "A-CAN, Botschaft ausgefallen IDENT_HVSTO_0R", "1" },
  { "0xCF9435", "A-CAN, Botschaft ausgefallen INFO_MOT_1", "1" },
  { "0xCF9436", "A-CAN, Botschaft ausgefallen MOD_VC", "1" },
  { "0xCF9437", "A-CAN, Botschaft ausgefallen OBD_INQY_LIM_TORQ", "1" },
  { "0xCF9438", "A-CAN, Botschaft ausgefallen PWMG_LV", "1" },
  { "0xCF9439", "A-CAN, Botschaft ausgefallen RLS_COOL_HVSTO", "1" },
  { "0xCF943A", "A-CAN, Botschaft ausgefallen RQ_RPM_MOT_2", "1" },
  { "0xCF943B", "A-CAN, Botschaft ausgefallen RQ_TORQ_OSTR", "1" },
  { "0xCF943C", "A-CAN, Botschaft ausgefallen ST_CHG_HVSTO_2", "1" },
  { "0xCF943D", "A-CAN, Botschaft ausgefallen ST_DT_MOT_1", "1" },
  { "0xCF943E", "A-CAN, Botschaft ausgefallen ST_GWS", "1" },
  { "0xCF943F", "A-CAN, CRC Fehler ST_GWS_CRC", "1" },
  { "0xCF9440", "A-CAN, Alive-Counter Fehler ST_GWS_ALV", "1" },
  { "0xCF9441", "A-CAN, Botschaft ausgefallen ST_HT_HVSTO", "1" },
  { "0xCF9442", "A-CAN, Botschaft ausgefallen ST_HVSTO_1", "1" },
  { "0xCF9443", "A-CAN, Botschaft ausgefallen ST_INFO_CENG", "1" },
  { "0xCF9444", "A-CAN, Botschaft ausgefallen ST_STA_PWR_DRV", "1" },
  { "0xCF9445", "A-CAN, Botschaft ausgefallen SU_SW_DRDY", "1" },
  { "0xCF9446", "A-CAN, Botschaft ausgefallen TORQ_CRSH_1", "1" },
  { "0xCF9447", "A-CAN, Botschaft ausgefallen UHRZEIT_DATUM", "1" },
  { "0xCF9448", "FA-CAN, Botschaft ausgefallen A_TEMP", "1" },
  { "0xCF9449", "FA-CAN, Botschaft ausgefallen ACLNX_MASSCNTR", "1" },
  { "0xCF944A", "FA-CAN, Botschaft ausgefallen ANG_ACPD", "1" },
  { "0xCF944B", "FA-CAN, Botschaft ausgefallen AVL_BRTORQ_SUM", "1" },
  { "0xCF944C", "FA-CAN, Botschaft ausgefallen AVL_DT_LT_CENG_REX", "1" },
  { "0xCF944D", "FA-CAN, Botschaft ausgefallen AVL_RPM_WHL_UPRT", "1" },
  { "0xCF944E", "FA-CAN, Botschaft ausgefallen FLLUPT_GPWSUP", "1" },
  { "0xCF944F", "FA-CAN, Botschaft ausgefallen KLEMMEN", "1" },
  { "0xCF9450", "FA-CAN, Botschaft ausgefallen RQ_2_WMOM_PT_SUM_DRS", "1" },
  { "0xCF9451", "FA-CAN, Botschaft ausgefallen RQ_AIC_1", "1" },
  { "0xCF9452", "FA-CAN, Botschaft ausgefallen RQ_AIC", "1" },
  { "0xCF9453", "FA-CAN, Botschaft ausgefallen ST_BLT_CT_SOCCU", "1" },
  { "0xCF9454", "FA-CAN, Botschaft ausgefallen ST_CDC_CHGNG_1", "1" },
  { "0xCF9455", "FA-CAN, Botschaft ausgefallen ST_CDC_CHGNG_2", "1" },
  { "0xCF9456", "FA-CAN, Botschaft ausgefallen ST_CDC_CHGNG_3", "1" },
  { "0xCF9457", "FA-CAN, Botschaft ausgefallen ST_CHGINTF", "1" },
  { "0xCF9458", "FA-CAN, Botschaft ausgefallen ST_STAB_DSC", "1" },
  { "0xCF9459", "FA-CAN, Botschaft ausgefallen ST_VHSS", "1" },
  { "0xCF945A", "FA-CAN, CRC Fehler ST_VHSS", "1" },
  { "0xCF945B", "FA-CAN, Alive-Counter Fehler ST_VHSS", "1" },
  { "0xCF945C", "FA-CAN, Botschaft ausgefallen STAT_DS_VRFD", "1" },
  { "0xCF945D", "FA-CAN, Botschaft ausgefallen STAT_ENG_STA_AUTO", "1" },
  { "0xCF945E", "FA-CAN, Botschaft ausgefallen TS_CALL_ST", "1" },
  { "0xCF945F", "FA-CAN, Botschaft ausgefallen U_BN", "1" },
  { "0xCF9460", "FA-CAN, Botschaft ausgefallen UHRZEIT_DATUM", "1" },
  { "0xCF9461", "FA-CAN, Botschaft ausgefallen WMOM_DRV_5", "1" },
  { "0xFFFFFF", "unbekannter Fehlerort", "0" }
};

// Bitte Flags auswählen!
table FDetailStruktur[2][]={
  { "NAME", "TYP" },
  { "F_UWB_ERW", "ja" },
  { "SAE_CODE", "nein" },
  { "F_HLZ", "ja" },
  { "F_SEVERITY", "nein" },
  { "F_UWB_SATZ", "2" },
  { "F_HLZ_VIEW", "ja" }
};

// In dieser Tabelle werden die möglichen Bereiche für Fehlerorte definiert.
table DTCBereiche[4][]={
  { "DTC-TYP", "MINIMALWERT", "MAXIMALWERT", "BESCHREIBUNG" },
  { "AllgemeinerDTC", "020000", "02FFFF", "Die zulässigen Bereiche sind für jedes Steuergerät festgelegt. Es können mehrere gültige Bereiche (Kacheln) definiert werden." },
  { "SystembusDTC", "CF8473", "CF847C", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "930030", "930055", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF850B", "CF8514", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "930000", "930011", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF8469", "CF8472", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF8401", "CF840A", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF847D", "CF8486", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF8487", "CF848F", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF843F", "CF8449", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF8415", "CF841E", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF8501", "CF850A", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF840B", "CF8414", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF845F", "CF8468", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SystembusDTC", "CF841F", "CF843E", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SubbusDTC", "CF8C00", "CF93FF", "Zulässiger Bereich wird mittels Formel berechnet. Enthält physikalische Fehler bzw. Protokollfehler des Systembusses." },
  { "SignalDTC", "CF9400", "CFC3FF", "Ist aus einem vorgegebenen Offset-Bereich frei wählbar. Enthält Signalfehler, die SG-spezifisch sind." },
  { "SignalDTC", "CF9400", "CFC3FF", "Ist aus einem vorgegebenen Offset-Bereich frei wählbar. Enthält Signalfehler, die SG-spezifisch sind." },
  { "SignalDTC", "CF8BFF", "CF8BFF", "Ist aus einem vorgegebenen Offset-Bereich frei wählbar. Enthält Signalfehler, die SG-spezifisch sind." },
  { "KomponentenDTC", "21EE00", "21EFFF", "Die zulässigen Bereiche sind für jedes Steuergerät festgelegt. Es können mehrere gültige Bereiche (Kacheln) definiert werden." },
  { "KomponentenDTC", "21EA00", "21EBFF", "Die zulässigen Bereiche sind für jedes Steuergerät festgelegt. Es können mehrere gültige Bereiche (Kacheln) definiert werden." }
};

// Tabelle ausfüllen, wenn  F_UWB_ERW = ja  gesetzt!
table FUmweltTexte[9][]={
  { "UWNR", "UWTEXT", "UW_EINH", "L/H", "UWTYP", "NAME", "MUL", "DIV", "ADD" },
  { "0x170C", "UBAT", "mV", "High", "unsigned int", "-", "1.0", "1.0", "0.0" },
  { "0x4100", "UWB_AE_EM_DREHZAL", "1/min", "High", "unsigned int", "-", "0.5", "1.0", "20000.0" },
  { "0x4101", "UWB_AE_PS_AKTUELLER_BEFEHL", "-", "High", "unsigned char", "-", "1.0", "1.0", "0.0" },
  { "0x4102", "UWB_AE_PS_STROM_HBRUECKE", "mA", "High", "signed int", "-", "1.0", "1.0", "0.0" },
  { "0x4103", "UWB_AE_PS_POS_SENS1", "%", "High", "unsigned char", "-", "1.0", "1.0", "0.0" },
  { "0x4104", "UWB_AE_PS_POS_SENS2", "%", "High", "unsigned char", "-", "1.0", "1.0", "0.0" },
  { "0x4105", "UWB_AE_PS_SPG_SENS1", "mV", "High", "unsigned char", "-", "20.0", "1.0", "0.0" },
  { "0x4107", "UWB_AE_EM_TEMPERATUR", "°C", "High", "unsigned char", "-", "1.0", "1.0", "-40.0" },
  { "0x4108", "UWB_AE_INV_TEMP_U", "°C", "High", "unsigned char", "-", "1.0", "1.0", "-40.0" },
  { "0x4109", "UWB_AE_INV_TEMP_V", "°C", "High", "unsigned char", "-", "1.0", "1.0", "-40.0" },
  { "0x410A", "UWB_AE_INV_TEMP_W", "°C", "High", "unsigned char", "-", "1.0", "1.0", "-40.0" },
  { "0x410B", "UWB_AE_EM_MD_SOLL", "Nm", "High", "unsigned int", "-", "0.5", "1.0", "-1023.5" }
};

// In diese Tabelle alle Fehlerorte eintragen!
table IOrtTexte[3][]={
  { "ORT", "ORTTEXT", "EREIGNIS_DTC" },
  { "0x1A0043", "Interner Fehler, Messwerterfassung, Sensor: Temperatur SLE PFC fehlerhaft", "0" },
  { "0x1A0015", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Digitalboard CY320_MC2 fehlerhaft", "0" },
  { "0x1A0016", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Phasenstromsensoren Temperaturkompensation des gemessenen Stroms MC2 fehlerhaft", "0" },
  { "0x1A003F", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Digitalboard fehlerhaft", "0" },
  { "0x1A0064", "Qualifierueberwachung, CAN von eDME, Signalausfall 2", "0" },
  { "0x1A0045", "Interner Fehler, Messwerterfassung, Sensor: SLE PFC-Strom 2 fehlerhaft", "0" },
  { "0x1A007E", "Checkcontrol 394: Eventuell Wahlhebel gestört!", "0" },
  { "0x1A002D", "Interner Fehler, Messwerterfassung, Sensor: Rückmessung Spannungsversorgung Pedalwergeber2 fehlerhaft", "0" },
  { "0x1A0013", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 3.3V CY320_MC0 fehlerhaft", "0" },
  { "0x1A0053", "FUSI, Radblockiererkennung: Anforderung 0 Nm aktiv", "0" },
  { "0x1A000D", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase W fehlerhaft", "0" },
  { "0x1A000F", "Interner Fehler, Messwerterfassung, Sensor: Versorgungsspannung Inverter Gatetreiber Phase V fehlerhaft", "0" },
  { "0x1A040F", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC2 Versorgungsspannung 3 fehlerhaft", "0" },
  { "0x1A001B", "Interner Fehler, Messwerterfassung, Sensor: Variantenerkennung Inverter fehlerhaft", "0" },
  { "0x1A005B", "CPLD AKS Anforderung mit Signal /I_S_AKS_REQ_MC0", "0" },
  { "0x1A041D", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE LLC Transformator Temperatur fehlerhaft", "0" },
  { "0x1A0018", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase U (redundant) fehlerhaft", "0" },
  { "0x1A0042", "Interner Fehler, Messwerterfassung, Sensor: Temperatur SLE Gleichrichter fehlerhaft", "0" },
  { "0x1A0058", "Zwischenkreis Brückenkurzschluss über CPLD ermittelt", "0" },
  { "0xC90402", "Fehler konnte nach maximaler Anzahl von Versuchen nicht gesendet werden", "1" },
  { "0x1A0047", "Interner Fehler, Messwerterfassung, Sensor: verstärkter SLE PFC-Summenstrom fehlerhaft", "0" },
  { "0x1A002B", "Interner Fehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 2 fehlerhaft", "0" },
  { "0x1A000B", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase U fehlerhaft", "0" },
  { "0x1A0010", "Interner Fehler, Messwerterfassung, Sensor: Versorgungsspannung Inverter Gatetreiber Phase W fehlerhaft", "0" },
  { "0x1A0039", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Digitalboard CY320_MC0 fehlerhaft", "0" },
  { "0x002001", "NVM_E_WRITE_FAILED", "0" },
  { "0x1A000E", "Interner Fehler, Messwerterfassung, Sensor: Versorgungsspannung Inverter Gatetreiber Phase U fehlerhaft", "0" },
  { "0x1A001C", "Interner Fehler, Messwerterfassung, Sensor: Variantenerkennung Steuer-/Ladeelektronik fehlerhaft", "0" },
  { "0x1A0041", "Interner Fehler, Messwerterfassung, Sensor: Temperatur SLE Gegentaktwandler fehlerhaft", "0" },
  { "0x1A005C", "CPLD AKS Anforderung mit Signal /I_S_CRASH von ACSM und Auswerteschaltung", "0" },
  { "0x1A002F", "Interner Fehler, Messwerterfassung, Sensor: Strommessung Parksperre Halbbrücke 2 fehlerhaft", "0" },
  { "0x1A003C", "Interner Fehler, Messwerterfassung, Sensor: Variantenerkennung Controllerboard fehlerhaft", "0" },
  { "0x1A002E", "Interner Fehler, Messwerterfassung, Sensor: Strommessung Parksperre Halbbrücke 1 fehlerhaft", "0" },
  { "0x002010", "NVM_E_WRONG_CONFIG_ID", "0" },
  { "0x1A0044", "Interner Fehler, Messwerterfassung, Sensor: SLE PFC-Strom 1 fehlerhaft", "0" },
  { "0x1A0063", "Qualifierueberwachung, CAN von eDME, Signalausfall 1", "0" },
  { "0x1A040C", "Interner Fehler, Messwerterfassung, Sensor: Zweiganggetriebe Aktuatorstrom fehlerhaft", "0" },
  { "0x1A0023", "Interner Fehler, Messwerterfassung, Sensor: Temperatur DC/DC Board fehlerhaft", "0" },
  { "0x1A0004", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Phase V fehlerhaft", "0" },
  { "0x1A000A", "Interner Fehler, Messwerterfassung, Sensor: DC Strom Inverter fehlerhaft", "0" },
  { "0x1A002A", "Interner Fehler, Messwerterfassung, Sensor: Sensorsignal Pedalwertgeber 1 fehlerhaft", "0" },
  { "0x1A040D", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC2 Versorgungsspannung 1 fehlerhaft", "0" },
  { "0x1A0030", "Interner Fehler, Messwerterfassung, Sensor: Stromrückmessung Parksperrenaktuator Ansteuerung fehlerhaft", "0" },
  { "0x1A0054", "Diagnose, AKS via Diagnosejob angefordert", "0" },
  { "0x1A0014", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 1.5V CY320_MC0 fehlerhaft", "0" },
  { "0x1A002C", "Interner Fehler, Messwerterfassung, Sensor: Rückmessung Spannungsversorgung Pedalwergeber1 fehlerhaft", "0" },
  { "0x1A0020", "Interner Fehler, Messwerterfassung, Sensor: Temperatur DC/DC Gegentaktwandler fehlerhaft", "0" },
  { "0x1A0060", "CPLD AKS Anforderung mit Signal /MC2_VOLT_FAIL", "0" },
  { "0x1A0001", "Interner Fehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 1 fehlerhaft", "0" },
  { "0x1A0412", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC0 Versorgungsspannung 3 fehlerhaft", "0" },
  { "0x1A0415", "Interner Fehler, Messwerterfassung, Sensor: 2.5V Spannungseingang Dcdc Board fehlerhaft", "0" },
  { "0xE89400", "Botschaft (Fahrzeugzustand, 0x3A0) fehlt", "1" },
  { "0x1A004F", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Strom 1 Trafo fehlerhaft", "0" },
  { "0x1A006E", "Ebene2 Fehler PS, Strom Aktuator in Ruhe zu hoch", "0" },
  { "0x1A0029", "Interner Fehler, Messwerterfassung, Sensor: analoger Messeingang COS-Resolversignal", "0" },
  { "0x1A003D", "Interner Fehler, Messwerterfassung, Sensor: CPLD Version fehlerhaft", "0" },
  { "0x1A040A", "Interner Fehler, Messwerterfassung, Sensor: Zweiganggetriebe Feedback H-Brücke 1 fehlerhaft", "0" },
  { "0x1A0031", "Interner Fehler, Messwerterfassung, Sensor: Bremsunterdrucksensorsignal fehlerhaft", "0" },
  { "0x002004", "NVM_E_ERASE_FAILED", "0" },
  { "0x1A0040", "Interner Fehler, Messwerterfassung, Sensor: Temperatur SLE Board fehlerhaft", "0" },
  { "0x1A004C", "Interner Fehler, Messwerterfassung, Sensor: SLE Gatetreiber Spannung fehlerhaft", "0" },
  { "0x1A006B", "Ebene2 Fehler PS, Command-Auswertung E1/E2 unterschiedlich", "0" },
  { "0x1A0409", "Interner Fehler, Messwerterfassung, Sensor: Position Zweiganggetriebe fehlerhaft", "0" },
  { "0x1A0017", "Interner Fehler, Messwerterfassung, Sensor: Zwischenkreisspannung fehlerhaft", "0" },
  { "0x1A0057", "Zwischenkreisspannung, Überspannung über CPLD ermittelt", "0" },
  { "0x1A0406", "Interner Fehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Stator fehlerhaft", "0" },
  { "0x1A040B", "Interner Fehler, Messwerterfassung, Sensor: Zweiganggetriebe Feedback H-Brücke 2 fehlerhaft", "0" },
  { "0x1A003E", "Interner Fehler, Messwerterfassung, Sensor: Temperatur 2 ELUP Endstufe fehlerhaft", "0" },
  { "0x1A0002", "Interner Fehler, Messwerterfassung, Sensor: Messsignal Motortemperatur 2 fehlerhaft", "0" },
  { "0x1A0070", "Ebene2 Fehler PS, Timeout Positionsverstellung", "0" },
  { "0x1A0038", "Interner Fehler, Messwerterfassung, Sensor: Rückmessung interne 32V fehlerhaft", "0" },
  { "0x1A0077", "Ebene2 Fehler PS, PS-Positionsänderung ohne gültiges PS-Kommando", "0" },
  { "0x1A0422", "Interner Fehler, Messwerterfassung, Sensor: Spannungswert SLE Board Revision fehlerhaft", "0" },
  { "0x1A0408", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Phasenstromsensoren fehlerhaft", "0" },
  { "0x1A0052", "Interner Fehler, Messwerterfassung, Sensor: DC/DC Zwischenkreisspannung fehlerhaft", "0" },
  { "0x1A0071", "Ebene2 Fehler PS, Timeout Init 10ms-Task E1", "0" },
  { "0x1A0059", "CPLD AKS Anforderung mit Signal /I_S_RST5_Cy0", "0" },
  { "0x1A0019", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase V (redundant) fehlerhaft", "0" },
  { "0x002002", "NVM_E_READ_FAILED", "0" },
  { "0x1A005A", "CPLD AKS Anforderung mit Signal /I_S_RST5_Cy2", "0" },
  { "0x1A001A", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase W (redundant) fehlerhaft", "0" },
  { "0x1A041B", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE PFC Board Temperatur 1 fehlerhaft", "0" },
  { "0x1A0072", "Ebene2 Fehler PS, Drehrichtung PS schliessen falsch", "0" },
  { "0xC90401", "Puffer für ausgehende Fehlermeldungen ist voll", "1" },
  { "0x002003", "NVM_E_CONTROL_FAILED", "0" },
  { "0x1A0008", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Gatedriver Phase W fehlerhaft", "0" },
  { "0x1A0027", "Interner Fehler, Messwerterfassung, Sensor: DC/DC Gatetreiber Spannung fehlerhaft", "0" },
  { "0x1A0006", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Gatedriver Phase U fehlerhaft", "0" },
  { "0x002006", "NVM_E_WRITE_ALL_FAILED", "0" },
  { "0x1A0403", "HV-Batterie: Ausfall Batteriekühlung", "1" },
  { "0x1A0007", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Gatedriver Phase V fehlerhaft", "0" },
  { "0x1A0028", "Interner Fehler, Messwerterfassung, Sensor: analoger Messeingang SIN-Resolversignal fehlerhaft", "0" },
  { "0x1A0401", "HV-Powermanagement: eKMV degradiert bei Fahrbereitschaft", "1" },
  { "0x1A0005", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Phase W fehlerhaft", "0" },
  { "0x1A0035", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 5V CY320_MC2 fehlerhaft", "0" },
  { "0x1A0055", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Spannung2 Niedervoltseite fehlerhaft", "0" },
  { "0x1A0074", "Ebene2 Fehler PS, Drehrichtung PS oeffnen falsch", "0" },
  { "0x1A0402", "HV-Powermanagement: Verhindern Standfunktionen aufgrund niedrigem Ladezustand HV-Batterie", "1" },
  { "0x1A0066", "Qualifierueberwachung, CAN von eDME, Signalausfall 4", "0" },
  { "0x1A0400", "F_M_BMW_SIG_HVPM_FAULTTYPE -> Signalausfall : HV Powermanagement", "1" },
  { "0x1A0056", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Strom2 auf der Niedervoltseite fehlerhaft", "0" },
  { "0x1A0036", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 3.3V CY320_MC2 fehlerhaft", "0" },
  { "0x1A0003", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Phase U fehlerhaft", "0" },
  { "0x1A006C", "Ebene2 Fehler PS, EWS-Auswertung E1/E2 unterschiedlich", "0" },
  { "0x1A004D", "Interner Fehler, Messwerterfassung, Sensor: Steuer-/Ladeelektronik Pic nicht verbunden", "0" },
  { "0x002007", "NVM_E_READ_ALL_FAILED", "0" },
  { "0x1A004E", "Interner Fehler, Messwerterfassung, Sensor: DC/DC Pic nicht verbunden", "0" },
  { "0x1A006D", "Ebene2 Fehler PS, Sensor-Auswertung E1/E2 unterschiedlich", "0" },
  { "0x1A0411", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC0 Versorgungsspannung 2 fehlerhaft", "0" },
  { "0x1A0079", "Checkcontrol 175: Getriebe-Position P gestört!", "0" },
  { "0x1A0078", "Checkcontrol 174: Getriebe-Position P nur im Stillstand!", "0" },
  { "0x1A0413", "Interner Fehler, Messwerterfassung, Sensor: Feedback Signal für Parksperrenaktuator Notfallentriegelung fehlerhaft", "0" },
  { "0x1A000C", "Interner Fehler, Messwerterfassung, Sensor: Phasenstrom Inverter Phase V fehlerhaft", "0" },
  { "0x1A0410", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC0 Versorgungsspannung 1 fehlerhaft", "0" },
  { "0x1A0416", "Interner Fehler, Messwerterfassung, Sensor: 3.3V Spannungseingang Dcdc Board fehlerhaft", "0" },
  { "0x1A0407", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Gatedriver fehlerhaft", "0" },
  { "0x1A0033", "Interner Fehler, Messwerterfassung, Sensor: analoges Messsignal Überwachung ELUP-Spannung fehlerhaft", "0" },
  { "0x1A007A", "Checkcontrol 203: Getriebe in Position N!", "0" },
  { "0x1A040E", "Interner Fehler, Messwerterfassung, Sensor: CY320 MC2 Versorgungsspannung 2 fehlerhaft", "0" },
  { "0x1A041A", "Interner Fehler, Messwerterfassung, Sensor: gefilterter Effektivwert von SLE PFC Strom fehlerhaft", "0" },
  { "0x1A0421", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE PFC Board Temperatur 3 fehlerhaft", "0" },
  { "0x1A0049", "Interner Fehler, Messwerterfassung, Sensor: SLE Eingangsspannung fehlerhaft", "0" },
  { "0x1A0068", "Qualifierueberwachung, CAN von SME, Signalausfall 2", "0" },
  { "0x1A041E", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE PFC Zwischenkreis Temperatur fehlerhaft", "0" },
  { "0x1A0420", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE PFC Board Temperatur 2 fehlerhaft", "0" },
  { "0x1A0024", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Spannung Niedervoltseite fehlerhaft", "0" },
  { "0x1A006A", "Qualifierueberwachung, CAN von SME, Signalausfall 4", "0" },
  { "0x1A004B", "Interner Fehler, Messwerterfassung, Sensor: Spannung Ausgang  PFC Stufe fehlerhaft", "0" },
  { "0x1A0021", "Interner Fehler, Messwerterfassung, Sensor: Temperatur DC/DC Tiefsetzsteller fehlerhaft", "0" },
  { "0x1A0061", "CPLD AKS Anforderung mit Signal /I_S_PHASE_OC_CPLD", "0" },
  { "0x1A0419", "Interner Fehler, Messwerterfassung, Sensor: gefilterter SLE LLC Strom fehlerhaft", "0" },
  { "0x1A0046", "Interner Fehler, Messwerterfassung, Sensor: SLE PFC-Summenstrom fehlerhaft", "0" },
  { "0x1A0000", "EME, interner Fehler, Momentenpfad: Abweichung Sollmoment Warnung", "0" },
  { "0x1A005F", "CPLD AKS Anforderung mit Signal I_S_INV_TEMP_CMP", "0" },
  { "0x1A001F", "Interner Fehler, Messwerterfassung, Sensor: Variantenerkennung DC/DC fehlerhaft", "0" },
  { "0x1A0076", "Ebene2 Fehler PS, PWM im Ruhezustand > 0", "0" },
  { "0x1A0418", "Interner Fehler, Messwerterfassung, Sensor: gefilterter Dcdc Trafostrom fehlerhaft", "0" },
  { "0x1A0417", "Interner Fehler, Messwerterfassung, Sensor: 5V Spannungseingang Dcdc Board fehlerhaft", "0" },
  { "0x001001", "Signal (Zeit_Sekunde_Zaehler_Relativ, 0x328): ungültig", "1" },
  { "0x1A004A", "Interner Fehler, Messwerterfassung, Sensor: SLE Zwischenkreisspannung fehlerhaft", "0" },
  { "0x1A0069", "Qualifierueberwachung, CAN von SME, Signalausfall 3", "0" },
  { "0x1A0032", "Interner Fehler, Messwerterfassung, Sensor: Stromsignal der elektrischen Unterdruckpumpe fehlerhaft", "0" },
  { "0x1A0025", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Strom auf der Niedervoltseite fehlerhaft", "0" },
  { "0x1A0009", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Inverter Mux_Adc fehlerhaft", "0" },
  { "0x1A0051", "Interner Fehler, Messwerterfassung, Sensor: Ausgangsspannung DC/DC Tiefsetzsteller fehlerhaft", "0" },
  { "0x1A0048", "Interner Fehler, Messwerterfassung, Sensor: SLE Summenstrom Trafo fehlerhaft", "0" },
  { "0x1A0067", "Qualifierueberwachung, CAN von SME, Signalausfall 1", "0" },
  { "0x1A007F", "Checkcontrol 557: Fahrzeug gegen Wegrollen sichern!", "0" },
  { "0x1A0414", "Interner Fehler, Messwerterfassung, Sensor: Diagnoseeingang für Massefehler fehlerhaft", "0" },
  { "0x1A003A", "Interner Fehler, Messwerterfassung, Sensor: Temperatur Phasenstromsensoren Temperaturkompensation des gemessenen Stroms MC0 fehlerhaft", "0" },
  { "0x1A007B", "Checkcontrol 244: Zum Gang einlegen Bremse treten!", "0" },
  { "0x1A007D", "Checkcontrol 252: Gong", "0" },
  { "0x1A0075", "Ebene2 Fehler PS, Unbekannter Zustand Regler beim PS oeffnen", "0" },
  { "0x1A0011", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 12V Klemme 30B fehlerhaft", "0" },
  { "0x1A041F", "Interner Fehler, Messwerterfassung, Sensor: SLE 3V A/D Konverter Referenzspannung fehlerhaft", "0" },
  { "0x1A0065", "Qualifierueberwachung, CAN von eDME, Signalausfall 3", "0" },
  { "0x1A0050", "Interner Fehler, Messwerterfassung, Sensor: DC/DC-Strom 2 Trafo fehlerhaft", "0" },
  { "0x1A006F", "Ebene2 Fehler PS, 10ms-Task E1 nicht aktiv", "0" },
  { "0x1A041C", "Interner Fehler, Messwerterfassung, Sensor: gefilterte SLE Hochvolttemperatur fehlerhaft", "0" },
  { "0x1A007C", "Checkcontrol 250: Gang ohne Bremse einlegbar!", "0" },
  { "0x1A0012", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 5V CY320_MC0 fehlerhaft", "0" },
  { "0x1A0022", "Interner Fehler, Messwerterfassung, Sensor: Temperatur DC/DC Gleichrichter fehlerhaft", "0" },
  { "0x1A0062", "CPLD AKS Anforderung mit Signal I_S_CPLD_SPARE_1", "0" },
  { "0x1A0073", "Ebene2 Fehler PS, Unbekannter Zustand Regler beim PS schliessen", "0" },
  { "0x1A0034", "Interner Fehler, Messwerterfassung, Sensor: Temperatur ELUP Endstufe fehlerhaft", "0" },
  { "0x1A0037", "Interner Fehler, Messwerterfassung, Sensor: Analogsignal Spannungsüberwachung interne 1.5V CY320_MC2 fehlerhaft", "0" },
  { "0x1A0404", "F_M_BMW_HVBATT_ISOERRDBL_FAULTTYPE -> HV Batterie : Isoaltionsfehler", "1" },
  { "0x1A005D", "CPLD AKS Anforderung mit Signal I_S_KL30C, Eingangssignal vom Einganspin der AE", "0" },
  { "0x1A001D", "Interner Fehler, Messwerterfassung, Sensor: DC/DC Tiefsetzsteller-Strom 1 fehlerhaft", "0" },
  { "0x1A0080", "Checkcontrol 565: Getriebe-Position P nur im Stillstand!", "0" },
  { "0x1A001E", "Interner Fehler, Messwerterfassung, Sensor: DC/DC Tiefsetzsteller-Strom 2 fehlerhaft", "0" },
  { "0x1A005E", "CPLD AKS Anforderung mit Signal /I_S_AKS_REQ_MC2", "0" },
  { "0x1A0405", "Interner Fehler, Messwerterfassung, Sensor: Messsignal Motortemperatur Drahtspuelenende fehlerhaft", "0" },
  { "0xFFFFFF", "unbekannter Fehlerort", "0" }
};

// Bitte Flags auswählen!
table IDetailStruktur[2][]={
  { "NAME", "TYP" },
  { "F_UWB_ERW", "nein" },
  { "SAE_CODE", "nein" },
  { "F_HLZ", "nein" },
  { "F_SEVERITY", "nein" }
};

// Tabelle nur für SGBDen der ISO 14229!  Weitere Informationen finden Sie im Dokument:  Anleitung_STATUS_STEUERN_UDS.pdf
table SG_Funktionen[16][]={
  { "ARG", "ID", "RESULTNAME", "INFO", "EINHEIT", "LABEL", "L/H", "DATENTYP", "NAME", "MUL", "DIV", "ADD", "SG_ADR", "SERVICE", "ARG_TABELLE", "RES_TABELLE" },
  { "STEUERN_START_LADEN", "0xADC0", "-", "Ladestart anfordern", "-", "B_remote_ladestart", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADC0", "-" },
  { "STEUERN_STOP_LADEN", "0xADC1", "-", "Ladestop anfordern", "-", "B_remote_ladestop", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADC1", "-" },
  { "REX_ON_OFF", "0xADC4", "-", "Ein-/Ausschalten des Range Extender Verbrennungsmotor", "-", "Pe_rex_soll_diag", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADC4", "-" },
  { "AE_EWP", "0xADC9", "-", "Ansteuern und Auslesen der elektrischen Wasserpumpe (Ansteuerung nur möglich bei AE Temperatur unter Schwelle, house keeping nicht aktiv, EWP nicht abgeschaltet und manuelle Drehzahl deaktivert)", "-", "V_e_EWP_ctl_status_test_job", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADC9", "RES_0xADC9" },
  { "EME_DCDC_WANDLER", "0xADF1", "-", "Steuern oder Auslesen des Status vom DC/DC-Wandler", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADF1", "RES_0xADF1" },
  { "EME_AKS_EMK", "0xADF4", "-", "E-Maschine in den AKS kommandieren: 0 - Kontrolle an EME-SW; 1 - AKS E-Maschine angefordert", "-", "V_e_DcmAksReq", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADF4", "RES_0xADF4" },
  { "AE_ROTORLAGESENSOR_ANLERNEN", "0xADF6", "-", "Anlernen Rotorlagesensor (TA-EOL STEUERN)", "-", "V_e_Rls_stdiag", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADF6", "RES_0xADF6" },
  { "AE_KLASSIERUNG", "0xADF8", "-", "Auslesen der  Drehzahl/Drehmoment-Klassierungsdaten", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADF8", "RES_0xADF8" },
  { "AE_DCDC_HISTOGRAMM", "0xADF9", "-", "Lesen des angeforderten Histogramm des DCDC-Wandlers", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xADF9", "RES_0xADF9" },
  { "EME_DCDC_LV", "0xDDF6", "-", "Spannung / Strom DCDC (12V Bordnetz) am B+ Bolzen", "-", "AVL_U_LV_DCDC_CNV", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDDF6" },
  { "EME_HVPM_DCDC_ANSTEUERUNG", "0xDE00", "-", "Rückgabewerte vom HVPM für DCDC Ansteuerung", "-", "CHGCOND_HVSTO", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE00" },
  { "EME_HVPM_HV_SYSTEM_ON_OFF", "0xDE02", "-", "Hochvoltsystem An / Aus", "-", "AVL_U_HV_LINK_MOT_TRCT", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE02" },
  { "EME_HVPM_ENERGIEBORDNETZ", "0xDE03", "-", "Rückgabewerte des HVPM über HV-Energie und Zellspannungen", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE03" },
  { "EME_HVPM_ENERGIEBORDNETZ_2", "0xDE04", "-", "Anzahl der Herstellung von Fahrbereitschaft im SOC Bereich", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE04" },
  { "EME_HVPM_PKOR", "0xDE06", "-", "HVPM Leistungskoordinator", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE06" },
  { "EME_HVPM_INFOSPEICHER_PKOR_LOESCHEN", "0xDE08", "-", "Alle Infospeicher des Diagnosejobs STATUS_HVPM_EKMV werden auf Null gesetzt.", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE08", "-" },
  { "EME_HVPM_INFOSPEICHER_STRZLR_LOESCHEN", "0xDE09", "-", "Löschen des Infospeicher HSPM (STRZL)", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE09", "-" },
  { "EME_HVPM_INFOSPEICHER_SPMON_LOESCHEN", "0xDE0A", "-", "Löschen des Infospeichers HVPMP (SPMON)", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE0A", "-" },
  { "EME_HVIL_GESAMT", "0xDE0C", "STAT_HVIL_GESAMT_NR", "Auslesen des HVIL-Zustandes in der EME; falls HVIL unterbrochen, dann n.i.O.", "0-n", "V_e_HvilError", "high", "unsigned char", "TAB_STAT_HVIL_GESAMT_NR", "1.0", "1.0", "0.0", "-", "22", "-", "-" },
  { "EME_HVPM_SPANNUNGSFREIHEIT", "0xDE18", "-", "Infospeicher zur Spannungsfreiheit des Hochvoltsystems (durch HVPM überwacht)", "-", "NV_ZEIT_START_CCM_636[0]", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE18" },
  { "EME_ELUP", "0xDE19", "-", "Anzahl der Bremsbetätigungen, Laufzeit und Anläufe der ELUP", "-", "Anzahl_brems_bttg", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE19" },
  { "EME_HVPM_DCDC_ALS", "0xDE1C", "-", "HVPM DCDC ALS", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE1C" },
  { "AE_CPLD_VERSION", "0xDE2D", "STAT_CPLD_VERSION_WERT", "CPLD-Version", "-", "V_e_CpldVersion", "high", "unsigned char", "-", "1.0", "1.0", "0.0", "-", "22", "-", "-" },
  { "AE_CHARGE_ENABLE", "0xDE71", "STAT_CHARGE_ENABLE_NR", "Aussage über die Erteilung der Ladefreigabe", "0-n", "ST_CHGNG_ENB", "high", "unsigned char", "TAB_AE_CHARGE_ENABLE", "-", "-", "-", "-", "22", "-", "-" },
  { "AE_PARKSPERRE_SENSOREN", "0xDE74", "-", "Status Sensoren der Parksperre", "-", "VaPS_StaSen1_CanTx", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE74" },
  { "AE_HV_SPANNUNG_LESEN", "0xDE75", "-", "Werte aller Zwischenkreisspannungen", "-", "V_U_SleZk", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE75" },
  { "AE_PARKSPERRE_SW", "0xDE76", "STAT_PS_SW_NR", "Status Parksperren Software", "0-n", "VaPS_Quallifier_CanTx", "high", "unsigned char", "TAB_AE_PARKSPERREN_SW", "-", "-", "-", "-", "22", "-", "-" },
  { "AE_PARKSPERRE", "0xDE77", "-", "Zustand Parksperre / Einlegen Parksperre", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE77", "-" },
  { "AE_PARKSPERRE_EINLERNEN", "0xDE78", "-", "Parksperre / Einlernen Parksperre", "-", "removeJob2", "-", "-", "-", "-", "-", "-", "-", "22;2E", "ARG_0xDE78", "RES_0xDE78" },
  { "AE_PARKSPERRE_POSITION", "0xDE79", "STAT_POSITION_PARKSPERRE_NR", "Aktuelle Position der Parksperre", "0-n", "removeJob3", "high", "unsigned int", "TAB_AE_PARKSPERRE_POSTION", "-", "-", "-", "-", "22", "-", "-" },
  { "AE_PARKSPERRE_POSITIONEN", "0xDE7A", "-", "Rückgabe angelernte Parksperrenpositionen", "-", "VaPS_PosGeschlossen", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE7A" },
  { "AE_PARKSPERRE_STROM", "0xDE7B", "STAT_STROM_PARKSPERRE_WERT", "Aktueller Strom Parksperrenaktuator", "A", "V_I_Psa", "high", "unsigned int", "-", "1.0", "1.0", "0.0", "-", "22", "-", "-" },
  { "AE_PARKSPERRE_SPANNUNGEN", "0xDE7C", "-", "Spannungen der Parksperre", "-", "VaPS_HB_Voltage", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE7C" },
  { "AE_ROHSIG_AUSGANG", "0xDE7D", "-", "Rohsignale Ausgangspins", "-", "V_DC_pbwHBModGrad_UE2", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE7D" },
  { "AE_ROHSIG_EINGANG_SENS_ELUP_BUDS", "0xDE7E", "-", "Rohsignale Ausgangspins Sensoren ELUP, BUDS", "-", "V_T_ElupLe_cal", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE7E" },
  { "AE_ROHSIG_EINGANG_SENS_EM_INV", "0xDE7F", "-", "Rohsignale Sensoren/Eingänge für E-Maschine/Umrichter", "-", "V_T_Motor1_cal", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE7F" },
  { "AE_ROHSIG_EINGANG_SENS_PARKSPERRE", "0xDE80", "-", "Rohsignale Sensoren/Eingänge Parksperre", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE80" },
  { "AE_ROHSIG_EINGANG_SENS_SG", "0xDE81", "-", "Rohsignale Sensoren/Eingänge Steuergerät", "-", "V_U_Int12V_cal", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE81" },
  { "AE_ROHSIG_EINGANG_SENS_SLE", "0xDE82", "-", "Rohsignale Sensoren/Eingänge SLE", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE82" },
  { "AE_ROHSIG_EINGANG_SENS_DCDC", "0xDE83", "-", "Rohsignale Sensoren/Eingänge DC/DC Wandler", "-", "V_U_DcdcLv_cal", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE83" },
  { "AE_BETRIEBSZUSTAND_SLE", "0xDE84", "-", "Betriebsarten SLE", "-", "V_F_SleAc", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE84" },
  { "AE_SLE_LEISTUNG", "0xDE85", "-", "Leistungswerte Zwischenkreis der SLE", "-", "V_P_XleIntLe_hv_ist", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE85" },
  { "AE_SLE_SPANNUNG", "0xDE86", "-", "AC und DC Spannungen SLE", "-", "V_U_SleAc", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE86" },
  { "AE_SLE_STROM", "0xDE87", "-", "AC und DC Ströme SLE", "-", "V_I_SlePfc", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE87" },
  { "AE_SPANNUNG_KLEMME30B", "0xDE88", "STAT_SPANNUNG_KL30B_WERT", "aktuelle Spannung an KL30B", "V", "V_U_Int12V", "high", "unsigned int", "-", "0.01", "1.0", "0.0", "-", "22", "-", "-" },
  { "AE_STROM_DCDC", "0xDE89", "-", "Ströme DC/DC Wandler", "-", "AVL_I_HV_DCDC", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE89" },
  { "AE_STROM_MAX", "0xDE8B", "-", "maximal gemessene Ströme seit letztem Rücksetzen oder Rücksetzen der Werte", "-", "V_I_DcdcHlDiag_Hv_mx_out", "-", "-", "-", "-", "-", "-", "-", "22;2E", "ARG_0xDE8B", "RES_0xDE8B" },
  { "AE_TEMP_LE", "0xDE8C", "-", "Temperaturen Steuergerät Antriebselektronik", "-", "V_T_InvU", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE8C" },
  { "AE_ZUSTAND_1_DCDC", "0xDE92", "-", "Status DC/DC-Wandler", "-", "AVL_OPMO_DCDC_CNV", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE92" },
  { "AE_ELUP", "0xDE93", "-", "aktueller Zustand ELUP bzw. aktivieren/deaktivieren ELUP", "-", "V_e_DcmCtrlJobAct[ST_ELUP]", "-", "-", "-", "-", "-", "-", "-", "2E;22", "ARG_0xDE93", "RES_0xDE93" },
  { "AE_PARKSPERRE_MAGNET", "0xDE94", "-", "Einschalten Magnet Parksperre", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE94", "-" },
  { "AE_PARKSPERRE_NVRAM_LOESCHEN", "0xDE95", "-", "Löscht NV-RAM Daten der Parksperre", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDE95", "-" },
  { "AE_ZUSTAND_DCDC_FEHLERBILD", "0xDE96", "-", "Rückgabe aktiver/inaktiver Fehler DC/DC-Wandler", "bit", "V_e_DcdcHl_ErSt_out", "-", "BITFIELD", "RES_0xDE96", "-", "-", "-", "-", "22", "-", "-" },
  { "STATUS_CONNECTED_DRIVE", "0xDE9E", "-", "Informationen über Connected Drive", "-", "Hym_Ts_status_laden", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDE9E" },
  { "STATUS_TSR_LADEN", "0xDEA0", "-", "Alle Rückgabewert bezüglich TSR Laden", "-", "NV_anzahl_ladevorgaenge_gesamt", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEA0" },
  { "AE_BUDS", "0xDEA5", "STAT_BUDS_WERT", "Sensorwert des Bremsunterdrucks", "hPa", "AVL_LOWP_BRKFA", "high", "unsigned char", "-", "4.0", "1.0", "-1000.0", "-", "22", "-", "-" },
  { "AE_TEMP_EMASCHINE", "0xDEA6", "-", "Wert der aktuellen Temperaturen der E-Maschine in Grad Celsius", "-", "V_T_Motor1", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEA6" },
  { "AE_ELEKTRISCHE_MASCHINE", "0xDEA7", "-", "Auslesen von Drehzahl, Drehmoment und Betriebsart der E-Maschine", "-", "AVL_RPM_MOT_TRCT", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEA7" },
  { "AE_ZUSTAND_2_DCDC", "0xDEA9", "-", "Rückgabe verschiederer Status vom DCDC-Wandler", "bit", "V_e_DcdcHl_St_out", "-", "BITFIELD", "RES_0xDEA9", "-", "-", "-", "-", "22", "-", "-" },
  { "AE_PARKSPERRE_VERSION", "0xDEB0", "-", "Rückgabe der aktuellen Version der Parksperren-SW", "-", "-", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEB0" },
  { "AE_ROTORLAGESENSOR_SCHREIBEN", "0xDEB1", "-", "Direktes Schreiben des Resolveroffset Winkels", "-", "V_phi_DcmDiagRlsoffsetMan_def", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB1", "-" },
  { "AE_DCDC_TEMPHISTOGRAMM_LESEN", "0xDEB2", "-", "Auslesen Temperatur-Histogramme DCDC / Rücksetzen Temperatur-Histogramme (0 = kein Reset; 1 = Reset)", "-", "V_e_DcmDcdcDiag_Histo_T_rst", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB2", "-" },
  { "AE_DCDC_LEISTUNGSHISTOGRAMM", "0xDEB3", "-", "Auslesen Leistungs-Histogramme DCDC-Wandler / Zurücksetzen Leistungs-Histogramme (0 = kein Reset; 1 = Reset)", "-", "V_e_DcdcDiag_Histo_P_rst", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB3", "-" },
  { "AE_RESET_TEMP_MIN_MAX", "0xDEB4", "-", "Rücksetzen der minimalen und maximalen Temperatur des DC/DC Wandlers (0 = kein Reset; 1 = Reset)", "-", "V_e_DcdcDiag_T_rst", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB4", "-" },
  { "AE_PIC_SW_VERSION", "0xDEB5", "-", "Gibt aktuellen Versionen der PIC-SW zurück", "-", "V_s_DcdcSwVersion", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEB5" },
  { "AE_ROTORLAGESENSOR_RESET", "0xDEB6", "-", "Zurücksetzen des Resolveroffsetwinkels", "-", "V_e_DcmDiagRlsoffsetReset", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB6", "-" },
  { "AE_KLASSIERUNG_LOESCHEN", "0xDEB7", "-", "Loeschen der gesamten Klassierungsdaten", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0xDEB7", "-" },
  { "AE_CTRL_VERSION", "0xDEBC", "STAT_CTRL_VERSION_WERT", "Controllerbord-Version", "-", "V_e_CtrlVarIn", "high", "unsigned char", "-", "1.0", "1.0", "0.0", "-", "22", "-", "-" },
  { "AE_SPANNUNG_DCDC", "0xDEBD", "-", "Spannungen DCDC Wandler", "-", "V_U_DcdcGtMc6", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEBD" },
  { "AE_SPANNUNG_LE", "0xDEBE", "-", "Interne Spannungen der Leistungselektronik", "-", "V_U_Int5VMc0", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEBE" },
  { "AE_SYSSTATE", "0xDEBF", "-", "Interne Statuszustände des Steuergerät", "-", "V_e_VsmDprActive", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEBF" },
  { "AE_FAHRSTUFE", "0xDEDD", "STAT_POS_PRND_NR", "aktuelle Ist-Position des Antriebsstrangs (PRND)", "0-n", "Hym_Vetrgr_e_achvdtrnspos", "high", "unsigned char", "TAB_AE_FAHRSTUFE", "-", "-", "-", "-", "22", "-", "-" },
  { "AE_LSC_LADEN", "0xDEDE", "-", "Rückmeldung zum Ladeverfahrens", "-", "Hym_St_ladeverfahren_diag", "-", "-", "-", "-", "-", "-", "-", "22", "-", "RES_0xDEDE" },
  { "AE_SN_SETZEN", "0x400C", "-", "Seriennummer", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0x400C", "-" },
  { "AE_HWCAL_SETZEN", "0x400D", "-", "Hardware Kalibrierungsdaten der AE setzen Es kann nicht die Seriennummer gesetz werden (eigener Job _steuern_sn_setzen)!!!", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0x400D", "-" },
  { "AE_HWCAL_FLASHEN", "0x400E", "-", "Schreibt die HWCALs eines bestimmten Blocks ins Flash", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0x400E", "-" },
  { "AE_HWCAL_MODE", "0x400F", "-", "SG in den HWCAL Flash-Mode bringen", "-", "-", "-", "-", "-", "-", "-", "-", "-", "2E", "ARG_0x400F", "-" },
  { "AE_HWCAL_LESEN", "0xF010", "-", "Auslesen der HWCALs anhand von Blocknummer und Prozessor", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xF010", "RES_0xF010" },
  { "AE_RESETINFO_LESEN", "0xF011", "-", "Auslesen der Resetinfo aus dem Flash", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "ARG_0xF011", "RES_0xF011" },
  { "AE_FREILAUF_MODUS", "0xF050", "-", "Freilauf Modus", "-", "-", "-", "-", "-", "-", "-", "-", "-", "31", "-", "RES_0xF050" }
};

table RES_0x1700[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_DID_1700_KILOMETER_WERT", "-", "-", "unsigned long", "-", "-", "-", "-", "-", "-" }
};

table ARG_0x1700[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "DIAG_DID_1700_KILOMETER", "-", "-", "unsigned long", "-", "-", "-", "-", "-", "-", "-", "-" }
};

// -
table TAB_STAT_ROTORLAGESENSOR_STATUS_MODE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Die Routine Rotorlagesensor Anlernen ist nicht angefordert." },
  { "0x01", "Die Routine Rotorlagesensor Anlernen ist angefordert und aktiv, aber es findet gerade kein aktiver Abgleich statt." },
  { "0x02", "Die Routine Rotorlagesensor Anlernen ist angefordert und aktiv." },
  { "0x03", "Die Routine Rotorlagesensor Anlernen wurde fehlerhaft beendet." },
  { "0x04", "Die Routine Rotorlagesensor Anlernen wurde erfolgreich beendet." }
};

// WERTE
table TAB_AE_SYSSYSTATE_MCS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "eINITIALIZATION" },
  { "0x01", "ePREDRIVE" },
  { "0x02", "eREADY" },
  { "0x03", "eWAITSLEEPACKNOWLEDGE" },
  { "0x04", "eFUNCTIONPOSTDRIVE" }
};

// BITFIELD
table BF_SYSSYSTATE_KLEMMEN[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SYSSYSTATE_KL153_0", "0/1", "high", "unsigned char", "0x01", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit0 = Kl15_3" },
  { "STAT_SYSSYSTATE_KL15WUP_1", "0/1", "high", "unsigned char", "0x02", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit1 = Kl15WUP" },
  { "STAT_SYSSYSTATE_KL30B_2", "0/1", "high", "unsigned char", "0x04", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit2 = KL30B" },
  { "STAT_SYSSYSTATE_KL30C_3", "0/1", "high", "unsigned char", "0x08", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit3 = KL30C" }
};

// WERTE
table TAB_AE_RESET_CRASHZAEHLER[2][]={
  { "WERT", "TEXT" },
  { "0x00", "keine Aktion" },
  { "0x01", "rücksetzen  1.Crashzähler" },
  { "0x02", "rücksetzen  2.Crashzähler" },
  { "0x03", "rücksetzen  1.Crashzählers und 2.Crashzählers" },
  { "0xFE", "nicht definiert" },
  { "0xFF", "ungültiger Wert" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADC0[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "STAT_ANFORDERUNG_START_LADEN", "+", "-", "0/1", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Ladestart anfordern = 1; keine Anforderung = 0" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADC1[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "STAT_ANFORDERUNG_STOP_LADEN", "+", "-", "0/1", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Ladestopp anfordern = 1; keine Anforderung = 0" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADC4[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "REX_SOLL_LEISTUNG", "+", "-", "W", "high", "unsigned int", "-", "-", "1.0", "100.0", "0.0", "0.0", "28000.0", "Sollleistung, die der Motor liefern soll" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADC9[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "STAT_EWP_ANST_WERT", "+", "-", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "1.0", "100.0", "Ansteuerwert in % (0 - 100%)" },
  { "STAT_EWP_TO_ANST_WERT", "+", "-", "s", "high", "unsigned char", "-", "-", "0.5", "1.0", "0.0", "0.0", "510.0", "Timeout elektrische Wasserpumpe (0-510s)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADF1[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "ST_DIAG_DCDC_ANF", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_ST_DIAG_DCDC_ANF", "1.0", "1.0", "0.0", "-", "-", "Anforderung Betriebsart DCDC" },
  { "ST_B_DIAG_DCDC", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_ST_B_DIAG_DCDC", "-", "-", "-", "-", "-", "Auswahl der Systemgrenze" },
  { "I_DIAG_DCDC_LV_OUT", "+", "-", "A", "high", "int", "-", "-", "10.0", "1.0", "0.0", "-200.0", "200.0", "LV Strom Systemgrenze" },
  { "I_DIAG_DCDC_HV_OUT", "+", "-", "A", "high", "int", "-", "-", "10.0", "1.0", "0.0", "-25.0", "25.0", "HV Strom Systemgrenze" },
  { "U_DIAG_DCDC_LV_OUT", "+", "-", "V", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "0.0", "33.0", "LV Spannung Systemgrenze" },
  { "U_DIAG_DCDC_HV_OUT", "+", "-", "V", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "0.0", "300.0", "HV Spannung Systemgrenze" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADF4[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKS_ANFORDERUNG", "+", "-", "0/1", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "0 - Kontrolle an EME-SW; 1 - AKS E-Maschine angefordert" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADF6[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_AE_ROTORLAGESENSOR_ANLEREN_AKTION", "-", "-", "-", "-", "-", "0x00 = Auto RLS-Anlernen 0x01 = Hochdrehen/Freilauf" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADF8[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "DREHZAHL_KLASSE", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_AE_DREHZAHL_KLASSE", "-", "-", "-", "-", "-", "Drehzahl-Klasse: 0 = 0-2000 U/min 1 = 2000-4000 U/min 2 = 4000-6000 U/min 3 = 6000-8000 U/min 4 = 8000-10000 U/min 5 = 10000-12000 U/min 6 = 12000-14000 U/min" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xADF9[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "HISTOGRAMM_NR", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_AE_DCDC_HISTOGRAMM", "-", "-", "-", "-", "-", "Histogramm das angefordert wird: 0 = PHistoF 1 = PHistoL 2 = T1HistoF 3 = T1HistoL 4 = T2HistoF 5 = T2HistoL 6 = T3HistoF 7 = T3HistoL 8 = T4HistoF 9 = T4HistoL 10 = rUtil 11 = rUtilF" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE08[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "DUMMY", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "wegen Kompatibilität zu ToolSet32" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE09[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "DUMMY", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "wegen Kompatibilität zu ToolSet32" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE0A[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "DUMMY", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "wegen Kompatibilität zu ToolSet32" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE77[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE", "-", "-", "-", "-", "-", "Ändern des Zustandes der Parksperre ( 0 = kein Einlegen; 1 = Einlegen der Parksperre )" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE78[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_EINLERNEN_STEUERN", "-", "-", "-", "-", "-", "Vorgabe Anlernen ( 0 = kein Anlernen; 1 = Anlernen der Parksperre)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE8B[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_RESET_STROM_MAX", "-", "-", "-", "-", "-", "Anforderung der Ströme, die zurückgesetzt werden sollen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE93[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_ELUP_STEUERN", "-", "-", "-", "-", "-", "Ansteuerung der ELUP für 1 Sekunde (elektrische Überwachung bleibt aktiv!)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE94[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_MAGNET_STEUERN", "-", "-", "-", "-", "-", "Mögliche Zustände des Parksperren-Magneten ( 0 = kein Einschalten; 1 = Einschalten )" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDE95[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_NVRAM_LOESCHEN", "-", "-", "-", "-", "-", "Mögliche Ausführung des Löschens vom NV-RAM der Parksperre ( 0 = kein Löschen; 1 = Löschen )" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB1[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "OFFSET", "°", "high", "int", "-", "-", "1.0", "0.0055", "0.0", "-", "-", "Resolver Offset Winkel" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB2[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "Aktion: 0 = kein Reset; 1 = Reset" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB3[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "Aktion: 0 = kein Reset; 1 = Reset" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB4[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "Aktion: 0 = kein Reset; 1 = Reset" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB6[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "0 = nicht rücksetzen; 1 = rücksetzen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xDEB7[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "0 = nicht loeschen 1 = loeschen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADC9[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_EWP_STATUS_NR", "-", "-", "+", "0-n", "high", "unsigned char", "-", "TAB_AE_EWP_STATUS", "-", "-", "-", "Status der Elektrischen Wasserpumpe" },
  { "STAT_EWP_ANST_WERT", "-", "-", "+", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Drehzahl der Wasserpumpe in Prozent (0 - 100%)" },
  { "STAT_EWP_TESTER_DOND", "-", "-", "+", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Bedingung für Testerkontrolle: 0 = nicht erfüllt; 1 = erfüllt" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADF1[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ST_DIAG_DCDC_MODUS", "-", "-", "+", "0-n", "high", "unsigned char", "-", "TAB_STAT_ST_DIAG_DCDC_MODUS", "1.0", "1.0", "0.0", "Rückmeldung Betriebsart DCDC" },
  { "STAT_ST_DIAG_DCDC_GRENZEN", "-", "-", "+", "0-n", "high", "unsigned char", "-", "TAB_STAT_ST_DIAG_DCDC_GRENZEN", "1.0", "1.0", "0.0", "Rückmeldung Grenzen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADF4[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_AKS_ANFORDERUNG", "-", "-", "+", "0-n", "high", "unsigned char", "-", "TAB_STAT_AKS_ANFORDERUNG", "-", "-", "-", "0 - kein AKS; 1 - AKS; 2 - Fehler" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADF6[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_BF_ROTORLAGESENSOR_STATUS_ERROR", "-", "-", "+", "Bit", "high", "bitfield", "-", "BF_AE_ROTORLAGESENSOR_ERROR", "-", "-", "-", "Infos zum Status des Rotorlagesensor Anlernens und zum Fehler" },
  { "STAT_ROTORLAGESENSOR_WERT", "-", "-", "+", "-", "high", "unsigned int", "-", "-", "0.0055", "1.0", "-180.22", "EPS Offset" },
  { "STAT_UDSPANNUNG_WERT", "-", "-", "+", "V", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rücklesen der Ud Spannung" },
  { "STAT_UQSPANNUNG_WERT", "-", "-", "+", "V", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rücklesen der Uq Spannung" },
  { "STAT_DREHZAHL_WERT", "-", "-", "+", "1/min", "high", "int", "-", "-", "1.0", "1.0", "0.0", "Rücklesen der Drehzahl" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADF8[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_DREHZAHL_KLASSE", "+", "-", "-", "0-n", "high", "unsigned char", "-", "TAB_AE_DREHZAHL_KLASSE", "-", "-", "-", "Drehzahl-Klasse" },
  { "STAT_KMSTAND_START_WERT", "+", "-", "-", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Start der Klassierung" },
  { "STAT_KMSTAND_AKTUELL_WERT", "+", "-", "-", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand der Klassierung (aktuell)" },
  { "STAT_DKVAL01_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 01" },
  { "STAT_DKVAL02_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 02" },
  { "STAT_DKVAL03_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 03" },
  { "STAT_DKVAL04_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 04" },
  { "STAT_DKVAL05_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 05" },
  { "STAT_DKVAL06_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 06" },
  { "STAT_DKVAL07_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 07" },
  { "STAT_DKVAL08_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 08" },
  { "STAT_DKVAL09_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 09" },
  { "STAT_DKVAL10_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 10" },
  { "STAT_DKVAL11_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 11" },
  { "STAT_DKVAL12_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 12" },
  { "STAT_DKVAL13_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 13" },
  { "STAT_DKVAL14_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 14" },
  { "STAT_DKVAL15_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 15" },
  { "STAT_DKVAL16_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 16" },
  { "STAT_DKVAL17_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 17" },
  { "STAT_DKVAL18_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 18" },
  { "STAT_DKVAL19_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 19" },
  { "STAT_DKVAL20_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 20" },
  { "STAT_DKVAL21_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 21" },
  { "STAT_DKVAL22_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 22" },
  { "STAT_DKVAL23_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 23" },
  { "STAT_DKVAL24_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 24" },
  { "STAT_DKVAL25_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 25" },
  { "STAT_DKVAL26_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 26" },
  { "STAT_DKVAL27_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 27" },
  { "STAT_DKVAL28_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 28" },
  { "STAT_DKVAL29_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 29" },
  { "STAT_DKVAL30_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 30" },
  { "STAT_DKVAL31_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 31" },
  { "STAT_DKVAL32_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 32" },
  { "STAT_DKVAL33_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 33" },
  { "STAT_DKVAL34_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 34" },
  { "STAT_DKVAL35_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 35" },
  { "STAT_DKVAL36_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 36" },
  { "STAT_DKVAL37_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 37" },
  { "STAT_DKVAL38_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 38" },
  { "STAT_DKVAL39_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 39" },
  { "STAT_DKVAL40_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Drehzahl-Klasse Wert 40" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xADF9[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_HISTVAL_01_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "1. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_02_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "2. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_03_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "3. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_04_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "4. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_05_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "5. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_06_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "6. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_07_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "7. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_08_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "8. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_09_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "9. Wert des angeforderten Histogramm" },
  { "STAT_HISTVAL_10_WERT", "+", "-", "-", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "10. Wert des angeforderten Histogramm" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDDF6[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SPANNUNG_DCDC_LV_WERT", "V", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "DCDC Wandler: IST-Spannung LV-Seite am B+ Bolzen" },
  { "STAT_STROM_DCDC_LV_WERT", "A", "high", "int", "-", "-", "0.1", "1.0", "0.0", "DCDC Wandler: IST-Strom LV-Seite am B+ Bolzen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE00[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SOC_HVB_WERT", "%", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Ladezustand HV Batterie" },
  { "STAT_SOC_HVB_MIN_WERT", "%", "high", "unsigned char", "-", "-", "0.5", "1.0", "0.0", "Startfähigkeitsgrenze Ladezustand HV Batterie" },
  { "STAT_LADEGERAET", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Ladegerät erkannt (1 = erkannt / 0 = nicht erkannt)" },
  { "STAT_FREMDLADUNG", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Fremdladung (1 = erkannt / 0 = nicht erkannt)" },
  { "STAT_FAHRB", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Fahrbereitschaft (1 = aktiv / 0 = nicht aktiv)" },
  { "STAT_BA_DCDC_KOMM_NR", "0-n", "high", "unsigned char", "-", "TAB_EME_KOMM_BETRIEBSART_DCDC", "-", "-", "-", "Kommandierte Betriebsart DC/DC Wandler" },
  { "STAT_I_DCDC_HV_OUT_WERT", "A", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Stromgrenze HV-Seite" },
  { "STAT_U_DCDC_HV_OUT_WERT", "V", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Spannungsgrenze HV-Seite" },
  { "STAT_I_DCDC_LV_OUT_WERT", "A", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Stromgrenze NV-Seite" },
  { "STAT_U_DCDC_LV_OUT_WERT", "V", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "Spannungsgrenze NV-Seite" },
  { "STAT_BA_DCDC_IST_NR", "0-n", "high", "unsigned char", "-", "TAB_EME_IST_BETRIEBSART_DCDC", "-", "-", "-", "IST-Betriebsart DCDC-Wandler" },
  { "STAT_ALS_DCDC_WERT", "%", "high", "unsigned char", "-", "-", "0.5", "1.0", "0.0", "Auslastung DC/DC-Wandler" },
  { "STAT_I_DCDC_HV_WERT", "A", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Strom HV-Seite" },
  { "STAT_U_DCDC_HV_WERT", "V", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Spannung HV-Seite" },
  { "STAT_I_DCDC_LV_WERT", "A", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Strom NV-Seite" },
  { "STAT_U_DCDC_LV_WERT", "V", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "Spannung NV-Seite" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE02[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_U_DC_HV_LE_WERT", "V", "high", "int", "-", "-", "0.0313", "1.0", "0.0", "HV-Zwischenkreisspannung" },
  { "STAT_HV_READY", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Freigabe HV" },
  { "STAT_HDCAC_EREQ", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Anforderung Schließen Schütze HV-Batterie" },
  { "STAT_I0ANF_HVB", "0-n", "high", "unsigned char", "-", "TAB_EME_I0ANF_HVB", "-", "-", "-", "Status Nullstromanforderung" },
  { "STAT_ANF_ENTL_DCDC", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Anforderung Entladung HV-Zwischenkreis durch DCDC-Wandler" },
  { "STAT_HVSTART_KOMM", "0-n", "high", "unsigned char", "-", "TAB_EME_HVSTART_KOMM", "-", "-", "-", "Ausgabe des Stateflow-Status des HVPM Startsystems" },
  { "STAT_ANF_ENTL_EME", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Anforderung Notentladung ZK: 0 = nicht aktiv; 1 = aktiv" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE03[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NV_MSA_DCDC_WERT", "Ah", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge DC/DC MSA" },
  { "STAT_NV_MSA_EKK_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EKK MSA" },
  { "STAT_NV_ENTL_EKK_STD_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EKK Standkühlung" },
  { "STAT_NV_ENTL_EKK15_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EKK Kl15" },
  { "STAT_NV_ENTL_DCDC15_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge DC/DC Kl15" },
  { "STAT_NV_ENTL_EM1_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EM1" },
  { "STAT_NV_ENTL_EKK_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EKK" },
  { "STAT_NV_ENTL_DCDC_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge DC/DC" },
  { "STAT_NV_MSA_EM1_WERT", "Ah", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Zähler Ladungsmenge EM1 MSA" },
  { "STAT_NV_UHVB_SB_NULL_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB0" },
  { "STAT_NV_UHVB_SB_1_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB1" },
  { "STAT_NV_UHVB_SB_2_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB2" },
  { "STAT_NV_UHVB_SB_3_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB3" },
  { "STAT_NV_UHVB_SB_4_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB4" },
  { "STAT_NV_UHVB_SB_5_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB5" },
  { "STAT_NV_UHVB_SB_6_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB6" },
  { "STAT_NV_UHVB_SB_7_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB7" },
  { "STAT_NV_UHVB_SB_8_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB8" },
  { "STAT_NV_UHVB_SB_9_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB9" },
  { "STAT_NV_UHVB_SB_10_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB10" },
  { "STAT_NV_UHVB_SB_11_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB11" },
  { "STAT_NV_UHVB_SB_12_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB12" },
  { "STAT_NV_UHVB_SB_13_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB13" },
  { "STAT_NV_UHVB_SB_14_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB14" },
  { "STAT_NV_UHVB_SB_15_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB15" },
  { "STAT_NV_UHVB_SB_16_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB16" },
  { "STAT_NV_UHVB_SB_17_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB17" },
  { "STAT_NV_UHVB_SB_18_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB18" },
  { "STAT_NV_UHVB_SB_19_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB19" },
  { "STAT_NV_UHVB_SB_20_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB20" },
  { "STAT_NV_UHVB_SB_21_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB21" },
  { "STAT_NV_UHVB_SB_22_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB22" },
  { "STAT_NV_UHVB_SB_23_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB23" },
  { "STAT_NV_UHVB_SB_24_WERT", "s", "high", "long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittliche Zellenspannung in SB24" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE04[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NV_HVB_SOC_FAHRB_0_20_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_20_25_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_25_30_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_30_33_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_33_36_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_36_39_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_39_42_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_42_45_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_45_48_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_48_51_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_51_56_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_56_65_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_65_80_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" },
  { "STAT_NV_HVB_SOC_FAHRB_80_100_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ladezustand HV-Batterie bei Herstellung Fahrbereitschaft" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE06[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NV_KM_DEG_EKMV_VM_AN_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei Beginn der Reduzierung EKMV bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EKMV_VM_AN_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EKMV bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_BUCK_VM_AN_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung Buckmode bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_BUCK_VM_AN_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen Buckmode bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EKMV_VM_AUS_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EKMV bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EKMV_VM_AUS_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EKMV bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_BUCK_VM_AUS_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung Buckmode bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_BUCK_VM_AUS_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen Buckmode bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EKMV_VM_AN_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EKMV bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EKMV_VM_AN_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EKMV bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_BUCK_VM_AN_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung Buckmode bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_BUCK_VM_AN_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen Buckmode bei VM an. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EKMV_VM_AUS_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei Beginn der Reduzierung EKMV bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EKMV_VM_AUS_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EKMV bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_BUCK_VM_AUS_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung Buckmode bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_BUCK_VM_AUS_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen Buckmode bei VM aus. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EM1_LL_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EM im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EM1_LL_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EM im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EM1_LL_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EM im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EM1_LL_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EM nicht im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EM1_NOTLL_A_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EM nicht im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EM1_NOTLL_A_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EM nicht im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_KM_DEG_EM1_NOTLL_B_WERT", "km", "high", "unsigned int", "-", "-", "10.0", "1.0", "0.0", "Kilometerstand bei beginn der Reduzierung EM nicht im Leerlauf. Änderung nur bei Reduzierungen > 1min." },
  { "STAT_NV_T_DEG_EM1_NOTLL_B_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Gesamtdauer der Reduzierungen EM nicht im Leerlauf. Änderung nur bei Reduzierungen > 1min." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE18[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ZEIT_START_CCM_636_0_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang)" },
  { "STAT_ZEIT_STOP_CCM_636_0_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang)" },
  { "STAT_KM_START_CCM_636_0_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang)" },
  { "STAT_ABBRUCHBEDINGUNG_0_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschalte t(letzter Vorgang)" },
  { "STAT_ZEIT_START_CCM_636_1_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -1)" },
  { "STAT_ZEIT_STOP_CCM_636_1_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -1)" },
  { "STAT_KM_START_CCM_636_1_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -1)" },
  { "STAT_ABBRUCHBEDINGUNG_1_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -1)" },
  { "STAT_ZEIT_START_CCM_636_2_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -2)" },
  { "STAT_ZEIT_STOP_CCM_636_2_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -2)" },
  { "STAT_KM_START_CCM_636_2_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -2)" },
  { "STAT_ABBRUCHBEDINGUNG_2_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -2)" },
  { "STAT_ZEIT_START_CCM_636_3_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -3)" },
  { "STAT_ZEIT_STOP_CCM_636_3_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -3)" },
  { "STAT_KM_START_CCM_636_3_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -3)" },
  { "STAT_ABBRUCHBEDINGUNG_3_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -3)" },
  { "STAT_ZEIT_START_CCM_636_4_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -4)" },
  { "STAT_ZEIT_STOP_CCM_636_4_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -4)" },
  { "STAT_KM_START_CCM_636_4_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -4)" },
  { "STAT_ABBRUCHBEDINGUNG_4_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -4)" },
  { "STAT_ZEIT_START_CCM_636_5_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -5)" },
  { "STAT_ZEIT_STOP_CCM_636_5_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -5)" },
  { "STAT_KM_START_CCM_636_5_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -5)" },
  { "STAT_ABBRUCHBEDINGUNG_5_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -5)" },
  { "STAT_ZEIT_START_CCM_636_6_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -6)" },
  { "STAT_ZEIT_STOP_CCM_636_6_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -6)" },
  { "STAT_KM_START_CCM_636_6_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -6)" },
  { "STAT_ABBRUCHBEDINGUNG_6_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -6)" },
  { "STAT_ZEIT_START_CCM_636_7_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -7)" },
  { "STAT_ZEIT_STOP_CCM_636_7_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -7)" },
  { "STAT_KM_START_CCM_636_7_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -7)" },
  { "STAT_ABBRUCHBEDINGUNG_7_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -7)" },
  { "STAT_ZEIT_START_CCM_636_8_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -8)" },
  { "STAT_ZEIT_STOP_CCM_636_8_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -8)" },
  { "STAT_KM_START_CCM_636_8_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -8)" },
  { "STAT_ABBRUCHBEDINGUNG_8_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -8)" },
  { "STAT_ZEIT_START_CCM_636_9_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Startzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -9)" },
  { "STAT_ZEIT_STOP_CCM_636_9_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Stopzeit der CC-Meldung HV-System abgeschaltet (letzter Vorgang -9)" },
  { "STAT_KM_START_CCM_636_9_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Kilometerstand bei Aktivieren der CC-Meldung HV-System abgeschaltet (letzter Vorgang -9)" },
  { "STAT_ABBRUCHBEDINGUNG_9_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Abbruchbedingung CC-Meldung HV-System abgeschaltet (letzter Vorgang -9)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE19[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ANZAHL_BREMSBTG_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Anzahl Bremsbetätigungen" },
  { "STAT_LAUFZEIT_ELUP_S_WERT", "s", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Laufzeit Elup" },
  { "STAT_ANLAUFE_ELUP_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Anzahl Anläufe Elup" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE1C[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NV_DCDC_ALS_HIST_BEREICH_NULL_WERT", "s", "high", "unsigned long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittlicher DCDC Strom im Buckmode LV-seitig in Bereich 0" },
  { "STAT_NV_DCDC_ALS_HIST_BEREICH_1_WERT", "s", "high", "unsigned long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittlicher DCDC Strom im Buckmode LV-seitig in Bereich 1" },
  { "STAT_NV_DCDC_ALS_HIST_BEREICH_2_WERT", "s", "high", "unsigned long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittlicher DCDC Strom im Buckmode LV-seitig in Bereich 2" },
  { "STAT_NV_DCDC_ALS_HIST_BEREICH_3_WERT", "s", "high", "unsigned long", "-", "-", "0.1", "1.0", "0.0", "Zeit durchschnittlicher DCDC Strom im Buckmode LV-seitig in Bereich 3" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE74[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SENSOR_1_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_SENSOREN", "-", "-", "-", "Status Sensor 1" },
  { "STAT_SENSOR_2_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_SENSOREN", "-", "-", "-", "Status Sensor 2" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE75[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SPANNUNG_HV_SLE_WERT", "V", "high", "unsigned int", "-", "-", "0.2", "1.0", "0.0", "HV Spannung in der SLE" },
  { "STAT_SPANNUNG_HV_SLE_PFC_WERT", "V", "high", "unsigned int", "-", "-", "0.2", "1.0", "0.0", "SLE Power Factor Corrector Spannung" },
  { "STAT_SPANNUNG_HV_SLE_AC_WERT", "V", "high", "unsigned int", "-", "-", "0.2", "1.0", "0.0", "SLE Eingangsspannung" },
  { "STAT_SPANNUNG_HV_DCDC_WERT", "V", "high", "unsigned int", "-", "-", "0.2", "1.0", "0.0", "HV Spannung im DC/DC-Wandler" },
  { "STAT_SPANNUNG_HV_UMRICHTER_WERT", "V", "high", "unsigned int", "-", "-", "0.2", "1.0", "0.0", "HV Spannung im Umrichter" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE78[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_PARKSPERRE_EINLERNEN", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_EINLERNEN_STATUS", "-", "-", "-", "Einlernzustand Parksperre ( 0 = nicht eingelernt; 1 = eingelernt )" },
  { "STAT_PARKSPERRE_DIAG_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_PARKSPERRE_ZUSTAND", "-", "-", "-", "Rückmeldung bzgl. Einlernvorgang" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE7A[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_PS_POSITION_EINGELEGT_WERT", "Bit", "high", "unsigned int", "-", "-", "-", "-", "-", "Position der Parksperre eingelegt" },
  { "STAT_PS_POSITION_OFFEN_WERT", "%", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Position der Parksperre offen" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE7C[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_PS_SPG_HBRUECKE_WERT", "mV", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Spannung der H-Brücke" },
  { "STAT_PS_POSITION_OFFEN_WERT", "mV", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Spannung der Sensierung" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE7D[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_ANSTEURUNG_PARKSPERRE1_WERT", "%", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Ansteuerung Parksperre (Duty Cycle H-Bruecke)." },
  { "STAT_ROHSIGNAL_ANSTEURUNG_PARKSPERRE2", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Rohsignal Ansteuerung Parksperre (Richtung)." },
  { "STAT_ROHSIGNAL_ANSTEURUNG_PARKSPERRE_NOTENTRIEGELUNG", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Rohsignal Ansteuerung Parksperre Notentrieglungsmagnet ( 0 = nicht angesteuert; 1 = angesteuert )" },
  { "STAT_ROHSIGNAL_ANSTEURUNG_ELUP_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ELUP_ROHSIGNALE", "-", "-", "-", "Rohsignal Ansteuerung ELUP." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE7E[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_TEMP_ENDSTUFE_ELUP_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Temperaturmessung Endstufe für ELUP." },
  { "STAT_ROHSIGNAL_BUDS_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal BUDS." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE7F[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_TEMP_EMASCHINE_STATOR_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Temperatursensor E-Maschine Stator" },
  { "STAT_ROHSIGNAL_TEMP_UMRICHTER_PHASE_U_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Temperatursensor Umrichter Phase U." },
  { "STAT_ROHSIGNAL_TEMP_UMRICHTER_PHASE_V_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Temperatursensor Umrichter Phase V." },
  { "STAT_ROHSIGNAL_TEMP_UMRICHTER_PHASE_W_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Temperatursensor Umrichter Phase W." },
  { "STAT_ROHSIGNAL_SPANNUNG_HVDC_UMRICHTER_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal HV DC Spannung Umrichter" },
  { "STAT_ROHSIGNAL_STROM_HVDC_UMRICHTER_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal HV DC Strom Umrichter." },
  { "STAT_ROHSIGNAL_STROM_U_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Stromsensor Phase U." },
  { "STAT_ROHSIGNAL_STROM_V_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Stromsensor Phase V." },
  { "STAT_ROHSIGNAL_STROM_W_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Stromsensor Phase W." },
  { "STAT_ROHSIGNAL_ROTORLAGESENSOR_WERT", "rad", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Rotorlagesensor korrigierte elektrische Winkelposition (Radian)" },
  { "STAT_ROHSIGNAL_SPANNUNG_U_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Spannungssensor Phase U." },
  { "STAT_ROHSIGNAL_SPANNUNG_V_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Spannungssensor Phase V." },
  { "STAT_ROHSIGNAL_SPANNUNG_W_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Spannungssensor Phase W." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE80[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_STROM_PARKSPERRE_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Strommessung Parksperre." },
  { "STAT_ROHSIGNAL_POSITION_PARKSPERRE3_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Rohsignal 3 Positionsmessung Parksperre ( 0-1000=0-100%; 2000=ungueltig)" },
  { "STAT_ROHSIGNAL_POSITION_PARKSPERRE4_WERT", "-", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "Rohsignal 4 Positionsmessung Parksperre (0-1000=0-100%; 2000=ungueltig)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE81[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_KL30B_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Spannungsmessung Klemme30b" },
  { "STAT_ROHSIGNAL_KL15WUO_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ROHSIGNAL_ZUSTAND", "-", "-", "-", "Rohsignal  Klemme 15WUO (0 = nicht aktiv, 1 = aktiv)" },
  { "STAT_ROHSIGNAL_KL15_3_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ROHSIGNAL_ZUSTAND", "-", "-", "-", "Rohsignal Klemme 15_3 ( 0 = nicht aktiv; 1 = aktiv )" },
  { "STAT_ROHSIGNAL_KL30C_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ROHSIGNAL_ZUSTAND", "-", "-", "-", "Rohsignal Klemme 30c; elektrisch ( 0 = nicht aktiv; 1 = aktiv )" },
  { "STAT_ROHSIGNAL_CRASHSIGNAL_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ROHSIGNAL_ZUSTAND", "-", "-", "-", "Rohsignal Crasheingang Crashsignal elektrisch ( 0 = nicht aktiv; 1 = aktiv )" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE82[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_SPANNUNG_AC_NETZ_L1_WERT", "V", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Spannungsmessung Phase L1 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_SPANNUNG_AC_NETZ_L2_WERT", "V", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Spannungsmessung Phase L2 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_SPANNUNG_AC_NETZ_L3_WERT", "V", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Spannungsmessung Phase L3 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_STROM_AC_NETZ_L1_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Strommessung Phase L1 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_STROM_AC_NETZ_L2_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Strommessung Phase L2 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_STROM_AC_NETZ_L3_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Strommessung Phase L3 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_FREQUENZ_AC_NETZ_L1_WERT", "Hz", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Frequenzmessung Phase L1 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_FREQUENZ_AC_NETZ_L2_WERT", "Hz", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Frequenzmessung Phase L2 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_FREQUENZ_AC_NETZ_L3_WERT", "Hz", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Frequenzmessung Phase L3 im AC Netz; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." },
  { "STAT_ROHSIGNAL_E_S_CHARGE_EN_WERT", "-", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rohsignal Charge Enable Leitung; Auflösung, Quantisierung, Range etc. wie in SG-interner Funktion verwendet wird." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE83[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROHSIGNAL_SPANNUNG_LV_DCDC_WERT", "V", "high", "unsigned long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Spannungsmessung LV DCDC Wandler." },
  { "STAT_ROHSIGNAL_STROM_LV_DCDC_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Strommessung LV DCDC Wandler." },
  { "STAT_ROHSIGNAL_STROM_HV_DCDC_WERT", "A", "high", "long", "-", "-", "0.0010", "1.0", "0.0", "Rohsignal Strommessung HV DCDC Wandler." }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE84[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NETZFREQUENZ_PHASE_1_WERT", "-", "high", "unsigned int", "-", "-", "0.25", "1.0", "0.0", "Aktuelle Netzfrequenz Phase 1" },
  { "STAT_LADEDAUER_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Rückgabe der im aktuellen Ladezyklus verstrichenen Ladezeit" },
  { "STAT_FEHLERZUSTAND_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_SLE_FEHLERZUSTAENDE", "-", "-", "-", "SLE Fehlerzustände: 0=Derating 1=Ladeunterbrechung 2=Notlauf 3=Kommunikationsausfall 4=Reserviert 255 Signal ungültig" },
  { "STAT_SLE_DERATING_WERT", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Wert, um den die DC-HV-Ausgangsleistung reduziert ist. 0-254%" },
  { "STAT_BETRIEBSART_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_SLE_BETRIEBSMODE", "-", "-", "-", "Betriebsart: 1=Standby 2=HV-DC Laden 3=Reserviert 15 Signal ungültig" },
  { "STAT_WIRKUNGSGRAD_LADEZYKLUS_WERT", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Wirkungsgrad Ladezyklus" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE85[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SLE_DC_HV_LEISTUNG_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "-30000.0", "Abgegebende Momentanleistung in den Zwischenkreis" },
  { "STAT_SLE_DC_HV_LEISTUNG_MAX_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "-30000.0", "Maximal abgebbare Leistung in den Zwischenkreis" },
  { "STAT_SLE_AC_WIRKLEISTUNG_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "-30000.0", "Entnommene Momentanwirkleistung aus dem Netz" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE86[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SPANNUNG_RMS_AC_PHASE_1_WERT", "V", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Effektivwerte der AC Leiterspannungen (Phase1)" },
  { "STAT_SPANNUNG_SLE_DC_HV_WERT", "V", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "SLE DC HV Spannung" },
  { "STAT_SPANNUNG_SLE_DC_HV_OBERGRENZE_WERT", "V", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "SLE DC HV Spannungsobergrenze" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE87[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_STROM_PCF_SUM_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "-100.0", "kalibrierter SLE Power Corrector Factor Summenstrom" },
  { "STAT_STROM_PCF1_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "-100.0", "kalibrierter SLE Power Corrector Factor1 Strom" },
  { "STAT_STROM_PCF2_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "-100.0", "kalibrierter SLE Power Corrector Factor2 Strom" },
  { "STAT_STROM_TRAFO_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "-100.0", "kalibrierter SLE Trafostrom" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE89[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_STROM_DCDC_WANDLER_HV_WERT", "A", "high", "unsigned int", "-", "-", "0.05", "1.0", "-100.0", "Strom des DCDC-Wandlers auf der HV-Seite" },
  { "STAT_STROM_DCDC_WANDLER_12V_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "-1000.0", "Strom des DCDC-Wandlers auf der 12V-Seite" },
  { "STAT_STROM_DCDC_TS1_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "DC/DC Tiefsetzsteller-Strom 1" },
  { "STAT_STROM_DCDC_TS2_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "DC/DC Tiefsetzsteller-Strom 2" },
  { "STAT_STROM_DCDC_TRAFO1_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "DC/DC Trafostrom 1" },
  { "STAT_STROM_DCDC_TRAFO2_WERT", "A", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "DC/DC Trafostrom 2" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE8B[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_STROM_DCDC_HV_IST_MAX_WERT", "A", "high", "unsigned int", "-", "-", "0.05", "1.0", "-100.0", "Maximaler betragsmäßiger HV Stroms des DCDC-Wandlers" },
  { "STAT_STROM_DCDC_LV_IST_MAX_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "-512.0", "Maximaler betragsmäßiger LV Stroms DCDC-Wandler" },
  { "STAT_STROM_EKMV_MAX_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Maximaler Strom zum eKMV" },
  { "STAT_ERREGERSTROM_MAX_WERT", "A", "high", "unsigned int", "-", "-", "0.1", "1.0", "0.0", "Maximaler Erregerstrom der Emaschine" },
  { "STAT_STROM_DC_HV_UMRICHTER_MOTOR_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Max. HV-DC Strom des Umrichters für den EM-Stator im motorischen Betrieb" },
  { "STAT_STROM_DC_HV_UMRICHTER_GENERATOR_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Max. HV-DC Strom des Umrichters für den EM-Stator im generatorischem Betrieb" },
  { "STAT_STROM_SLE_DC_HV_IST_MAX_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Maximaler betragsmäßiger HV Stroms der SLE DC HV" },
  { "STAT_STROM_SLE_AC_RMS_IST_MAX_WERT", "A", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Maximaler betragsmäßiger HV Stroms der SLE AC RMS" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE8C[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_TEMP_UMRICHTER_PHASE_U_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Umrichter Phase U" },
  { "STAT_TEMP_UMRICHTER_PHASE_V_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Umrichter Phase V" },
  { "STAT_TEMP_UMRICHTER_PHASE_W_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Umrichter Phase W" },
  { "STAT_TEMP_UMRICHTER_GT_PHASE_U_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Inverter Gatedriver Phase U" },
  { "STAT_TEMP_UMRICHTER_GT_PHASE_V_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Inverter Gatedriver Phase U" },
  { "STAT_TEMP_UMRICHTER_GT_PHASE_W_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Inverter Gatedriver Phase W" },
  { "STAT_TEMP_UMRICHTER_MUX_ADC_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur am MUX_ADC des Inverters" },
  { "STAT_TEMP_DCDC_BO_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur des DCDC Boards" },
  { "STAT_TEMP_DCDC_GTW_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur DC/DC-Gegentaktwandler" },
  { "STAT_TEMP_DCDC_TS_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur DC/DC-Tiefsetzer" },
  { "STAT_TEMP_DCDC_GR_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur des DCDC Boards" },
  { "STAT_TEMP_SLE_PFC_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur SLE-PowerFactorCorrection" },
  { "STAT_TEMP_SLE_GR_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur SLE-Gleichrichter" },
  { "STAT_TEMP_SLE_GTW_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur SLE-Gegentaktwandler" },
  { "STAT_TEMP_SLE_BO_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur des SLE Boards" },
  { "STAT_TEMP_ELUP_LE_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur auf dem Powerbord - Messstelle ELUP Leistungsendstufe" },
  { "STAT_TEMP_DIG_CY320_MC0_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur auf dem Digitalbord am CY320_MC0" },
  { "STAT_TEMP_DIG_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur auf dem Digitalbord" },
  { "STAT_TEMP_DIG_CY320_MC2_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur auf dem Digitalbord am CY320_MC2" },
  { "STAT_TEMP_PROZESSOR_MC0_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Prozessor MC0" },
  { "STAT_TEMP_PROZESSOR_MC2_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "Temperatur Prozessor MC2" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE92[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_BETRIEBSART_DCDC_IST", "0-n", "high", "unsigned char", "-", "TAB_AE_ZST_AKTIV_NAKTIV", "-", "-", "-", "Ist-Betriebsart des DCDC-Wandlers" },
  { "STAT_SPANNUNG_LV_IST_WERT", "V", "high", "unsigned int", "-", "-", "0.05", "1.0", "0.0", "-" },
  { "STAT_AUSLASTUNG_WERT", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Auslastung des DCDC-Wandlers" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE93[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ELUP_ANSTEUERUNG", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Aktueller Schaltzustand der ELUP ( 0 = aus; 1 = an )" },
  { "STAT_ELUP_SPANNUNG_WERT", "V", "high", "unsigned char", "-", "-", "0.1", "1.0", "0.0", "Spannung am ELUP Ausgang" },
  { "STAT_ELUP_STROM_WERT", "A", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Strom am ELUP-Ausgang" },
  { "STAT_ELUP_TEMP_WERT", "°C", "high", "unsigned char", "-", "-", "1.0", "1.0", "-40.0", "Temperatur des ELUP-Treibers" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE96[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_FEHLER_BIT0_EIN", "0/1", "high", "unsigned int", "0x0001", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 0: Shutdown Undervoltage 0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT1_EIN", "0/1", "high", "unsigned int", "0x0002", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 1: Shutdown Overvoltage  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT2_EIN", "0/1", "high", "unsigned int", "0x0004", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 2: Shutdown Overtemperature  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT3_EIN", "0/1", "high", "unsigned int", "0x0008", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 3: Shutdown Overcurrent  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT4_EIN", "0/1", "high", "unsigned int", "0x0010", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 4: Interlock Fault  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT5_EIN", "0/1", "high", "unsigned int", "0x0020", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 5: Not in commanded mode  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT6_EIN", "0/1", "high", "unsigned int", "0x0040", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 6: Genereller HW-Fehler (Err_State)  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT7_EIN", "0/1", "high", "unsigned int", "0x0080", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 7: -Vorhalt- Verfeinerung HW-Fehler 1  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT8_EIN", "0/1", "high", "unsigned int", "0x0100", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit 8: -Vorhalt- Verfeinerung HW-Fehler 2  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT9_EIN", "0/1", "high", "unsigned int", "0x0200", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit9: -Vorhalt- Verfeinerung HW-Fehler 3  0=nicht aktiv 1=aktiv" },
  { "STAT_FEHLER_BIT10_EIN", "0/1", "high", "unsigned int", "0x0400", "-", "-", "-", "-", "Diagnosestatus des DCDC-Wandler: Bit10: -Vorhalt- Verfeinerung HW-Fehler 4  0=nicht aktiv 1=aktiv" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDE9E[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_LADEN_NR", "0-n", "high", "unsigned char", "-", "TAB_EDME_STATUS_LADEN", "-", "-", "-", "Information über den aktuellen Status des Ladens (siehe TAB_EDME_STATUS_LADEN)" },
  { "STAT_REMOTE_LADEN_NR", "0-n", "high", "unsigned char", "-", "TAB_EDME_REMOTE_LADEN", "-", "-", "-", "Bit0: RemoteLaden nicht aktiv Bit1: RemoteLaden on Hold Bit2: RemoteLaden aktiv" },
  { "STAT_TIMER_LADEN_NR", "0-n", "high", "unsigned char", "-", "TAB_EDME_TIMER_LADEN_NR", "-", "-", "-", "Bit0: TimerLaden nicht aktiv Bit1: TimerLaden on Hold Bit2: TimerLaden aktiv" },
  { "STAT_HV_SOC_WERT", "%", "high", "unsigned char", "-", "-", "0.5", "1.0", "0.0", "Anzeige Ladezustand HV-Batterie" },
  { "STAT_ZEIT_LADEENDE_WERT", "min", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Ladedauer" },
  { "STAT_MAX_LADESTROM_LADEGERAET_WERT", "A", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Maximaler AC-Ladestrom Ladegerät" },
  { "STAT_IST_AC_SPANNUNG_LADEGERAET_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ist-AC-Spannung Ladegerät" },
  { "STAT_REICHWEITE_WERT", "km", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Reichweite" },
  { "STAT_HVB_TEMP_WERT", "°", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Temperatur der HV-Batterie" },
  { "STAT_TRIGGER_SEGMENTSPEICHER_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Auslösebedingung für das Lesen des Segmentspeichers" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEA0[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ANZ_LADEVORGAENGE_GESAMT_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Anzahl Ladevorgänge seit letztem TSR" },
  { "STAT_ANZ_LADEVORGAENGE_REG_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Anzahl Ladevorgänge seit letztem TSR größer eine Minute" },
  { "STAT_TIME_LADEBEGINN_HR_WERT", "h", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Uhrzeit bei Ladebeginn (Kombi) Stunde" },
  { "STAT_TIME_LADEBEGINN_MIN_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Uhrzeit bei Ladebeginn (Kombi) Minute" },
  { "STAT_KM_STAND_LADEBEGINN_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "km-Stand bei Ladebeginn" },
  { "STAT_DELTA_RANGE_WERT", "km", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Differenz Reichweitenprognose zu letztem Ladeende und aktuellem Ladebeginn" },
  { "STAT_DELTA_KM_STAND_WERT", "km", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Differenz km-Stand seit letztem Ladeende und aktuellem Ladebeginn" },
  { "STAT_DELTA_SOC_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "SoC-Hub zwischen letztem Ladevorgang und aktuellem Ladebeginn" },
  { "STAT_SOC_LADEBEGINN_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "HV-SoC bei Ladebeginn" },
  { "STAT_SOC_LADEENDE_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "HV-SoC bei Ladeende" },
  { "STAT_ABBRUCHBED_LADEN_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Start- und Abbruchbedingung Laden" },
  { "STAT_LADEDAUER_GESAMT_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Ladevorgang gesamt" },
  { "STAT_LADEDAUER_EFFEKTIV_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Ladevorgang ohne Ladeunterbrechungen" },
  { "STAT_ANZ_LADEUNTERBR_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Anzahl Ladeunterbrechungen" },
  { "STAT_REAS_LDUNTERBR_WERT", "-", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Ursache für die letzten 4 Ladeunterbrechungen" },
  { "STAT_PROGNOSE_LADEDAUER_WERT", "min", "high", "unsigned int", "-", "-", "5.0", "1.0", "0.0", "Prognostizierte Ladedauer zu Ladebeginn" },
  { "STAT_DAUER_DER_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Deratings" },
  { "STAT_MIN_VALUE_DER_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Minimal auftretender Wert während Derating" },
  { "STAT_DERATING_PROZENTUAL_WERT", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Mittlerer Wert des Deratings" },
  { "STAT_I_LIM_GRID_WERT", "A", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Netzseitige Stromgrenze" },
  { "STAT_T_AMB_LADEBEGINN_WERT", "°C", "high", "int", "-", "-", "0.5", "1.0", "0.0", "Umgebungstemperatur Ladebeginn" },
  { "STAT_T_AMB_LADEENDE_WERT", "°C", "high", "int", "-", "-", "0.5", "1.0", "0.0", "Umgebungstemperatur Ladeende" },
  { "STAT_T_HVB_LADEBEGINN_WERT", "°C", "high", "int", "-", "-", "1.0", "1.0", "0.0", "Temperatur HV-Batterie" },
  { "STAT_T_HVB_LADEENDE_WERT", "°C", "high", "int", "-", "-", "1.0", "1.0", "0.0", "Temperatur HV-Batterie Ladeende" },
  { "STAT_U_GRID_MIN_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Minimale Netzspannung" },
  { "STAT_U_GRID_MAX_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Maximale Netzspannung" },
  { "STAT_HIST_P_KLE_0_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 0-1 kW" },
  { "STAT_HIST_P_KLE_1_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 1-2 kW" },
  { "STAT_HIST_P_KLE_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 2-3 kW" },
  { "STAT_HIST_P_KLE_3_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 3-4 kW" },
  { "STAT_HIST_P_KLE_4_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 4-5 kW" },
  { "STAT_HIST_P_KLE_5_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 5-6 kW" },
  { "STAT_HIST_P_KLE_6_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall > 6 kW" },
  { "STAT_ENERGIE_KLE_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch KLE" },
  { "STAT_HIST_P_EKMV_EDH_0_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 0-1 kW" },
  { "STAT_HIST_P_EKMV_EDH_1_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 1-2 kW" },
  { "STAT_HIST_P_EKMV_EDH_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 2-3 kW" },
  { "STAT_HIST_P_EKMV_EDH_3_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 3-4 kW" },
  { "STAT_HIST_P_EKMV_EDH_4_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 4-5 kW" },
  { "STAT_HIST_P_EKMV_EDH_5_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall > 5 kW" },
  { "STAT_ENERGIE_EDH_EKMV_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch EDH und EKMV" },
  { "STAT_ANF_ART_VOKO_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Bit0: Voko Innenraum Bit1: Voko Innenraum forced Bit2: Voko Batt Bit3: Voko Batt forced" },
  { "STAT_HIST_P_HVB_0_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB < -4 kW" },
  { "STAT_HIST_P_HVB_1_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -4 kW bis -3 kW" },
  { "STAT_HIST_P_HVB_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -3 kW bis -2 kW" },
  { "STAT_HIST_P_HVB_3_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -2 kW bis -1 kW" },
  { "STAT_HIST_P_HVB_4_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -1 kW bis 0 kW" },
  { "STAT_HIST_P_HVB_5_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 0 kW bis 1 kW" },
  { "STAT_HIST_P_HVB_6_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 1 kW bis 2 kW" },
  { "STAT_HIST_P_HVB_7_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 2 kW bis 3 kW" },
  { "STAT_HIST_P_HVB_8_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 3 kW bis 4 kW" },
  { "STAT_HIST_P_HVB_9_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 4 kW bis 5 kW" },
  { "STAT_HIST_P_HVB_10_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 5 kW bis 6 kW" },
  { "STAT_HIST_P_HVB_11_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 6 kW bis 7 kW" },
  { "STAT_HIST_P_HVB_12_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB > 7 kW" },
  { "STAT_ENERGIE_HVB_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch HVB" },
  { "STAT_P_AVG_DCDC_HV_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Leistung DCDC-Wandler HV-seitig" },
  { "STAT_DAUER_SPANNUNGSGRENZE_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer in Spannungsbegrenzung während Ladevorgang" },
  { "STAT_SOC_SPANNUNGSGRENZE_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "SoC bei der Spannungsgrenze erreicht wird" },
  { "STAT_TIME_LADEBEGINN_HR_2_WERT", "h", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Uhrzeit bei Ladebeginn (Kombi) Stunde 2" },
  { "STAT_TIME_LADEBEGINN_MIN_2_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Uhrzeit bei Ladebeginn (Kombi) Minute 2" },
  { "STAT_KM_STAND_LADEBEGINN_2_WERT", "km", "high", "unsigned long", "-", "-", "1.0", "1.0", "0.0", "km-Stand bei Ladebeginn 2" },
  { "STAT_DELTA_RANGE_2_WERT", "km", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Differenz Reichweitenprognose zu letztem Ladeende und aktuellem Ladebeginn 2" },
  { "STAT_DELTA_KM_STAND_2_WERT", "km", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Differenz km-Stand seit letztem Ladeende und aktuellem Ladebeginn 2" },
  { "STAT_DELTA_SOC_2_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "SoC-Hub zwischen letztem Ladevorgang und aktuellem Ladebeginn 2" },
  { "STAT_SOC_LADEBEGINN_2_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "HV-SoC bei Ladebeginn 2" },
  { "STAT_SOC_LADEENDE_2_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "HV-SoC bei Ladeende 2" },
  { "STAT_ABBRUCHBED_LADEN_2_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Start- und Abbruchbedingung Laden 2" },
  { "STAT_LADEDAUER_GESAMT_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Ladevorgang gesamt 2" },
  { "STAT_LADEDAUER_EFFEKTIV_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Ladevorgang ohne Ladeunterbrechungen 2" },
  { "STAT_ANZ_LADEUNTERBR_2_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Anzahl Ladeunterbrechungen 2" },
  { "STAT_REAS_LDUNTERBR_2_WERT", "-", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Ursache für die letzten 4 Ladeunterbrechungen 2" },
  { "STAT_PROGNOSE_LADEDAUER_2_WERT", "min", "high", "unsigned int", "-", "-", "5.0", "1.0", "0.0", "Prognostizierte Ladedauer zu Ladebeginn 2" },
  { "STAT_DAUER_DER_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Deratings 2" },
  { "STAT_MIN_VALUE_DER_2_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Minimal auftretender Wert während Derating 2" },
  { "STAT_DERATING_PROZENTUAL_2_WERT", "%", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Mittlerer Wert des Deratings 2" },
  { "STAT_I_LIM_GRID_2_WERT", "A", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Netzseitige Stromgrenze 2" },
  { "STAT_T_AMB_LADEBEGINN_2_WERT", "°C", "high", "int", "-", "-", "0.5", "1.0", "0.0", "Umgebungstemperatur Ladebeginn 2" },
  { "STAT_T_AMB_LADEENDE_2_WERT", "°C", "high", "int", "-", "-", "0.5", "1.0", "0.0", "Umgebungstemperatur Ladeende 2" },
  { "STAT_T_HVB_LADEBEGINN_2_WERT", "°C", "high", "int", "-", "-", "1.0", "1.0", "0.0", "Temperatur HV-Batterie 2" },
  { "STAT_T_HVB_LADEENDE_2_WERT", "°C", "high", "int", "-", "-", "1.0", "1.0", "0.0", "Temperatur HV-Batterie Ladeende 2" },
  { "STAT_U_GRID_MIN_2_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Minimale Netzspannung 2" },
  { "STAT_U_GRID_MAX_2_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Maximale Netzspannung 2" },
  { "STAT_HIST_P_KLE_0_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 0-1 kW 2" },
  { "STAT_HIST_P_KLE_1_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 1-2 kW 2" },
  { "STAT_HIST_P_KLE_2_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 2-3 kW 2" },
  { "STAT_HIST_P_KLE_3_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 3-4 kW 2" },
  { "STAT_HIST_P_KLE_4_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 4-5 kW 2" },
  { "STAT_HIST_P_KLE_5_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall 5-6 kW 2" },
  { "STAT_HIST_P_KLE_6_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs KLE im Intervall > 6 kW 2" },
  { "STAT_ENERGIE_KLE_2_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch KLE 2" },
  { "STAT_HIST_P_EKMV_EDH_0_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 0-1 kW 2" },
  { "STAT_HIST_P_EKMV_EDH_1_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 1-2 kW 2" },
  { "STAT_HIST_P_EKMV_EDH_2_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 2-3 kW 2" },
  { "STAT_HIST_P_EKMV_EDH_3_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 3-4 kW 2" },
  { "STAT_HIST_P_EKMV_EDH_4_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall 4-5 kW 2" },
  { "STAT_HIST_P_EKMV_EDH_5_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfs von EKMV und EDH im Intervall > 5 kW 2" },
  { "STAT_ENERGIE_EDH_EKMV_2_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch EDH und EKMV 2" },
  { "STAT_ANF_ART_VOKO_2_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Bit0: Voko Innenraum_2 Bit1: Voko Innenraum forced_2 Bit2: Voko Batt_2 Bit3: Voko Batt forced_2" },
  { "STAT_HIST_P_HVB_0_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB < -4 kW 2" },
  { "STAT_HIST_P_HVB_1_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -4 kW bis -3 kW 2" },
  { "STAT_HIST_P_HVB_2_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -3 kW bis -2 kW 2" },
  { "STAT_HIST_P_HVB_3_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -2 kW bis -1 kW 2" },
  { "STAT_HIST_P_HVB_4_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB -1 kW bis 0 kW 2" },
  { "STAT_HIST_P_HVB_5_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 0 kW bis 1 kW 2" },
  { "STAT_HIST_P_HVB_6_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 1 kW bis 2 kW 2" },
  { "STAT_HIST_P_HVB_7_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 2 kW bis 3 kW 2" },
  { "STAT_HIST_P_HVB_8_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 3 kW bis 4 kW 2" },
  { "STAT_HIST_P_HVB_9_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 4 kW bis 5 kW 2" },
  { "STAT_HIST_P_HVB_10_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 5 kW bis 6 kW 2" },
  { "STAT_HIST_P_HVB_11_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB 6 kW bis 7 kW 2" },
  { "STAT_HIST_P_HVB_12_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer des Leistungsbedarfes der HVB > 7 kW 2" },
  { "STAT_ENERGIE_HVB_2_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Energieverbrauch HVB 2" },
  { "STAT_P_AVG_DCDC_HV_2_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Leistung DCDC-Wandler HV-seitig 2" },
  { "STAT_DAUER_SPANNUNGSGRENZE_2_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer in Spannungsbegrenzung während Ladevorgang 2" },
  { "STAT_SOC_SPANNUNGSGRENZE_2_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "SoC bei der Spannungsgrenze erreicht wird 2" },
  { "STAT_ANZ_NACHLADEANF_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Anzahl Nachladeanforderungen seit letztem TSR" },
  { "STAT_DAUER_NACHLADEANF_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer der letzen Nachladeanforderung" },
  { "STAT_P_LADE_AVG_NVB_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Ladeleistung NVB während Nachladeanforderung" },
  { "STAT_P_LADE_AVG_DCDC_HV_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Leistung DCDC-Wandler HV-seitig während Nachladeanforderung" },
  { "STAT_ZUSATZINFO_NACHLADEANF_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Bit0: Nachladeanforderung nach Wecken durch IBS Bit1: Ladevorgang bei Fahrzeug wach Bit2: Vorbehalt Bit3: Vorbehalt Bit4: HVB-SoC min. unterschritten Bit5: Min. Nachladestrom NVB unterschritten Bit6: Abbruch durch St_kl_15 Bit7: Schlechte Ladebilanz" },
  { "STAT_GESAMTDAUER_NACHLAUF_WERT", "s", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Aufsummierte Nachlaufdauer seit letzten TSR" },
  { "STAT_P_AVG_DCDC_INSGESAMT_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Leistung DCDC-Wandler während Nachlauf" },
  { "STAT_P_AVG_BATT_INSGESAMT_WERT", "W", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Durchschnittliche Ladeleistung NVB während Nachlauf" },
  { "STAT_DELTA_SOC_STANDZEIT_1_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Änderung SoC über Standzeit_1" },
  { "STAT_DAUER_STANDZEIT_1_WERT", "min", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Standzeit_1" },
  { "STAT_DELTA_SOC_STANDZEIT_2_WERT", "%", "high", "int", "-", "-", "0.1", "1.0", "0.0", "Änderung SoC über Standzeit_2" },
  { "STAT_DAUER_STANDZEIT_2_WERT", "min", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Dauer Standzeit_2" },
  { "STAT_REAS_DERATING_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ursache(n) des Deratings Bit0: Übertemperatur Bit1: Netzfrequenz zu niedrig Bit2: Ausfall eines Lademoduls Bit3: DC-Strombegrenzung Bit4: Netzseitig verfügbare Leistung kleiner Nennleistung" },
  { "STAT_REAS_DERATING_2_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Ursache(n) des Deratings Bit0: Übertemperatur Bit1: Netzfrequenz zu niedrig Bit2: Ausfall eines Lademoduls Bit3: DC-Strombegrenzung Bit4: Netzseitig verfügbare Leistung kleiner Nennleistung" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEA6[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_TEMP1_E_MOTOR_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "E-Motor Temperatur 1" },
  { "STAT_TEMP2_E_MOTOR_WERT", "°C", "high", "int", "-", "-", "0.0156", "1.0", "0.0", "E-Motor Temperatur 2" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEA7[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ELEKTRISCHE_MASCHINE_DREHZAHL_WERT", "1/min", "high", "unsigned int", "-", "-", "0.5", "1.0", "-5000.0", "Drehzahl der E-Maschine" },
  { "STAT_ELEKTRISCHE_MASCHINE_IST_MOMENT_WERT", "Nm", "high", "int", "-", "-", "0.5", "1.0", "0.0", "IST Moment der E-Maschine" },
  { "STAT_ELEKTRISCHE_MASCHINE_SOLL_MOMENT_WERT", "Nm", "high", "int", "-", "-", "0.5", "1.0", "0.0", "SOLL Moment der E-Maschine" },
  { "STAT_ELEKTRISCHE_BETRIEBSART_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_ELEKTRISCHE_BETRIEBSART", "-", "-", "-", "aktuelle Betriebsart der E-Maschine" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEA9[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_DIAG_BIT0", "0/1", "high", "unsigned int", "0x0001", "-", "-", "-", "-", "Limitierung durch die kommandierte Leistungsgrenze: 0=nicht aktiv 1=aktiv" },
  { "STAT_DIAG_BIT1", "0/1", "high", "unsigned int", "0x0002", "-", "-", "-", "-", "Limitierung der Ausgangsleistung wegen Spannungskriterium: 0=nicht aktiv 1=aktiv" },
  { "STAT_DIAG_BIT2", "0/1", "high", "unsigned int", "0x0004", "-", "-", "-", "-", "Limitierung durch kommandierte Minimalspannung auf HV-Seite:  0=nicht aktiv 1=aktiv" },
  { "STAT_DIAG_BIT3", "0/1", "high", "unsigned int", "0x0008", "-", "-", "-", "-", "Limitierung wegen Temperaturkriterium: 0=nicht aktiv 1=aktiv" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEB0[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_PS_VERSION_MAIN_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Main-Version Parksperren-SW" },
  { "STAT_PS_VERSION_SUB_WERT", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Revision Parksperren-SW" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEB5[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_DCDC_SW_VERSION_WERT", "-", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Softwareversion des DCDC Pics" },
  { "STAT_SLE_SW_VERSION_WERT", "-", "high", "unsigned int", "-", "-", "1.0", "1.0", "0.0", "Softwareversion des SLE Pics" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEBD[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SPANNUNG_GT_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "DC/DC Gatetreiber Spannung" },
  { "STAT_SPANNUNG_LV_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "DC/DC-Spannung Niedervoltseite" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEBE[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SPANNUNG_CY0_5V0_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 5V von CY320_MC0" },
  { "STAT_SPANNUNG_CY2_5V0_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 5V von CY320_MC2" },
  { "STAT_SPANNUNG_CY0_3V3_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 3,3V von CY320_MC0" },
  { "STAT_SPANNUNG_CY2_3V3_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 3,3V von CY320_MC2" },
  { "STAT_SPANNUNG_CY0_1V5_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 1,5V von CY320_MC0" },
  { "STAT_SPANNUNG_CY2_1V5_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Spannungsüberwachung der internen 1,5V von CY320_MC2" },
  { "STAT_SPANNUNG_PWG1_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Rückmessung der Spannungsversorgung des PWG1" },
  { "STAT_SPANNUNG_PWG2_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Rückmessung der Spannungsversorgung des PWG2" },
  { "STAT_SPANNUNG_32V_WERT", "V", "high", "unsigned int", "-", "-", "0.0010", "1.0", "0.0", "Rückmessung der internen 32 V" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEBF[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SYSSTATE_DPR", "0/1", "high", "unsigned char", "-", "-", "-", "-", "-", "Dualported RAM aktiv 0 = nicht aktiv 1 = aktiv" },
  { "STAT_SYSSTATE_MC0_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_SYSSTATE_MCS", "-", "-", "-", "Systemzustand des MC0" },
  { "STAT_SYSSTATE_MC2_NR", "0-n", "high", "unsigned char", "-", "TAB_AE_SYSSTATE_MCS", "-", "-", "-", "Systemzustand des MC2" },
  { "STAT_SYSSTATE_KLX", "Bit", "high", "bitfield", "-", "BF_SYSSTATE_KLEMMEN", "-", "-", "-", "Klemmenzustand" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xDEDE[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_LADEVERFAHREN_NR", "0-n", "high", "unsigned char", "-", "TAB_LADEVERFAHREN", "-", "-", "-", "Art des Ladetyps" },
  { "STAT_LADESTATUS_NR", "0-n", "high", "unsigned char", "-", "TAB_LADESTATUS", "-", "-", "-", "Art des Ladestatus" },
  { "STAT_BEGINN_FENSTER_STD_WERT", "h", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Nur bei AC-Laden: Beginn des günstigen Ladefensters (Stunden)" },
  { "STAT_BEGINN_FENSTER_MIN_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Nur bei AC-Laden: Beginn des günstigen Ladefensters (Minuten)" },
  { "STAT_ENDE_FENSTER_STD_WERT", "h", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Nur bei AC-Laden: Ende des günstigen Ladefensters (Stunden)" },
  { "STAT_ENDE_FENSTER_MIN_WERT", "min", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Nur bei AC-Laden: Ende des günstigen Ladefensters (Minuten)" },
  { "STAT_LADEFENSTER1_AUSWAHL_NR", "0-n", "high", "unsigned char", "-", "TAB_LADEFENSTER_1", "-", "-", "-", "Nur bei AC-Laden, Zwei Zeit Wecker: Auswahl des günstigen Ladefensters" },
  { "STAT_LADEFENSTER2_AUSWAHL_NR", "0-n", "high", "unsigned char", "-", "TAB_LADEFENSTER_1", "-", "-", "-", "Nur bei AC-Laden, Zwei Zeit Wecker: Auswahl des günstigen Ladefensters" },
  { "STAT_FAKTOR_STROMBEGRENZUNG_NR", "0-n", "high", "unsigned char", "-", "TAB_FAKTOR_STROMBEGRENZUNG", "-", "-", "-", "Nur bei AC-Laden Rückmeldung der Strombegrenzung" },
  { "STAT_STROMBEGRENZUNG_AUSWAHL_NR", "0-n", "high", "unsigned char", "-", "TAB_STROMBEGRENZUNG_AUSWAHL", "-", "-", "-", "Rückmeldung der AC- Strombegrenzungauswahl Nur bei AC-Laden:" },
  { "STAT_POLY_TIM_1_WERT", "-", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte: Zeit(normiert) des ersten Stützpunktes" },
  { "STAT_POLY_SOC_1_WERT", "%", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte:  SOC des ersten Stützpunktes" },
  { "STAT_POLY_TIM_2_WERT", "-", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte: Zeit(normiert) des zweiten Stützpunktes" },
  { "STAT_POLY_SOC_2_WERT", "%", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte:  SOC des zweiten Stützpunktes" },
  { "STAT_POLY_TIM_3_WERT", "-", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte: Zeit(normiert) des dritten Stützpunktes" },
  { "STAT_POLY_SOC_3_WERT", "%", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte:  SOC des dritten Stützpunktes" },
  { "STAT_POLY_TIM_4_WERT", "-", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte: Zeit(normiert) des vierten Stützpunktes" },
  { "STAT_POLY_SOC_4_WERT", "%", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte:  SOC des fünften Stützpunktes" },
  { "STAT_POLY_TIM_5_WERT", "-", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte: Zeit(normiert) des fünften Stützpunktes" },
  { "STAT_POLY_SOC_5_WERT", "%", "high", "unsigned char", "-", "-", "0.01", "1.0", "0.0", "Rückmeldung der SOC Unterstützpunkte:  SOC des fünften Stützpunktes" },
  { "STAT_HV_SOC_IST_WERT", "%", "high", "unsigned int", "-", "-", "0.01", "1.0", "0.0", "Aktueller SOC der HV-Batterie" },
  { "STAT_LADEN_PROGNOSE_WERT", "min", "high", "unsigned char", "-", "-", "5.0", "1.0", "0.0", "Ladezeitprognose" },
  { "STAT_LADEN_SPANNUNG_WERT", "V", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "AC-Ladespannung (nur bei AC Laden)" },
  { "STAT_LADEN_STROM_WERT", "A", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "AC-Ladestrom (nur bei AC Laden)" },
  { "STAT_ENERGIEINHALT_IST_WERT", "Ws", "high", "unsigned int", "-", "-", "3600.0", "1.0", "0.0", "Prognostizierte Energieinhalt in Abhängigkeit des Ladezustands und des Bordnetzverbrauches" },
  { "STAT_LSC_TRIGGER_INHALT_NR", "0-n", "high", "unsigned char", "-", "TAB_LSC_TRIGGER_INHALT", "-", "-", "-", "Status des LSC-Triggers" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0x400C[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "SERIENNUMMER", "-", "high", "string[10]", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Seriennummer (10 Zeichen)" },
  { "JAHR", "HEX", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "JAHR in HEX-Format  Bsp.: 15.12.2011 JAHR=0x11" },
  { "MONAT", "HEX", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "MONAT in HEX-Format  Bsp.: 15.12.2011 MONAT=0x12" },
  { "TAG", "HEX", "high", "unsigned char", "-", "-", "-", "-", "-", "-", "-", "TAG in HEX-Format  Bsp.: 15.12.2011 TAG=0x15" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0x400D[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "PROZESSOR", "0-n", "high", "unsigned char", "-", "TAB_PROZESSOR", "1.0", "1.0", "0.0", "-", "-", "Prozessor auf dem die HWCALs geschrieben werden sollen" },
  { "SENSOR_BLOCK", "0-n", "high", "unsigned char", "-", "TAB_SENSOR_BLOCK_SETHWCAL", "-", "-", "-", "-", "-", "Sensor Block: 0 = nicht definiert 1 = CPU-Sensoren 2 = PCP-Sensoren 3 = PIC-SensorenA 4 = PIC-SensorenB" },
  { "SENSOR_NR", "HEX", "-", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Nummer des Sensors im ausgewählten Sensor Block: 0 = nicht definiert 1-63 = Nummer des Sensors 64 - 255  = nicht definiert" },
  { "GAIN", "HEX", "high", "unsigned long", "-", "-", "-", "-", "-", "-", "-", "Gain-Korrektur des Sensors im HEX-Format (4Byte)" },
  { "OFFSET", "HEX", "high", "unsigned long", "-", "-", "-", "-", "-", "-", "-", "Offset-Korrektur des Sensors im HEX-Format (4Byte)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0x400E[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "PROZESSOR", "0-n", "high", "unsigned char", "-", "TAB_PROZESSOR", "1.0", "1.0", "0.0", "-", "-", "Prozessor" },
  { "SENSOR_BLOCK", "0-n", "high", "unsigned char", "-", "TAB_SENSOR_BLOCK", "-", "-", "-", "-", "-", "Sensor-Block, der geschrieben werden soll 0 = Seriennummer 1 = CPU-Sensoren 2 = PCP-Sensoren 3 = PIC-SensorenA 4 = PIC-SensorenB" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0x400F[12][]={
  { "ARG", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "AKTION", "0/1", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Hardwarekalibrationsmode setzen (0/1): 0 = keine Aktion 1 = Hardwarekalibrationsmode" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xF010[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "PROZESSOR", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_PROZESSOR", "1.0", "1.0", "0.0", "-", "-", "Prozessor auf dem die HWCALs geschrieben werden sollen" },
  { "SENSOR_BLOCK", "+", "-", "0-n", "high", "unsigned char", "-", "TAB_SENSOR_BLOCK_SETHWCAL", "-", "-", "-", "-", "-", "Sensor Block: 0 = Seriennummer 1 = CPU-Sensoren 2 = PCP-Sensoren 3 = PIC-SensorenA 4 = PIC-SensorenB" },
  { "SENSOR_NR", "+", "-", "HEX", "-", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "-", "-", "Nummer des Sensors im ausgewählten Sensor Block: 0 = nicht definiert 1-63 = Nummer des Sensors 64 - 255  = nicht definiert" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table ARG_0xF011[14][]={
  { "ARG", "STR", "STPR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "MIN", "MAX", "INFO" },
  { "RESET_NR", "+", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "1.0", "64.0", "Nummer des Resets der im Flash abgespeichert wurde" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xF010[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_GAIN_WERT", "+", "-", "-", "HEX", "high", "unsigned long", "-", "-", "-", "-", "-", "Gain-Korrektur des Sensors im HEX-Format (4Byte)" },
  { "STAT_OFFSET_WERT", "+", "-", "-", "HEX", "high", "unsigned long", "-", "-", "-", "-", "-", "Offset-Korrektur des Sensors im HEX-Format (4Byte)" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xF011[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_NUMENTRY_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Nummer des angeforderten Reset Slots" },
  { "STAT_TYPE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Single Reset=1; Permanent Reset=2" },
  { "STAT_CAUSE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Resetgrund: POWERUP_RST = 0, EXT_WATCHDOG_RST=1, INT_WATCHDOG_RST=2, SOFTWARE_RST=3, EXCEPTION_RST=4, UNKNOWN_RST=5" },
  { "STAT_EXCADDR_WERT", "+", "-", "-", "HEX", "high", "unsigned long", "-", "-", "-", "-", "-", "Erweiterte Adresse" },
  { "STAT_EXCCLASS_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Erweiterte Klasse" },
  { "STAT_EXCTIN_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "excTin" },
  { "STAT_WD_ERRCTR_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Watchdog-Error-Counter" },
  { "STAT_OWN_VSMSTATE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Eigener System State" },
  { "STAT_PARTNER_VSMSTATE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Partner System State" },
  { "STAT_OWN_SYNCSTATE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Eigener Sync State" },
  { "STAT_PARTNER_SYNCSTATE_WERT", "+", "-", "-", "-", "high", "unsigned char", "-", "-", "1.0", "1.0", "0.0", "Partner Sync State" },
  { "STAT_RESETDUMP_DATA", "+", "-", "-", "DATA", "high", "data[128]", "-", "-", "1.0", "1.0", "0.0", "Hex-Dump des Resets-Slots aus dem Flash" }
};

// Das Ändern der Tabelle erfolgt im Formular  SG Funktionen
table RES_0xF050[13][]={
  { "RESULTNAME", "STR", "STPR", "RRR", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_STATUS", "-", "-", "+", "0-n", "high", "char", "-", "TAB_AKTIV", "-", "-", "-", "0=inaktiv; 1=aktiv" }
};

// WERTE
table RDBI_PC_PCS_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "ECUMehrmalsProgrammierbar" },
  { "1", "ECUMindestensEinmalVollstaendigProgrammierbar" },
  { "2", "ECUNichtMehrProgrammierbar" }
};

// WERTE
table TAB_AE_PARKSPERRE_SENSOREN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Offen" },
  { "0x01", "Geschlossen" },
  { "0x02", "In Bewegung" },
  { "0x03", "Ungültig" }
};

// WERTE
table DM_TAB_ROE_ACTIVATED_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "Aktive Fehlermeldung deaktiviert" },
  { "1", "Aktive Fehlermeldung aktiviert" }
};

// WERTE
table TAB_AE_CHARGE_ENABLE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "keine Aussage" },
  { "0x01", "wahr" },
  { "0x02", "falsch" },
  { "0x03", "ungültig" }
};

// WERTE
table TAB_AE_SLE_FEHLERZUSTAENDE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Derating" },
  { "0x01", "Ladeunterbrechung" },
  { "0x02", "Notlauf" },
  { "0x03", "Kommunikationsausfall" },
  { "0x04", "Reserviert" },
  { "0xFF", "Signal ungültig" }
};

// WERTE
table TAB_EDME_TIMER_LADEN_NR[2][]={
  { "WERT", "TEXT" },
  { "0x00", "TimerLaden nicht aktiv" },
  { "0x01", "TimerLaden on Hold" },
  { "0x02", "TimerLaden aktiv" }
};

// WERTE
table TAB_STAT_ST_DIAG_DCDC_MODUS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Antwort ausstehend" },
  { "0x01", "Erfolg" },
  { "0x02", "Fehler" }
};

// WERTE
table TAB_EDME_REMOTE_LADEN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "RemoteLaden nicht aktiv" },
  { "0x01", "RemoteLaden on Hold" },
  { "0x02", "RemoteLaden aktiv" }
};

// WERTE
table TAB_AE_PARKSPERRE_NVRAM_LOESCHEN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "kein Löschen" },
  { "0x01", "Löschen des NV-Ram (Parksperre)" }
};

// WERTE
table TAB_AE_PARKSPERRE_EINLERNEN_STATUS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Parksperre nicht eingelernt" },
  { "0x01", "Parksperre eingelernt" }
};

// WERTE
table ENERGIESPARMODE_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "Normalmode" },
  { "1", "Fertigungsmode" },
  { "2", "Transportmode" },
  { "3", "Flashmode" }
};

// WERTE
table TAB_AE_SLE_BETRIEBSMODE[2][]={
  { "WERT", "TEXT" },
  { "0x01", "Standby" },
  { "0x02", "HV-DC Laden" },
  { "0x03", "Reserviert" },
  { "0x0F", "Signal ungültig" }
};

// WERTE
table TAB_LSC_TRIGGER_INHALT[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kein Trigger für TS-Dienst  Last State Call " },
  { "0x01", "Laden ist aufgestartet (Ladeparameter liegen vor)" },
  { "0x02", "Toleranz für Abweicheung zwischen dem prognostizerten und dem Ist-Ladezustand des HV-Speichers überschritten" },
  { "0x03", "Temporäre Aufhebung des Teilnetzbetriebs" },
  { "0x04", "Aufladung des Hochvoltspeichers abgeschlossen (Ladeziel erreicht oder Kunde hat beendet)" },
  { "0x05", "Laden abgebrochen" },
  { "0x06", "Laden für Ladepause unterbrochen" },
  { "0x07", "Zyklisches Nachladen wegen Energiemangel nicht möglich" },
  { "0x08", "Zyklisches Nachladen nicht möglich" },
  { "0x0D", "Signal nicht verfügbar möglich" },
  { "0x0E", "Fehler" },
  { "0x0F", "Signal nicht verfügbar" }
};

// ARG
table TAB_AE_DREHZAHL_KLASSE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "0-2000 U/min" },
  { "0x01", "2000-4000 U/min" },
  { "0x02", "4000-6000 U/min" },
  { "0x03", "6000-8000 U/min" },
  { "0x04", "8000-10000 U/min" },
  { "0x05", "10000-12000 U/min" },
  { "0x06", "12000-14000 U/min" }
};

// WERTE
table TAB_ST_B_DIAG_DCDC[2][]={
  { "WERT", "TEXT" },
  { "0x02", "I_diag_dcdc_lv_out verwenden" },
  { "0x04", "I_diag_dcdc_hv_out verwenden" },
  { "0x08", "U_diag_dcdc_lv_out verwenden" },
  { "0x10", "U_diag_dcdc_hv_out verwenden" }
};

// WERTE
table TAB_STAT_ST_DIAG_DCDC_GRENZEN[2][]={
  { "WERT", "TEXT" },
  { "0x01", "erfolgreich" },
  { "0x02", "nicht erfolgreich: mindestens eine geforderte Grenze verletzt eine Systemgrenze, stattdessen wird diese Systemgrenze verwendet." }
};

// WERTE
table TAB_STAT_AKS_ANFORDERUNG[2][]={
  { "WERT", "TEXT" },
  { "0x00", "kein AKS" },
  { "0x01", "AKS" },
  { "0x02", "Fehler" }
};

// WERTE
table TAB_LADEVERFAHREN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kein Ladeverfahren" },
  { "0x01", "AC-Laden mit Steckertyp 1 (Yazaki)" },
  { "0x02", "AC-Laden mit Steckertyp 2 (Mennekes)" },
  { "0x03", "DC-Laden mit CHAdeMo-Protokoll" },
  { "0x04", "DC-Laden mit SAE-Protokoll" },
  { "0x05", "AC-Laden China" },
  { "0xFD", "Signal nicht verfügbar" },
  { "0xFE", "Fehler" },
  { "0xFF", "Signal ungültig" }
};

// WERTE
table TAB_AE_ELUP_ROHSIGNALE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Nicht definiert" },
  { "0x01", "Ausschalten" },
  { "0x02", "Einschalten" }
};

// WERTE
table TAB_AE_PARKSPERRE_POSTION[2][]={
  { "WERT", "TEXT" },
  { "0x00", "offen" },
  { "0x01", "geschlossen" },
  { "0x02", "nicht definiert" }
};

// WERTE
table SVK_VERSION_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "reserved" },
  { "1", "SVKVersion_01" }
};

// BITFIELD
table BF_SYSSTATE_KLEMMEN[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_SYSSTATE_KL153_0", "0/1", "high", "unsigned char", "0x01", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit0 = Kl15_3" },
  { "STAT_SYSSTATE_KL15WUP_1", "0/1", "high", "unsigned char", "0x02", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit1 = Kl15WUP" },
  { "STAT_SYSSTATE_KL30B_2", "0/1", "high", "unsigned char", "0x04", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit2 = KL30B" },
  { "STAT_SYSSTATE_KL30C_3", "0/1", "high", "unsigned char", "0x08", "-", "-", "-", "-", "Klemmenzustand (bitcodiert): Bit3 = KL30C" }
};

// WERTE
table RDBI_ADS_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "ISOSAEReserved_00" },
  { "1", "defaultSession" },
  { "2", "programmingSession" },
  { "3", "extendedDiagnosticSession" },
  { "4", "safetySystemDiagnosticSession" },
  { "64", "vehicleManufacturerSpecific_40" },
  { "65", "codingSession" },
  { "66", "SWTSession" }
};

// WERTE
table TAB_AE_PARKSPERRE_MAGNET_STEUERN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kein Einschalten" },
  { "0x01", "Einschalten des Parksperren-Magneten" }
};

// WERTE
table PROG_DEP_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "reserved" },
  { "1", "correctResult" },
  { "2", "incorrectResult" },
  { "3", "incorrectResult error SWE - HWE" },
  { "4", "incorrectResult error SWE - SWE" },
  { "255", "reserved" }
};

// WERTE
table TAB_SENSOR_BLOCK[2][]={
  { "WERT", "TEXT" },
  { "0x0", "Seriennummer" },
  { "0x1", "CPU-Sensoren" },
  { "0x2", "PCP-Sensoren" },
  { "0x3", "PIC-SensorenA" },
  { "0x4", "PIC-SensorenB" },
  { "0xff", "nicht definiert" }
};

// WERTE
table TAB_EME_IST_BETRIEBSART_DCDC[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Standby" },
  { "0x01", "Buck" }
};

// WERTE
table TAB_EME_I0ANF_HVB[2][]={
  { "WERT", "TEXT" },
  { "0x00", "keine Anforderung" },
  { "0x01", "Anforderung Nullstrom ohne EV: HV-Batteriefehler der Kategorie 5 oder geringe Ladeleistung" },
  { "0x02", "Anforderung Nullstrom mit EV: Entladeschutzfunktion HV-Batterie" },
  { "0x03", "Anforderung Nullstrom mit EV: HV-Power-Down" },
  { "0x04", "Anforderung Nullstrom mit EV: Batterieloser Betrieb" }
};

// WERTE
table TAB_STROMBEGRENZUNG_AUSWAHL[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Nicht ausgewählt" },
  { "0x01", "Ausgewählt" },
  { "0x03", "Ungültig" }
};

// WERTE
table TAB_AKTIV[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Inaktiv" },
  { "0x01", "Aktiv" },
  { "0xFF", "unbekannt" }
};

// WERTE
table TAB_AE_FAHRSTUFE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Initialisierung" },
  { "0x01", "ungültig" },
  { "0x02", "ungültig" },
  { "0x03", "ungültig" },
  { "0x04", "ungültig" },
  { "0x05", "D" },
  { "0x06", "N" },
  { "0x07", "R" },
  { "0x08", "P" },
  { "0x0F", "ungültig" }
};

// WERTE
table TAB_AE_PARKSPERRE_ZUSTAND[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Einlernvorgang abgeschlossen und OK" },
  { "0x01", "Einlernvorgang abgeschlossen und NOK" },
  { "0x02", "Einlernvorgang aktiv" }
};

// BITFIELD
table BF_AE_ROTORLAGESENSOR_ERROR[10][]={
  { "RESULTNAME", "EINHEIT", "L/H", "DATENTYP", "MASKE", "NAME", "MUL", "DIV", "ADD", "INFO" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_0", "0/1", "high", "unsigned int", "0x0001", "-", "-", "-", "-", "Status Code: Bit 0: Abgleich erfolgreich beendet  0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_1", "0/1", "high", "unsigned int", "0x0002", "-", "-", "-", "-", "Status Code: Bit 1: Abgleich ungültig beendet 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_2", "0/1", "high", "unsigned int", "0x0004", "-", "-", "-", "-", "Status Code: Bit 2: Beschleunigungsphase aktiv 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_3", "0/1", "high", "unsigned int", "0x0008", "-", "-", "-", "-", "Status Code: Bit 3: Abgleichsphase aktiv 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_4", "0/1", "high", "unsigned int", "0x0010", "-", "-", "-", "-", "Error Code: Bit 4: Beschleunigungszeit zu hoch 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_5", "0/1", "high", "unsigned int", "0x0020", "-", "-", "-", "-", "Error Code: Bit 5: Auslaufzeit zu gering 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_6", "0/1", "high", "unsigned int", "0x0040", "-", "-", "-", "-", "Error Code: Bit 6: Ermittelter Offsetwert ungültig 0=nicht aktiv 1=aktiv" },
  { "STAT_ROTORLAGESENSOR_STATUS_ERROR_7", "0/1", "high", "unsigned int", "0x0080", "-", "-", "-", "-", "Error Code: Bit 7: Nullstromabweichung in Abgleichphase 0=nicht aktiv 1=aktiv" }
};

// WERTE
table TAB_AE_ELEKTRISCHE_BETRIEBSART[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Standby (AKS)" },
  { "0x01", "Drehmomentenregelung" },
  { "0x0C", "sicherer Zustand / Fehler (AKS)" },
  { "0x0D", "Initialisierung" },
  { "0x0E", "Zwischenkreisvorladung" }
};

// WERTE
table TAB_AE_PARKSPERREN_SW[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Keine Fehler" },
  { "0x01", "Fehler steht an!" }
};

// WERTE
table TAB_AE_PARKSPERRE[2][]={
  { "WERT", "TEXT" },
  { "0x00", "keine Aktion" },
  { "0x01", "Einlegen der Parksperre" },
  { "0x02", "Auslegen der Parksperre" }
};

// WERTE
table TAB_LADEFENSTER_1[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Nicht ausgewählt" },
  { "0x01", "Ausgewählt" },
  { "0x03", "Nicht gültig" }
};

// WERTE
table TAB_STAT_HVIL_GESAMT_NR[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Interlock nicht unterbrochen" },
  { "0x01", "Interlock unterbrochen" },
  { "0xFF", "nicht definiert" }
};

// ARG
table TAB_AE_DCDC_HISTOGRAMM[2][]={
  { "WERT", "TEXT" },
  { "0x00", "PHistoF" },
  { "0x01", "PHistoL" },
  { "0x02", "T1HistoF" },
  { "0x03", "T1HistoL" },
  { "0x04", "T2HistoF" },
  { "0x05", "T2HistoL" },
  { "0x06", "T3HistoF" },
  { "0x07", "T3HistoL" },
  { "0x08", "T4HistoF" },
  { "0x09", "T4HistoL" },
  { "0x0A", "rUtil" },
  { "0x0B", "rUtilF" }
};

// WERTE
table TAB_ST_DIAG_DCDC_ANF[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kontrolle an EME-SW" },
  { "0x01", "Anforderung Buck-Modus" },
  { "0x03", "Anforderung Standby-Modus" }
};

// WERTE
table TAB_AE_EWP_STATUS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Inaktiv (Grundzustand nach Initialisierung oder EWP ausgeschaltet)" },
  { "0x01", "Aktiv - OK" },
  { "0x02", "Aktiv - Trockenlauf" },
  { "0x03", "Aktiv - blockiert" },
  { "0x04", "Aktiv - Übertemperatur" },
  { "0x05", "Aktiv - minimale Drehzahl" },
  { "0x06", "Elektrischer Fehler oder Kommunikationsfehler am Leistungs - ASIC" },
  { "0x07", "Elektrischer Fehler Kurzschluss auf Masse" }
};

// WERTE
table TAB_EME_HVSTART_KOMM[2][]={
  { "WERT", "TEXT" },
  { "0x00", "HV aus" },
  { "0x01", "HV ein Anforderung" },
  { "0x02", "Freigabe HV" },
  { "0x03", "HV-Batterie Nullstromanforderung" },
  { "0x04", "HV Nachlauf 1" },
  { "0x05", "HV Nachlauf 2" },
  { "0x06", "Shutdown: Anforderung Schütze öffnen" },
  { "0x07", "Shutdown: Anforderung HV-Zwischenkreisentladung" },
  { "0x09", "Anforderung Batterieloser Betrieb" },
  { "0x0A", "HV Batterieloser Betrieb: Anforderung Schütze öffnen" },
  { "0x0B", "HV Batterieloser Betrieb aktiv" },
  { "0x0C", "fehlerbedingter Shutdown: Rücknahme Freigabe HV" },
  { "0x0D", "fehlerbedingter Shutdown: Anforderung Schütze öffnen" },
  { "0x0E", "fehlerbedingter Shutdown: Anforderung HV-Zwischenkreisentladung" },
  { "0x0F", "HV Störung" },
  { "0x10", "Initialisierung / ungültig" }
};

// WERTE
table FEHLERKLASSE_DOP[2][]={
  { "WERT", "TEXT" },
  { "0", "Keine Fehlerklasse verfuegbar" },
  { "1", "Ueberpruefung beim naechsten Werkstattbesuch" },
  { "2", "Ueberpruefung beim naechsten Halt" },
  { "4", "Ueberpruefung sofort erforderlich" }
};

// WERTE
table TAB_PROZESSOR[2][]={
  { "WERT", "TEXT" },
  { "0x0", "undefiniert" },
  { "0x1", "mc0" },
  { "0x2", "mc2" }
};

// WERTE
table TAB_EME_KOMM_BETRIEBSART_DCDC[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Anforderung Standby" },
  { "0x01", "Anforderung Buck" }
};

// WERTE
table TAB_LADESTATUS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kein Laden" },
  { "0x01", "Initialisierung" },
  { "0x02", "Laden aktiv" },
  { "0x03", "Ladepulse" },
  { "0x04", "Laden beendet" },
  { "0x05", "Ladefehler" },
  { "0x0F", "Signal ungültig" }
};

// WERTE
table TAB_AE_SYSSTATE_MCS[2][]={
  { "WERT", "TEXT" },
  { "0x00", "eINITIALIZATION" },
  { "0x01", "ePREDRIVE" },
  { "0x02", "eREADY" },
  { "0x03", "eWAITSLEEPACKNOWLEDGE" },
  { "0x04", "eFUNCTIONPOSTDRIVE" }
};

// WERTE
table TAB_AE_ROTORLAGESENSOR_ANLEREN_AKTION[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Auto RLS-Anlernen" },
  { "0x01", "Hochdrehen/Freilauf" }
};

// WERTE
table TAB_SENSOR_BLOCK_SETHWCAL[2][]={
  { "WERT", "TEXT" },
  { "0x0", "nicht definiert" },
  { "0x1", "CPU-Sensoren" },
  { "0x2", "PCP-Sensoren" },
  { "0x3", "PIC-SensorenA" },
  { "0x4", "PIC-SensorenB" },
  { "0xff", "nicht definiert" }
};

// WERTE
table TAB_AE_ELUP_STEUERN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Keine Aktion!" },
  { "0x01", "ELUP ansteuern" }
};

// WERTE
table TAB_EDME_STATUS_LADEN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "kein Laden" },
  { "0x01", "Ladestecker gesteckt - kein Laden" },
  { "0x02", "Laden aktiv" },
  { "0x03", "Laden beendet" },
  { "0x04", "Ladestörung" },
  { "0x05", "Ladefehler" }
};

// WERTE
table TAB_AE_PARKSPERRE_EINLERNEN_STEUERN[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Kein Anlernen" },
  { "0x01", "Anlernen der Parksperre" }
};

// WERTE
table TAB_AE_ZST_AKTIV_NAKTIV[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Nicht aktiv" },
  { "0x01", "Aktiv" }
};

// WERTE
table TAB_AE_ROHSIGNAL_ZUSTAND[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Nicht aktiv" },
  { "0x01", "Aktiv" }
};

// WERTE
table TAB_FAKTOR_STROMBEGRENZUNG[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Maximales Laden mit vollem AC Ladestrom." },
  { "0x01", "Reduziertes Laden mit reduziertem AC Ladestrom." },
  { "0x02", "Minimales Laden mit minimalen AC Ladestrom." },
  { "0xFF", "Signal ungültig" }
};

// WERTE
table TAB_AE_RESET_STROM_MAX[2][]={
  { "WERT", "TEXT" },
  { "0x00", "Keine Aktion." },
  { "0x01", "Alle maximale Ströme zurücksetzen." },
  { "0x02", "Strom zum eKMV zurücksetzen." },
  { "0x03", "Strom zum EDH zurücksetzen." },
  { "0x04", "Strom zur E-Maschine zurücksetzen." },
  { "0x05", "Maximalen Strom zur SLE zurücksetzen." },
  { "0x06", "Maximalen Strom zum DC/DC Wandler zurücksetzen." }
};


// start of : #include "MONTAGEMODUS_TAB.b2s"
/*********************** E:\MONTAGEMODUS_TAB2.b2s ******************************
// Ersteller: qx35475
// Datum der Erstellung: 27.05.10 13:42
// SGBD-Generator Version: 5.5.0_b10
*/

// -
table TAB_AE_FUNKSTAT_MONTAGEMODUS[2][]={
                                            { "WERT", "TEXT" },
                                            { "0x00", "Funktion noch nicht gestartet" },
                                            { "0x01", "Start-/Ansteuerbedingung nicht erfuellt" },
                                            { "0x02", "Uebergabeparameter nicht plausibel" },
                                            { "0x03", "Funktion wartet auf Freigabe" },
                                            { "0x04", "nicht verfuegbarer Wert" },
                                            { "0x05", "Funktion laeuft" },
                                            { "0x06", "Funktion beendet (ohne Ergebnis)" },
                                            { "0x07", "Funktion abgebrochen (kein Zyklusflag/Readiness gesetzt)" },
                                            { "0x08", "Funktion vollständig durchlaufen (Zyklusflag/Readiness gesetzt) und kein Fehler erkannt" },
                                            { "0x09", "Funktion vollständig durchlaufen (Zyklusflag/Readiness gesetzt) und Fehler erkannt" },
                                            { "0xFE", "nicht definiert" },
                                            { "0xFF", "ungueltiger Wert" }
                                        };

// -
table TAB_AE_STAT_MONTAGEMODUS[2][]={
                                        { "WERT", "TEXT" },
                                        { "0x00", "Montage-Modus ist inaktiv" },
                                        { "0x01", "Montage-Modus ist aktiv" },
                                        { "0xFE", "nicht definiert" },
                                        { "0xFF", "ungueltiger Wert" }
                                    };



// end of : #include "MONTAGEMODUS_TAB.b2s"

// start of : #include "STATUS_EWS_TAB.b2s"
// *******************************************************************
//
// -------------------------------------------------------------------
// Tabelle: Zuordnung 'Statusbyte <-> Statustext'
// -------------------------------------------------------------------
// Gültig:
// Lastenheft EWS4_Funktionsbeschreibung (SAP 10001217)
// -------------------------------------------------------------------
// History:
// 09.07.2006 Schl V0.001 Erstellung fuer UDS
// 01.07.2008 Schl V1.000 Text Zündung, Einspritzung, Motorlauf entfernt
// 06.03.2011 Schl V1.001 Tabelle StatEwsVerTxt ergänzt
// *******************************************************************
// 
// *******************************************************************
#define INCLUDE_UDS_TAB_DMEEWSTXT_B2S_NOT_FOUND

table StatClientAuthTxt[2][]={
  { "SB", "TEXT" },
  { "0x00", "Freigabe (noch) nicht erteilt (noch nicht versucht oder Kommunikation gestört)" },
  { "0x01", "Freigabe erteilt (Challenge-Response erfolgreich)" },
  { "0x02", "Freigabe abgelehnt (Challenge-Response fehlgeschlagen, falsche Response, Kommunikation i.O.)" },
  { "0x03", "nicht definiert" }
};

table StatFreeSkTxt[2][]={
  { "SB", "TEXT" },
  { "0xFE", "Ablage unbegrenzt" },
  { "0xFF", "ungültig" },
  { "0xXY", "freie Ablagen" }
};

table StatEwsVerTxt[2][]={
  { "SB", "TEXT" },
  { "0x01", "Direktschreiben des SecretKey" },
  { "0x02", "Direktschreiben des SecretKey und DH-Abgleich" },
  { "0x03", "DH-Abgleich" },
  { "0x11", "Direktschreiben des SecretKey und EWS5" },
  { "0x12", "Direktschreiben des SecretKey und EWS5 und DH-Abgleich" },
  { "0xXY", "unbekannt" }
};

// end of : #include "STATUS_EWS_TAB.b2s"

// *******************************************************************
// Includes für Jobs
// *******************************************************************

// Standard Diagnose-Jobs
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_PACKAGE.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Die Include-Paket-Nummer ist im INFO-Job mit Result PACKAGE lesbar.
// -------------------------------------------------------------------
// History:
// 14.03.2005  gh  V0.01 Erstellung
//                       Datei UDS_INIT.B2S
//                         Job INITIALISIERUNG
//                       Datei UDS_INFO.B2S
//                         Job INFO
//                       Datei UDS_22_IDENT.B2S
//                         Job IDENT
//                       Datei UDS_19_02.B2S
//                         Job FS_LESEN
//                       Datei UDS_19_04_06.B2S  ?
//                         Job FS_LESEN_DETAIL   ?
//                       Datei UDS_14.B2S
//                         Job FS_LOESCHEN
//                       Datei UDS_22_1000.B2S
//                         Job PRUEFSTEMPEL_LESEN
//                       Datei UDS_2E_1000.B2S
//                         Job PRUEFSTEMPEL_SCHREIBEN
// 18.04.2005  gh  V0.02 Datei UDS_22_IDENT.B2S
//                         Job IDENT_VORAB => IDENT
// 28.07.2005  gh  V0.03 alle Dateien
//                         Namensänderung auf mehr als 8 Zeichen
//                       Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                         neu dazu
// 18.11.2005  gr  V0.04 alle Dateien
//                         Umstellung auf send_and_receive_uds
// 28.11.2005  rd  V0.05 Datei UDS_CONSTANTS.B2S
//                       Datei UDS_PARAMETER.B2S
//                         neu dazu
// 02.02.2006  gr  V0.06 Datei UDS_TAB_FKLASSE.B2S
//                         Entfall (aufgrund Entfall SeverityByte)
//                       Datei UDS_TAB_DIGITAL_ARGUMENT.B2S
//                         Entfall (keine Aenderung zu STD_DIGI)
//                       Dateien UDS_85_02_FS_SPERREN.B2S, UDS_10_DIAG_MODE.B2S, UDS_3E_DIAG_AUFRECHT.B2S
//                         Anpassungen fuer STD_DIGI
//                       Dateien UDS_19_02_FS_LESEN.B2S, UDS_19_04_06_FS_LESEN_DETAIL.B2S, UDS_TAB_FART.B2S
//                               UDS_TAB_IART.B2S
//                         Anpassungen an DTCStatusMask 0x0C
//                       Dateien UDS_31_01_0F_0C_ENERGIESPARMODE.B2S, UDS_31_01_10_03_STEUERN_BETRIEBSMODE.B2S
//                               UDS_31_01_0F_06_IS_LOESCHEN.B2S, UDS_14_FS_LOESCHEN.B2S
//                         Fehlerkorrekturen
//                       Dateien UDS_19_02_FS_LESEN.B2S, UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                         Anpassungen an DTCStatusMask 0x0C
//                       Datei UDS_TAB_SVK_ID.B2S
//                         Erweiterung Tabelle
// 02.02.2006  gh  V0.06 Datei UDS_10_DIAGNOSE_MODE.B2S
//                       Datei UDS_11_STEUERGERAETE_RESET.B2S
//                       Datei UDS_22_10_00_PRUEFSTEMPEL_LESEN.B2S
//                       Datei UDS_22_16_00_SENSOREN_ANZAHL_LESEN.B2S
//                       Datei UDS_22_16_XX_SENSOREN_IDENT_LESEN.B2S
//                       Datei UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S
//                       Datei UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S
//                       Datei UDS_2E_10_00_PRUEFSTEMPEL_SCHREIBEN.B2S
//                       Datei UDS_3E_DIAGNOSE_AUFRECHT.B2S
//                       Datei UDS_INITIALISIERUNG.B2S
//                       Datei STANDARD.UDS
//                          Include-Name geändert (wie Job-Name)
//                       Datei UDS_TAB_DiagMode.B2S
//                       Datei UDS_TAB_DTCExtendedDataRecordNumber.B2S
//                       Datei UDS_TAB_DTCSnapshotIdentifier.B2S
//                       Datei UDS_TAB_FArtTexte.B2S
//                       Datei UDS_TAB_IArtTexte.B2S
//                       Datei UDS_TAB_Lieferanten.B2S
//                       Datei UDS_TAB_Prozessklassen.B2S
//                       Datei TABELLEN.UDS
//                       Datei UDS_10_DIAGNOSE_MODE.B2S
//                       Datei UDS_19_02_FS_LESEN.B2S
//                       Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN.B2S
//                       Datei UDS_22_F1_01_SVK_LESEN.B2S
//                       Datei UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S
//                         Include-Name geändert (wie Tabellen-Name)
// 17.02.2006  gh  V0.07 Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                       Datei UDS_FS_DetailStruktur.B2S (Sub-Include)
//                       Datei UDS_FS_Ort_Art.B2S        (Sub-Include)
//                       Datei UDS_FS_Extended_Data.B2S  (Sub-Include)
//                       Datei UDS_FS_Snapshot.B2S       (Sub-Include)
//                         IS_LESEN_DETAIL: neu dazu
//                         FS/IS_LESEN_DETAIL: Sub-Includes abgespalten
// 20.02.2006  gh  V0.08 Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                       Datei UDS_FS_Extended_Data.B2S  (Sub-Include)
//                       Datei UDS_FS_Snapshot.B2S       (Sub-Include)
//                         Anzahl der Ergebnissätze wie bei KWP2000
//                         F_UW_ZEIT_DATUM => F_UW_DATUM_ZEIT
// 22.02.2006  gh  V0.09 Datei UDS_TAB_DiagMode.B2S
//                         Korrektur: 0x03 = ECUExtendedDiagnosticSession
// 23.02.2006  gh  V0.10 Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                       Datei UDS_FS_Snapshot.B2S       (Sub-Include)
//                         Integration Sub-Tabellen "Tab_<Index>"
// 24.02.2006  gh  V0.11 Datei CODIER.UDS
//                         neu angelegt (wegen CPS_LESEN)
//                       Datei STANDARD.UDS
//                         Jobs DIAGNOSE_AUFRECHT und STATUS_BLOCK_LESEN entfernt
// 24.03.2006  gh  V0.12 Datei UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S
//                         Interpretation geändert von ASCII nach HEX
//                       Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                       Datei UDS_FS_Ort_Art.B2S
//                         Zuweisung Result F_HEX_CODE erweitert
//                       Datei UDS_FS_Snapshot.B2S
//                         Zuweisung Result F_UW_DATUM_ZEIT präzisiert
//                         Schaltjahrberechnung korrigiert
// 27.03.2006  gh  V0.13 Datei UDS_FS_Snapshot.B2S
//                         diskrete UW: F_UWi_WERT jetzt real
//                         Format bei F_UW_DATUM_ZEIT optimiert
//                       Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                         Abbruch, wenn zu wenig Daten in SG-Antwort
// 28.03.2006  gh        Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                         Abbruch, wenn Anzahl der Daten in SG-Antwort falsch
// 29.03.2006  gh        Datei UDS_FS_Snapshot.B2S
//                         Trace-Meldungen bzgl. return_with_message optimiert
// 30.03.2006  gh        Datei UDS_22_F1_01_SVK_LESEN.B2S
//                         PROZESSKLASSE_WERT und VERSION: Berechnung korrigiert
// 31.05.2006  rd  V0.14 Datei UDS_22_STATUS_LESEN.B2S
//                         überarbeitet
//                       Datei UDS_2E_STEUERN.B2S
//                         überarbeitet
//                       Datei UDS_2F_STEUERN_IO.B2S
//                         neu
//                       Datei UDS_31_STEUERN_ROUTINE.B2S
//                         neu
//                       UDS_TAB_JOBRESULT.B2S
//                         überarbeitet
// 12.06.2006  rd  V0.15 Datei UDS_22_STATUS_LESEN.B2S
//                         Datentyp integer und BITFIELD dazu
//                       Datei UDS_2E_STEUERN.B2S
//                         Datentyp integer dazu
//                       Datei UDS_2F_STEUERN_IO.B2S
//                         Datentyp integer dazu
//                       Datei UDS_31_STEUERN_ROUTINE.B2S
//                         Datentyp integer dazu
// 21.06.2006  rd  V0.16 Datei UDS_2C_STATUS_BLOCK_LESEN.B2S
//                         neu
//                       Datei UDS_22_STATUS_LESEN.B2S
//                         Fehlermeldung bei string überarbeitet
//                         Serviceüberprüfung dazu aber noch nicht aktiviert
//                       Datei UDS_2F_STEUERN_IO.B2S
//                         Fehlermeldung bei string überarbeitet
//                         Serviceüberprüfung dazu aber noch nicht aktiviert
//                       Datei UDS_31_STEUERN_ROUTINE.B2S
//                         Fehlermeldung bei string überarbeitet
//                         Serviceüberprüfung dazu aber noch nicht aktiviert
//                         Unterschiedliche Result- und Argumentauswertung
//                         für STR, STPR, RRR
//                       Datei UDS_2E_STEUERN.B2S
//                         Serviceüberprüfung dazu aber noch nicht aktiviert
//                       UDS_TAB_JOBRESULT.B2S
//                         Erweiterung für Standard-Job STATUS_BLOCK_LESEN
// 27.06.2006  rd  V0.17 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferantentext 0x77 bis 0x80 neu hinzu
// 28.06.2006  gh  V0.18 Datei STANDARD.UDS
//                         Includes STEUERN_IO und STEUERN_ROUTINE entfernt
//                       Datei TABELLEN.UDS
//                         UDS_TAB_Fehlerklasse hinzu
//                       Datei UDS_19_02_FS_LESEN.B2S
//                         Angleichung der Auswertung an Job IS_LESEN
//                       Datei UDS_22_20_00_IS_LESEN.B2S
//                         Angleichung der Auswertung an Job FS_LESEN
//                       Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                         Integration Severity-Byte
//                         Result "F_UW_DATUM_ZEIT" entfernt
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                         Integration Severity-Byte
//                         Result "F_UW_DATUM_ZEIT" entfernt
//                       Datei UDS_FS_DetailStruktur.B2S
//                         Integration Flag "severity_exist"
//                       Datei UDS_FS_Snapshot.B2S
//                         Zuweisung Result "F_UW_DATUM_ZEIT" auskommentiert
//                       Datei UDS_TAB_Fehlerklasse.B2S
//                         neu
//                       Datei UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S
//                         Anpassung an LH SAP 10000970
//                       Datei UDS_TAB_DiagMode.B2S
//                         Integration weiterer Diagnose-Modi
// 29.06.2006  gh  V0.19 Datei UDS_FS_DetailStruktur.B2S
//                         Fehlerbehandlung Flags
// 08.08.2006  rd  V0.20 Datei UDS_CONSTANTS.UDS
//                         REPAET_COUNTER von 2 auf 1 reduziert
//                         wegen Einsatz parallele Diagnose am D-CAN
//                       Datei UDS_PARAMETER.B2S
//                         BMW-KWP2000-CAN Timeout und TP-Layer angepasst
// 14.09.2006  rd  V0.21 Datei UDS_TAB_LIEFERANTEN.B2S
//                         Lieferanten 0x81 und 0x84 dazu
// 18.09.2006  gh  V0.22 Datei STANDARD.UDS
//                         Job SERIENNUMMER_LESEN dazu
// 15.11.2006  gh  V0.23 Datei UDS_19_04_06_FS_LESEN_DETAIL.B2S
//                         Sonderfall Fehler nicht in SG gespeichert
//                         Anzahl UWB-Sätze einstellbar
//                         komplexe UWB: Ausgabe als Text (string)
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                         Anpassungen wegen Erweiterung FS_LESEN_DETAIL
//                       Datei UDS_FS_DetailStruktur.B2S
//                         Anzahl UWB-Sätze einstellbar
//                       Datei UDS_FS_Snapshot.B2S
//                         komplexe UWB: Ausgabe als Text (string)
// 04.12.2006  gh  V0.24 Datei UDS_TAB_ROE_AKTIV.B2S
//                         neu dazu (Tabelle bzgl. Response On Event)
//                       Datei UDS_JOBS_ROE.B2S
//                         neu dazu (Sanmmelinclude: 5 Jobs bzgl. Response On Event)
//                       Datei UDS_86_00_02_STEUERN_ROE_STOP.B2S
//                         neu dazu (optionaler Jobs bzgl. Response On Event)
//                       Datei UDS_86_04_STATUS_ROE_REPORT.B2S
//                         neu dazu (optionaler Jobs bzgl. Response On Event)
//                       Datei UDS_86_05_02_STEUERN_ROE_START.B2S
//                         neu dazu (optionaler Jobs bzgl. Response On Event)
//                       Datei UDS_86_40_02_STEUERN_ROE_PERSISTENT_STOP.B2S
//                         neu dazu (optionaler Jobs bzgl. Response On Event)
//                       Datei UDS_86_45_02_STEUERN_ROE_PERSISTENT_START.B2S
//                         neu dazu (optionaler Jobs bzgl. Response On Event)
// 23.03.2007  gh  V0.25 Datei UDS_22_16_XX_SENSOREN_IDENT_LESEN.B2S
//                         Verbauort mit SG-Adresse verknüpft
//                         Auswertung optionaler LIN-Daten hinzu
//                       Datei UDS_22_F1_86_DIAG_SESSION_LESEN.B2S
//                         Anforderung W 2.4, Richard Kolbeck (fuer LDM)
//                       Datei UDS_22_25_02_PROG_ZAEHLER_LESEN.B2S
//                         Anforderung W 2.4, Richard Kolbeck (fuer LDM)
//                       Datei UDS_22_25_03_PROG_MAX_LESEN.B2S
//                         Anforderung W 2.4, Richard Kolbeck (fuer LDM)
//                       Datei UDS_22_25_04_FLASH_TP_LESEN.B2S
//                         Anforderung W 2.4, Richard Kolbeck (fuer LDM)
//                       Datei UDS_31_01_FF_01_PROG_ABHAENGIGKEITEN_LESEN.B2S
//                         Anforderung W 2.4, Richard Kolbeck (fuer LDM)
//                       Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten 0x85 bis 0x96 neu dazu
//                         Lieferant   0x72 Rechtschreibfehler behoben
//                       Datei UDS_22_37_FE_CPS_LESEN.B2S
//                         BEST-Befehl dataclear integriert
//                       Datei UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S
//                         Service $F18A jetzt optional
//                       Datei UDS_22_20_00_IS_LESEN_DETAIL.B2S
//                         Sonderfall "anzahl_snapshotRecord = 0" ohne Error "Division by Zero"
//                       Datei UDS_TAB_Prozessklassen.B2S
//                         Prozessklassen geändert (teilweise INKOMPATIBEL !!!)
// 28.03.2007  gh  V0.26 Datei UDS_31_01_FF_01_PROG_ABHAENGIGKEITEN_LESEN.B2S
//                         entfernt, da Job nur in ProgrammingSession möglich
//                       Datei UDS_22_F1_01_SVK_LESEN.B2S
//                         Result (int) PROG_TEST dazu
//                       Datei UDS_22_STATUS_LESEN.B2S
//                         Serviceüberprüfung aktiv
//                         Resultname beginnend mit _STAT_ jetzt erlaubt
//                       Datei UDS_2C_STATUS_BLOCK_LESEN.B2S
//                         Serviceüberprüfung aktiv
//                         Resultname beginnend mit _STAT_ jetzt erlaubt
//                       Datei UDS_2E_STEUERN.B2S
//                         Serviceüberprüfung aktiv
//                       Datei UDS_2F_STEUERN_IO.B2S
//                         Serviceüberprüfung aktiv
//                         Resultname beginnend mit _STAT_ jetzt erlaubt
//                       Datei UDS_31_STEUERN_ROUTINE.B2S
//                         Serviceüberprüfung aktiv
//                         Resultname beginnend mit _STAT_ jetzt erlaubt
// 02.05.2007  gh  V0.27 Datei UDS_22_25_04_FLASH_TP_LESEN.B2S
//                         Reihenfolge bei 18-Byte-Antwort korrigiert
//                       Datei CBS5JOBS.B2S
//                         Korrektur von Stefan Jurthe, EF620 (Job CBS_RESET)
// 30.10.2007  gr  V0.28 Datei UDS_19_02_FS_LESEN.B2S angepasst
// 22.11.2007  rd  V0.29 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten 0x9A bis 0x9E neu dazu
// 20.02.2008  rd  V1.00 Datei STD_ISEN.B2S
//                         Spurwechselradarsensor Lin 2 Format
// 25.02.2008  rd  V1.01 Datei STD_ISEN.B2S
//                         PMA Sensoren hinzu
// 07.03.2008  rd  V1.02 Datei STD_ISEN.B2S
//                         Startergenerator, Ölqualitätsensor hinzu
// 17.03.2008  rd  V1.03 Datei STD_ISEN.B2S
//                         Topview, Sideview, Rearview Kameras LIN_2_FORMAT
// 01.04.2008  as  V1.04 Datei UDS_TAB_IArtTexte.B2S
//                         Texte von UDS_TAB_FArtTexte.B2S übernommen
// 14.06.2008  rd  V1.05 Datei UDS_TAB_Lieferante.B2S
//                         Lieferanten bis 0xA4 dazu
// 01.08.2008  rd  V1.06 Datei STD_ISEN.B2S
//                         ACSM4 Sensoren dazu
// 15.09.2008  gr  V1.07 Datei UDS_22_20_00_IS_LESEN.B2S
//                         Korrektur bei Result F_HEX_CODE
// 21.10.2008  rd  V1.08 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferant 0xA5 dazu
// 18.11.2008  rd  V1.09 Datei STD_ISEN.B2S
//                         Mirkrowellensensoren überarbeitet
// 19.01.2009  as  V1.10 Datei UDS_TAB_JobResult.B2S
//                           Erweiterung der JobResult-Tabelle
// 19.01.2009  as  V1.11 Datei UDS_TAB_JobResult.B2S, UDS_TAB_DiagMode.B2S
//                           Erweiterung der JobResult-Tabelle, Modierweiterung
// 19.01.2009  gh  V1.12 Datei UDS_19_15_FS_LESEN_PERMANENT.B2S hinzu
// 30.07.2009  rd  V1.13 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten aktualisiert
// 30.07.2009  gr  V1.14 Datei UDS_TAB_LieferantenLIN.B2S
//                         Lieferanten aktualisiert
// 07.12.2009  rd  V1.15 Datei UDS_TAB_LieferantenLIN.B2S
//                         Lieferanten aktualisiert
//                       Datei UDS_TAB_GROBNAME.B2S
//                         Aktualisiert
// 05.03.2010  rd  V1.16 Datei UDS_TAB_GROBNAME.B2S
//                         Aktualisiert
// 29.04.2010  gh  V1.17 Datei UDS_FS_Snapshot.B2S
//                         Sub-Tabellen für diskrete UW: Spaltenname "UWTEXT" oder "TEXT"
//             rd        Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten aktualisiert
// 10.12.2010  gh  V1.18 Datei UDS_TAB_LIEFERANTENLIN.B2S
//                         Lieferanten aktualisiert
//                         Datei UDS_2C_STATUS_BLOCK_LESEN.B2S
//                         Datei UDS_2E_STEUERN.B2S
//                         Datei UDS_2F_STEUERN_IO.B2S
//                         Datei UDS_31_STEUERN_ROUTINE.B2S
//                         Datei UDS_22_STATUS_LESEN.B2S
//                         neue Einheit DATA, TEXT dazu
//                         Integration DUMMY_ bei Einheit DATA
//                         Integration Entfall Längenprüfung
//                         Anforderungen VH-53,Waegner und EA-410, Lorch
//                         Datei UDS_MOSTJOBS.B2S
//                         Datei UDS_MOST_TAB.B2S
//                         Update, neue Verantwortung: Florian Lange, EI-42
// 26.05.2011  gh  V1.19 Datei UDS_TAB_Prozessklassen.B2S
//                         Prozessklasse 0x04 GWTB hinzu
// 30.11.2011  rd  V1.20 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten aktualisiert
// 15.12.2011  rd  V1.21 Datei STD_ISEN.B2S
//                         überarbeitet
// 25.01.2012  rd  V1.22 Datei UDS_TAB_Lieferanten.B2S
//                         Lieferanten aktualisiert
// 02.02.2012  rd  V1.23 Datei STD_ISEN.B2S
//                         überarbeitet
// 24.02.2012  rd  V1.24 Datei UDS_22_10_0B_I_STUFE_LESEN.B2S
//                         Backup jetzt CAS oder KOMBI oder FEM
// 01.03.2012  rd  V1.25 Datei STD_ISEN.B2S
//                         überarbeitet
// *******************************************************************
// UDS_PACKAGE.B2S @(#)@ V1.25 @(#)@
// *******************************************************************
#define __PACKAGE__ "1.25"
// end of : #include "UDS_PACKAGE.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\STD_INFO.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : INFO
// -------------------------------------------------------------------
// History:
// 31.01.2001  rd  V0.01 Erstellung
// 25.03.2002  rd  V1.00 Freigabe
// 22.04.2003  rd  V1.01 Versionskennung hinzu
// *******************************************************************
// STD_INFO.B2S @(#)@ V1.01 @(#)@
// *******************************************************************
job ( name      :       INFO;
      comment   :       Information SGBD;

      result    :       ECU;
        type    :       string;
        defrslt :       ;
        comment :       Steuergerät im Klartext;

      result    :       ORIGIN;
        type    :       string;
        defrslt :       ;
        comment :       Steuergeräte-Verantwortlicher;

      result    :       REVISION;
        type    :       string;
        defrslt :       ;
        comment :       Versions-Nummer;

      result    :       AUTHOR;
        type    :       string;
        defrslt :       ;
        comment :       Namen aller Autoren;

      result    :       COMMENT;
        type    :       string;
        defrslt :       ;
        comment :       wichtige Hinweise;

      result    :       PACKAGE;
        type    :       string;
        defrslt :       ;
        comment :       Include-Paket-Nummer;

      result    :       SPRACHE;
        type    :       string;
        defrslt :       ;
        comment :       deutsch, english;
    )
{
  ECU      = __ECU__;
  ORIGIN   = __ORIGIN__;
  REVISION = __REVISION__;
  AUTHOR   = __AUTHOR__;
  COMMENT  = __ECUCOMMENT__;
  PACKAGE  = __PACKAGE__;
  SPRACHE  = "deutsch";
}
// end of : #include "STD_INFO.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_INITIALISIERUNG.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : INITIALISIERUNG
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005  rd  V0.001 Erstellung
// 28.11.2005  rd  V0.002 CAN Parameter dazu
// 02.02.2006  gh  V0.003 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_INITIALISIERUNG.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
job ( name      :       INITIALISIERUNG;
      comment   :       Initialisierung und Kommunikationsparameter;

      result    :       DONE;
        type    :       int;
        defrslt :       ;
        comment :       1, wenn Okay;
    )
{
  open_communication();                              // Kommunikation starten
  stop_frequent();                                   // evtl. bestehende ACK killen
  set_repeat_counter(REPEAT_COUNTER);                // Wiederholzaehler setzen
  set_communication_pars(PARAMETER_BMW_KWP2000_CAN); // Konzept einstellen
  set_answer_length(AWLEN_BMW_KWP2000_CAN);          // Antwortlaenge
  DONE = 1;                                          // muss immer 'DONE' heissen !
}


// end of : #include "UDS_INITIALISIERUNG.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_F1_50_IDENT.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : IDENT
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005  gr  V0.001 Erstellung
// *******************************************************************
// UDS_22_F1_50_IDENT.B2S @(#)@ V0.001 @(#)@
// *******************************************************************
job ( name      :       IDENT;
      comment   :       Identdaten;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $F150 Sub-Parameter SGBD-Index;
      comment   :       Modus: Default;

      result    :       ID_SG_ADR;
        type    :       long;
        comment :       Steuergeraeteadresse;

      result    :       ID_SGBD_INDEX;
        type    :       long;
        comment :       Index zur Erkennung der SG-Variante;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22, 0xF1, 0x50};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if(ID_SG_ADR)
        ID_SG_ADR = SA_response;
        
  if(ID_SGBD_INDEX)
        ID_SGBD_INDEX = (response[3] << 16) + (response[4] << 8) + response[5];

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_F1_50_IDENT.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_19_02_FS_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult, FOrtTexte, FArtTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 15.11.2005  gr  V0.001 Erstellung
// 02.02.2006  gr  V0.002 Anpassung an neue DTCStatusMask 0C
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Tabellen-Name)
// 22.06.2006  gh  V0.003 Angleichung der Auswertung an Job IS_LESEN
// 30.10.2007  gr  V0.004 Ausgabe des F_HEX_CODE korrigiert (dataclear(temp))
// *******************************************************************
// UDS_19_02_FS_LESEN.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
job ( name      :       FS_LESEN;
      comment   :       Fehlerspeicher lesen (alle Fehler / Ort und Art);
      comment   :       UDS  : $19 ReadDTCInformation;
      comment   :       UDS  : $02 ReadDTCByStatusMask;
      comment   :       UDS  : $0C StatusMask (Bit2, Bit3);
      comment   :       Modus: Default;

      result    :       F_VERSION;
        type    :       int;
        defrslt :       3;
        comment :       Typ des Fehlerspeichers;
        comment :       Fuer UDS immer 3;

      result    :       F_HEX_CODE;
        type    :       data;
        comment :       Fehlerdaten pro Fehler als Hexcode;

      result    :       F_ORT_NR;
        type    :       long;
        comment :       Index fuer Fehlerort;

      result    :       F_ORT_TEXT;
        type    :       string;
        comment :       Fehlerort als Text;
        comment :       table FOrtTexte ORTTEXT;

      result    :       F_EREIGNIS_DTC;
        type    :       int;
        comment :       0: DTC kein Ereignis DTC;
        comment :       1: DTC ist Ereignis DTC;
        comment :       table FOrtTexte EREIGNIS_DTC;

      result    :       F_READY_NR;
        type    :       int;
        comment :       Readyness Flag (Standard-Fehlerart) als Zahl;

      result    :       F_READY_TEXT;
        type    :       string;
        comment :       Readyness Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_VORHANDEN_NR;
        type    :       int;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Zahl;

      result    :       F_VORHANDEN_TEXT;
        type    :       string;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_WARNUNG_NR;
        type    :       int;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Zahl;

      result    :       F_WARNUNG_TEXT;
        type    :       string;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x19, 0x02, 0x0C};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

  // Variablen fuer Job  
  unsigned char temp[];
  unsigned char text[];
           int  anzahl;
           int  index;
           int  offset;
           long wert;
           int  LIStatusDTC = 0x00;

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_UDS_TAB_FArtTexte_B2S_NOT_FOUND;
               
// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  index = 0;
  offset = 3;      
  anzahl = (datalen(response) - 3) / 4;


  // Verifikation der Datenlaenge
  if (datalen(response) != (3 + (anzahl*4))) { // Rundungsfehler bei Berechnung der ANZAHL
    if (_REQUEST)              
      _REQUEST = request;

    if (_RESPONSE)
      _RESPONSE = response;

    JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";

    return;
  }

  while (index < anzahl) {
    LIStatusDTC = response[offset + 3] & 0x4D; // Auslesen des Status Bytes. Für die Auswertung sind die Bits 0,2,3,6 entscheidend

    if (F_HEX_CODE) {
      dataclear(temp);	
      datacopy(temp, response, offset, 4);
      F_HEX_CODE = temp;
    }

    if (F_ORT_NR || F_ORT_TEXT || F_EREIGNIS_DTC || F_READY_NR || F_READY_TEXT || F_VORHANDEN_NR || F_VORHANDEN_TEXT || F_WARNUNG_NR || F_WARNUNG_TEXT) {
      // Ausgabe Fehlerort 
      wert = (response[offset] << 16) + (response[offset + 1] <<  8) + response[offset + 2];
      F_ORT_NR = wert;

      // Dazugehoeriger Fehlertext
      tabset("FOrtTexte");
      tab_suche_unsigned("ORT", wert);
      tabget(text, "ORTTEXT");
      F_ORT_TEXT = text;

      // Ereignis-DTC ja / nein        
      tabget(text, "EREIGNIS_DTC");
      F_EREIGNIS_DTC = atoi(text);

      // Gibt an, ob Test seit dem letzten loeschen einmal komplett durchlaufen wurde; Offset 0x10 wird addiert, um Tabelle FArtTexte verwenden zu können
      wert = ((response[offset+3] >> 4)  & 0x01) + 0x10;
      F_READY_NR = wert;

      tabset("FArtTexte");
      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_READY_TEXT = text;

      // Fehler aktuell vorhanden? Bit 0 und Bit 6 muessen beide 1 beinhalten, dann ist Fehler aktuell vorhanden
      F_VORHANDEN_NR = LIStatusDTC;

      tab_suche_unsigned("ARTNR", LIStatusDTC);
      tabget(text, "ARTTEXT");
      F_VORHANDEN_TEXT = text;

      // Geht eine Warnlampe an oder nicht
      wert = ((response[offset+3] >> 7) & 0x01) + 0x80;
      F_WARNUNG_NR = wert;

      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_WARNUNG_TEXT = text;
    }
        
    new_set_of_results(); // neuer Ergebnissatz

    index++;
    offset += 4;
  }

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_19_02_FS_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_19_04_06_FS_LESEN_DETAIL.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 28.07.2005  gh  V0.001 Erstellung (nur Teilumfang !)
// 24.11.2005  gr  V0.002 Erweiterung
// 14.12.2005  gr  V0.003 Result F_SATZ_ZEIT_DATUM hinzu
// 20.12.2005  gr  V0.004 *_SATZ_* aus den Results entfernt (Verwendbarkeit)
// 20.12.2005  gr  V0.004 SAECodeTexte auf externe Tabellen-SGBD T_SCOD umgestellt
// 02.02.2006  gr  V0.005 Entfall Abfrage ServerityByte (Beschluss AKD)
// 02.02.2006  gr  V0.005 Include-Name geändert (wie Tabellen-Name)
// 09.02.2006  gh  V0.006 4 Sub-Includes abgespalten
// 15.02.2006  gh  V0.007 gestestet mit Simulation
// 16.02.2006  gh  V0.008 Zuweisung "response1 = response;" integriert
// 20.02.2006  gh  V0.009 Umbenennung F_UW_ZEIT_DATUM => F_UW_DATUM_ZEIT
// 22.02.2006  gh  V0.010 Integration Subtabellen Tab_<Index>
// 23.02.2006  gh  V0.010 Korrektur Variablendefinition: unsigned !
// 24.03.2006  gh  V0.011 Zuweisung Result F_HEX_CODE integriert
// 24.03.2006  gh  V0.011 Sonderfälle 0xFFFFFF(FF) bei F_UW_KM / F_UW_DATUM_ZEIT
// 24.03.2006  gh  V0.011 _RESPONSE_* auch bei Abbruch
// 27.03.2006  gh  V0.012 Abbruch, wenn zu wenig Daten in SG-Antwort
// 28.03.2006  gh  V0.012 Abbruch, wenn Anzahl der Daten in SG-Antwort falsch
// 23.06.2006  gh  V0.013 Integration Severity-Byte
// 28.06.2006  gh  V0.014 Result "F_UW_DATUM_ZEIT" entfernt
// 29.06.2006  gh  V0.015 Results bzgl. Severity-Byte in Satz 1
// 18.10.2006  gh  V0.020 $19 $04: Sonderfall Fehler nicht in SG gespeichert
// 18.10.2006  gh  V0.020 $19 $04: Anzahl UWB-Sätze einstellbar
// 19.10.2006  gh  V0.020 $19 $04: komplexe UWB: Ausgabe als Text (string)
// 14.03.2008  gr  V0.021 Variable LIHlzValid hinzu 
// *******************************************************************
// UDS_19_04_06_FS_LESEN_DETAIL.B2S @(#)@ V0.021 @(#)@
// *******************************************************************
job ( name      :       FS_LESEN_DETAIL;
      comment   :       Fehlerspeicher lesen (einzelner Fehler / Ort und Art);
      comment   :       UDS  : $19 ReadDTCInformation;
      comment   :       UDS  : $04 reportDTCSnapshotRecordByDTCNumber;
      comment   :       UDS  : $06 reportDTCExtendedDataRecordByDTCNumber;
      comment   :       UDS  : $09 reportSeverityInformationOfDTC;
      comment   :       Modus: Default;

      argument  :       F_CODE;
        type    :       long;
        comment :       gewaehlter Fehlercode;

      result    :       F_VERSION;
        type    :       int;
        defrslt :       3;
        comment :       Typ des Fehlerspeichers;
        comment :       Fuer UDS immer 3;

      result    :       F_HEX_CODE;
        type    :       data;
        comment :       Fehlerdaten pro Fehler als Hexcode;

      result    :       F_ORT_NR;
        type    :       long;
        comment :       Index fuer Fehlerort;

      result    :       F_ORT_TEXT;
        type    :       string;
        comment :       Fehlerort als Text;
        comment :       table FOrtTexte ORTTEXT;

      result    :       F_EREIGNIS_DTC;
        type    :       int;
        comment :       0: DTC kein Ereignis DTC;
        comment :       1: DTC ist Ereignis DTC;
        comment :       table FOrtTexte EREIGNIS_DTC;        

      result    :       F_READY_NR;
        type    :       int;
        comment :       Readyness Flag (Standard-Fehlerart) als Zahl;

      result    :       F_READY_TEXT;
        type    :       string;
        comment :       Readyness Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_VORHANDEN_NR;
        type    :       int;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Zahl;

      result    :       F_VORHANDEN_TEXT;
        type    :       string;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_WARNUNG_NR;
        type    :       int;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Zahl;

      result    :       F_WARNUNG_TEXT;
        type    :       string;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_HFK;
        type    :       int;
        comment :       Haufigkeitszaehler als Zahl;
        comment :       Wertebereich 0 - 255;
        comment :       Bei mehr als 255 bleibt Zaehler stehen. Kein Ueberlauf;

      result    :       F_HLZ;
        type    :       int;
        comment :       Heilungsszaehler als Zahl;
        comment :       Wertebereich 0 - 255;
        comment :       -1: ohne Haufigkeitszaehler;

      result    :       F_UEBERLAUF;
        type    :       int;
        comment :       0: Kein Ueberlauf des Fehlerspeichers;
        comment :       1: Ueberlauf des Fehlerspeichers;

      result    :       F_FEHLERKLASSE_NR;
        type    :       int;
        comment :       0: Keine Fehlerklasse verfuegbar;
        comment :       1: Ueberpruefung bei naechstem Werkstattbesuch;
        comment :       2: Ueberpruefung bei naechstem Halt;        
        comment :       4: Ueberpruefung sofort erforderlich !;

      result    :       F_FEHLERKLASSE_TEXT;
        type    :       string;
        comment :       Ausgabe der Fehlerklasse als Text;
        comment :       table Fehlerklasse TEXT;        

      result    :       F_UW_ANZ;
        type    :       int;
        comment :       Anzahl der Umweltbedingungen;
        comment :       Je nach dieser Anzahl i (i = 1, 2, ...);
        comment :       existieren i mal folgende Results:;
        comment :       (long)   F_UWi_NR   Index   der i. Umweltbedingung;
        comment :       (string) F_UWi_TEXT Text    zur i. Umweltbedingung;
        comment :       (real)   F_Uwi_WERT Wert    der i. Umweltbedingung;
        comment :       (string) F_UWi_EINH Einheit der i. Umweltbedingung;

      result    :       F_UW_KM;
        type    :       long;
        comment :       Umweltbedingung Kilometerstand (3 Byte);
        comment :       Wertebereich: 0 - 16777215 km;
        comment :                    -1, wenn Kilometerstand nicht zur Verfuegung steht;

      result    :       F_UW_ZEIT;
        type    :       long;
        comment :       Umweltbedingung Absolute Zeit (4 Byte);
        comment :       Genauigkeit: in Sekunden;
        comment :       -1, wenn Absolute Zeit nicht zur Verfuegung steht;
/*
      result    :       F_UW_DATUM_ZEIT;
        type    :       string;
        comment :       Umweltbedingung Absolute Zeit im Datumsformat DD.MM.YYYY  hh:mm:ss;
        comment :       Beginn: 01.01.2000  00:00:00;
*/
      result    :       F_SAE_CODE;
        type    :       unsigned int;
        comment :       Wertebereich 0x000000 - 0xFFFFFF;
        comment :       externe Tabelle T_SCOD;

      result    :       F_SAE_CODE_STRING;
        type    :       string;
        comment :       5 stelliger Text in der Form 'Sxxxx';

      result    :       F_SAE_CODE_TEXT;
        type    :       string;
        comment :       Text zu F_SAE_CODE;

      result    :       _RESPONSE_SNAPSHOT;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE_EXTENDED_DATA;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE_SEVERITY;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;
    )
{
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned  int LIStatusDTC = 0x00;
  unsigned char temp[];
  unsigned char text[];           
  unsigned char text1[];
  unsigned char response1[];           

           long wert;
  unsigned long code;  
  unsigned  int offset;
  unsigned  int LILaengeData;
  unsigned long LLData;
  unsigned long zeit_aktuell;

            // Variablen für die Basis-Infos des DTC    
            int LIExtendedRecordNumber;
            int LIUWErweitertExist;
            int LIHlzExist;
            int LIHlzValid; // Hinzu in Version 0.021
            int LISaeCodeExist;
            int severity_exist;
  unsigned char severity_byte;

/*          // Variablen zur Zeitberechnung
  unsigned  int LIJahr;
  unsigned  int LIMonat;
  unsigned  int LITag;
  unsigned  int LIStunden;
  unsigned  int LIMinuten;
  unsigned  int LISekunden;
  unsigned  int LIAbbruch;
  unsigned  int LISchaltjahr;
*/
           // Variablen fuer die Umweltsaetze
  unsigned long LLAnzahlSnapshotIdentifier;
  unsigned  int LISnapshotNumber;
  unsigned  int LIIdentifier;
  unsigned  int LICounterUW;
  unsigned  int LIAnzUW;
  unsigned  int LICounterIdentifier;
            int uw_satz_anzahl;
            
  unsigned  int uw_sub_index;     // Index der Sub-UW
  unsigned  int uw_sub_anz;       // Anzahl der Sub-UWs
  unsigned  int identifier_sub;   // Identifier der Sub-UW

  unsigned  int offset_start;     // Startwert bei Extended Data

  unsigned  int uw_laenge;        // Laenge der einzelnen UW [Bytes]            

  unsigned char uw_gueltig;       // Flag, ob UW gueltig d.h. "offset < daten_laenge"

  unsigned long uw_mask;          // Maske fuer digitale bzw. diskrete UW

  unsigned long uw_wert_mask;     // Puffer fuer F_UWn_WERT (Bitmaske: digital / diskret)
           long uw_wert;          // Puffer fuer F_UWn_WERT (long)
           real uw_wert_real;     // Puffer fuer F_UWn_WERT (real)

           real uw_mul_real;      // fuer Berechnung analoger UW
           real uw_div_real;      // fuer Berechnung analoger UW
           real uw_add_real;      // fuer Berechnung analoger UW

  unsigned  int daten_laenge;     // "datalen(daten)" (kommt mehrfach vor)

  unsigned  int uw_typ;           // ODER-Verknuefpung von UW-Typ-Flags

  unsigned  int uw_typ_digital  = 0x0001;   // Flag fuer digitale UW                               (Grundtyp / Zuweisung )
  unsigned  int uw_typ_diskret  = 0x0002;   // Flag fuer diskrete UW                               (Grundtyp / Zuweisung )
  unsigned  int uw_typ_analog   = 0x0004;   // Flag fuer analoge  UW (long)                        (Grundtyp / Zuweisung )

  unsigned  int uw_typ_float    = 0x0008;   // Flag fuer analoge  UW (real / float)                (Zusatz   / Veroderung)
  unsigned  int uw_typ_double   = 0x0010;   // Flag fuer analoge  UW (real / double)               (Zusatz   / Veroderung)

  unsigned  int uw_typ_signed   = 0x0020;   // Flag fuer Vorzeichen der UW (unsigned / signed)     (Zusatz   / Veroderung)
  unsigned  int uw_typ_Motorola = 0x0040;   // Flag fuer Prozessor (Intel / Motorola)              (Zusatz   / Veroderung)
  unsigned  int uw_typ_low_high = 0x0080;   // Flag fuer Reihenfolge (high/low, low/high)          (Zusatz   / Veroderung)

  unsigned  int uw_typ_hex      = 0x0100;   // Flag fuer hexadezimale UW (1, 2, 4 Byte => string)  (Grundtyp / Zuweisung )
  unsigned  int uw_typ_text     = 0x0200;   // Flag fuer UW als Text (string mit n Bytes)          (Grundtyp / Zuweisung )

// Telegram fuer Severity-Byte      
  unsigned char request[]       = {0x19,0x09,0xFF,0xFF,0xFF};
// Service ReadDTCInformation --------+    |    |    |    |    
// SubPara SeverityInformationOfDTC -------+    |    |    |
// DTCNumber------------------------------------+----+----+

// ---------------- Ueberpruefung ob Tabellen includiert sind --------

  INCLUDE_UDS_TAB_FArtTexte_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_DTCExtendedDataRecordNumber_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_DTCSnapshotIdentifier_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_Fehlerklasse_B2S_NOT_FOUND;

// ---------------- Argumente des Jobs auswerten ---------------------

  if (exist(F_CODE)) {
    code = F_CODE;
    request[2] = (code >>16) & 0xFF;
    request[3] = (code >> 8) & 0xFF;
    request[4] =  code       & 0xFF;
  }
  else {
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

// ---------------- Auswertung XDetailStruktur -----------------------

#define DetailStruktur  "FDetailStruktur"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_DetailStruktur.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 23.06.2006  gh  V0.003 Integration Flag "severity_exist"
// 29.06.2006  gh  V0.004 Fehlerbehandlung Flags
// 18.10.2006  gh  V0.020 neues Konfigurationselement: F_UWB_SATZ
// 14.03.2007  gr  V0.021 neues Konfigurationselement: F_HLZ_VIEW
// *******************************************************************
// UDS_FS_DetailStruktur.B2S @(#)@ V0.021 @(#)@
// *******************************************************************

// ---------------- Auswertung XDetailStruktur -----------------------

   tabset(DetailStruktur);        // Tabelle nicht vorhanden muss noch abgefangen werden (bei Generator immer vorhanden!)
     
// ................ Auswertung Umweltbedingungen erweitert ...........

   if (tabseek("NAME", "F_UWB_ERW")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LIUWErweitertExist = 0;
      else         
         LIUWErweitertExist = 1;
   }
   else
      LIUWErweitertExist = 0;
   

// ................ Auswertung Umweltbedingungs-Sätze ................

   if (tabseek("NAME", "F_UWB_SATZ")) {
      tabget(temp, "TYP");

      uw_satz_anzahl = atoi(temp);
   }
   else
      uw_satz_anzahl = 2;
   

// ................ Auswertung SAE-Codes .............................

   dataclear(temp);
   if (tabseek("NAME", "F_SAE_CODE")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LISaeCodeExist = 0;
      else         
         LISaeCodeExist = 1;
   }
   else
      LISaeCodeExist = 0;

// ................ Auswertung Heilungszähler ........................

   dataclear(temp);
   if (tabseek("NAME", "F_HLZ")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E) {         // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LIHlzExist = 0;
                
         if (F_HLZ)
            F_HLZ = -1;
      }                
      else         
         LIHlzExist = 1;
   }
   else
      LIHlzExist = 0;

// ................ Auswertung Severity-Byte .........................

   dataclear(temp);
   if (tabseek("NAME", "F_SEVERITY")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         severity_exist = 0;
      else         
         severity_exist = 1;
   }
   else
      severity_exist = 0;
   

// ................ Auswertung Heilungszähler gültig .........................

   // Parameter ist solange erfoderlich, bis das Problem mit dem HLZ im Standard-Core gelöst ist	
   dataclear(temp);
   if (tabseek("NAME", "F_HLZ_VIEW")) {
      tabget(temp, "TYP");

      if (temp[0] == 0x2D)	// Handelt es sich bei diesem Zeichen um ein '-'?
      	LIHlzValid = 1; 	// Wenn nichts angebenen wird, dann richtet sich die Auswertung allein nach F_HLZ
      else
      {	 	
      	temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      	if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
        	LIHlzValid = 0;
      	else         
        	LIHlzValid = 1;
       }
   }
   else
      LIHlzValid = 1; // Wenn nichts angebenen wird, dann richtet sich die Auswertung allein nach F_HLZ 

// End of file

// end of : #include "UDS_FS_DetailStruktur.b2s"

#undef  DetailStruktur

// ---------------- 1. Kommunikation (Severity) ----------------------

  if (severity_exist) {
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) {
      if (_RESPONSE_SEVERITY) _RESPONSE_SEVERITY = response;
      return;
    }

// ---------------- 1. Test: richtiger Fehlercode ? ------------------

    if (code != ((response[5] << 16) + (response[6] << 8) + response[7]))
      return_with_message("?10?", "ERROR-CODE RESPONSE IS NOT ERROR-CODE REQUEST", response, "_RESPONSE_SEVERITY", 0);
  }

// ---------------- Auswertung Severity-Byte -------------------------

  if (severity_exist)
    severity_byte = (response[3] >> 5) & 0x07;   // Es werden nur die obersten 3 Bit benötigt.
  else
    severity_byte = 0;                           // There is no severity information available.

  if (F_FEHLERKLASSE_NR)
    F_FEHLERKLASSE_NR = severity_byte;

  if (F_FEHLERKLASSE_TEXT) {
    tabset("Fehlerklasse");
    tab_suche_unsigned("NR", severity_byte);
    tabget(text,"TEXT");
    F_FEHLERKLASSE_TEXT = text;               
  }        
/*
  if (_RESPONSE_SEVERITY)                   // würde im 1. Ergebnissatz abgelegt !
    if (severity_exist)
      _RESPONSE_SEVERITY = response;
    else
      _RESPONSE_SEVERITY = "-";
*/

// ---------------- 2. Kommunikation (Extended Data) -----------------

  dataclear(request);   
  dataclear(response);    

  request                       = {0x19,0x06,0xFF,0xFF,0xFF,0xFF};
// Service ReadDTCInformation --------+    |    |    |    |    |    
// SubPara ExtendedDataRecordByDTCNumber --+    |    |    |    |    
// DTCNumber -----------------------------------+----+----+    |
// DTCExtendedDataRecordNumber (alle) -------------------------+            

  request[2] = (code >>16) & 0xFF;
  request[3] = (code >> 8) & 0xFF;
  request[4] =  code       & 0xFF;

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) {
    if (_RESPONSE_EXTENDED_DATA) _RESPONSE_EXTENDED_DATA = response;
    return;
  }
  response1 = response;    // zwischenpuffern, da erst am Ende des Jobs benötigt

// ---------------- 2. Test: richtiger Fehlercode ? ------------------

  if (code != ((response[2] << 16) + (response[3] << 8) + response[4]))
    return_with_message("?10?", "ERROR-CODE RESPONSE IS NOT ERROR-CODE REQUEST", response, "_RESPONSE_EXTENDED_DATA", 0);

// ---------------- Zuweisung F-Ort, F-Arten   -----------------------

  offset = 5;   // Startpunkt: Byte "statusOfDTC"

#define OrtTexte        "FOrtTexte"
#define ArtTexte        "FArtTexte"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Ort_Art.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 16.02.2006  gh  V0.003 Zuweisung "response1 = response;" entfernt
// 24.03.2006  gh  V0.004 Zuweisung Result F_HEX_CODE entfernt
// *******************************************************************
// UDS_FS_Ort_Art.B2S @(#)@ V0.004 @(#)@
// *******************************************************************

// ................ Rückgabe buffer löschen ..........................

   dataclear(temp);
   dataclear(text);           
   dataclear(text1);

// ................ Rückgabe Basis-Infos .............................

   LIStatusDTC = response[offset] & 0x4D;   // Auslesen des Status Bytes. Für die Auswertung sind die Bits 0,2,3,6 entscheidend

   if (F_ORT_NR || F_ORT_TEXT || F_EREIGNIS_DTC || F_READY_NR || F_READY_TEXT || F_VORHANDEN_NR || F_VORHANDEN_TEXT || F_WARNUNG_NR || F_WARNUNG_TEXT) {
      dataclear(temp);

      F_ORT_NR = code;                 // Ausgabe Fehlerort

      tabset(OrtTexte);                // Dazugehoeriger Fehlertext
      tab_suche_unsigned("ORT", code);
      tabget(temp, "ORTTEXT");
      F_ORT_TEXT = temp;

                        
      tabget(temp, "EREIGNIS_DTC");    // Ereignis-DTC ja / nein
      F_EREIGNIS_DTC = atoi(temp);


      wert = ((response[offset] >> 4)  & 0x01) + 0x10;     // Gibt an, ob Test seit dem letzten Löschen einmal komplett durchlaufen wurde
      F_READY_NR = wert;                                   // Offset 0x10 wird addiert, um Tabelle FArtTexte verwenden zu können
      
      tabset(ArtTexte);
      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_READY_TEXT = text;

                
      F_VORHANDEN_NR = LIStatusDTC;                   // Fehler aktuell vorhanden? (siehe Matrix in XArtTexte)

      tab_suche_unsigned("ARTNR", LIStatusDTC);
      tabget(text, "ARTTEXT");
      F_VORHANDEN_TEXT = text;

                
      wert = ((response[offset] >> 7) & 0x01) + 0x80; // Geht eine Warnlampe an oder nicht
      F_WARNUNG_NR = wert;

      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_WARNUNG_TEXT = text;
   }

// end of : #include "UDS_FS_Ort_Art.b2s"

#undef  OrtTexte
#undef  ArtTexte

// ---------------- Auswertung Extended Data -------------------------

  daten_laenge = datalen(response);
  offset = 6;   // DTCExtendedDataRecordNumber #1

  if (daten_laenge == 6) {   // Sonderfall: Fehler nicht in SG gespeichert
    ;
//  F_UEBERLAUF = -1;
//  F_HFK = -1;
  }
  else {
    offset_start = offset;

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Extended_Data.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 20.02.2006  gh  V0.003 Entfernung "new_set_of_results();"
// 14.03.2008  gr  V0.004 Abfrage, ob Heilungszähler angezeigt werden soll
// *******************************************************************
// UDS_FS_Extended_Data.B2S @(#)@ V0.004 @(#)@
// *******************************************************************

// ................ Solange noch Einträge vorhanden sind .............

   while (offset < (datalen(response))) {
      LIExtendedRecordNumber = response[offset];

      tabset("DTCExtendedDataRecordNumber");
      tab_suche_unsigned("WERT", LIExtendedRecordNumber);
      tabget(temp, "ANZ_BYTE");
        
      LILaengeData = atoi(temp);
        
      LLData = 0;        
      while (LILaengeData > 0) {  // Anzahl der Bytes
         offset = offset + 1;
         LLData = LLData + (response[offset] << ((LILaengeData - 1) * 8));
        
         LILaengeData--;
      }
        
      if (LIExtendedRecordNumber == 0x01) { // Condition-Byte ist Pflicht
         if (F_UEBERLAUF)
            F_UEBERLAUF = LLData & 0x01;
      }

      if (LIExtendedRecordNumber == 0x02) { // Haeufigkeitszaehler ist Pflicht
         if (F_HFK)
            F_HFK = LLData;
      }

      if ((LIExtendedRecordNumber == 0x03) && (LIHlzExist == 1) && (LIHlzValid == 1)) {  // Heilungszähler (optional)
         if (F_HLZ)
            F_HLZ = LLData;
      }
      
      offset = offset + 1;
   }

// end of : #include "UDS_FS_Extended_Data.b2s"

    // Abfrage, nach LIHlzValid darf nicht gemacht werden, da sonst Telegrammlänge nicht mehr stimmt.
    if (((LIHlzExist == 1) && ((datalen(response) - offset_start) != 6)) ||
        ((LIHlzExist != 1) && ((datalen(response) - offset_start) != 4))) {
      return_with_message("?12?", "INCORRECT NUMBER OF DATA IN RESPONSE-TELEGRAM", response1,"_RESPONSE_EXTENDED_DATA", 1);
    }
  }

// ---------------- 3. Kommunikation (Snapshots) ---------------------

  dataclear(request);   
  dataclear(response);    
  dataclear(text);

  request                       = {0x19,0x04,0xFF,0xFF,0xFF,0xFF};
// Service ReadDTCInformation --------+    |    |    |    |    |    
// SubPara SnapshotRecordByDTCNumber-------+    |    |    |    |
// DTCNumber------------------------------------+----+----+    |
// DTCSnapshotRecordNumber (alle)------------------------------+            

  request[2] = (code >>16) & 0xFF;
  request[3] = (code >> 8) & 0xFF;
  request[4] =  code       & 0xFF;

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) {
    if (_RESPONSE_SNAPSHOT)      _RESPONSE_SNAPSHOT      = response;
    if (_RESPONSE_EXTENDED_DATA) _RESPONSE_EXTENDED_DATA = response1;
    return;
  }
// ................ Zuweisung F_HEX_CODE (ohne Severity!) ............

  if (F_HEX_CODE) {
    text1 = response1;       // Extended Data
    dataerase(text1, 0, 2);
    text = response;         // Snapshots
    dataerase(text, 0, 2);
    datacat(text, text1);
    F_HEX_CODE = text;
  }

// ---------------- 3. Test: richtiger Fehlercode ? ------------------

  if (code != ((response[2] << 16) + (response[3] << 8) + response[4])) {
    new_set_of_results();
    if (_RESPONSE_EXTENDED_DATA) _RESPONSE_EXTENDED_DATA = response1;
    return_with_message("?10?", "ERROR-CODE RESPONSE IS NOT ERROR-CODE REQUEST", response, "_RESPONSE_SNAPSHOT", 0);
  }

// ---------------- Auswertung Snapshots -----------------------------

  daten_laenge = datalen(response);
  offset = 7;   // Ab dem 8. Byte beginnen die relevanten Nutzdaten 

  LISnapshotNumber = 1;

  while (LISnapshotNumber <= uw_satz_anzahl) {   // Es gibt maximal uw_satz_anzahl Snapshots
    LIAnzUW = 0; // Anzahl der zusaetzlichen Umweltbedingungen zuruecksetzen
        
    LLAnzahlSnapshotIdentifier = response[offset]; // Anzahl der Identifier für diesen Snapshot
    LICounterIdentifier = LLAnzahlSnapshotIdentifier;

    if (daten_laenge == 6) {   // Sonderfall: Fehler nicht in SG gespeichert
      F_UW_ANZ  = 0;
//    F_UW_KM   = -1;
//    F_UW_ZEIT = -1;
      offset = daten_laenge;   // sonst JOB_STATUS ungleich "OKAY" 
      new_set_of_results();    // neuer Ergebnissatz !
      break;
    }

    if (LLAnzahlSnapshotIdentifier < 2) {   // Abbruch, wenn zu wenig Daten in SG-Antwort
      new_set_of_results();
      if (_RESPONSE_EXTENDED_DATA) _RESPONSE_EXTENDED_DATA = response1;
      return_with_message("?12?", "OBLIGATORY SNAPSHOTS (MILAGE / TIME) ARE MISSING", response,"_RESPONSE_SNAPSHOT", 0);
    }
        
    offset = offset + 1;
        
    LICounterUW = 1; // Zähler der Umweltbedingungen zurück setzen
    uw_gueltig = 1;
        
    while (LICounterIdentifier > 0) {

#define UmweltTexte  "FUmweltTexte"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Snapshot.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 20.02.2006  gh  V0.003 Umbenennung F_UW_ZEIT_DATUM => F_UW_DATUM_ZEIT
// 22.02.2006  gh  V0.004 Integration Subtabellen Tab_<Index>
// 24.03.2006  gh  V0.005 Sonderfall   0xFFFFFF bei F_UW_KM
// 24.03.2006  gh  V0.005 Sonderfall 0xFFFFFFFF bei F_UW_DATUM_ZEIT
// 24.03.2006  gh  V0.005 Korrektur Schaltjahrberechnung
// 27.03.2006  gh  V0.006 diskrete UW: real bei F_UWi_WERT, zusammengesetzter Text bei F_UWi_TEXT
// 27.03.2006  gh  V0.006 Format bei F_UW_DATUM_ZEIT optimiert
// 29.03.2006  gh  V0.006 Trace-Meldungen bzgl. return_with_message optimiert
// 28.06.2006  gh  V0.007 Zuweisung Result "F_UW_DATUM_ZEIT" auskommentiert
// 19.10.2006  gh  V0.020 $19 $04: komplexe UWB: Ausgabe als Text (string)
// 03.12.2007  rd  V0.021 Bug behoben bei hex, text Abfrage
// 21.02.2008  gr  V0.022 Auskommentierten Teil F_UW_DATUM_ZEIT entfernt 
// 21.02.2008  gr  V0.022 Bei SAE-Codes von Tabelle T_SCOD auf Tabelle T_PCOD umgestellt
// 21.02.2008  gr  V0.022 Bei SAE-Codes werden nur die ersten beiden Byte verwendet
// 21.02.2008  gr  V0.022 Zusätzliche Einträge der Tabelle DTCSnapshotIdentifier möglich
// 12.03.2010  gh  V0.030 Sub-Tabellen für diskrete UW: Spaltenname "UWTEXT" oder "TEXT" möglich
// *******************************************************************
// UDS_FS_Snapshot.B2S @(#)@ V0.030 @(#)@
// *******************************************************************

   uw_laenge = 0; // Laenge der Umweltbedingung zuruecksetzen
   uw_typ    = 0x00;       

   LIIdentifier = (response[offset] << 8) + response[offset+1];

   offset = offset + 2;   // bei digitaler oder diskreter UW nicht grundsätzlich weiterschalten !!! 

   // Einlesen des Identifier
   tabset("DTCSnapshotIdentifier");
   if (tab_suche_unsigned("UWNR", LIIdentifier) == 0) { // Falls der Identifier nicht in der Standard-UW-Tabelle enthalten ist, muss die spezielle Tabelle ausgewertet werden
      if (LIUWErweitertExist == 1) {
         tabset(UmweltTexte);
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0) { // Falls der Identifier auch nicht in der speziellen UW-Tabelle enthalten ist => Fehler
            temp = UmweltTexte;
            if (!strcmp(temp, "FUmweltTexte")) {
               new_set_of_results();
               var_result_data("_RESPONSE_EXTENDED_DATA", response1);
               return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_SNAPSHOT", 0);
            }
            else {
               new_set_of_results();
               var_result_data("_RESPONSE_2000", response1);
               return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_200X", 0);
            }
         }
      }                                                
      else  {
         temp = UmweltTexte;
         if (!strcmp(temp, "FUmweltTexte")) {
            new_set_of_results();
            var_result_data("_RESPONSE_EXTENDED_DATA", response1);
            return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_SNAPSHOT", 0);
         }
         else {
            new_set_of_results();
            var_result_data("_RESPONSE_2000", response1);
            return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_200X", 0);
         }
      }
   } // Ende 'if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)'

// ... Standard-Identifier (KM, Zeit, SAE-Code) ......................

   if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1702) {
      if (LIIdentifier == 0x1700) { // KM-Stand
         uw_laenge = 3;
         LLData = (response[offset] << 16) + (response[offset+1] << 8) + (response[offset+2]);
         if (LLData == 0xFFFFFF)  // Bei 0xFFFFFF steht der KM-Stand nicht zur Verfügung.
            LLData = -1;          // Hier soll analog zu F_UW_ZEIT der Wert -1 kommen.

         if (F_UW_KM)
            var_result_long("F_UW_KM", LLData);
      }

      // Auswertung des Datensatzes
      if (LIIdentifier == 0x1701) { // Absolute Zeit
         uw_laenge = 4;
         LLData = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] << 8) + (response[offset+3]);   // Angabe der Zeit seit 01.01.2000
         zeit_aktuell = LLData;
                          
         if (F_UW_ZEIT)
            var_result_long("F_UW_ZEIT", zeit_aktuell);
      } // Ende 'if (LIIdentifier == 0x1701)'
          
      // Auswertung des Datensatzes
      if (LIIdentifier == 0x1702) { // SAE-Code
         uw_laenge = 3;

	// alte Zuordnung
        // LLData = (response[offset] << 16) + (response[offset+1] << 8) + (response[offset+2]);
        
        // Bei den SAE-Codes werden doch nur die ersten beiden Bytes belegt 
        // Da ein 3-Byte-Wert geliefert wird, wird das letzte Byte abgeschnitten
	LLData = (response[offset] << 8) + response[offset+1];                      
	                          
         if (F_SAE_CODE)
            F_SAE_CODE = LLData;

         tabsetext("T_PCOD","PCodeTexte");
         tab_suche_unsigned("PCODE", LLData);

         if (F_SAE_CODE_STRING) {
            tabget(text, "STRING");                
            F_SAE_CODE_STRING = text;      
         }
                  
         if (F_SAE_CODE_TEXT) {
            tabget(text, "TEXT");                
            F_SAE_CODE_TEXT = text;                                       
         }
      }               
   } // Ende IF-Zweig 'if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1703)'

// ... SG-spezifischer Identifier ....................................

   else {
      uw_sub_index = 0;

// . . für alle Sub-Identifier . . . . . . . . . . . . . . . . . . . .

      do {

// . . nur beim ersten Mal . . . . . . . . . . . . . . . . . . . . . .

         if (uw_sub_index == 0) {
            identifier_sub = LIIdentifier;
            set_trap_mask(0x0400);     // Trap-Bit für Tabellenzugriff setzen

            strcpy(text, "Tab_");
            itoax(temp, identifier_sub);
            dataerase(temp, 2, 4);
            strcat(text, temp);
            tabset(text);              // Erweiterungsmatrix öffnen

            set_trap_mask(0);          // Trap-Bit für Tabellenzugriff ruecksetzen

            if (get_error(10)) {       // Sub-Tabelle existiert nicht
               uw_sub_index = 0;       // keine Aktion
            }
            else {                     // Sub-Tabelle existiert
               ++uw_sub_index;         // 1. Wert: uw_sub_index = 1;
               tabline(0);          
               tabget(text1, "UW_ANZ");
               uw_sub_anz = atoi(text1);
            }
         }

// . . ab dem ersten Mal . . . . . . . . . . . . . . . . . . . . . . .

         if (uw_sub_index > 0) {
            if (uw_sub_index <= uw_sub_anz) {    // Suchen in Zusatz-Matrix
               strcpy(text, "Tab_");
               itoax(temp, identifier_sub);
               dataerase(temp, 2, 4);
               strcat(text, temp);
               tabset(text);                     // Erweiterungsmatrix öffnen

               tabline(0);
               itoad(temp, uw_sub_index);
               strinsert(temp, "UW", 0);
               strcat(temp, "_NR");
               tab2fix(LIIdentifier, temp);      // neue "uw_nr" aus Zusatz-Matrix

               if (uw_sub_index == uw_sub_anz) {      // ! letzter digit./diskr. Wert
//                ++uw_sub_anz;
                  uw_sub_index = 0;
               }
               else                                   // sonst: weiterschalten !
                  ++uw_sub_index;
            }
            else {     // !!! darf eigentlich nie vorkommen
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?12?", "INCREMENT (++uw_sub_index)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?12?", "INCREMENT (++uw_sub_index)", response,"_RESPONSE_200X", 0);
               }
            }
         }

// . . UW normal abarbeiten  . . . . . . . . . . . . . . . . . . . . .

         LIAnzUW++; // Anzahl der echten UW-Bedingungen hochzaehlen

         text = "F_UW";

         itoad(text1, LIAnzUW);
         strinsert(text1, text , 0);

         // Es wird zuerst die Standard-Tabelle durchsucht
         tabset("DTCSnapshotIdentifier");
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)
         	tabset(UmweltTexte);                         // Wenn in der Standard-Tabelle der Eintrag nicht enthalten ist, dann wird auf die spezifische UW-Daten gegangen
         	
         tab_suche_unsigned("UWNR", LIIdentifier);    // (wieder) in die richtige Zeile springen
         tabget(text, "UW_EINH");            // !!! >> "text" wird noch gebraucht (F_UWn_EINH)

         if (!strcmp(text, "0/1"))
            uw_typ = uw_typ_digital;          // ! Typ -> digital
         else if (!strcmp(text, "0-n"))
            uw_typ = uw_typ_diskret;          // ! Typ -> diskret
         else {
            temp = text;
            temp[0] = temp[0] | 0x20;      // ! Kleinschrift (1. Zeichen)  h  t
            temp[1] = temp[1] | 0x20;      // ! Kleinschrift (2. Zeichen)  e  e
            temp[2] = temp[2] | 0x20;      // ! Kleinschrift (3. Zeichen)  x  x
            if (temp[3] != 0x00) // V0.021
              temp[3] = temp[3] | 0x20;    // ! Kleinschrift (4. Zeichen) \0  t

            if (!strcmp(temp, "hex"))
               uw_typ = uw_typ_hex;            // ! Typ -> hex (neu)
            else if (!strcmp(temp, "text"))
               uw_typ = uw_typ_text;           // ! Typ -> text (neu)
            else
               uw_typ = uw_typ_analog;         // ! Typ -> analog (evtl. -> real (siehe unten))
         } // Ende ELSE-Zweig    !strcmp(text

// . . Zuweisung Result "F_UWn_NR" . . . . . . . . . . . . . . . . . .

         temp = text1;
         strcat(temp, "_NR");
         var_result_long(temp, LIIdentifier);

// . . Zuweisung Result "F_UWn_TEXT" . . . . . . . . . . . . . . . . .
/***
         tabget(text, "UWTEXT");
         temp = text1;
         strcat(temp, "_TEXT");
         var_result_string(temp, text);
***/
// . . Zuweisung Result "F_UWn_EINH" . . . . . . . . . . . . . . . . .

         tabget(text, "UW_EINH");        
         temp = text1;
         strcat(temp, "_EINH");
         var_result_string(temp, text);

// . . Aufschluesselung des Types um die Laenge der UW zu ermitteln

         tabget(text, "UWTYP");
         if ((uw_typ & uw_typ_analog) || (uw_typ & uw_typ_hex)) {
            get_token(temp, text, " ", 1);

            temp[0] = temp[0] | 0x20;          // ! immer Kleinschrift
            if (temp[0] == 's')                  // unsigned / signed
               uw_typ = uw_typ | uw_typ_signed;     // ! hier : "ODER"
            if (temp[0] == 'm')                  // Intel / Motorola
               uw_typ = uw_typ | uw_typ_Motorola;   // ! hier : "ODER"

// . . Feststellen der Art der UW (3) Datentyp -> "uw_laenge"  . . . .

            get_token(temp, text, " ", 2);

            temp[0] = temp[0] | 0x20;     // ! immer Kleinschrift
            if (temp[0] == 'c')             // char
               uw_laenge = 1;
            else if (temp[0] == 'i')        // int
               uw_laenge = 2;
            else if (temp[0] == 'l')        // long
               uw_laenge = 4;
            else if (temp[0] == 'f') {      // float
               uw_laenge = 4;
               uw_typ = uw_typ | uw_typ_float;      // ! Typ -> float  (! hier : "ODER")
            }
            else if (temp[0] == 'd') {      // double
               uw_laenge = 8;
               uw_typ = uw_typ | uw_typ_double;     // ! Typ -> double (! hier : "ODER")
            }
            else {                          // ! Default: FEHLER
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?0A?", "NOT DEFINED TYPE (use: char, int, long, float, double)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?0A?", "NOT DEFINED TYPE (use: char, int, long, float, double)", response,"_RESPONSE_200X", 0);
               }
            }
         }

         else if (uw_typ & uw_typ_text)
            uw_laenge = atoi(text);  // Fehlerbehandlung ?

         else if ((uw_typ & uw_typ_digital) || (uw_typ & uw_typ_diskret)) 
            uw_laenge = (strlen(text) - 2) / 2;
            // z.B.: 0x4321 => 1.) strlen()-2=4 (ohne "0x")
            //                 2.) 4       /2=2 (2 Hex-Ziffern pro Byte)
            // else FEHLERMELDUNG
            // ---------------------------------
            // Zuweisung WERT

// . . Puffer für Ergebnis zuweisen (uw_wert_real, uw_wert_mask, uw_wert, ...)

         if (uw_gueltig == 1) { //Nur bei gueltiger UW
            if ((uw_typ & uw_typ_float) || (uw_typ & uw_typ_double)) // analoger Wert (real)
               data_to_real(uw_wert_real, response, offset, uw_laenge-4, uw_typ & uw_typ_Motorola);

            else if (uw_typ & uw_typ_text) {         // string mit n Bytes
               tabget(temp, "L/H");                  // Auswertung Byte-Order

               temp[0] = temp[0] | 0x20;             // ! immer Kleinschrift
               if (temp[0] == 'l')
                  uw_typ = uw_typ | uw_typ_low_high;      // ! hier : "ODER"
            }

            else { // Analogwert (long) oder digitaler/diskreter Wert . . . . . .
               tabget(temp, "L/H");                    // Auswertung Byte-Order

               temp[0] = temp[0] | 0x20;             // ! immer Kleinschrift
               if (temp[0] == 'l')
                  uw_typ = uw_typ | uw_typ_low_high;      // ! hier : "ODER"

               switch (uw_laenge) {
                  case 4: // signed long / ! unsigned long NICHT moeglich
                     // Sonderfall: Fuer Bitmasken unsigned erforderlich falls das hoechste Bit gesetzt ist
                     if ((uw_typ & uw_typ_digital) || (uw_typ & uw_typ_diskret)) {
                        if (uw_typ & uw_typ_low_high)  // low / middle_l / middle_h / high
                           uw_wert_mask =  response[offset]+ (response[offset+1] <<  8) + (response[offset+2] << 16) + (response[offset+3] << 24);
                        else                          // high / middle_h / middle_l / low
                           uw_wert_mask = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] <<  8) + response[offset+3];
                     }
                     else {                                // Normalfall: analoger Wert (signed)
                        if (uw_typ & uw_typ_low_high) // low / middle_l / middle_h / high 
                           uw_wert =  response[offset] + (response[offset+1] << 8) + (response[offset+2] << 16) + (response[offset+3] << 24);
                        else                      // high / middle_h / middle_l / low
                           uw_wert = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] << 8) + response[offset+3];
                     }
                     break;

                  case 2:                                  // unsigned int
                     if (uw_typ & uw_typ_low_high)  // low / high
                        uw_wert =  response[offset] + (response[offset+1] << 8);
                     else 
                        uw_wert = (response[offset  ] << 8) + response[offset+1];
   
                     if (uw_typ & uw_typ_signed) {         // -> signed
                        if (uw_wert > 32767)
                           uw_wert = uw_wert - 65536;
                     }

                     uw_wert_mask = uw_wert;               // bei int kein Unterschied
                     break;

                  case 1:                                  // unsigned char
                     uw_wert = response[offset];
   
                     if (uw_typ & uw_typ_signed) {         // -> signed
                        if (uw_wert > 127)
                           uw_wert = uw_wert - 256;
                     }

                     uw_wert_mask = uw_wert;               // bei char kein Unterschied
                     break;

                  default:                                 // ! Default: FEHLER
                     temp = UmweltTexte;
                     if (!strcmp(temp, "FUmweltTexte")) {
                        new_set_of_results();
                        var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                        return_with_message("?0A?", "LENGTH (BYTES) OF ENVIRONMENT CONDITION NOT ALLOWED", response,"_RESPONSE_SNAPSHOT", 0);
                     }
                     else {
                        new_set_of_results();
                        var_result_data("_RESPONSE_2000", response1);
                        return_with_message("?0A?", "LENGTH (BYTES) OF ENVIRONMENT CONDITION NOT ALLOWED", response,"_RESPONSE_200X", 0);
                     }
               } // Ende 'switch (uw_laenge)'
            } // Ende else Zweig von 'if ((uw_typ & uw_typ_float) || (uw_typ & uw_typ_double))'

// . . 1. Fall: digitale UW  . . . . . . . . . . . . . . . . . . . . .

            if (uw_typ & uw_typ_digital) {
               tabget(temp, "UWTYP");
               if (uw_laenge == 4) {                                       // ! Ein Wert vom Typ "unsigned long" kann        !
                  text = temp;                  // ! mit "atoi" nicht direkt interpretiert werden !
                  strerase(temp, 6, 4);         // ! -> (1) Aufteilung in 2 "int"-Werte           !
                  uw_mask = atoi(temp) & 0xFFFF;// ! -> (2) anschliessend zusammensetzen          !
                  uw_mask = uw_mask << 16;

                  strerase(text, 2, 4);
                  uw_mask = uw_mask | (atoi(text) & 0xFFFF);
               }
               else                                 // Normalfall: direkte Wandlung
                  uw_mask = atoi(temp);

               if ((uw_wert_mask & uw_mask) == uw_mask)
                  uw_wert = 1;
               else
                  uw_wert = 0;

               itor(uw_wert_real, uw_wert);         // -> real
            } // Ende 'if (uw_typ & uw_typ_digital)'

// . . 2. Fall: diskrete UW  . . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_diskret) {
               // !        tab2fix(uw_mask, "UWTYP");           // ! funktioniert nicht fuer hoechstes Bit

               tabget(temp, "UWTYP");
               if (uw_laenge == 4) {             // ! Ein Wert vom Typ "unsigned long" kann        !
                  strerase(temp, 6, 4);          // ! mit "atoi" nicht direkt interpretiert werden !
                  uw_mask = atoi(temp) & 0xFFFF; // ! -> (1) Aufteilung in 2 "int"-Werte           !
                  uw_mask = uw_mask << 16;       // ! -> (2) anschliessend zusammensetzen          !

                  tabget(temp, "UWTYP");
                  strerase(temp, 2, 4);
                  uw_mask = uw_mask | (atoi(temp) & 0xFFFF);
               }
               else                              // Normalfall: direkte Wandlung
                  uw_mask = atoi(temp);

               tabget(text, "NAME");             // Zusatztabelle <Name>

               set_trap_mask(0x0400);     // Trap-Bit für Tabellenzugriff setzen
               tabset(text);              // Tabelle bzgl. diskreter Werte oeffnen
               if (get_error(10)) {
                  text1 = "Table  not found";
                  strinsert(text1, text, 6);

                  temp = UmweltTexte;
                  if (!strcmp(temp, "FUmweltTexte")) {
                     new_set_of_results();
                     var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                     return_with_message("?0A?", text1, response,"_RESPONSE_SNAPSHOT", 0);
                  }
                  else {
                     new_set_of_results();
                     var_result_data("_RESPONSE_2000", response1);
                     return_with_message("?0A?", text1, response,"_RESPONSE_200X", 0);
                  }
               }
               set_trap_mask(0);          // Trap-Bit für Tabellenzugriff ruecksetzen

               uw_wert_mask = uw_wert_mask & uw_mask;   // ! beide Masken unsigned int
               itor(uw_wert_real, uw_wert_mask);        // -> real (für F_UWi_WERT)  /*** ***/
               tab_suche_unsigned("WERT", uw_wert_mask);

               set_trap_mask(0x0400);                   // Trap-Bit für Tabellenzugriff setzen
               tabget(text, "UWTEXT");                  // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
               set_trap_mask(0);                        // Trap-Bit für Tabellenzugriff ruecksetzen
               
               if (get_error(10))
                  tabget(text, "TEXT");                 // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
            
            } // Ende 'else if (uw_typ & uw_typ_diskret)'  !!! >> "text"  wird noch gebraucht (F_UWn_TEXT)

// . . 3 Fall: UW vom Typ Hex . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_hex) {
               itoax(text, uw_wert);                    // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
               strerase(text, 0, 10 - (2 * uw_laenge)) ;    // Anzahl: 2 + (8 - (2 * uw_laenge))
            }

// . . 4 Fall: UW vom Typ text .  . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_text) {
               ;  // keine Ergebnisberechnung erforderlich
            }

// . . 5 Fall: analoge UW . . . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_analog) {
               // ! nur bei long: d.h. nicht float / nicht double
               if (!(uw_typ & uw_typ_float) && !(uw_typ & uw_typ_double))       
                  itor(uw_wert_real, uw_wert);       // <Bytes aus SG-Antwort> -> real

               tabget(temp, "MUL");               // Multiplikator MUL
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "1";                                    // Default : 1
               ator(uw_mul_real, temp);           // -> real

               tabget(temp, "DIV");               // Divisor       DIV
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "1";                                    // Default : 1
               ator(uw_div_real, temp);           // -> real

               ator(uw_add_real, "0.0");          // uw_add_real kurzfristig als (real) 0.0
               if (realcomp(uw_div_real, "==", uw_add_real)) {   // ! FEHLER (Division durch "0")
                  temp = UmweltTexte;
                  if (!strcmp(temp, "FUmweltTexte")) {
                     new_set_of_results();
                     var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                     return_with_message("?0A?", "DIVISION BY ZERO", response,"_RESPONSE_SNAPSHOT", 0);
                  }
                  else {
                     new_set_of_results();
                     var_result_data("_RESPONSE_2000", response1);
                     return_with_message("?0A?", "DIVISION BY ZERO", response,"_RESPONSE_200X", 0);
                  }
               }

               tabget(temp, "ADD");               // Offset        ADD
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "0";                                    // Default : 0
               ator(uw_add_real, temp);           // -> real

               realmul (uw_wert_real, uw_mul_real); // uw_wert_real = ( uw_wert_real * uw_mul_real
               realdiv (uw_wert_real, uw_div_real); //                               / uw_div_real)
               realadd (uw_wert_real, uw_add_real); //                               + uw_add_real;
            } // Ende 'else if (uw_typ & uw_typ_analog'

// . . 6 Fall: Fehler, da nichts passt  . . . . . . . . . . . . . . .

            else {
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?12?", "TYPE uw_typ NOT DEFINED (1)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?12?", "TYPE uw_typ NOT DEFINED (1)", response,"_RESPONSE_200X", 0);
               }
            }

// . . Zuweisung Result "F_UWn_WERT" . . . . . . . . . . . . . . . . .

            temp = text1;
            strcat(temp, "_WERT");
/***
            if ((uw_typ & uw_typ_diskret) || (uw_typ & uw_typ_hex))    // (string) bei diskreten UW (string) bei UW vom Typ "Hex"
               var_result_string(temp, text);    // !!! << text1 wieder frei
            else                                 // (real)   bei sonstigen UW
               var_result_real(temp, uw_wert_real);
***/
            if (uw_typ & uw_typ_hex)             // (string) bei UW vom Typ "Hex"
               var_result_string(temp, text);

            else if (uw_typ & uw_typ_text) {     // (string) mit VS (Hr. Graf) abgestimmt !
               dataclear(temp);
               datacopy(temp, response, offset, uw_laenge); 

               if (uw_typ & uw_typ_low_high)
                 datarevers(temp);

               hex2ascii(text, temp, 0, uw_laenge);
                 
               temp = text1;
               strcat(temp, "_WERT");

               var_result_string(temp, text);
            }

            else                                 // (real)   bei sonstigen UW
               var_result_real(temp, uw_wert_real);
              		
               

// . . Zuweisung Result "F_UWn_TEXT" . . . . . . . . . . . . . . . . .   /*** ***/

            temp = text1;                                // !!! << text1 wieder frei
            strcat(temp, "_TEXT");

         // Es wird zuerst die Standard-Tabelle durchsucht
         tabset("DTCSnapshotIdentifier");
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)
         	tabset(UmweltTexte);                         // Wenn in der Standard-Tabelle der Eintrag nicht enthalten ist, dann wird auf die spezifische UW-Daten gegangen

            tab_suche_unsigned("UWNR", LIIdentifier);    // (wieder) in die richtige Zeile springen
            tabget(text1, "UWTEXT");

            if (uw_typ & uw_typ_diskret) {
               strcat(text1, ": ");
               strcat(text1, text);
            }
            var_result_string(temp, text1);

         } // Ende 'if (uw_gueltig  == 1) '

      } while (uw_sub_index);     // für alle Sub-Identifier abarbeiten !

   } // Ende else-Zweig von 'if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1703)'

   offset = offset + uw_laenge;   // bei digitaler oder diskreter UW nicht grundsätzlich weiterschalten !!!


// End of File

// end of : #include "UDS_FS_Snapshot.b2s"

#undef  UmweltTexte

      if (offset > daten_laenge) { // Der neue Offset ist länger als die Datenlänge
        uw_gueltig = 0;            // ! keine Resultbildung mehr
        new_set_of_results();
        if (_RESPONSE_EXTENDED_DATA) _RESPONSE_EXTENDED_DATA = response1;
        return_with_message("?0A?", "TOO MUCH DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_SNAPSHOT", 0);
      }
      else
        LICounterUW++;

// . . nach Bearbeitung eines kompletten UW-Satzes . . . . . . . . . .
// . . nach Bearbeitung aller UW-Saetze  . . . . . . . . . . . . . . .

      LICounterIdentifier--;
    } // Ende 'while(LLCounterIdentifier > 0)'


    if (offset < daten_laenge) {
      LISnapshotNumber++;
      offset = offset + 1;    // Byte DTCSnapshotRecordNumber = 2 oder 3 wird nicht ausgewertet
    }
    else
      LISnapshotNumber = uw_satz_anzahl + 1;   // = Abbruchkriterium für while-Schleife
//    LISnapshotNumber = 3;   // = Abbruchkriterium für while-Schleife

    if (F_UW_ANZ) // Anzahl der zusaetzlichen Umweltbedingungen ausgeben
      F_UW_ANZ = LIAnzUW;
                
    new_set_of_results();                   // neuer Ergebnissatz        
  } // Ende 'while (LISnapshotNumber < uw_satz_anzahl+1)'

// ---------------- JOB_STATUS,_RESPONSE* ---------------------------

  if (_RESPONSE_SNAPSHOT)
    _RESPONSE_SNAPSHOT = response;

  if (_RESPONSE_EXTENDED_DATA)
    _RESPONSE_EXTENDED_DATA = response1;
        
  if (_RESPONSE_SEVERITY)
    if (severity_exist)
      _RESPONSE_SEVERITY = "?";   // erst möglich, wenn mehr als 6 Array-Variablen zur Verfügung stehen!
    else
      _RESPONSE_SEVERITY = "-";
        
  if ((offset - daten_laenge) == 0)
    JOB_STATUS = "OKAY";
  else
    return_with_message("?12?", "INCORRECT NUMBER OF DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_SNAPSHOT", 0);
}

// End of File

// end of : #include "UDS_19_04_06_FS_LESEN_DETAIL.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_14_FS_LOESCHEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LOESCHEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 22.03.2005  gh  V0.001 Erstellung
// 14.11.2005  gr  V0.002 Anpassung auf send_and_receive_uds
//                        Einbau optionales Argument F_CODE 
// 01.02.2006  gr  V0.003 Fehler bei Interpretation des optionalen Arguments behoben
// 10.02.2006  gh  V0.004 lokale Variable "code" von int auf long erweitert
// *******************************************************************
// UDS_14_FS_LOESCHEN.B2S @(#)@ V0.004@(#)@
// *******************************************************************
job ( name      :       FS_LOESCHEN;
      comment   :       Fehlerspeicher loeschen;
      comment   :       UDS  : $14 ClearDiagnosticInformation;
      comment   :       UDS  : $FF DTCHighByte;
      comment   :       UDS  : $FF DTCMiddleByte;
      comment   :       UDS  : $FF DTCLowByte;
      comment   :       Modus: Default;

      argument  :       F_CODE;
        type    :       long;
        comment :       0x??????: Angabe eines einzelnen Fehlers;
        comment :       Default:; 
        comment :       0xFFFFFF: alle Fehler; 

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x14, 0xFF, 0xFF, 0xFF};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  
  // Variablen fuer Job
  unsigned long code;       // Fehlercode (in "auftrag")

// ---------------- Argumente des Jobs auswerten ---------------------    

  if (exist(F_CODE)) {
    code = F_CODE;
    request[1] = (code >>16) & 0xFF;
    request[2] = (code >> 8) & 0xFF;
    request[3] =  code       & 0xFF;
  }

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_14_FS_LOESCHEN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_10_00_PRUEFSTEMPEL_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : PRUEFSTEMPEL_LESEN
// -------------------------------------------------------------------
// Globale Variable   : SG_Adresse
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gueltig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 22.03.2005  gh  V0.001 Erstellung
// 28.07.2005  gh  V0.002 Namensänderung dieser Datei
// 28.07.2005  gh  V0.002 Entfernung defrslt
// 18.11.2005  gr  V0.003 Anpassung send_and_receice_uds
// 02.02.2006  gh  V0.004 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_22_10_00_PRUEFSTEMPEL_LESEN.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
job ( name      :       PRUEFSTEMPEL_LESEN;
      comment   :       Auslesen des Pruefstempels;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $1000 TestStamp;
      comment   :       Modus: Default;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       BYTE1;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      result    :       BYTE2;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      result    :       BYTE3;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x22, 0x10, 0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (BYTE1) 
        BYTE1 = response[3];

  if (BYTE2) 
        BYTE2 = response[4];

  if (BYTE3) 
        BYTE3 = response[5];

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_10_00_PRUEFSTEMPEL_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_2E_10_00_PRUEFSTEMPEL_SCHREIBEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : PRUEFSTEMPEL_SCHREIBEN
// -------------------------------------------------------------------
// Globale Variable   : SG_Adresse
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gueltig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 22.03.2005  gh  V0.001 Erstellung
// 28.07.2005  gh  V0.002 Namensänderung dieser Datei
// 28.07.2005  gh  V0.002 Entfernung defrslt
// 18.11.2005  gr  V0.003 Anpassung send_and_receice_uds
// 28.11.2005  rd  V0.004 Result JOB_STATUS dazu
// 02.02.2006  gh  V0.005 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_2E_10_00_PRUEFSTEMPEL_SCHREIBEN.B2S @(#)@ V0.005@(#)@
// *******************************************************************
job ( name      :       PRUEFSTEMPEL_SCHREIBEN;
      comment   :       Beschreiben des Pruefstempels;
      comment   :       Es muessen immer alle drei Argumente im Bereich;
      comment   :       von 0-255 bzw. 0x00-0xFF uebergeben werden.;
      comment   :       UDS  : $2E   WriteDataByIdentifier;
      comment   :       UDS  : $1000 TestStamp;
      comment   :       Modus: Default;

      argument  :       BYTE1;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      argument  :       BYTE2;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      argument  :       BYTE3;
        type    :       int;
        comment :       Bereich: 0-255 bzw. 0x00-0xFF;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x2E, 0x10, 0x00, 0x00, 0x00, 0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

           int  wert1;
           int  wert2;
           int  wert3;

// ---------------- Argumente des Jobs auswerten ---------------------

  if (exist(BYTE1)) {                      // 1. Byte
    wert1 = BYTE1;
    if (wert1 < 0 || wert1 > 255) {
      JOB_STATUS = "ERROR_BYTE1";
      return;
    }
  }
  else {
    JOB_STATUS = "ERROR_BYTE1";
    return;
  }

  if (exist(BYTE2)) {                      // 2. Byte
    wert2 = BYTE2;
    if (wert2 < 0 || wert2 > 255) {
      JOB_STATUS = "ERROR_BYTE2";
      return;
    }
  }
  else {
    JOB_STATUS = "ERROR_BYTE2";
    return;
  }

  if (exist(BYTE3)) {                      // 3. Byte
    wert3 = BYTE3;
    if (wert3 < 0 || wert3 > 255) {
      JOB_STATUS = "ERROR_BYTE3";
      return;
    }
  }
  else {
    JOB_STATUS = "ERROR_BYTE3";
    return;
  }

// ---------------- Kommunikation ------------------------------------

  request[3] = wert1;
  request[4] = wert2;
  request[5] = wert3;

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_2E_10_00_PRUEFSTEMPEL_SCHREIBEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_F1_01_SVK_LESEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : SVK_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
//                      Prozessklassen
//                      SVK_ID
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 07.11.2005  gr  V0.001 Erstellung
// 14.12.2005  gr  V0.002 Result PROG_KM hinzu, toleranter Umgang mit Fingerprintlaenge
// 02.02.2006  gh  V0.003 Ueberpruefung, ob Tabellen includiert sind, integriert
// 02.02.2006  gh  V0.003 Include-Name wie Tabellen-Name
// 30.03.2006  gh  V0.004 PROZESSKLASSE_WERT und VERSION: Berechnung korrigiert
// 27.03.2007  gh  V0.005 neues Result "PROG_TEST", Anforderer: Richard Kolbeck (für LDM)
// 19.10.2007  rd  V0.006 Result  SGBM_ID neu dazu
// *******************************************************************
// UDS_22_F1_01_SVK_LESEN.B2S @(#)@ V0.006 @(#)@
// *******************************************************************
job ( name      :       SVK_LESEN;
      comment   :       Informationen zur Steuergeraete-Verbau-Kennung;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $F1xx Sub-Parameter fuer SVK;
      comment   :       UDS  : $F101 SVK_AKTUELL (Default);     
      comment   :       Modus: Default;

      argument  :       SVK;
        type    :       string;
        comment :       table SVK_ID BEZEICHNUNG WERT;
        comment :       default SVK_AKTUELL;

      result    :       PROG_TEST;
        type    :       int;
        comment :       Programmierabhaengigkeiten (ProgrammingDependenciesChecked);
        comment :       1: IO : Signaturpruefung und ProgrammingDependenciesCheck erfolgreich;
        comment :       2: NIO: mindestens eine SWE fehlerhaft oder ProgrammingDependenciesCheck nicht durchgefuehrt;
        comment :       3: NIO: mindestens eine SWE passt nicht mit einer HWE zusammen;
        comment :       4: NIO: mindestens eine SWE passt nicht mit einer anderen SWE zusammen;
        comment :       sonst: reserviert;

      result    :       ANZAHL_EINHEITEN;
        type    :       int;
        comment :       Anzahl der xWEn;

      result    :       PROG_DATUM;
        type    :       string;
        comment :       Programmierdatum (DD.MM.YY);

      result    :       PROG_KM;
        type    :       long;
        comment :       KM-Stand bei Programmierung (10 KM bis 655350 KM);
        comment :       Inkrement sind 10 KM;
        comment :       -1: KM-Stand wird nicht unterstuetzt;

      result    :       PROZESSKLASSE_WERT;
        type    :       int;
        comment :       table Prozessklassen WERT;
        comment :       dezimale Angabe der Prozessklasse;

      result    :       PROZESSKLASSE_TEXT;
        type    :       string;
        comment :       table Prozessklassen BEZEICHNUNG;
        comment :       Text-Angabe der Prozessklasse;

      result    :       PROZESSKLASSE_KURZTEXT;
        type    :       string;
        comment :       table Prozessklassen PROZESSKLASSE;
        comment :       Text-Angabe des Prozessklassenkurztextes;

      result    :       SGBM_IDENTIFIER;
        type    :       string;
        comment :       Angabe SGBM-ID der Prozessklasse;

      result    :       VERSION;
        type    :       string;
        comment :       Angabe der Version der Prozessklasse;

      result    :       SGBM_ID;
        type    :       string;
        comment :       Angabe von Prozessklasse, SGBM-Identifier, Version;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
   unsigned char request[] = {0x22, 0xF1, 0x01};
   unsigned char SA_response;
   unsigned char TA_response;
   unsigned char response[];

   // Variablen fuer Job
   unsigned char temp[];  
   unsigned int  LIAnzahl;
            int  index = 0;
   unsigned char temp2[];
   unsigned char LSIndex[];
   unsigned int  LIFingerprint = 13;
   unsigned int  LISVK=0; 
   unsigned int  LIFingerprintIO = 1;
            int  datenlaenge;    
            char sgbmid[];

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
   INCLUDE_UDS_TAB_Prozessklassen_B2S_NOT_FOUND;
               
// ---------------- Argumente des Jobs auswerten ---------------------  
   if (exist(SVK)) {
      dataclear(temp);
      temp2 = SVK;

      // Tabelle SVK_ID nach uebergebenen Wert durchsuchen
      tabset("SVK_ID");
      if ((tabseek("BEZEICHNUNG",temp2)) != 0)
         tabget(temp, "WERT");
      else {      // keinen Eintrag gefunden                
         JOB_STATUS = "ERROR_ARGUMENT";
         return;  // weitere Verarbeitung abbrechen
      }
      
      request[2] = atoi(temp); 
   }

// ---------------- Kommunikation ------------------------------------ 

   if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

   if (PROG_TEST)
      PROG_TEST = response[4];

   dataclear(temp);
   datacopy(temp, response, 5, 2);
   LIAnzahl = (response[5] << 8) + response[6];      
  
   if (LIAnzahl == 0) {
      JOB_STATUS = "ERROR_NO_SVK";
   }
   else {
   // Länge Fingerprint auswerten. Die Länge des Fingerprints beträgt entweder 4 oder 13 Bytes.
   // Information steht im 4.Byte des Fingerprints (Byte 11 in SVK).
   // Ist das 7.Bit des Bytes eine 0, dann ist die Länge 4. Bei einer 1 beträgt die Länge 13.
      if (((response[10] >> 7) & 0x01) == 1)
         LIFingerprint = 13;
      else
         LIFingerprint = 4;                       

      datenlaenge =  datalen(response);

      // Schleife fuer die einzelnen xWEn
      while (index < LIAnzahl) {   
         sgbmid="";

         // Ueberpruefung der Datenlaenge // Fehlerabfangen, wenn kurzer Fingerprint geliefert wird, aber ein langer gemeint ist
         if ((datalen(response) != (7 + LIFingerprint + (LIAnzahl * 8))) && (datalen(response) != (7 + 13 + (LIAnzahl * 8)))) {
            if (ANZAHL_EINHEITEN) 
               ANZAHL_EINHEITEN = LIAnzahl;

            if (_REQUEST) 
               _REQUEST = request;

            if (_RESPONSE) 
               _RESPONSE = response;

            JOB_STATUS = "ERROR_SVK_INCORRECT_LEN";
            return;   
         }                               // Langer Fingerprint, aber Laengenangabe fuer kurzen Fingerprint angegeben
         else if ((datalen(response) == (7 + 13 + (LIAnzahl * 8))) && (LIFingerprint == 4)) {
            LIFingerprintIO = 0; // Fingerprint nicht IO
            LIFingerprint = 13;
         }         

         itoad(LSIndex, index+1);

         // Ausgabe der Prozessklasse        
         if (PROZESSKLASSE_WERT || PROZESSKLASSE_TEXT || PROZESSKLASSE_KURZTEXT || SGBM_ID) {
            // Abholen der Daten und Hex-String zusammenbauen        

            dataclear(temp2);
            LISVK = response[7 + LIFingerprint + (8*index)];

            if (PROZESSKLASSE_WERT)
               PROZESSKLASSE_WERT = LISVK;

            // Text aus Tabelle PROZESSKLASSEN holen
            tabset("Prozessklassen");
            tab_suche_unsigned("WERT", LISVK);

            if (PROZESSKLASSE_TEXT) {
               tabget(temp2, "BEZEICHNUNG");
               PROZESSKLASSE_TEXT = temp2;
            }

            if (PROZESSKLASSE_KURZTEXT || SGBM_ID) {
               tabget(temp2, "PROZESSKLASSE");
               if (PROZESSKLASSE_KURZTEXT) {
                  PROZESSKLASSE_KURZTEXT = temp2;
               }
               if (SGBM_ID) {
                  sgbmid=temp2;
                  strcat(sgbmid,"-");
               }
            }
         }

         // Ausgabe des Log.-Identifier
         if (SGBM_IDENTIFIER || SGBM_ID) {
            dataclear(temp);
            hex2ascii(temp, response, 8 + LIFingerprint + (8*index), 4); // Abholen der Daten 

            if (SGBM_IDENTIFIER) {
               SGBM_IDENTIFIER = temp;
            }
            if (SGBM_ID) {
               strcat(sgbmid,temp);
               strcat(sgbmid,"-");
            }
         }

         // Ausgabe der Versionsnummer 
         if (VERSION || SGBM_ID) {
            dataclear(temp);       
            dataclear(temp2);       

            // Hauptversionsnummer
            itoad(temp, response[12 + LIFingerprint + (8*index)]);
            if (strlen(temp) == 1)
               strinsert(temp, "00", 0); 
            if (strlen(temp) == 2)
               strinsert(temp, "0", 0); 
            strcat(temp,".");

            // Nebenversionsnummer
            itoad(temp2, response[13 + LIFingerprint + (8*index)]);
            if (strlen(temp2) == 1)
               strinsert(temp2, "00", 0); 
            if (strlen(temp2) == 2)
               strinsert(temp2, "0", 0); 
            strcat(temp,temp2);
            strcat(temp,".");

            // Patchversionsnummer
            itoad(temp2, response[14 + LIFingerprint + (8*index)]);
            if (strlen(temp2) == 1)
               strinsert(temp2, "00", 0); 
            if (strlen(temp2) == 2)
               strinsert(temp2, "0", 0); 
            strcat(temp,temp2);

            // Ausgabe Version
            if (VERSION)
               VERSION = temp;
            if (SGBM_ID) {
               strcat(sgbmid,temp);
            }
         }

         if (SGBM_ID) {
            SGBM_ID=sgbmid;
         }

         // neuen Ergebnissatz erzeugen            
         new_set_of_results();            

         index++;
      }      

      if (LIFingerprintIO == 1)
         JOB_STATUS = "OKAY";
      else
         JOB_STATUS = "ERROR_SVK_INCORRECT_FINGERPRINT";
   }  

   if (ANZAHL_EINHEITEN) 
      ANZAHL_EINHEITEN = LIAnzahl;

   if (PROG_DATUM) {
      bcd2ascii(temp, response, 9, 1);
      strcat(temp, ".");

      bcd2ascii(temp2, response, 8, 1);
      strcat(temp, temp2);
      strcat(temp, ".");

      bcd2ascii(temp2, response, 7, 1);
      strcat(temp, temp2);

      PROG_DATUM = temp;        
   }  

   if (PROG_KM) {
      if (LIFingerprint == 13)  // langer Fingerprint: Byte 18 und 19 enthalten den KM-Stand
         PROG_KM = ((response[18] << 8) + response[19]) * 10;  // lt. Lastenheft ist das Inkrement 10
      else
         PROG_KM = -1;        
   }

   if (_REQUEST)
      _REQUEST = request;

   if (_RESPONSE) 
      _RESPONSE = response;
}

// end of : #include "UDS_22_F1_01_SVK_LESEN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_STATUS_LESEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STATUS_LESEN
// -------------------------------------------------------------------
// Globale Konstanten : TA, MAX_ARGUMENT_STATUS_LESEN,
//                      UNCHECK_LEN_IDENTIFIER_LIST[]
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 02.12.2005  rd  V0.01 Erstellung
// 13.12.2005  rd  V0.02 ator durch aitor ersetzt damit auch Zahlen im
//             rd  V0.02 Hex-Format 0x... unterstützt werden
//             rd  V0.02 Fehlermeldung bei MUL=0
// 15.12.2005  rd  V0.03 Spalte RES_TABELLE dazu,
//             rd  V0.03 für mehrere Results eines DataIdentifiers
// 30.05.2006  rd  V0.10 Header überarbeitet
// 12.06.2006  rd  V0.11 Datentyp integer und BITFIELD dazu
// 20.06.2006  rd  V0.12 Fehlermeldung bei string überarbeitet
// 22.06.2006  rd  V0.20 Serviceüberprüfung dazu
// 24.07.2006  rd  V0.21 '0-n' _WERT- Results nicht erlaubt
// 27.03.2007  rd  V0.60 Serviceüberprüfung aktiv
//             rd  V0.60 Resultname beginnend mit _stat_ jetzt erlaubt
// 22.05.2007  rd  V0.75 Bug Bitfeld-Maske behoben
// 04.09.2007  rd  V0.80 Bug Analoger Wert unsigned long / long behoben
// 06.12.2007  rd  V1.00 Freigabe
// 22.11.2010  rd  V2.00 Bug unsigned integer l/h behoben
//                 V2.00 Bug bei Fehlerausgabe behoben
//                 V2.00 Einheit DATA, TEXT dazu
//                 V2.00 Anforderung VH-53 Waegner
//                 V2.00 Integration DUMMY_ bei Einheit DATA
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Integration Entfall Längenprüfung
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Freigabe
// *******************************************************************
// UDS_22_STATUS_LESEN.B2S @(#)@ V2.00 @(#)@
// *******************************************************************
job ( name      :       STATUS_LESEN;
      comment   :       Lesen eines oder mehrerer Stati;
      comment   :       UDS  : $22 ReadDataByIdentifier;

      argument  :       ARGUMENT_SPALTE;
        type    :       string;
        comment :       'ARG', 'ID', 'LABEL';

      argument  :       STATUS;
        type    :       string;
        comment :       Es muss mindestens ein Argument übergeben werden;
        comment :       Es wird das zugehörige result erzeugt;
        comment :       table SG_Funktionen ARG ID RESULTNAME RES_TABELLE ARG_TABELLE;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x22};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned char argument_name[];
  unsigned char argument_spalte[];
  unsigned char temp1[];
  unsigned char temp2[];
  unsigned int  i;
  unsigned int  k;
  unsigned int  n;
  unsigned int  id;
  unsigned int  id_response;
  unsigned int  len;
  unsigned int  unsigned_long_flag;
  unsigned int  hex_len;
  unsigned int  data_flag;
  unsigned int  data_pos;
  unsigned int  data_len;
  unsigned int  string_flag;
  unsigned int  string_pos;
  unsigned int  string_len;
  unsigned int  res_table_flag;
  unsigned int  line_res_table;
  unsigned int  size_bitfield;
  unsigned int  size_bitfield_old;
  unsigned int  line_bitfield_table;
  unsigned int  gefunden_flag;
           long value;
           long value_unsigned;
           long maske;
           real value_real;
           real real_temp1;
           real real_temp2;

// ---------------- Argumente des Jobs auswerten ---------------------
  if (exist(ARGUMENT_SPALTE)) {
    argument_spalte = ARGUMENT_SPALTE;
    strupper(argument_spalte);
    if ((strcmp(argument_spalte,"ARG")!=0) &&
        (strcmp(argument_spalte,"ID")!=0) &&
        (strcmp(argument_spalte,"LABEL")!=0)) {
      temp1="Argument ARGUMENT_SPALTE='";strcat(temp1,argument_spalte);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
  }
  else {
    var_result_string("JOB_MESSAGE","Argument ARGUMENT_SPALTE missing ('ARG', 'ID', 'LABEL').");
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

  if (!exist(STATUS)) {
    temp1="Argument STATUS[1] missing. MAX_ARGUMENT_STATUS_LESEN='";
    itoad(temp2,MAX_ARGUMENT_STATUS_LESEN);
    strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

// ---------------- Request erzeugen ---------------------------------
  set_trap_mask(0x400);
  tabset("SG_Funktionen");
  if (get_error(10)) {
    var_result_string("JOB_MESSAGE","Table 'SG_Funktionen' not found.");
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }
  n=1;
  i=1;
  do {
    if (!get_argument(argument_name,i+1)) break;
    if (strcmp(argument_name,"-")==0) {
      temp1="Argument STATUS[";
      itoad(temp2,i);
      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
    if (!tabseek(argument_spalte,argument_name)) {
      temp1="Argument STATUS[";
      itoad(temp2,i);
      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"' not found.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
    tabget(temp2,"SERVICE");
    if (strcmp(temp2,"-")!=0) {
      strupper(temp2);
      k=0;
      gefunden_flag=FALSE;
      while (temp2[k]!=0){
        if (temp2[k]=='2') {
          if (temp2[k+1]=='2') {
            gefunden_flag=TRUE;
            break;
          }
        }
        k++;
      }
      if (gefunden_flag==FALSE) {
        temp1="Argument STATUS[";
        itoad(temp2,i);
        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
        strcat(temp1,"' not valid. Service '22' not found in Table 'SG_Funktionen' column 'SERVICE'='");
        tabget(temp2,"SERVICE");
        strcat(temp1,temp2);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_ARGUMENT";
        set_trap_mask(0);
        return;
      }
    }
    tabget(temp2,"ID");
    id = atoi(temp2);
    request[n++] = id >> 8;
    request[n++] = id & 0xFF;
    i++;
  }
  while (i <= MAX_ARGUMENT_STATUS_LESEN);
  if (i > MAX_ARGUMENT_STATUS_LESEN) {
    if (get_argument(argument_name,i+1)) {
      temp1="Argument STATUS[";
      itoad(temp2,i);
      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"' too many arguments. MAX_ARGUMENT_STATUS_LESEN='");
      itoad(temp2,MAX_ARGUMENT_STATUS_LESEN);
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }

// ---------------- Kommunikation ------------------------------------
  if (_REQUEST) _REQUEST = request;
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "_RESPONSE", 2)) {
    set_trap_mask(0);
    return;
  }

// ---------------- Response auswerten -------------------------------
  n=1;
  i=1;
  do {
    tabset("SG_Funktionen");
    if (!get_argument(argument_name,i+1)) break;
    tabseek(argument_spalte,argument_name);
    tabget(temp2,"ID");
    id = atoi(temp2);
    id_response = (response[n]<<8)+response[n+1];
    n=n+2;
    if (datalen(response) < n) {
      temp1="Argument STATUS[";
      itoad(temp2,i);
      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
      set_trap_mask(0);
      return;
    }
    if (id_response != id) {
      temp1="Argument STATUS[";
      itoad(temp2,i);
      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response data identifier. Expected='");
      itoax(temp2,id);strerase(temp2,2,4);
      strcat(temp1,temp2);strcat(temp1,"' != Response='");
      itoax(temp2,id_response);strerase(temp2,2,4);
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_DATA_IDENTIFIER";
      set_trap_mask(0);
      return;
    }
    res_table_flag=FALSE;
    tabget(temp2,"RES_TABELLE");
    if (strcmp(temp2,"-")!=0) {
      tabset(temp2);
      if (get_error(10)) {
        temp1="Argument STATUS[";
        itoad(temp2,i);
        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Result table not found='");
        tabset("SG_Funktionen");
        tabseek(argument_spalte,argument_name);
        tabget(temp2,"RES_TABELLE");
        strcat(temp1,temp2);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_TABLE";
        set_trap_mask(0);
        return;
      }
      res_table_flag=TRUE;
      line_res_table=0;
      tabline(line_res_table);
    }
    do {
      // Längenprüfung abschalten ?
      // nur wenn keine Restdaten vorhanden
      if (datalen(response) == n) {
        // nur beim ersten Argument
        if (i==1) {
          // nur wenn kein zweites Argument
          if (!get_argument(temp1,2+1)) {
            len = datalen(UNCHECK_LEN_IDENTIFIER_LIST) / 2 ; // 1 Integer = 2 Byte
            k=0;
            do {
              if (UNCHECK_LEN_IDENTIFIER_LIST[k] != 0) {
                if (UNCHECK_LEN_IDENTIFIER_LIST[k] == id) {
                  // Zu wenig Daten. Restliche Results werden nicht erzeugt
                  temp1="Argument STATUS[";
                  itoad(temp2,i);
                  strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data. UNCHECK_LEN_IDENTIFIER_LIST contains ID='");
                  itoax(temp2,id);strerase(temp2,2,4);
                  strcat(temp1,temp2);strcat(temp1,"'. WARNING: Remaining results are not created.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "OKAY";
                  set_trap_mask(0);
                  return;
                }
              }
              k++;
            } while (k<len);
          }
        }
      }
      tabget(temp1,"EINHEIT");
      strlower(temp1);
      if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
        tabget(temp1,"DATENTYP");
        strlower(temp1);
        if ((strcmp(temp1,"char")==0) ||
            (strcmp(temp1,"unsigned char")==0) ||
            (strcmp(temp1,"signed char")==0)) {
          value = response[n];
          n++;
        }
        else {
          if ((strcmp(temp1,"int")==0) ||
              (strcmp(temp1,"integer")==0) ||
              (strcmp(temp1,"unsigned int")==0) ||
              (strcmp(temp1,"unsigned integer")==0) ||
              (strcmp(temp1,"signed int")==0) ||
              (strcmp(temp1,"signed integer")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L'))
              value = (response[n+1]<<8)+response[n];
            else
              value = (response[n]<<8)+response[n+1];
            n=n+2;
          }
          else {
            if ((strcmp(temp1,"long")==0) ||
                (strcmp(temp1,"unsigned long")==0) ||
                (strcmp(temp1,"signed long")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
              else
                value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
              n=n+4;
            }
            else {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
              tabget(temp2,"DATENTYP");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
        }
        if (datalen(response) < n) {
          temp1="Argument STATUS[";
          itoad(temp2,i);
          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
          set_trap_mask(0);
          return;
        }
        tabget(temp1,"RESULTNAME");
        len=strlen(temp1);
        if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
          temp1="Argument STATUS[";
          itoad(temp2,i);
          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        if (len >= 5) {
          temp2="";
          temp2[0] = temp1[len-5];
          temp2[1] = temp1[len-4];
          temp2[2] = temp1[len-3];
          temp2[3] = temp1[len-2];
          temp2[4] = temp1[len-1];
          temp2[5] = 0;
          strlower(temp2);
          if (strcmp(temp2,"_wert")==0) {
            temp1="Argument STATUS[";
            itoad(temp2,i);
            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
        temp2="";
        if (len >= 5) {
          temp2[0] = temp1[0];
          temp2[1] = temp1[1];
          temp2[2] = temp1[2];
          temp2[3] = temp1[3];
          temp2[4] = temp1[4];
          temp2[5] = 0;
          strlower(temp2);
        }
        if (strcmp(temp2,"stat_")!=0) {
          if (len >= 6) {
            temp2[5] = temp1[5];
            temp2[6] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_stat_")!=0) {
            temp1="Argument STATUS[";
            itoad(temp2,i);
            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
        var_result_long(temp1,value);
        strcat(temp1,"_INFO");
        tabget(temp2,"INFO");
        var_result_string(temp1,temp2);
        if ((value!=0) && (value!=1)) {
          temp1="Argument STATUS[";
          itoad(temp2,i);
          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Digital value not valid='");
          itoad(temp2,value);
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ECU_RESPONSE_VALUE_OUT_OF_RANGE";
          set_trap_mask(0);
          return;
        }
      }
      else {
        if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
          unsigned_long_flag=FALSE;
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            value = response[n];
            value_unsigned = value;
            if (strcmp(temp1,"unsigned char")!=0)
              if (value & 0x80) value = value | 0xFFFFFF00;
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+1]<<8)+response[n];
              else
                value = (response[n]<<8)+response[n+1];
              value_unsigned = value;
              if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                if (value & 0x8000) value = value | 0xFFFF0000;
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L'))
                  value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                else
                  value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                value_unsigned = value;
                n=n+4;
                if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
              }
              else {
                temp1="Argument STATUS[";
                itoad(temp2,i);
                strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
          }
          if (datalen(response) < n) {
            temp1="Argument STATUS[";
            itoad(temp2,i);
            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
            set_trap_mask(0);
            return;
          }
          tabget(temp1,"RESULTNAME");
          len=strlen(temp1);
          if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
            temp1="Argument STATUS[";
            itoad(temp2,i);
            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[len-5];
            temp2[1] = temp1[len-4];
            temp2[2] = temp1[len-3];
            temp2[3] = temp1[len-2];
            temp2[4] = temp1[len-1];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_wert")==0) {
            temp1="Argument STATUS[";
            itoad(temp2,i);
            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[0];
            temp2[1] = temp1[1];
            temp2[2] = temp1[2];
            temp2[3] = temp1[3];
            temp2[4] = temp1[4];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"stat_")!=0) {
            if (len >= 6) {
              temp2[5] = temp1[5];
              temp2[6] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"_stat_")!=0) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
          if (unsigned_long_flag == TRUE)
            var_result_unsigned_long(temp1,value);
          else
            var_result_long(temp1,value);

          strcat(temp1,"_EINH");
          tabget(temp2,"EINHEIT");
          var_result_string(temp1,temp2);

          strerase(temp1,len,5);
          strcat(temp1,"_INFO");
          tabget(temp2,"INFO");
          var_result_string(temp1,temp2);

          tabget(temp2,"NAME");
          if (strcmp(temp2,"-")!=0) {
            tabset(temp2);
            if (get_error(10)) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            tab_suche_unsigned("WERT",value_unsigned);
            if (get_error(10)) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            tabget(temp2,"TEXT");
            if (get_error(10)) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_spalte,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            strerase(temp1,len,5);
            strcat(temp1,"_TEXT");
            var_result_string(temp1,temp2);
          }
        }
        else {
          if (strcmp(temp1,"hex")==0) {
// Hex String
            unsigned_long_flag=FALSE;
            tabget(temp1,"DATENTYP");
            strlower(temp1);
            if ((strcmp(temp1,"char")==0) ||
                (strcmp(temp1,"unsigned char")==0) ||
                (strcmp(temp1,"signed char")==0)) {
              value = response[n];
              hex_len=2;
              n++;
            }
            else {
              if ((strcmp(temp1,"int")==0) ||
                  (strcmp(temp1,"integer")==0) ||
                  (strcmp(temp1,"unsigned int")==0) ||
                  (strcmp(temp1,"unsigned integer")==0) ||
                  (strcmp(temp1,"signed int")==0) ||
                  (strcmp(temp1,"signed integer")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L'))
                  value = (response[n+1]<<8)+response[n];
                else
                  value = (response[n]<<8)+response[n+1];
                hex_len=4;
                n=n+2;
              }
              else {
                if ((strcmp(temp1,"long")==0) ||
                    (strcmp(temp1,"unsigned long")==0) ||
                    (strcmp(temp1,"signed long")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L'))
                    value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                  else
                    value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                  hex_len=8;
                  n=n+4;
                }
                else {
                  temp1="Argument STATUS[";
                  itoad(temp2,i);
                  strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                  tabget(temp2,"DATENTYP");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
            }
            if (datalen(response) < n) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
              set_trap_mask(0);
              return;
            }
            tabget(temp1,"RESULTNAME");
            len=strlen(temp1);
            if (len > 63) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            temp2="";
            if (len >= 5) {
              temp2[0] = temp1[len-5];
              temp2[1] = temp1[len-4];
              temp2[2] = temp1[len-3];
              temp2[3] = temp1[len-2];
              temp2[4] = temp1[len-1];
              temp2[5] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"_wert")!=0) {
              temp1="Argument STATUS[";
              itoad(temp2,i);
              strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            temp2="";
            if (len >= 5) {
              temp2[0] = temp1[0];
              temp2[1] = temp1[1];
              temp2[2] = temp1[2];
              temp2[3] = temp1[3];
              temp2[4] = temp1[4];
              temp2[5] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"stat_")!=0) {
              if (len >= 6) {
                temp2[5] = temp1[5];
                temp2[6] = 0;
                strlower(temp2);
              }
              if (strcmp(temp2,"_stat_")!=0) {
                temp1="Argument STATUS[";
                itoad(temp2,i);
                strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                tabget(temp2,"RESULTNAME");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
            itoax(temp2,value);
            strerase(temp2,0,10-hex_len);
            strupper(temp2);
            var_result_string(temp1,temp2);

            strerase(temp1,len-5,5);
            strcat(temp1,"_EINH");
            tabget(temp2,"EINHEIT");
            var_result_string(temp1,temp2);

            strerase(temp1,len-5,5);
            strcat(temp1,"_INFO");
            tabget(temp2,"INFO");
            var_result_string(temp1,temp2);
          }
          else {
            if (strcmp(temp1,"bit")==0) {
// Bitfeld
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              if (strcmp(temp1,"bitfield")==0) {
                tabget(temp2,"NAME");
                tabset(temp2);
                if (get_error(10)) {
                  temp1="Argument STATUS[";
                  itoad(temp2,i);
                  strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. bitfield table not found='");
                  if (res_table_flag==FALSE) {
                    tabset("SG_Funktionen");
                    tabseek(argument_spalte,argument_name);
                  }
                  else {
                    tabset("SG_Funktionen");
                    tabseek(argument_spalte,argument_name);
                    tabget(temp2,"RES_TABELLE");
                    tabset(temp2);
                    tabline(line_res_table);
                  }
                  tabget(temp2,"NAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                size_bitfield=0;
                size_bitfield_old=0;
                line_bitfield_table=0;
                tabline(line_bitfield_table);
                do {
                  tabget(temp1,"EINHEIT");
                  strlower(temp1);
                  if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert im Bitfeld
                    tabget(temp1,"DATENTYP");
                    strlower(temp1);
                    if ((strcmp(temp1,"char")==0) ||
                        (strcmp(temp1,"unsigned char")==0) ||
                        (strcmp(temp1,"signed char")==0)) {
                      value = response[n];
                      size_bitfield=1;
                    }
                    else {
                      if ((strcmp(temp1,"int")==0) ||
                          (strcmp(temp1,"integer")==0) ||
                          (strcmp(temp1,"unsigned int")==0) ||
                          (strcmp(temp1,"unsigned integer")==0) ||
                          (strcmp(temp1,"signed int")==0) ||
                          (strcmp(temp1,"signed integer")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<8)+response[n+1];
                        size_bitfield=2;
                      }
                      else {
                        if ((strcmp(temp1,"long")==0) ||
                            (strcmp(temp1,"unsigned long")==0) ||
                            (strcmp(temp1,"signed long")==0)) {
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L'))
                            value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                          else
                            value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                          size_bitfield=4;
                        }
                        else {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                          tabget(temp2,"DATENTYP");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                    }
                    if (size_bitfield_old != size_bitfield) {
                      if (size_bitfield_old == 0) {
                        size_bitfield_old = size_bitfield;
                      }
                      else {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_spalte,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_spalte,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    if (datalen(response) < (n+size_bitfield)) {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                      set_trap_mask(0);
                      return;
                    }
                    tabget(temp1,"MASKE");
                    maske=atoi(temp1);
                    if ((maske & value) == maske)
                      value=1;
                    else
                      value=0;
                    tabget(temp1,"RESULTNAME");
                    len=strlen(temp1);
                    if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                    if (len >= 5) {
                      temp2="";
                      temp2[0] = temp1[len-5];
                      temp2[1] = temp1[len-4];
                      temp2[2] = temp1[len-3];
                      temp2[3] = temp1[len-2];
                      temp2[4] = temp1[len-1];
                      temp2[5] = 0;
                      strlower(temp2);
                      if (strcmp(temp2,"_wert")==0) {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    temp2="";
                    if (len >= 5) {
                      temp2[0] = temp1[0];
                      temp2[1] = temp1[1];
                      temp2[2] = temp1[2];
                      temp2[3] = temp1[3];
                      temp2[4] = temp1[4];
                      temp2[5] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"stat_")!=0) {
                      if (len >= 6) {
                        temp2[5] = temp1[5];
                        temp2[6] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"_stat_")!=0) {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    var_result_long(temp1,value);
                    strcat(temp1,"_INFO");
                    tabget(temp2,"INFO");
                    var_result_string(temp1,temp2);
                  }
                  else {
                    if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert im Bitfeld
                      unsigned_long_flag=FALSE;
                      tabget(temp1,"DATENTYP");
                      strlower(temp1);
                      if ((strcmp(temp1,"char")==0) ||
                          (strcmp(temp1,"unsigned char")==0) ||
                          (strcmp(temp1,"signed char")==0)) {
                        value = response[n];
                        value_unsigned = value;
                        if (strcmp(temp1,"unsigned char")!=0)
                          if (value & 0x80) value = value | 0xFFFFFF00;
                        size_bitfield=1;
                      }
                      else {
                        if ((strcmp(temp1,"int")==0) ||
                            (strcmp(temp1,"integer")==0) ||
                            (strcmp(temp1,"unsigned int")==0) ||
                            (strcmp(temp1,"unsigned integer")==0) ||
                            (strcmp(temp1,"signed int")==0) ||
                            (strcmp(temp1,"signed integer")==0)) {
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L'))
                            value = (response[n+1]<<8)+response[n];
                          else
                            value = (response[n]<<8)+response[n+1];
                          value_unsigned = value;
                          if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                            if (value & 0x8000) value = value | 0xFFFF0000;
                          size_bitfield=2;
                        }
                        else {
                          if ((strcmp(temp1,"long")==0) ||
                              (strcmp(temp1,"unsigned long")==0) ||
                              (strcmp(temp1,"signed long")==0)) {
                            tabget(temp2,"L/H");
                            if ((temp2[0]=='l') || (temp2[0]=='L'))
                              value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                            else
                              value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                            value_unsigned = value;
                            size_bitfield=4;
                            if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
                          }
                          else {
                            temp1="Argument STATUS[";
                            itoad(temp2,i);
                            strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                            tabget(temp2,"DATENTYP");
                            strcat(temp1,temp2);strcat(temp1,"'.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_TABLE";
                            set_trap_mask(0);
                            return;
                          }
                        }
                      }
                      if (size_bitfield_old != size_bitfield) {
                        if (size_bitfield_old == 0) {
                          size_bitfield_old = size_bitfield;
                        }
                        else {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      if (datalen(response) < (n+size_bitfield)) {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                        set_trap_mask(0);
                        return;
                      }
                      tabget(temp1,"MASKE");
                      maske=atoi(temp1);
                      value = maske & value;
                      value_unsigned = maske & value_unsigned;
                      tabget(temp1,"RESULTNAME");
                      len=strlen(temp1);
                      if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      temp2="";
                      if (len >= 5) {
                        temp2[0] = temp1[len-5];
                        temp2[1] = temp1[len-4];
                        temp2[2] = temp1[len-3];
                        temp2[3] = temp1[len-2];
                        temp2[4] = temp1[len-1];
                        temp2[5] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"_wert")==0) {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      temp2="";
                      if (len >= 5) {
                        temp2[0] = temp1[0];
                        temp2[1] = temp1[1];
                        temp2[2] = temp1[2];
                        temp2[3] = temp1[3];
                        temp2[4] = temp1[4];
                        temp2[5] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"stat_")!=0) {
                        if (len >= 6) {
                          temp2[5] = temp1[5];
                          temp2[6] = 0;
                          strlower(temp2);
                        }
                        if (strcmp(temp2,"_stat_")!=0) {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                          tabget(temp2,"RESULTNAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      if (unsigned_long_flag == TRUE)
                        var_result_unsigned_long(temp1,value);
                      else
                        var_result_long(temp1,value);

                      strcat(temp1,"_EINH");
                      tabget(temp2,"EINHEIT");
                      var_result_string(temp1,temp2);

                      strerase(temp1,len,5);
                      strcat(temp1,"_INFO");
                      tabget(temp2,"INFO");
                      var_result_string(temp1,temp2);

                      tabget(temp2,"NAME");
                      if (strcmp(temp2,"-")!=0) {
                        tabset(temp2);
                        if (get_error(10)) {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        tab_suche_unsigned("WERT",value_unsigned);
                        if (get_error(10)) {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        tabget(temp2,"TEXT");
                        if (get_error(10)) {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_spalte,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        strerase(temp1,len,5);
                        strcat(temp1,"_TEXT");
                        var_result_string(temp1,temp2);

                        // wieder zurück
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_spalte,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_spalte,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        tabset(temp2);
                      }
                    }
                    else {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  line_bitfield_table++;
                } while (tabline(line_bitfield_table));
                n = n + size_bitfield;
              }
              else {
                temp1="Argument STATUS[";
                itoad(temp2,i);
                strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
            else {
              if (strcmp(temp1,"data")==0) {
// Data
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                len = strlen(temp1);
                temp2="?????";
                strncpy(temp2,temp1,5);
                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,5);
                  data_len=atoi(temp2);
                  if ((data_len > 0) && (data_len < 256)) {
                    data_pos=n;
                    n=n+data_len;
                  }
                  else {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                    tabget(temp2,"DATENTYP");
                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                    itoad(temp2,data_len);
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  temp1="Argument STATUS[";
                  itoad(temp2,i);
                  strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                  tabget(temp2,"DATENTYP");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }

                if (datalen(response) < n) {
                  temp1="Argument STATUS[";
                  itoad(temp2,i);
                  strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                  set_trap_mask(0);
                  return;
                }
                tabget(temp1,"RESULTNAME");
                len=strlen(temp1);

                temp2="";
                if (len >= 6) {
                  temp2[0] = temp1[0];
                  temp2[1] = temp1[1];
                  temp2[2] = temp1[2];
                  temp2[3] = temp1[3];
                  temp2[4] = temp1[4];
                  temp2[5] = temp1[5];
                  temp2[6] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"dummy_")==0) {
                  // Warnung bei Dummy_
                  var_result_string("JOB_MESSAGE","Warning: RESULTNAME 'DUMMY_..' ignored.");
                }
                else {
                  if (len > 63) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_data")!=0) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  dataclear(temp2);
                  datacopy(temp2,response,data_pos,data_len);
                  var_result_data(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                }
              }
              else {
                if (strcmp(temp1,"text")==0) {
// Text
                  tabget(temp1,"DATENTYP");
                  strlower(temp1);
                  len = strlen(temp1);
                  temp2="???????";
                  strncpy(temp2,temp1,7);
                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                    temp2=temp1;
                    strerase(temp2,len-1,1);
                    strerase(temp2,0,7);
                    string_len=atoi(temp2);
                    if ((string_len > 0) && (string_len < 256)) {
                      string_pos=n;
                      n=n+string_len;
                    }
                    else {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                      itoad(temp2,string_len);
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    if (strcmp(temp1,"string")==0) {
                      k=0;
                      string_flag=FALSE;
                      while ((n+k) < datalen(response)) {
                        if (response[n+k]==0) {
                          string_flag=TRUE;
                          string_pos=n;
                          string_len=k+1;
                          n=n+string_len;
                          break;
                        }
                        k++;
                      }
                      if (string_flag==FALSE) {
                        temp1="Argument STATUS[";
                        itoad(temp2,i);
                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                        tabget(temp2,"DATENTYP");
                        strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    else {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  if (datalen(response) < n) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                    set_trap_mask(0);
                    return;
                  }
                  tabget(temp1,"RESULTNAME");
                  len=strlen(temp1);
                  if (len > 63) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_text")!=0) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  dataclear(temp2);
                  datacopy(temp2,response,string_pos,string_len);
                  temp2[string_len]=0;
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                }
                else {
// Analoger Wert
                  data_flag=FALSE;
                  string_flag=FALSE;
                  tabget(temp1,"DATENTYP");
                  strlower(temp1);
                  if ((strcmp(temp1,"char")==0) ||
                      (strcmp(temp1,"unsigned char")==0) ||
                      (strcmp(temp1,"signed char")==0)) {
                    value = response[n];
                    if (strcmp(temp1,"unsigned char")!=0)
                      if (value & 0x80) value = value | 0xFFFFFF00;
                    itor(value_real,value);
                    n++;
                  }
                  else {
                    if ((strcmp(temp1,"int")==0) ||
                        (strcmp(temp1,"integer")==0) ||
                        (strcmp(temp1,"unsigned int")==0) ||
                        (strcmp(temp1,"unsigned integer")==0) ||
                        (strcmp(temp1,"signed int")==0) ||
                        (strcmp(temp1,"signed integer")==0)) {
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L'))
                        value = (response[n+1]<<8)+response[n];
                      else
                        value = (response[n]<<8)+response[n+1];
                      if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                        if (value & 0x8000) value = value | 0xFFFF0000;
                      itor(value_real,value);
                      n=n+2;
                    }
                    else {
                      if ((strcmp(temp1,"long")==0) ||
                          (strcmp(temp1,"unsigned long")==0) ||
                          (strcmp(temp1,"signed long")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                        itor(value_real,value);
                        if (strcmp(temp1,"unsigned long")==0) {
                          if (value & 0x80000000) {
                            ator(real_temp1,"4294967296");
                            realadd(value_real,real_temp1);
                          }
                        }
                        n=n+4;
                      }
                      else {
                        if ((strcmp(temp1,"float")==0) ||
                            (strcmp(temp1,"intel float")==0)) {
                          data_to_real(value_real,response,n,0,0);
                          n=n+4;
                        }
                        else {
                          if (strcmp(temp1,"motorola float")==0) {
                            data_to_real(value_real,response,n,0,1);
                            n=n+4;
                          }
                          else {
                            if ((strcmp(temp1,"double")==0) ||
                                (strcmp(temp1,"intel double")==0)) {
                              data_to_real(value_real,response,n,1,0);
                              n=n+8;
                            }
                            else {
                              if (strcmp(temp1,"motorola double")==0) {
                                data_to_real(value_real,response,n,1,1);
                                n=n+8;
                              }
                              else {
                                len = strlen(temp1);
                                temp2="?????";
                                strncpy(temp2,temp1,5);
                                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                                  temp2=temp1;
                                  strerase(temp2,len-1,1);
                                  strerase(temp2,0,5);
                                  data_len=atoi(temp2);
                                  if ((data_len > 0) && (data_len < 256)) {
                                    data_flag=TRUE;
                                    data_pos=n;
                                    n=n+data_len;
                                  }
                                  else {
                                    temp1="Argument STATUS[";
                                    itoad(temp2,i);
                                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                    tabget(temp2,"DATENTYP");
                                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                    itoad(temp2,data_len);
                                    strcat(temp1,temp2);strcat(temp1,"'.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_TABLE";
                                    set_trap_mask(0);
                                    return;
                                  }
                                }
                                else {
                                  len = strlen(temp1);
                                  temp2="???????";
                                  strncpy(temp2,temp1,7);
                                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                                    temp2=temp1;
                                    strerase(temp2,len-1,1);
                                    strerase(temp2,0,7);
                                    string_len=atoi(temp2);
                                    if ((string_len > 0) && (string_len < 256)) {
                                      string_flag=TRUE;
                                      string_pos=n;
                                      n=n+string_len;
                                    }
                                    else {
                                      temp1="Argument STATUS[";
                                      itoad(temp2,i);
                                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                      tabget(temp2,"DATENTYP");
                                      strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                      itoad(temp2,string_len);
                                      strcat(temp1,temp2);strcat(temp1,"'.");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_TABLE";
                                      set_trap_mask(0);
                                      return;
                                    }
                                  }
                                  else {
                                    if (strcmp(temp1,"string")==0) {
                                      k=0;
                                      string_flag=FALSE;
                                      while ((n+k) < datalen(response)) {
                                        if (response[n+k]==0) {
                                          string_flag=TRUE;
                                          string_pos=n;
                                          string_len=k+1;
                                          n=n+string_len;
                                          break;
                                        }
                                        k++;
                                      }
                                      if (string_flag==FALSE) {
                                        temp1="Argument STATUS[";
                                        itoad(temp2,i);
                                        strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                        tabget(temp2,"DATENTYP");
                                        strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                                        var_result_string("JOB_MESSAGE",temp1);
                                        JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                                        set_trap_mask(0);
                                        return;
                                      }
                                    }
                                    else {
                                      temp1="Argument STATUS[";
                                      itoad(temp2,i);
                                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                                      tabget(temp2,"DATENTYP");
                                      strcat(temp1,temp2);strcat(temp1,"'.");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_TABLE";
                                      set_trap_mask(0);
                                      return;
                                    }  // else string
                                  }  // else string[
                                }  // else data[
                              }  // else motorola double
                            }  // else intel double
                          }  // else motorola float
                        }  // else intel float
                      }  // else long
                    }  // else int
                  }  // else char
                  if (datalen(response) < n) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                    set_trap_mask(0);
                    return;
                  }
                  tabget(temp1,"RESULTNAME");
                  len=strlen(temp1);
                  if (len > 63) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_wert")!=0) {
                    temp1="Argument STATUS[";
                    itoad(temp2,i);
                    strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS[";
                      itoad(temp2,i);
                      strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  if (data_flag==TRUE) {
                    dataclear(temp2);
                    datacopy(temp2,response,data_pos,data_len);
                    var_result_long(temp1,0);
                    strerase(temp1,len-5,5);
                    strcat(temp1,"_DATA");
                    var_result_data(temp1,temp2);
                  }
                  else {
                    if (string_flag==TRUE) {
                      dataclear(temp2);
                      datacopy(temp2,response,string_pos,string_len);
                      temp2[string_len]=0;
                      var_result_long(temp1,0);
                      strerase(temp1,len-5,5);
                      strcat(temp1,"_TEXT");
                      var_result_string(temp1,temp2);
                    }
                    else {
                      tabget(temp2,"MUL");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Multiplication with Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realmul(value_real,real_temp1);
                      }
                      tabget(temp2,"DIV");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument STATUS[";
                          itoad(temp2,i);
                          strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);strcat(temp1,"'. Division by Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realdiv(value_real,real_temp1);
                      }
                      tabget(temp2,"ADD");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        realadd(value_real,real_temp1);
                      }
                      var_result_real(temp1,value_real);
                    }
                  }

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                } // else Text
              } // else Data
            } // else Bitfeld
          } // else Hex String
        } // else Diskreter Wert
      } // else Digitaler Wert
      if (res_table_flag==TRUE) {
        tabset("SG_Funktionen");
        tabseek(argument_spalte,argument_name);
        tabget(temp2,"RES_TABELLE");
        tabset(temp2);
        line_res_table++;
        if (!tabline(line_res_table)) res_table_flag=FALSE;
      }
    } while (res_table_flag==TRUE);
    i++;
  }
  while (i <= MAX_ARGUMENT_STATUS_LESEN);
  if (datalen(response) != n) {
    temp1="Too much data.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_MUCH_DATA";
    set_trap_mask(0);
    return;
  }
  JOB_STATUS = "OKAY";
  set_trap_mask(0);
}
// end of : #include "UDS_22_STATUS_LESEN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_2E_STEUERN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN
// -------------------------------------------------------------------
// Globale Konstanten : TA
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 12.12.2005  rd  V0.01 Erstellung
// 30.05.2006  rd  V0.10 Header überarbeitet
// 12.06.2006  rd  V0.11 Datentyp integer dazu
// 22.06.2006  rd  V0.20 Serviceüberprüfung dazu
// 24.07.2006  rd  V0.21 '0-n' _WERT- Results nicht erlaubt
// 06.03.2007  rd  V0.50 Bei diskretem Argument. Wenn Argument nicht
//             rd  V0.50 in Spalte Text gefunden wird,
//             rd  V0.50 dann auch in Spalte WERT suchen
// 27.03.2007  rd  V0.60 Serviceüberprüfung aktiv
// 06.12.2007  rd  V1.00 Freigabe
// 22.11.2010  rd  V2.00 Bug bei Fehlerausgabe behoben
//                 V2.00 Freigabe
// *******************************************************************
// UDS_2E_STEUERN.B2S @(#)@ V2.00 @(#)@
// *******************************************************************
job ( name      :       STEUERN;
      comment   :       Vorgeben eines Status;
      comment   :       UDS  : $2E WriteDataByIdentifier;

      argument  :       ARGUMENT_SPALTE;
        type    :       string;
        comment :       'ARG', 'ID', 'LABEL';

      argument  :       STATUS;
        type    :       string;
        comment :       Siehe table SG_Funktionen ARG ID LABEL ARG_TABELLE;

      argument  :       WERT;
        type    :       string;
        comment :       Es muss mindestens ein Argument übergeben werden;
        comment :       Argumente siehe table SG_Funktionen ARG ID ARG_TABELLE;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x2E};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned char argument_name[];
  unsigned char argument_string[];
  unsigned char temp1[];
  unsigned char temp2[];
  unsigned int  k;
  unsigned int  n;
  unsigned int  id;
  unsigned int  id_response;
  unsigned int  len;
  unsigned int  anz_arg;
  unsigned int  found_flag;
  unsigned int  data_len;
  unsigned int  gefunden_flag;
  unsigned long argument_unsigned;
           long value;
           real value_real;
           real real_temp1;
           real real_temp2;

// ---------------- Argumente des Jobs auswerten ---------------------
  if (exist(ARGUMENT_SPALTE)) {
    argument_string = ARGUMENT_SPALTE;
    strupper(argument_string);
    if ((strcmp(argument_string,"ARG")!=0) &&
        (strcmp(argument_string,"ID")!=0) &&
        (strcmp(argument_string,"LABEL")!=0)) {
      temp1="Argument ARGUMENT_SPALTE='";strcat(temp1,argument_string);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
  }
  else {
    var_result_string("JOB_MESSAGE","Argument ARGUMENT_SPALTE missing ('ARG', 'ID', 'LABEL').");
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

  if (!exist(STATUS)) {
    temp1="Argument STATUS missing.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

// ---------------- Request erzeugen ---------------------------------
  set_trap_mask(0x400);
  tabset("SG_Funktionen");
  if (get_error(10)) {
    var_result_string("JOB_MESSAGE","Table 'SG_Funktionen' not found.");
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }
  argument_name=STATUS;
  if (strcmp(argument_name,"-")==0) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not valid.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  if (!tabseek(argument_string,argument_name)) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not found.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  tabget(temp2,"SERVICE");
  if (strcmp(temp2,"-")!=0) {
    strupper(temp2);
    k=0;
    gefunden_flag=FALSE;
    while (temp2[k]!=0){
      if (temp2[k]=='2') {
        if (temp2[k+1]=='E') {
          gefunden_flag=TRUE;
          break;
        }
      }
      k++;
    }
    if (gefunden_flag==FALSE) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);
      strcat(temp1,"' not valid. Service '2E' not found in Table 'SG_Funktionen' column 'SERVICE'='");
      tabget(temp2,"SERVICE");
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }
  n=1;
  tabget(temp2,"ID");
  id = atoi(temp2);
  request[n++] = id >> 8;
  request[n++] = id & 0xFF;
  tabget(argument_string,"ARG_TABELLE");
  if (strcmp(argument_string,"-")==0) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. ARG_TABELLE='-' not valid.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }
  tabset(argument_string);
  if (get_error(10)) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Argument table not found='");
    strcat(temp1,argument_string);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }
  if (WERT); // damit die Compilerwarnung entfällt
  anz_arg=0;
  while (tabline(anz_arg)) {
    if (!get_argument(argument_name,anz_arg+3)) {
      tabget(temp1,"DATENTYP");
      strlower(temp1);
      if (strcmp(temp1,"string")!=0) { // Leerstring erlauben
        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);
        strcat(temp1,"] missing. Argument table='");strcat(temp1,argument_string);
        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_ARGUMENT";
        set_trap_mask(0);
        return;
      }
    }
    tabget(temp1,"EINHEIT");
    strlower(temp1);
    if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
      aitor(value_real,argument_name);
      value=atoi(argument_name);
      if ((strcmp(argument_name,"0")!=0) && (strcmp(argument_name,"1")!=0)) {
        temp1="Argument WERT[";
        itoad(temp2,anz_arg+1);
        strcat(temp1,temp2);strcat(temp1,"] Digital value not valid='");
        strcat(temp1,argument_name);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_ARGUMENT";
        set_trap_mask(0);
        return;
      }
      tabget(temp1,"MIN");
      if (strcmp(temp1,"-")!=0) {
        aitor(real_temp1,temp1);
        if (realcomp(value_real,"<",real_temp1)) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Out of range. '");
          strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ARGUMENT";
          set_trap_mask(0);
          return;
        }
      }
      tabget(temp1,"MAX");
      if (strcmp(temp1,"-")!=0) {
        aitor(real_temp1,temp1);
        if (realcomp(value_real,">",real_temp1)) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Out of range. '");
          strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ARGUMENT";
          set_trap_mask(0);
          return;
        }
      }
      tabget(temp1,"DATENTYP");
      strlower(temp1);
      if ((strcmp(temp1,"char")==0) ||
          (strcmp(temp1,"unsigned char")==0) ||
          (strcmp(temp1,"signed char")==0)) {
        request[n] = value;
        n++;
      }
      else {
        if ((strcmp(temp1,"int")==0) ||
            (strcmp(temp1,"integer")==0) ||
            (strcmp(temp1,"unsigned int")==0) ||
            (strcmp(temp1,"unsigned integer")==0) ||
            (strcmp(temp1,"signed int")==0) ||
            (strcmp(temp1,"signed integer")==0)) {
          tabget(temp2,"L/H");
          if ((temp2[0]=='l') || (temp2[0]=='L')) {
            request[n]   = value;
            request[n+1] = value>>8;
          }
          else {
            request[n+1] = value;
            request[n]   = value>>8;
          }
          n=n+2;
        }
        else {
          if ((strcmp(temp1,"long")==0) ||
              (strcmp(temp1,"unsigned long")==0) ||
              (strcmp(temp1,"signed long")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L')) {
              request[n]   = value;
              request[n+1] = value>>8;
              request[n+2] = value>>16;
              request[n+3] = value>>24;
            }
            else {
              request[n+3] = value;
              request[n+2] = value>>8;
              request[n+1] = value>>16;
              request[n]   = value>>24;
            }
            n=n+4;
          }
          else {
            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
            strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
      }
    }
    else {
      if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
        tabget(temp2,"NAME");
        if (strcmp(temp2,"-")==0) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. NAME not valid='");tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        tabset(temp2);
        if (get_error(10)) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          tabset(argument_string);tabline(anz_arg);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Discrete value table not found='");
          tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        found_flag=tabseek("TEXT",argument_name);
        if (get_error(10)) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          tabset(argument_string);tabline(anz_arg);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Discrete value table='");
          tabget(temp2,"NAME");strcat(temp1,temp2);
          strcat(temp1,"'. Column 'TEXT' not found.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        if (found_flag!=TRUE) {
          // Wenn nicht in Spalte Text gefunden, dann auch in Spalte Wert als Zahl suchen
          if (is_hex_string(argument_name) || is_unsigned_string(argument_name)) {
            argument_unsigned = atoi(argument_name);
            found_flag=tab_suche_unsigned("WERT",argument_unsigned);
            if (get_error(10)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              tabset(argument_string);tabline(anz_arg);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Discrete value table='");
              tabget(temp2,"NAME");strcat(temp1,temp2);
              strcat(temp1,"'. Column 'WERT' not found.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
        }
        if (found_flag!=TRUE) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          tabset(argument_string);tabline(anz_arg);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Discrete table='");
          tabget(temp2,"NAME");strcat(temp1,temp2);
          strcat(temp1,"'. Argument not found.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ARGUMENT";
          set_trap_mask(0);
          return;
        }
        tabget(temp1,"WERT");
        aitor(value_real,temp1);
        value=atoi(temp1);
        if (get_error(10)) {
          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
          tabset(argument_string);tabline(anz_arg);
          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
          strcat(temp1,"'. Discrete value table='");
          tabget(temp2,"NAME");strcat(temp1,temp2);
          strcat(temp1,"'. Column 'WERT' not found.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        // wieder zurück zur Tabelle
        tabset(argument_string);
        tabline(anz_arg);
        tabget(temp1,"MIN");
        if (strcmp(temp1,"-")!=0) {
          aitor(real_temp1,temp1);
          if (realcomp(value_real,"<",real_temp1)) {
            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
            strcat(temp1,"'. Out of range. '");
            strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ARGUMENT";
            set_trap_mask(0);
            return;
          }
        }
        tabget(temp1,"MAX");
        if (strcmp(temp1,"-")!=0) {
          aitor(real_temp1,temp1);
          if (realcomp(value_real,">",real_temp1)) {
            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
            strcat(temp1,"'. Out of range. '");
            strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ARGUMENT";
            set_trap_mask(0);
            return;
          }
        }
        tabget(temp1,"DATENTYP");
        strlower(temp1);
        if ((strcmp(temp1,"char")==0) ||
            (strcmp(temp1,"unsigned char")==0) ||
            (strcmp(temp1,"signed char")==0)) {
          request[n] = value;
          n++;
        }
        else {
          if ((strcmp(temp1,"int")==0) ||
              (strcmp(temp1,"integer")==0) ||
              (strcmp(temp1,"unsigned int")==0) ||
              (strcmp(temp1,"unsigned integer")==0) ||
              (strcmp(temp1,"signed int")==0) ||
              (strcmp(temp1,"signed integer")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L')) {
              request[n]   = value;
              request[n+1] = value>>8;
            }
            else {
              request[n+1] = value;
              request[n]   = value>>8;
            }
            n=n+2;
          }
          else {
            if ((strcmp(temp1,"long")==0) ||
                (strcmp(temp1,"unsigned long")==0) ||
                (strcmp(temp1,"signed long")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L')) {
                request[n]   = value;
                request[n+1] = value>>8;
                request[n+2] = value>>16;
                request[n+3] = value>>24;
              }
              else {
                request[n+3] = value;
                request[n+2] = value>>8;
                request[n+1] = value>>16;
                request[n]   = value>>24;
              }
              n=n+4;
            }
            else {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
        }
      }
      else {
        if (strcmp(temp1,"hex")==0) {
// Hex String
          aitor(value_real,argument_name);
          value=atoi(argument_name);
          tabget(temp1,"MIN");
          if (strcmp(temp1,"-")!=0) {
            aitor(real_temp1,temp1);
            if (realcomp(value_real,"<",real_temp1)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Out of range. '");
              strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
          }
          tabget(temp1,"MAX");
          if (strcmp(temp1,"-")!=0) {
            aitor(real_temp1,temp1);
            if (realcomp(value_real,">",real_temp1)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Out of range. '");
              strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
          }
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            request[n] = value;
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L')) {
                request[n]   = value;
                request[n+1] = value>>8;
              }
              else {
                request[n+1] = value;
                request[n]   = value>>8;
              }
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                  request[n]   = value;
                  request[n+1] = value>>8;
                  request[n+2] = value>>16;
                  request[n+3] = value>>24;
                }
                else {
                  request[n+3] = value;
                  request[n+2] = value>>8;
                  request[n+1] = value>>16;
                  request[n]   = value>>24;
                }
                n=n+4;
              }
              else {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
          }
        }
        else {
// Analoger Wert
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          len = strlen(temp1);
          temp2="?????";
          strncpy(temp2,temp1,5);
          if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
            temp2=temp1;
            strerase(temp2,len-1,1);
            strerase(temp2,0,5);
            data_len=atoi(temp2);
            if ((data_len > 0) && (data_len < 256)) {
              len=strlen(argument_name);
              if (len == 2*data_len) {
                ascii2hex(request,argument_name,n);
                n=n+data_len;
                if (datalen(request) != n) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                  strcat(temp1,"'. Invalid characters in argument. Valid characters=0123456789ABCDEF.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              else {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                if (len < 2*data_len)
                  strcat(temp1,"'. Too less data. Expected argument string len='");
                else
                  strcat(temp1,"'. Too much data. Expected argument string len='");
                itoad(temp2,2*data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
            }
            else {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
              strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
          else {
            len = strlen(temp1);
            temp2="???????";
            strncpy(temp2,temp1,7);
            if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
              temp2=temp1;
              strerase(temp2,len-1,1);
              strerase(temp2,0,7);
              data_len=atoi(temp2);
              if ((data_len > 0) && (data_len < 256)) {
                len=strlen(argument_name);
                if (len == data_len) {
                  datacat(request,argument_name);
                  dataerase(request,n+data_len,1);  // String end character '0x00' entfernen
                  n=n+data_len;
                }
                else {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                  if (len < data_len)
                    strcat(temp1,"'. Too less data. Expected argument string len='");
                  else
                    strcat(temp1,"'. Too much data. Expected argument string len='");
                  itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              else {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
            else {
              if (strcmp(temp1,"string")==0) {
                data_len=strlen(argument_name)+1; // String end character '0x00'
                if ((data_len > 0) && (data_len < 256)) {
                  datacat(request,argument_name);
                  n=n+data_len;
                }
                else {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                  strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              else {
                aitor(value_real,argument_name);
                tabget(temp1,"MIN");
                if (strcmp(temp1,"-")!=0) {
                  aitor(real_temp1,temp1);
                  if (realcomp(value_real,"<",real_temp1)) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                }
                tabget(temp1,"MAX");
                if (strcmp(temp1,"-")!=0) {
                  aitor(real_temp1,temp1);
                  if (realcomp(value_real,">",real_temp1)) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                }
                tabget(temp2,"MUL");
                if (strcmp(temp2,"-")!=0) {
                  aitor(real_temp1,temp2);
                  ator(real_temp2,"0");
                  if (realcomp(real_temp1,"==",real_temp2))
                  {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Multiplication with Zero.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  realmul(value_real,real_temp1);
                }
                tabget(temp2,"DIV");
                if (strcmp(temp2,"-")!=0) {
                  aitor(real_temp1,temp2);
                  ator(real_temp2,"0");
                  if (realcomp(real_temp1,"==",real_temp2))
                  {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Division by Zero.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  realdiv(value_real,real_temp1);
                }
                tabget(temp2,"ADD");
                if (strcmp(temp2,"-")!=0) {
                  aitor(real_temp1,temp2);
                  realadd(value_real,real_temp1);
                }
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                if ((strcmp(temp1,"char")==0) ||
                    (strcmp(temp1,"signed char")==0)) {
                  value=rtoi_round(value_real);
                  if (value < -128) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -128.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                  if (value > 127) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 127.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                  request[n] = value;
                  n++;
                }
                else {
                  if (strcmp(temp1,"unsigned char")==0) {
                    value=rtoi_round(value_real);
                    if (value < 0) {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Out of range. '");
                      itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                    if (value > 255) {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Out of range. '");
                      itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 255.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                    request[n] = value;
                    n++;
                  }
                  else {
                    if ((strcmp(temp1,"int")==0) ||
                        (strcmp(temp1,"integer")==0) ||
                        (strcmp(temp1,"signed int")==0) ||
                        (strcmp(temp1,"signed integer")==0)) {
                      value=rtoi_round(value_real);
                      if (value < -32768) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -32768.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                      if (value > 32767) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 32767.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L')) {
                        request[n]   = value;
                        request[n+1] = value>>8;
                      }
                      else {
                        request[n+1] = value;
                        request[n]   = value>>8;
                      }
                      n=n+2;
                    }
                    else {
                      if ((strcmp(temp1,"unsigned int")==0) ||
                          (strcmp(temp1,"unsigned integer")==0)) {
                        value=rtoi_round(value_real);
                        if (value < 0) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        if (value > 65535) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 65535.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L')) {
                          request[n]   = value;
                          request[n+1] = value>>8;
                        }
                        else {
                          request[n+1] = value;
                          request[n]   = value>>8;
                        }
                        n=n+2;
                      }
                      else {
                        if ((strcmp(temp1,"long")==0) ||
                            (strcmp(temp1,"signed long")==0)) {
                          ator(real_temp1,"-2147483648");
                          if (realcomp(value_real,"<",real_temp1)) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -2147483648.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          ator(real_temp1,"2147483647");
                          if (realcomp(value_real,">",real_temp1)) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 2147483647.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          value=rtoi_round(value_real);
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L')) {
                            request[n]   = value;
                            request[n+1] = value>>8;
                            request[n+2] = value>>16;
                            request[n+3] = value>>24;
                          }
                          else {
                            request[n+3] = value;
                            request[n+2] = value>>8;
                            request[n+1] = value>>16;
                            request[n]   = value>>24;
                          }
                          n=n+4;
                        }
                        else {
                          if (strcmp(temp1,"unsigned long")==0) {
                            ator(real_temp1,"0");
                            if (realcomp(value_real,"<",real_temp1)) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            ator(real_temp1,"4294967295");
                            if (realcomp(value_real,">",real_temp1)) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 4294967295.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            value=rtoi_round(value_real);
                            tabget(temp2,"L/H");
                            if ((temp2[0]=='l') || (temp2[0]=='L')) {
                              request[n]   = value;
                              request[n+1] = value>>8;
                              request[n+2] = value>>16;
                              request[n+3] = value>>24;
                            }
                            else {
                              request[n+3] = value;
                              request[n+2] = value>>8;
                              request[n+1] = value>>16;
                              request[n]   = value>>24;
                            }
                            n=n+4;
                          }
                          else {
                            if ((strcmp(temp1,"float")==0) ||
                                (strcmp(temp1,"intel float")==0)) {
                              ator(real_temp1,"-3.4028234663852884E+038");
                              if (realcomp(value_real,"<",real_temp1)) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              ator(real_temp1,"3.4028234663852884E+038");
                              if (realcomp(value_real,">",real_temp1)) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              ator(real_temp1,"0");
                              if (realcomp(value_real,">",real_temp1)) {
                                ator(real_temp1,"1.1754943508222877E-038");
                                if (realcomp(value_real,"<",real_temp1)) {
                                  value_real=real_temp1;
                                }
                              }
                              ator(real_temp1,"0");
                              if (realcomp(value_real,"<",real_temp1)) {
                                ator(real_temp1,"-1.1754943508222877E-038");
                                if (realcomp(value_real,">",real_temp1)) {
                                  value_real=real_temp1;
                                }
                              }
                              real_to_data(request,value_real,n,0,0);
                              n=n+4;
                            }
                            else {
                              if (strcmp(temp1,"motorola float")==0) {
                                ator(real_temp1,"-3.4028234663852884E+038");
                                if (realcomp(value_real,"<",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                ator(real_temp1,"3.4028234663852884E+038");
                                if (realcomp(value_real,">",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                ator(real_temp1,"0");
                                if (realcomp(value_real,">",real_temp1)) {
                                  ator(real_temp1,"1.1754943508222877E-038");
                                  if (realcomp(value_real,"<",real_temp1)) {
                                    value_real=real_temp1;
                                  }
                                }
                                ator(real_temp1,"0");
                                if (realcomp(value_real,"<",real_temp1)) {
                                  ator(real_temp1,"-1.1754943508222877E-038");
                                  if (realcomp(value_real,">",real_temp1)) {
                                    value_real=real_temp1;
                                  }
                                }
                                real_to_data(request,value_real,n,0,1);
                                n=n+4;
                              }
                              else {
                                if ((strcmp(temp1,"double")==0) ||
                                    (strcmp(temp1,"intel double")==0)) {
                                  real_to_data(request,value_real,n,1,0);
                                  n=n+8;
                                }
                                else {
                                  if (strcmp(temp1,"motorola double")==0) {
                                    real_to_data(request,value_real,n,1,1);
                                    n=n+8;
                                  }
                                  else {
                                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                    strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_TABLE";
                                    set_trap_mask(0);
                                    return;
                                  } // else Analog motorola double
                                } // else Analog (intel) double
                              } // else Analog motorola float
                            } // else Analog (intel) float
                          } // else Analog unsigned long
                        } // else Analog (signed) long
                      } // else Analog unsigned int
                    } // else Analog (signed) int
                  } // else Analog unsigned char
                } // else Analog (signed) char
              } // else Analog string
            } // else Analog string[x]
          } // else Analog data[x]
        } // else Hex String
      } // else Diskreter Wert
    } // else Digitaler Wert
    anz_arg++;
  }
  if (get_argument(temp1,anz_arg+3)) {
    temp1="Argument WERT[";
    itoad(temp2,anz_arg+1);
    strcat(temp1,temp2);strcat(temp1,"]='");
    get_argument(temp2,anz_arg+3);
    strcat(temp1,temp2);strcat(temp1,"'. Too many arguments. Number of arguments='");
    itoad(temp2,anz_arg);strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }

// ---------------- Kommunikation ------------------------------------
  if (_REQUEST) _REQUEST = request;
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "_RESPONSE", 2)) {
    set_trap_mask(0);
    return;
  }

// ---------------- Response auswerten -------------------------------
  if (datalen(response) < 3) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
    set_trap_mask(0);
    return;
  }
  if (datalen(response) > 3) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too much data.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_MUCH_DATA";
    set_trap_mask(0);
    return;
  }
  id_response = (response[1]<<8)+response[2];
  if (id_response != id) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response data identifier. Expected='");
    itoax(temp2,id);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"' != Response='");
    itoax(temp2,id_response);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_DATA_IDENTIFIER";
    set_trap_mask(0);
    return;
  }
  JOB_STATUS = "OKAY";
  set_trap_mask(0);
}
// end of : #include "UDS_2E_STEUERN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : SERIENNUMMER_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005  gr  V0.001 Erstellung
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// 23.03.2006  gh  V0.003 Interpretation geändert von ASCII nach HEX
// 22.06.2006  gh  V0.004 Anpassung an LH SAP 10000970
// *******************************************************************
// UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S @(#)@ V0.004 @(#)@
// *******************************************************************
job ( name      :       SERIENNUMMER_LESEN;
      comment   :       Seriennummer des Steuergeraets;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $F18C Sub-Parameter ECUSerialNumber;
      comment   :       Modus: Default;

      result    :       SERIENNUMMER;
        type    :       string;
        comment :       Seriennummer des Steuergeraets;      
        
      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
   unsigned char request[] = {0x22, 0xF1, 0x8C};
   unsigned char SA_response;
   unsigned char TA_response;
   unsigned char response[];
   unsigned char temp[];
            int  index;

// ---------------- Kommunikation ------------------------------------
   if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------
/* 
   if (SERIENNUMMER) { 
      dataclear(temp);
//    datacopy(temp, response, 3, 10);   manche Zeichen nicht darstellbar !
      hex2ascii(temp, response, 3, 10);
      strinsert(temp, "0x", 0);
      SERIENNUMMER = temp;
   }
*/
   JOB_STATUS = "OKAY";   // Hier weiter vorne notwendig !

   if (SERIENNUMMER) {
     temp = "**********";
     index = 0;
     while (index < 10) {
       if ((response[index+3] >= 0x00) && (response[index+3] <= 0x09)) {
         temp[index] = 0x30 + response[index+3];
       }
       else {
         if ((response[index+3] >= 0x30) && (response[index+3] <= 0x39)) {
           temp[index] = response[index+3];
         }
         else {
           JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_SERIAL_NUMBER_FORMAT";
         }
       }
       index++;
     }
     SERIENNUMMER = temp;
   }

   if (_REQUEST)              
      _REQUEST = request;

   if (_RESPONSE)
      _RESPONSE = response;
}

// end of : #include "UDS_22_F1_8C_SERIENNUMMER_LESEN.B2S"

// optionale Standard Diagnose-Jobs
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_2F_STEUERN_IO.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_IO
// -------------------------------------------------------------------
// Globale Konstanten : TA
//                      UNCHECK_LEN_IDENTIFIER_LIST[]
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 30.05.2006  rd  V0.01 Erstellung
// 31.05.2006  rd  V0.10 Header überarbeitet
// 12.06.2006  rd  V0.11 Datentyp integer dazu
// 20.06.2006  rd  V0.12 Datentyp BITFIELD dazu
//                 V0.12 Fehlermeldung bei string überarbeitet
// 22.06.2006  rd  V0.20 Serviceüberprüfung dazu
// 24.07.2006  rd  V0.21 '0-n' _WERT- Results nicht erlaubt
// 04.09.2006  rd  V0.22 Erstes Result führt zu keiner Fehlermeldung
//                 V0.22 wenn RESULTNAME und DATENTYP und EINHEIT == '-'
// 06.03.2007  rd  V0.50 Steuerparameter optional
//             rd  V0.50 Bei diskretem Argument. Wenn Argument nicht
//             rd  V0.50 in Spalte Text gefunden wird,
//             rd  V0.50 dann auch in Spalte WERT suchen
// 27.03.2007  rd  V0.60 Serviceüberprüfung aktiv
//             rd  V0.60 Resultname beginnend mit _stat_ jetzt erlaubt
// 09.05.2007  rd  V0.70 Mindestlänge response bug behoben
// 22.05.2007  rd  V0.75 Bug Bitfeld-Maske behoben
// 04.09.2007  rd  V0.80 Bug Analoger Wert unsigned long / long behoben
// 06.12.2007  rd  V1.00 Freigabe
// 22.11.2010  rd  V2.00 Bug unsigned integer l/h behoben
//                 V2.00 Bug default-argument mit string behoben
//                 V2.00 Bug bei Fehlerausgabe behoben
//                 V2.00 Einheit DATA, TEXT dazu
//                 V2.00 Anforderung VH-53 Waegner
//                 V2.00 Integration DUMMY_ bei Einheit DATA
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Integration Entfall Längenprüfung
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Freigabe
// *******************************************************************
// UDS_2F_STEUERN_IO.B2S @(#)@ V2.00 @(#)@
// *******************************************************************
job ( name      :       STEUERN_IO;
      comment   :       Vorgeben eines Status;
      comment   :       UDS  : $2F InputOutputControlByIdentifier;

      argument  :       ARGUMENT_SPALTE;
        type    :       string;
        comment :       'ARG', 'ID', 'LABEL';

      argument  :       STATUS;
        type    :       string;
        comment :       Siehe table SG_Funktionen ARG ID RES_TABELLE ARG_TABELLE;

      argument  :       STEUERPARAMETER;
        type    :       string;
        comment :       'RCTECU' = returnControlToECU;
        comment :       'RTD'    = resetToDefault;
        comment :       'FCS'    = freezeCurrentState;
        comment :       'STA'    = shortTermAdjustment;
        comment :       optionales Argument;
        comment :       Wenn nicht angegeben, dann kein InputOutputControlParameter im Request;

      argument  :       WERT;
        type    :       string;
        comment :       Argumente siehe table SG_Funktionen ARG_TABELLE;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x2F};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned char argument_name[];
  unsigned char argument_string[];
  unsigned char temp1[];
  unsigned char temp2[];
  unsigned char control_parameter;
  unsigned char control_parameter_response;
  unsigned int  k;
  unsigned int  n;
  unsigned int  id;
  unsigned int  id_response;
  unsigned int  len;
  unsigned int  anz_arg;
  unsigned int  found_flag;
  unsigned int  defaultargument_flag;
  unsigned int  data_len;
  unsigned int  unsigned_long_flag;
  unsigned int  data_flag;
  unsigned int  data_pos;
  unsigned int  string_flag;
  unsigned int  string_pos;
  unsigned int  string_len;
  unsigned int  hex_len;
  unsigned int  res_table_flag;
  unsigned int  line_res_table;
  unsigned int  first_result_flag;
  unsigned int  size_bitfield;
  unsigned int  size_bitfield_old;
  unsigned int  line_bitfield_table;
  unsigned int  gefunden_flag;
  unsigned long enable_flag;
  unsigned long enable_mask;
  unsigned long argument_unsigned;
           long value;
           long value_unsigned;
           long maske;
           real value_real;
           real real_temp1;
           real real_temp2;

// ---------------- Argumente des Jobs auswerten ---------------------
  if (exist(ARGUMENT_SPALTE)) {
    argument_string = ARGUMENT_SPALTE;
    strupper(argument_string);
    if ((strcmp(argument_string,"ARG")!=0) &&
        (strcmp(argument_string,"ID")!=0) &&
        (strcmp(argument_string,"LABEL")!=0)) {
      temp1="Argument ARGUMENT_SPALTE='";strcat(temp1,argument_string);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
  }
  else {
    var_result_string("JOB_MESSAGE","Argument ARGUMENT_SPALTE missing ('ARG', 'ID', 'LABEL').");
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

  if (!exist(STATUS)) {
    temp1="Argument STATUS missing.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

// ---------------- Request erzeugen ---------------------------------
  set_trap_mask(0x400);
  tabset("SG_Funktionen");
  if (get_error(10)) {
    var_result_string("JOB_MESSAGE","Table 'SG_Funktionen' not found.");
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }
  argument_name=STATUS;
  if (strcmp(argument_name,"-")==0) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not valid.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  if (!tabseek(argument_string,argument_name)) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not found.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  tabget(temp2,"SERVICE");
  if (strcmp(temp2,"-")!=0) {
    strupper(temp2);
    k=0;
    gefunden_flag=FALSE;
    while (temp2[k]!=0){
      if (temp2[k]=='2') {
        if (temp2[k+1]=='F') {
          gefunden_flag=TRUE;
          break;
        }
      }
      k++;
    }
    if (gefunden_flag==FALSE) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);
      strcat(temp1,"' not valid. Service '2F' not found in Table 'SG_Funktionen' column 'SERVICE'='");
      tabget(temp2,"SERVICE");
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }
  n=1;
  tabget(temp2,"ID");
  id = atoi(temp2);
  request[n++] = id >> 8;
  request[n++] = id & 0xFF;

  if (exist(STEUERPARAMETER)) {
    temp2 = STEUERPARAMETER;
    strupper(temp2);
    if ((strcmp(temp2,"RCTECU")!=0) &&
        (strcmp(temp2,"RTD")!=0) &&
        (strcmp(temp2,"FCS")!=0) &&
        (strcmp(temp2,"STA")!=0)) {
      temp1="Argument STEUERPARAMETER='";strcat(temp1,temp2);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
    else {
      if (strcmp(temp2,"RCTECU")==0) control_parameter = 0x00;
      if (strcmp(temp2,"RTD")   ==0) control_parameter = 0x01;
      if (strcmp(temp2,"FCS")   ==0) control_parameter = 0x02;
      if (strcmp(temp2,"STA")   ==0) control_parameter = 0x03;
      request[n++] = control_parameter;
    }
  }
  else {
    // optionales Argument
    control_parameter = 0xFF;
//  var_result_string("JOB_MESSAGE","Argument STEUERPARAMETER missing ('RCTECU', 'RTD', 'FCS', 'STA').");
//  JOB_STATUS = "ERROR_ARGUMENT";
//  return;
  }

  tabget(argument_string,"ARG_TABELLE");
  if (strcmp(argument_string,"-")!=0) {
    tabset(argument_string);
    if (get_error(10)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Argument table not found='");
      strcat(temp1,argument_string);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    if (tabline(32)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Argument table ='");
      strcat(temp1,argument_string);strcat(temp1,"'. Too many arguments. Limit is 32.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    if (WERT); // damit die Compilerwarnung entfällt
    anz_arg=0;
    if ((control_parameter == 0x03) || (control_parameter == 0xFF)) {
      // Argumente nur bei ShortTermAdjustment oder wenn kein Steuerparameter
      enable_flag=0x80000000;
      enable_mask=0;
      while (tabline(anz_arg)) {
        defaultargument_flag = FALSE;
        if (!get_argument(argument_name,anz_arg+4)) {
          if (!tabline(1)) {
            // Pflicht bei nur einem Argument
            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);
            strcat(temp1,"] missing. Argument table='");strcat(temp1,argument_string);
            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ARGUMENT";
            set_trap_mask(0);
            return;
          }
          else {
            defaultargument_flag = TRUE;
          }
        }
        if (defaultargument_flag == TRUE) {
          tabline(anz_arg);
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                n=n+4;
              }
              else {
                len = strlen(temp1);
                temp2="?????";
                strncpy(temp2,temp1,5);
                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,5);
                  data_len=atoi(temp2);
                  if ((data_len > 0) && (data_len < 256)) {
                    n=n+data_len;
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  len = strlen(temp1);
                  temp2="???????";
                  strncpy(temp2,temp1,7);
                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                    temp2=temp1;
                    strerase(temp2,len-1,1);
                    strerase(temp2,0,7);
                    data_len=atoi(temp2);
                    if ((data_len > 0) && (data_len < 256)) {
                      n=n+data_len;
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    if (strcmp(temp1,"string")==0) {
                      n++;
                    }
                    else {
                      if ((strcmp(temp1,"float")==0) ||
                          (strcmp(temp1,"intel float")==0) ||
                          (strcmp(temp1,"motorola float")==0)) {
                        n=n+4;
                      }
                      else {
                        if ((strcmp(temp1,"double")==0) ||
                            (strcmp(temp1,"intel double")==0) ||
                            (strcmp(temp1,"motorola double")==0)) {
                          n=n+8;
                        }
                        else {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        } // else double
                      } // else float
                    } // else string
                  } // else string[x]
                } // else data[x]
              } // else long
            } // else int
          } // else char
        } // if defaultargument_flag
        else {
          enable_mask = enable_mask | enable_flag;
          tabget(temp1,"EINHEIT");
          strlower(temp1);
          if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
            aitor(value_real,argument_name);
            value=atoi(argument_name);
            if ((strcmp(argument_name,"0")!=0) && (strcmp(argument_name,"1")!=0)) {
              temp1="Argument WERT[";
              itoad(temp2,anz_arg+1);
              strcat(temp1,temp2);strcat(temp1,"] Digital value not valid='");
              strcat(temp1,argument_name);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
            tabget(temp1,"MIN");
            if (strcmp(temp1,"-")!=0) {
              aitor(real_temp1,temp1);
              if (realcomp(value_real,"<",real_temp1)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Out of range. '");
                strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
            }
            tabget(temp1,"MAX");
            if (strcmp(temp1,"-")!=0) {
              aitor(real_temp1,temp1);
              if (realcomp(value_real,">",real_temp1)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Out of range. '");
                strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
            }
            tabget(temp1,"DATENTYP");
            strlower(temp1);
            if ((strcmp(temp1,"char")==0) ||
                (strcmp(temp1,"unsigned char")==0) ||
                (strcmp(temp1,"signed char")==0)) {
              request[n] = value;
              n++;
            }
            else {
              if ((strcmp(temp1,"int")==0) ||
                  (strcmp(temp1,"integer")==0) ||
                  (strcmp(temp1,"unsigned int")==0) ||
                  (strcmp(temp1,"unsigned integer")==0) ||
                  (strcmp(temp1,"signed int")==0) ||
                  (strcmp(temp1,"signed integer")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                  request[n]   = value;
                  request[n+1] = value>>8;
                }
                else {
                  request[n+1] = value;
                  request[n]   = value>>8;
                }
                n=n+2;
              }
              else {
                if ((strcmp(temp1,"long")==0) ||
                    (strcmp(temp1,"unsigned long")==0) ||
                    (strcmp(temp1,"signed long")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L')) {
                    request[n]   = value;
                    request[n+1] = value>>8;
                    request[n+2] = value>>16;
                    request[n+3] = value>>24;
                  }
                  else {
                    request[n+3] = value;
                    request[n+2] = value>>8;
                    request[n+1] = value>>16;
                    request[n]   = value>>24;
                  }
                  n=n+4;
                }
                else {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
            }
          }
          else {
            if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
              tabget(temp2,"NAME");
              if (strcmp(temp2,"-")==0) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. NAME not valid='");tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
              tabset(temp2);
              if (get_error(10)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                tabset(argument_string);tabline(anz_arg);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Discrete value table not found='");
                tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
              found_flag=tabseek("TEXT",argument_name);
              if (get_error(10)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                tabset(argument_string);tabline(anz_arg);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Discrete value table='");
                tabget(temp2,"NAME");strcat(temp1,temp2);
                strcat(temp1,"'. Column 'TEXT' not found.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
              if (found_flag!=TRUE) {
                // Wenn nicht in Spalte Text gefunden, dann auch in Spalte Wert als Zahl suchen
                if (is_hex_string(argument_name) || is_unsigned_string(argument_name)) {
                  argument_unsigned = atoi(argument_name);
                  found_flag=tab_suche_unsigned("WERT",argument_unsigned);
                  if (get_error(10)) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    tabset(argument_string);tabline(anz_arg);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Discrete value table='");
                    tabget(temp2,"NAME");strcat(temp1,temp2);
                    strcat(temp1,"'. Column 'WERT' not found.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
              }
              if (found_flag!=TRUE) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                tabset(argument_string);tabline(anz_arg);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Discrete table='");
                tabget(temp2,"NAME");strcat(temp1,temp2);
                strcat(temp1,"'. Argument not found.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
              tabget(temp1,"WERT");
              aitor(value_real,temp1);
              value=atoi(temp1);
              if (get_error(10)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                tabset(argument_string);tabline(anz_arg);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Discrete value table='");
                tabget(temp2,"NAME");strcat(temp1,temp2);
                strcat(temp1,"'. Column 'WERT' not found.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
              // wieder zurück zur Tabelle
              tabset(argument_string);
              tabline(anz_arg);
              tabget(temp1,"MIN");
              if (strcmp(temp1,"-")!=0) {
                aitor(real_temp1,temp1);
                if (realcomp(value_real,"<",real_temp1)) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. Out of range. '");
                  strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              tabget(temp1,"MAX");
              if (strcmp(temp1,"-")!=0) {
                aitor(real_temp1,temp1);
                if (realcomp(value_real,">",real_temp1)) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. Out of range. '");
                  strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              if ((strcmp(temp1,"char")==0) ||
                  (strcmp(temp1,"unsigned char")==0) ||
                  (strcmp(temp1,"signed char")==0)) {
                request[n] = value;
                n++;
              }
              else {
                if ((strcmp(temp1,"int")==0) ||
                    (strcmp(temp1,"integer")==0) ||
                    (strcmp(temp1,"unsigned int")==0) ||
                    (strcmp(temp1,"unsigned integer")==0) ||
                    (strcmp(temp1,"signed int")==0) ||
                    (strcmp(temp1,"signed integer")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L')) {
                    request[n]   = value;
                    request[n+1] = value>>8;
                  }
                  else {
                    request[n+1] = value;
                    request[n]   = value>>8;
                  }
                  n=n+2;
                }
                else {
                  if ((strcmp(temp1,"long")==0) ||
                      (strcmp(temp1,"unsigned long")==0) ||
                      (strcmp(temp1,"signed long")==0)) {
                    tabget(temp2,"L/H");
                    if ((temp2[0]=='l') || (temp2[0]=='L')) {
                      request[n]   = value;
                      request[n+1] = value>>8;
                      request[n+2] = value>>16;
                      request[n+3] = value>>24;
                    }
                    else {
                      request[n+3] = value;
                      request[n+2] = value>>8;
                      request[n+1] = value>>16;
                      request[n]   = value>>24;
                    }
                    n=n+4;
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
              }
            }
            else {
              if (strcmp(temp1,"hex")==0) {
// Hex String
                aitor(value_real,argument_name);
                value=atoi(argument_name);
                tabget(temp1,"MIN");
                if (strcmp(temp1,"-")!=0) {
                  aitor(real_temp1,temp1);
                  if (realcomp(value_real,"<",real_temp1)) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                }
                tabget(temp1,"MAX");
                if (strcmp(temp1,"-")!=0) {
                  aitor(real_temp1,temp1);
                  if (realcomp(value_real,">",real_temp1)) {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. Out of range. '");
                    strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                }
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                if ((strcmp(temp1,"char")==0) ||
                    (strcmp(temp1,"unsigned char")==0) ||
                    (strcmp(temp1,"signed char")==0)) {
                  request[n] = value;
                  n++;
                }
                else {
                  if ((strcmp(temp1,"int")==0) ||
                      (strcmp(temp1,"integer")==0) ||
                      (strcmp(temp1,"unsigned int")==0) ||
                      (strcmp(temp1,"unsigned integer")==0) ||
                      (strcmp(temp1,"signed int")==0) ||
                      (strcmp(temp1,"signed integer")==0)) {
                    tabget(temp2,"L/H");
                    if ((temp2[0]=='l') || (temp2[0]=='L')) {
                      request[n]   = value;
                      request[n+1] = value>>8;
                    }
                    else {
                      request[n+1] = value;
                      request[n]   = value>>8;
                    }
                    n=n+2;
                  }
                  else {
                    if ((strcmp(temp1,"long")==0) ||
                        (strcmp(temp1,"unsigned long")==0) ||
                        (strcmp(temp1,"signed long")==0)) {
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L')) {
                        request[n]   = value;
                        request[n+1] = value>>8;
                        request[n+2] = value>>16;
                        request[n+3] = value>>24;
                      }
                      else {
                        request[n+3] = value;
                        request[n+2] = value>>8;
                        request[n+1] = value>>16;
                        request[n]   = value>>24;
                      }
                      n=n+4;
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                }
              }
              else {
// Analoger Wert
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                len = strlen(temp1);
                temp2="?????";
                strncpy(temp2,temp1,5);
                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,5);
                  data_len=atoi(temp2);
                  if ((data_len > 0) && (data_len < 256)) {
                    len=strlen(argument_name);
                    if (len == 2*data_len) {
                      ascii2hex(request,argument_name,n);
                      n=n+data_len;
                      if (datalen(request) != n) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Invalid characters in argument. Valid characters=0123456789ABCDEF.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      if (len < 2*data_len)
                        strcat(temp1,"'. Too less data. Expected argument string len='");
                      else
                        strcat(temp1,"'. Too much data. Expected argument string len='");
                      itoad(temp2,2*data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  len = strlen(temp1);
                  temp2="???????";
                  strncpy(temp2,temp1,7);
                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                    temp2=temp1;
                    strerase(temp2,len-1,1);
                    strerase(temp2,0,7);
                    data_len=atoi(temp2);
                    if ((data_len > 0) && (data_len < 256)) {
                      len=strlen(argument_name);
                      if (len == data_len) {
                        request[n-1] = request[n-1];      // request Länge auf n setzen ! default-Werte ändern nur n
                        datacat(request,argument_name);   // String anhängen
                        dataerase(request,n+data_len,1);  // String end character '0x00' entfernen
                        n=n+data_len;
                      }
                      else {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        if (len < data_len)
                          strcat(temp1,"'. Too less data. Expected argument string len='");
                        else
                          strcat(temp1,"'. Too much data. Expected argument string len='");
                        itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    if (strcmp(temp1,"string")==0) {
                      data_len=strlen(argument_name)+1; // String end character '0x00'
                      if ((data_len > 0) && (data_len < 256)) {
                        request[n-1] = request[n-1];      // request Länge auf n setzen ! default-Werte ändern nur n
                        datacat(request,argument_name);   // String anhängen
                        n=n+data_len;
                      }
                      else {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    else {
                      aitor(value_real,argument_name);
                      tabget(temp1,"MIN");
                      if (strcmp(temp1,"-")!=0) {
                        aitor(real_temp1,temp1);
                        if (realcomp(value_real,"<",real_temp1)) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      tabget(temp1,"MAX");
                      if (strcmp(temp1,"-")!=0) {
                        aitor(real_temp1,temp1);
                        if (realcomp(value_real,">",real_temp1)) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      tabget(temp2,"MUL");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. Multiplication with Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realmul(value_real,real_temp1);
                      }
                      tabget(temp2,"DIV");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. Division by Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realdiv(value_real,real_temp1);
                      }
                      tabget(temp2,"ADD");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        realadd(value_real,real_temp1);
                      }
                      tabget(temp1,"DATENTYP");
                      strlower(temp1);
                      if ((strcmp(temp1,"char")==0) ||
                          (strcmp(temp1,"signed char")==0)) {
                        value=rtoi_round(value_real);
                        if (value < -128) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -128.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        if (value > 127) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 127.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        request[n] = value;
                        n++;
                      }
                      else {
                        if (strcmp(temp1,"unsigned char")==0) {
                          value=rtoi_round(value_real);
                          if (value < 0) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          if (value > 255) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 255.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          request[n] = value;
                          n++;
                        }
                        else {
                          if ((strcmp(temp1,"int")==0) ||
                              (strcmp(temp1,"integer")==0) ||
                              (strcmp(temp1,"signed int")==0) ||
                              (strcmp(temp1,"signed integer")==0)) {
                            value=rtoi_round(value_real);
                            if (value < -32768) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -32768.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            if (value > 32767) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 32767.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            tabget(temp2,"L/H");
                            if ((temp2[0]=='l') || (temp2[0]=='L')) {
                              request[n]   = value;
                              request[n+1] = value>>8;
                            }
                            else {
                              request[n+1] = value;
                              request[n]   = value>>8;
                            }
                            n=n+2;
                          }
                          else {
                            if ((strcmp(temp1,"unsigned int")==0) ||
                                (strcmp(temp1,"unsigned integer")==0)) {
                              value=rtoi_round(value_real);
                              if (value < 0) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              if (value > 65535) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 65535.");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              tabget(temp2,"L/H");
                              if ((temp2[0]=='l') || (temp2[0]=='L')) {
                                request[n]   = value;
                                request[n+1] = value>>8;
                              }
                              else {
                                request[n+1] = value;
                                request[n]   = value>>8;
                              }
                              n=n+2;
                            }
                            else {
                              if ((strcmp(temp1,"long")==0) ||
                                  (strcmp(temp1,"signed long")==0)) {
                                ator(real_temp1,"-2147483648");
                                if (realcomp(value_real,"<",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -2147483648.");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                ator(real_temp1,"2147483647");
                                if (realcomp(value_real,">",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 2147483647.");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                value=rtoi_round(value_real);
                                tabget(temp2,"L/H");
                                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                                  request[n]   = value;
                                  request[n+1] = value>>8;
                                  request[n+2] = value>>16;
                                  request[n+3] = value>>24;
                                }
                                else {
                                  request[n+3] = value;
                                  request[n+2] = value>>8;
                                  request[n+1] = value>>16;
                                  request[n]   = value>>24;
                                }
                                n=n+4;
                              }
                              else {
                                if (strcmp(temp1,"unsigned long")==0) {
                                  ator(real_temp1,"0");
                                  if (realcomp(value_real,"<",real_temp1)) {
                                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                    strcat(temp1,"'. Out of range. '");
                                    rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_ARGUMENT";
                                    set_trap_mask(0);
                                    return;
                                  }
                                  ator(real_temp1,"4294967295");
                                  if (realcomp(value_real,">",real_temp1)) {
                                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                    strcat(temp1,"'. Out of range. '");
                                    rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 4294967295.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_ARGUMENT";
                                    set_trap_mask(0);
                                    return;
                                  }
                                  value=rtoi_round(value_real);
                                  tabget(temp2,"L/H");
                                  if ((temp2[0]=='l') || (temp2[0]=='L')) {
                                    request[n]   = value;
                                    request[n+1] = value>>8;
                                    request[n+2] = value>>16;
                                    request[n+3] = value>>24;
                                  }
                                  else {
                                    request[n+3] = value;
                                    request[n+2] = value>>8;
                                    request[n+1] = value>>16;
                                    request[n]   = value>>24;
                                  }
                                  n=n+4;
                                }
                                else {
                                  if ((strcmp(temp1,"float")==0) ||
                                      (strcmp(temp1,"intel float")==0)) {
                                    ator(real_temp1,"-3.4028234663852884E+038");
                                    if (realcomp(value_real,"<",real_temp1)) {
                                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                      strcat(temp1,"'. Out of range. '");
                                      rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_ARGUMENT";
                                      set_trap_mask(0);
                                      return;
                                    }
                                    ator(real_temp1,"3.4028234663852884E+038");
                                    if (realcomp(value_real,">",real_temp1)) {
                                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                      strcat(temp1,"'. Out of range. '");
                                      rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_ARGUMENT";
                                      set_trap_mask(0);
                                      return;
                                    }
                                    ator(real_temp1,"0");
                                    if (realcomp(value_real,">",real_temp1)) {
                                      ator(real_temp1,"1.1754943508222877E-038");
                                      if (realcomp(value_real,"<",real_temp1)) {
                                        value_real=real_temp1;
                                      }
                                    }
                                    ator(real_temp1,"0");
                                    if (realcomp(value_real,"<",real_temp1)) {
                                      ator(real_temp1,"-1.1754943508222877E-038");
                                      if (realcomp(value_real,">",real_temp1)) {
                                        value_real=real_temp1;
                                      }
                                    }
                                    real_to_data(request,value_real,n,0,0);
                                    n=n+4;
                                  }
                                  else {
                                    if (strcmp(temp1,"motorola float")==0) {
                                      ator(real_temp1,"-3.4028234663852884E+038");
                                      if (realcomp(value_real,"<",real_temp1)) {
                                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                        strcat(temp1,"'. Out of range. '");
                                        rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                        var_result_string("JOB_MESSAGE",temp1);
                                        JOB_STATUS = "ERROR_ARGUMENT";
                                        set_trap_mask(0);
                                        return;
                                      }
                                      ator(real_temp1,"3.4028234663852884E+038");
                                      if (realcomp(value_real,">",real_temp1)) {
                                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                        strcat(temp1,"'. Out of range. '");
                                        rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                        var_result_string("JOB_MESSAGE",temp1);
                                        JOB_STATUS = "ERROR_ARGUMENT";
                                        set_trap_mask(0);
                                        return;
                                      }
                                      ator(real_temp1,"0");
                                      if (realcomp(value_real,">",real_temp1)) {
                                        ator(real_temp1,"1.1754943508222877E-038");
                                        if (realcomp(value_real,"<",real_temp1)) {
                                          value_real=real_temp1;
                                        }
                                      }
                                      ator(real_temp1,"0");
                                      if (realcomp(value_real,"<",real_temp1)) {
                                        ator(real_temp1,"-1.1754943508222877E-038");
                                        if (realcomp(value_real,">",real_temp1)) {
                                          value_real=real_temp1;
                                        }
                                      }
                                      real_to_data(request,value_real,n,0,1);
                                      n=n+4;
                                    }
                                    else {
                                      if ((strcmp(temp1,"double")==0) ||
                                          (strcmp(temp1,"intel double")==0)) {
                                        real_to_data(request,value_real,n,1,0);
                                        n=n+8;
                                      }
                                      else {
                                        if (strcmp(temp1,"motorola double")==0) {
                                          real_to_data(request,value_real,n,1,1);
                                          n=n+8;
                                        }
                                        else {
                                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                          strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                                          var_result_string("JOB_MESSAGE",temp1);
                                          JOB_STATUS = "ERROR_TABLE";
                                          set_trap_mask(0);
                                          return;
                                        } // else Analog motorola double
                                      } // else Analog (intel) double
                                    } // else Analog motorola float
                                  } // else Analog (intel) float
                                } // else Analog unsigned long
                              } // else Analog (signed) long
                            } // else Analog unsigned int
                          } // else Analog (signed) int
                        } // else Analog unsigned char
                      } // else Analog (signed) char
                    } // else Analog string
                  } // else Analog string[x]
                } // else Analog data[x]
              } // else Hex String
            } // else Diskreter Wert
          } // else Digitaler Wert
        } // else defaultargument_flag
        anz_arg++;
        enable_flag = enable_flag >> 1 ;
      }
    } // if control_parameter==0x03 || control_parameter==0xFF

    if (get_argument(temp1,anz_arg+4)) {
      temp1="Argument WERT[";
      itoad(temp2,anz_arg+1);
      strcat(temp1,temp2);strcat(temp1,"]='");
      get_argument(temp2,anz_arg+4);
      strcat(temp1,temp2);strcat(temp1,"'. Too many arguments. Number of arguments='");
      itoad(temp2,anz_arg);strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
    if ((control_parameter != 0x03) && (control_parameter != 0xFF)) enable_mask=0xFFFFFFFF;
    // EnableMask setzen bei mehr als einem Argument
    tabset(argument_string);
    if (tabline(1)) {
      request[n++] = enable_mask>>24;    // mehr als 1  Argument
      if (tabline(8)) {
        request[n++] = enable_mask>>16;  // mehr als 8  Argumente
        if (tabline(16)) {
          request[n++] = enable_mask>>8; // mehr als 16 Argumente
          if (tabline(24)) {
            request[n++] = enable_mask;  // mehr als 24 Argumente
          }
        }
      }
    }
  } // if ARG_TABELLE != '-'
  else {
    k=0;
    while (!get_argument(temp1,k+4)) {
      if (k >= 31) break;
      k++;
    }
    if (strlen(temp1) > 0) {
      temp1="Argument WERT[";
      itoad(temp2,k+1);
      strcat(temp1,temp2);strcat(temp1,"]='");
      get_argument(temp2,k+4);
      strcat(temp1,temp2);strcat(temp1,"'. Too many arguments. Number of arguments='0'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }

// ---------------- Kommunikation ------------------------------------
  if (_REQUEST) _REQUEST = request;
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "_RESPONSE", 2)) {
    set_trap_mask(0);
    return;
  }

// ---------------- Response auswerten -------------------------------
  if (datalen(response) < 4) {
    if ((datalen(response) < 3) || (control_parameter != 0xFF)) {
      argument_name=STATUS;
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
      set_trap_mask(0);
      return;
    }
  }
  id_response = (response[1]<<8)+response[2];
  if (id_response != id) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response data identifier. Expected='");
    itoax(temp2,id);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"' != Response='");
    itoax(temp2,id_response);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_DATA_IDENTIFIER";
    set_trap_mask(0);
    return;
  }

  n=3;
  if (control_parameter != 0xFF) {
    control_parameter_response = response[n];
    if (control_parameter_response != control_parameter) {
      argument_name=STATUS;
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response io control parameter. Expected='");
      itoax(temp2,control_parameter);strerase(temp2,2,6);
      strcat(temp1,temp2);strcat(temp1,"' != Response='");
      itoax(temp2,control_parameter_response);strerase(temp2,2,6);
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_IO_CONTROL_PARAMETER";
      set_trap_mask(0);
      return;
    }
    n++;
  }

  tabset("SG_Funktionen");
  argument_string = ARGUMENT_SPALTE;
  argument_name=STATUS;
  tabseek(argument_string,argument_name);

  res_table_flag=FALSE;
  tabget(temp2,"RES_TABELLE");
  if (strcmp(temp2,"-")!=0) {
    tabset(temp2);
    if (get_error(10)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Result table not found='");
      tabset("SG_Funktionen");
      tabseek(argument_string,argument_name);
      tabget(temp2,"RES_TABELLE");
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    res_table_flag=TRUE;
    line_res_table=0;
    tabline(line_res_table);
  }
  first_result_flag=TRUE;

  do {
    if (first_result_flag == TRUE) {
      tabget(temp1,"RESULTNAME");
      if (strcmp(temp1,"-")==0) {
        tabget(temp1,"DATENTYP");
        if (strcmp(temp1,"-")==0) {
          tabget(temp1,"EINHEIT");
          if (strcmp(temp1,"-")==0) break;
        }
      }
      first_result_flag=FALSE;
    }
    // Längenprüfung abschalten ?
    // nur wenn keine Restdaten vorhanden
    if (datalen(response) == n) {
      len = datalen(UNCHECK_LEN_IDENTIFIER_LIST) / 2 ; // 1 Integer = 2 Byte
      k=0;
      do {
        if (UNCHECK_LEN_IDENTIFIER_LIST[k] != 0) {
          if (UNCHECK_LEN_IDENTIFIER_LIST[k] == id) {
            // Zu wenig Daten. Restliche Results werden nicht erzeugt
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data. UNCHECK_LEN_IDENTIFIER_LIST contains ID='");
            itoax(temp2,id);strerase(temp2,2,4);
            strcat(temp1,temp2);strcat(temp1,"'. WARNING: Remaining results are not created.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "OKAY";
            set_trap_mask(0);
            return;
          }
        }
        k++;
      } while (k<len);
    }
    tabget(temp1,"EINHEIT");
    strlower(temp1);
    if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
      tabget(temp1,"DATENTYP");
      strlower(temp1);
      if ((strcmp(temp1,"char")==0) ||
          (strcmp(temp1,"unsigned char")==0) ||
          (strcmp(temp1,"signed char")==0)) {
        value = response[n];
        n++;
      }
      else {
        if ((strcmp(temp1,"int")==0) ||
            (strcmp(temp1,"integer")==0) ||
            (strcmp(temp1,"unsigned int")==0) ||
            (strcmp(temp1,"unsigned integer")==0) ||
            (strcmp(temp1,"signed int")==0) ||
            (strcmp(temp1,"signed integer")==0)) {
          tabget(temp2,"L/H");
          if ((temp2[0]=='l') || (temp2[0]=='L'))
            value = (response[n+1]<<8)+response[n];
          else
            value = (response[n]<<8)+response[n+1];
          n=n+2;
        }
        else {
          if ((strcmp(temp1,"long")==0) ||
              (strcmp(temp1,"unsigned long")==0) ||
              (strcmp(temp1,"signed long")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L'))
              value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
            else
              value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
            n=n+4;
          }
          else {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
            tabget(temp2,"DATENTYP");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
      }
      if (datalen(response) < n) {
        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
        set_trap_mask(0);
        return;
      }
      tabget(temp1,"RESULTNAME");
      len=strlen(temp1);
      if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
        tabget(temp2,"RESULTNAME");
        strcat(temp1,temp2);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_TABLE";
        set_trap_mask(0);
        return;
      }
      if (len >= 5) {
        temp2="";
        temp2[0] = temp1[len-5];
        temp2[1] = temp1[len-4];
        temp2[2] = temp1[len-3];
        temp2[3] = temp1[len-2];
        temp2[4] = temp1[len-1];
        temp2[5] = 0;
        strlower(temp2);
        if (strcmp(temp2,"_wert")==0) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
      }
      temp2="";
      if (len >= 5) {
        temp2[0] = temp1[0];
        temp2[1] = temp1[1];
        temp2[2] = temp1[2];
        temp2[3] = temp1[3];
        temp2[4] = temp1[4];
        temp2[5] = 0;
        strlower(temp2);
      }
      if (strcmp(temp2,"stat_")!=0) {
        if (len >= 6) {
          temp2[5] = temp1[5];
          temp2[6] = 0;
          strlower(temp2);
        }
        if (strcmp(temp2,"_stat_")!=0) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
      }
      var_result_long(temp1,value);
      strcat(temp1,"_INFO");
      tabget(temp2,"INFO");
      var_result_string(temp1,temp2);
      if ((value!=0) && (value!=1)) {
        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Digital value not valid='");
        itoad(temp2,value);
        strcat(temp1,temp2);strcat(temp1,"'.");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_ECU_RESPONSE_VALUE_OUT_OF_RANGE";
        set_trap_mask(0);
        return;
      }
    }
    else {
      if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
        unsigned_long_flag=FALSE;
        tabget(temp1,"DATENTYP");
        strlower(temp1);
        if ((strcmp(temp1,"char")==0) ||
            (strcmp(temp1,"unsigned char")==0) ||
            (strcmp(temp1,"signed char")==0)) {
          value = response[n];
          value_unsigned = value;
          if (strcmp(temp1,"unsigned char")!=0)
            if (value & 0x80) value = value | 0xFFFFFF00;
          n++;
        }
        else {
          if ((strcmp(temp1,"int")==0) ||
              (strcmp(temp1,"integer")==0) ||
              (strcmp(temp1,"unsigned int")==0) ||
              (strcmp(temp1,"unsigned integer")==0) ||
              (strcmp(temp1,"signed int")==0) ||
              (strcmp(temp1,"signed integer")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L'))
              value = (response[n+1]<<8)+response[n];
            else
              value = (response[n]<<8)+response[n+1];
            value_unsigned = value;
            if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
              if (value & 0x8000) value = value | 0xFFFF0000;
            n=n+2;
          }
          else {
            if ((strcmp(temp1,"long")==0) ||
                (strcmp(temp1,"unsigned long")==0) ||
                (strcmp(temp1,"signed long")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
              else
                value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
              value_unsigned = value;
              n=n+4;
              if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
            }
            else {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
              tabget(temp2,"DATENTYP");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
        }
        if (datalen(response) < n) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
          set_trap_mask(0);
          return;
        }
        tabget(temp1,"RESULTNAME");
        len=strlen(temp1);
        if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        temp2="";
        if (len >= 5) {
          temp2[0] = temp1[len-5];
          temp2[1] = temp1[len-4];
          temp2[2] = temp1[len-3];
          temp2[3] = temp1[len-2];
          temp2[4] = temp1[len-1];
          temp2[5] = 0;
          strlower(temp2);
        }
        if (strcmp(temp2,"_wert")==0) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        temp2="";
        if (len >= 5) {
          temp2[0] = temp1[0];
          temp2[1] = temp1[1];
          temp2[2] = temp1[2];
          temp2[3] = temp1[3];
          temp2[4] = temp1[4];
          temp2[5] = 0;
          strlower(temp2);
        }
        if (strcmp(temp2,"stat_")!=0) {
          if (len >= 6) {
            temp2[5] = temp1[5];
            temp2[6] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_stat_")!=0) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
        if (unsigned_long_flag == TRUE)
          var_result_unsigned_long(temp1,value);
        else
          var_result_long(temp1,value);

        strcat(temp1,"_EINH");
        tabget(temp2,"EINHEIT");
        var_result_string(temp1,temp2);

        strerase(temp1,len,5);
        strcat(temp1,"_INFO");
        tabget(temp2,"INFO");
        var_result_string(temp1,temp2);

        tabget(temp2,"NAME");
        if (strcmp(temp2,"-")!=0) {
          tabset(temp2);
          if (get_error(10)) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
            if (res_table_flag==FALSE) {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
            }
            else {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
              tabget(temp2,"RES_TABELLE");
              tabset(temp2);
              tabline(line_res_table);
            }
            tabget(temp2,"NAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          tab_suche_unsigned("WERT",value_unsigned);
          if (get_error(10)) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
            if (res_table_flag==FALSE) {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
            }
            else {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
              tabget(temp2,"RES_TABELLE");
              tabset(temp2);
              tabline(line_res_table);
            }
            tabget(temp2,"NAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          tabget(temp2,"TEXT");
          if (get_error(10)) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
            if (res_table_flag==FALSE) {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
            }
            else {
              tabset("SG_Funktionen");
              tabseek(argument_string,argument_name);
              tabget(temp2,"RES_TABELLE");
              tabset(temp2);
              tabline(line_res_table);
            }
            tabget(temp2,"NAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          strerase(temp1,len,5);
          strcat(temp1,"_TEXT");
          var_result_string(temp1,temp2);
        }
      }
      else {
        if (strcmp(temp1,"hex")==0) {
// Hex String
          unsigned_long_flag=FALSE;
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            value = response[n];
            hex_len=2;
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+1]<<8)+response[n];
              else
                value = (response[n]<<8)+response[n+1];
              hex_len=4;
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L'))
                  value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                else
                  value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                hex_len=8;
                n=n+4;
              }
              else {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
          }
          if (datalen(response) < n) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
            set_trap_mask(0);
            return;
          }
          tabget(temp1,"RESULTNAME");
          len=strlen(temp1);
          if (len > 63) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[len-5];
            temp2[1] = temp1[len-4];
            temp2[2] = temp1[len-3];
            temp2[3] = temp1[len-2];
            temp2[4] = temp1[len-1];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_wert")!=0) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[0];
            temp2[1] = temp1[1];
            temp2[2] = temp1[2];
            temp2[3] = temp1[3];
            temp2[4] = temp1[4];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"stat_")!=0) {
            if (len >= 6) {
              temp2[5] = temp1[5];
              temp2[6] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"_stat_")!=0) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
          itoax(temp2,value);
          strerase(temp2,0,10-hex_len);
          strupper(temp2);
          var_result_string(temp1,temp2);

          strerase(temp1,len-5,5);
          strcat(temp1,"_EINH");
          tabget(temp2,"EINHEIT");
          var_result_string(temp1,temp2);

          strerase(temp1,len-5,5);
          strcat(temp1,"_INFO");
          tabget(temp2,"INFO");
          var_result_string(temp1,temp2);
        }
        else {
          if (strcmp(temp1,"bit")==0) {
// Bitfeld
            tabget(temp1,"DATENTYP");
            strlower(temp1);
            if (strcmp(temp1,"bitfield")==0) {
              tabget(temp2,"NAME");
              tabset(temp2);
              if (get_error(10)) {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. bitfield table not found='");
                if (res_table_flag==FALSE) {
                  tabset("SG_Funktionen");
                  tabseek(argument_string,argument_name);
                }
                else {
                  tabset("SG_Funktionen");
                  tabseek(argument_string,argument_name);
                  tabget(temp2,"RES_TABELLE");
                  tabset(temp2);
                  tabline(line_res_table);
                }
                tabget(temp2,"NAME");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
              size_bitfield=0;
              size_bitfield_old=0;
              line_bitfield_table=0;
              tabline(line_bitfield_table);
              do {
                tabget(temp1,"EINHEIT");
                strlower(temp1);
                if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert im Bitfeld
                  tabget(temp1,"DATENTYP");
                  strlower(temp1);
                  if ((strcmp(temp1,"char")==0) ||
                      (strcmp(temp1,"unsigned char")==0) ||
                      (strcmp(temp1,"signed char")==0)) {
                    value = response[n];
                    size_bitfield=1;
                  }
                  else {
                    if ((strcmp(temp1,"int")==0) ||
                        (strcmp(temp1,"integer")==0) ||
                        (strcmp(temp1,"unsigned int")==0) ||
                        (strcmp(temp1,"unsigned integer")==0) ||
                        (strcmp(temp1,"signed int")==0) ||
                        (strcmp(temp1,"signed integer")==0)) {
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L'))
                        value = (response[n+1]<<8)+response[n];
                      else
                        value = (response[n]<<8)+response[n+1];
                      size_bitfield=2;
                    }
                    else {
                      if ((strcmp(temp1,"long")==0) ||
                          (strcmp(temp1,"unsigned long")==0) ||
                          (strcmp(temp1,"signed long")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                        size_bitfield=4;
                      }
                      else {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                        tabget(temp2,"DATENTYP");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                  }
                  if (size_bitfield_old != size_bitfield) {
                    if (size_bitfield_old == 0) {
                      size_bitfield_old = size_bitfield;
                    }
                    else {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                      if (res_table_flag==FALSE) {
                        tabset("SG_Funktionen");
                        tabseek(argument_string,argument_name);
                      }
                      else {
                        tabset("SG_Funktionen");
                        tabseek(argument_string,argument_name);
                        tabget(temp2,"RES_TABELLE");
                        tabset(temp2);
                        tabline(line_res_table);
                      }
                      tabget(temp2,"NAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  if (datalen(response) < (n+size_bitfield)) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                    set_trap_mask(0);
                    return;
                  }
                  tabget(temp1,"MASKE");
                  maske=atoi(temp1);
                  if ((maske & value) == maske)
                    value=1;
                  else
                    value=0;
                  tabget(temp1,"RESULTNAME");
                  len=strlen(temp1);
                  if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  if (len >= 5) {
                    temp2="";
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                    if (strcmp(temp2,"_wert")==0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  var_result_long(temp1,value);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                }
                else {
                  if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert im Bitfeld
                    unsigned_long_flag=FALSE;
                    tabget(temp1,"DATENTYP");
                    strlower(temp1);
                    if ((strcmp(temp1,"char")==0) ||
                        (strcmp(temp1,"unsigned char")==0) ||
                        (strcmp(temp1,"signed char")==0)) {
                      value = response[n];
                      value_unsigned = value;
                      if (strcmp(temp1,"unsigned char")!=0)
                        if (value & 0x80) value = value | 0xFFFFFF00;
                      size_bitfield=1;
                    }
                    else {
                      if ((strcmp(temp1,"int")==0) ||
                          (strcmp(temp1,"integer")==0) ||
                          (strcmp(temp1,"unsigned int")==0) ||
                          (strcmp(temp1,"unsigned integer")==0) ||
                          (strcmp(temp1,"signed int")==0) ||
                          (strcmp(temp1,"signed integer")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<8)+response[n+1];
                        value_unsigned = value;
                        if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                          if (value & 0x8000) value = value | 0xFFFF0000;
                        size_bitfield=2;
                      }
                      else {
                        if ((strcmp(temp1,"long")==0) ||
                            (strcmp(temp1,"unsigned long")==0) ||
                            (strcmp(temp1,"signed long")==0)) {
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L'))
                            value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                          else
                            value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                          value_unsigned = value;
                          size_bitfield=4;
                          if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
                        }
                        else {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                          tabget(temp2,"DATENTYP");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                    }
                    if (size_bitfield_old != size_bitfield) {
                      if (size_bitfield_old == 0) {
                        size_bitfield_old = size_bitfield;
                      }
                      else {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    if (datalen(response) < (n+size_bitfield)) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                      set_trap_mask(0);
                      return;
                    }
                    tabget(temp1,"MASKE");
                    maske=atoi(temp1);
                    value = maske & value;
                    value_unsigned = maske & value_unsigned;
                    tabget(temp1,"RESULTNAME");
                    len=strlen(temp1);
                    if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                    temp2="";
                    if (len >= 5) {
                      temp2[0] = temp1[len-5];
                      temp2[1] = temp1[len-4];
                      temp2[2] = temp1[len-3];
                      temp2[3] = temp1[len-2];
                      temp2[4] = temp1[len-1];
                      temp2[5] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_wert")==0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                    temp2="";
                    if (len >= 5) {
                      temp2[0] = temp1[0];
                      temp2[1] = temp1[1];
                      temp2[2] = temp1[2];
                      temp2[3] = temp1[3];
                      temp2[4] = temp1[4];
                      temp2[5] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"stat_")!=0) {
                      if (len >= 6) {
                        temp2[5] = temp1[5];
                        temp2[6] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"_stat_")!=0) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    if (unsigned_long_flag == TRUE)
                      var_result_unsigned_long(temp1,value);
                    else
                      var_result_long(temp1,value);

                    strcat(temp1,"_EINH");
                    tabget(temp2,"EINHEIT");
                    var_result_string(temp1,temp2);

                    strerase(temp1,len,5);
                    strcat(temp1,"_INFO");
                    tabget(temp2,"INFO");
                    var_result_string(temp1,temp2);

                    tabget(temp2,"NAME");
                    if (strcmp(temp2,"-")!=0) {
                      tabset(temp2);
                      if (get_error(10)) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      tab_suche_unsigned("WERT",value_unsigned);
                      if (get_error(10)) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      tabget(temp2,"TEXT");
                      if (get_error(10)) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      strerase(temp1,len,5);
                      strcat(temp1,"_TEXT");
                      var_result_string(temp1,temp2);

                      // wieder zurück
                      if (res_table_flag==FALSE) {
                        tabset("SG_Funktionen");
                        tabseek(argument_string,argument_name);
                      }
                      else {
                        tabset("SG_Funktionen");
                        tabseek(argument_string,argument_name);
                        tabget(temp2,"RES_TABELLE");
                        tabset(temp2);
                        tabline(line_res_table);
                      }
                      tabget(temp2,"NAME");
                      tabset(temp2);
                    }
                  }
                  else {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                    tabget(temp2,"DATENTYP");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                line_bitfield_table++;
              } while (tabline(line_bitfield_table));
              n = n + size_bitfield;
            }
            else {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
              tabget(temp2,"DATENTYP");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
          else {
            if (strcmp(temp1,"data")==0) {
// Data
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              len = strlen(temp1);
              temp2="?????";
              strncpy(temp2,temp1,5);
              if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                temp2=temp1;
                strerase(temp2,len-1,1);
                strerase(temp2,0,5);
                data_len=atoi(temp2);
                if ((data_len > 0) && (data_len < 256)) {
                  data_pos=n;
                  n=n+data_len;
                }
                else {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                  tabget(temp2,"DATENTYP");
                  strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                  itoad(temp2,data_len);
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
              else {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }

              if (datalen(response) < n) {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                set_trap_mask(0);
                return;
              }
              tabget(temp1,"RESULTNAME");
              len=strlen(temp1);

              temp2="";
              if (len >= 6) {
                temp2[0] = temp1[0];
                temp2[1] = temp1[1];
                temp2[2] = temp1[2];
                temp2[3] = temp1[3];
                temp2[4] = temp1[4];
                temp2[5] = temp1[5];
                temp2[6] = 0;
                strlower(temp2);
              }
              if (strcmp(temp2,"dummy_")==0) {
                // Warnung bei Dummy_
                var_result_string("JOB_MESSAGE","Warning: RESULTNAME 'DUMMY_..' ignored.");
              }
              else {
                if (len > 63) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[len-5];
                  temp2[1] = temp1[len-4];
                  temp2[2] = temp1[len-3];
                  temp2[3] = temp1[len-2];
                  temp2[4] = temp1[len-1];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"_data")!=0) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[0];
                  temp2[1] = temp1[1];
                  temp2[2] = temp1[2];
                  temp2[3] = temp1[3];
                  temp2[4] = temp1[4];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"stat_")!=0) {
                  if (len >= 6) {
                    temp2[5] = temp1[5];
                    temp2[6] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_stat_")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                dataclear(temp2);
                datacopy(temp2,response,data_pos,data_len);
                var_result_data(temp1,temp2);

                strerase(temp1,len-5,5);
                strcat(temp1,"_EINH");
                tabget(temp2,"EINHEIT");
                var_result_string(temp1,temp2);

                strerase(temp1,len-5,5);
                strcat(temp1,"_INFO");
                tabget(temp2,"INFO");
                var_result_string(temp1,temp2);
              }
            }
            else {
              if (strcmp(temp1,"text")==0) {
// Text
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                len = strlen(temp1);
                temp2="???????";
                strncpy(temp2,temp1,7);
                if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,7);
                  string_len=atoi(temp2);
                  if ((string_len > 0) && (string_len < 256)) {
                    string_pos=n;
                    n=n+string_len;
                  }
                  else {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                    tabget(temp2,"DATENTYP");
                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                    itoad(temp2,string_len);
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  if (strcmp(temp1,"string")==0) {
                    k=0;
                    string_flag=FALSE;
                    while ((n+k) < datalen(response)) {
                      if (response[n+k]==0) {
                        string_flag=TRUE;
                        string_pos=n;
                        string_len=k+1;
                        n=n+string_len;
                        break;
                      }
                      k++;
                    }
                    if (string_flag==FALSE) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                    tabget(temp2,"DATENTYP");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }

                if (datalen(response) < n) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                  set_trap_mask(0);
                  return;
                }
                tabget(temp1,"RESULTNAME");
                len=strlen(temp1);
                if (len > 63) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[len-5];
                  temp2[1] = temp1[len-4];
                  temp2[2] = temp1[len-3];
                  temp2[3] = temp1[len-2];
                  temp2[4] = temp1[len-1];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"_text")!=0) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[0];
                  temp2[1] = temp1[1];
                  temp2[2] = temp1[2];
                  temp2[3] = temp1[3];
                  temp2[4] = temp1[4];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"stat_")!=0) {
                  if (len >= 6) {
                    temp2[5] = temp1[5];
                    temp2[6] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_stat_")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }

                dataclear(temp2);
                datacopy(temp2,response,string_pos,string_len);
                temp2[string_len]=0;
                var_result_string(temp1,temp2);

                strerase(temp1,len-5,5);
                strcat(temp1,"_EINH");
                tabget(temp2,"EINHEIT");
                var_result_string(temp1,temp2);

                strerase(temp1,len-5,5);
                strcat(temp1,"_INFO");
                tabget(temp2,"INFO");
                var_result_string(temp1,temp2);
              }
              else {
// Analoger Wert
                data_flag=FALSE;
                string_flag=FALSE;
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                if ((strcmp(temp1,"char")==0) ||
                    (strcmp(temp1,"unsigned char")==0) ||
                    (strcmp(temp1,"signed char")==0)) {
                  value = response[n];
                  if (strcmp(temp1,"unsigned char")!=0)
                    if (value & 0x80) value = value | 0xFFFFFF00;
                  itor(value_real,value);
                  n++;
                }
                else {
                  if ((strcmp(temp1,"int")==0) ||
                      (strcmp(temp1,"integer")==0) ||
                      (strcmp(temp1,"unsigned int")==0) ||
                      (strcmp(temp1,"unsigned integer")==0) ||
                      (strcmp(temp1,"signed int")==0) ||
                      (strcmp(temp1,"signed integer")==0)) {
                    tabget(temp2,"L/H");
                    if ((temp2[0]=='l') || (temp2[0]=='L'))
                      value = (response[n+1]<<8)+response[n];
                    else
                      value = (response[n]<<8)+response[n+1];
                    if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                      if (value & 0x8000) value = value | 0xFFFF0000;
                    itor(value_real,value);
                    n=n+2;
                  }
                  else {
                    if ((strcmp(temp1,"long")==0) ||
                        (strcmp(temp1,"unsigned long")==0) ||
                        (strcmp(temp1,"signed long")==0)) {
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L'))
                        value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                      else
                        value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                      itor(value_real,value);
                      if (strcmp(temp1,"unsigned long")==0) {
                        if (value & 0x80000000) {
                          ator(real_temp1,"4294967296");
                          realadd(value_real,real_temp1);
                        }
                      }
                      n=n+4;
                    }
                    else {
                      if ((strcmp(temp1,"float")==0) ||
                          (strcmp(temp1,"intel float")==0)) {
                        data_to_real(value_real,response,n,0,0);
                        n=n+4;
                      }
                      else {
                        if (strcmp(temp1,"motorola float")==0) {
                          data_to_real(value_real,response,n,0,1);
                          n=n+4;
                        }
                        else {
                          if ((strcmp(temp1,"double")==0) ||
                              (strcmp(temp1,"intel double")==0)) {
                            data_to_real(value_real,response,n,1,0);
                            n=n+8;
                          }
                          else {
                            if (strcmp(temp1,"motorola double")==0) {
                              data_to_real(value_real,response,n,1,1);
                              n=n+8;
                            }
                            else {
                              len = strlen(temp1);
                              temp2="?????";
                              strncpy(temp2,temp1,5);
                              if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                                temp2=temp1;
                                strerase(temp2,len-1,1);
                                strerase(temp2,0,5);
                                data_len=atoi(temp2);
                                if ((data_len > 0) && (data_len < 256)) {
                                  data_flag=TRUE;
                                  data_pos=n;
                                  n=n+data_len;
                                }
                                else {
                                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                  tabget(temp2,"DATENTYP");
                                  strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                  itoad(temp2,data_len);
                                  strcat(temp1,temp2);strcat(temp1,"'.");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_TABLE";
                                  set_trap_mask(0);
                                  return;
                                }
                              }
                              else {
                                len = strlen(temp1);
                                temp2="???????";
                                strncpy(temp2,temp1,7);
                                if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                                  temp2=temp1;
                                  strerase(temp2,len-1,1);
                                  strerase(temp2,0,7);
                                  string_len=atoi(temp2);
                                  if ((string_len > 0) && (string_len < 256)) {
                                    string_flag=TRUE;
                                    string_pos=n;
                                    n=n+string_len;
                                  }
                                  else {
                                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                    tabget(temp2,"DATENTYP");
                                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                    itoad(temp2,string_len);
                                    strcat(temp1,temp2);strcat(temp1,"'.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_TABLE";
                                    set_trap_mask(0);
                                    return;
                                  }
                                }
                                else {
                                  if (strcmp(temp1,"string")==0) {
                                    k=0;
                                    string_flag=FALSE;
                                    while ((n+k) < datalen(response)) {
                                      if (response[n+k]==0) {
                                        string_flag=TRUE;
                                        string_pos=n;
                                        string_len=k+1;
                                        n=n+string_len;
                                        break;
                                      }
                                      k++;
                                    }
                                    if (string_flag==FALSE) {
                                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                      tabget(temp2,"DATENTYP");
                                      strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                                      set_trap_mask(0);
                                      return;
                                    }
                                  }
                                  else {
                                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                                    tabget(temp2,"DATENTYP");
                                    strcat(temp1,temp2);strcat(temp1,"'.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_TABLE";
                                    set_trap_mask(0);
                                    return;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (datalen(response) < n) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                  set_trap_mask(0);
                  return;
                }
                tabget(temp1,"RESULTNAME");
                len=strlen(temp1);
                if (len > 63) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[len-5];
                  temp2[1] = temp1[len-4];
                  temp2[2] = temp1[len-3];
                  temp2[3] = temp1[len-2];
                  temp2[4] = temp1[len-1];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"_wert")!=0) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                  tabget(temp2,"RESULTNAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                temp2="";
                if (len >= 5) {
                  temp2[0] = temp1[0];
                  temp2[1] = temp1[1];
                  temp2[2] = temp1[2];
                  temp2[3] = temp1[3];
                  temp2[4] = temp1[4];
                  temp2[5] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"stat_")!=0) {
                  if (len >= 6) {
                    temp2[5] = temp1[5];
                    temp2[6] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_stat_")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }

                if (data_flag==TRUE) {
                  dataclear(temp2);
                  datacopy(temp2,response,data_pos,data_len);
                  var_result_long(temp1,0);
                  strerase(temp1,len-5,5);
                  strcat(temp1,"_DATA");
                  var_result_data(temp1,temp2);
                }
                else {
                  if (string_flag==TRUE) {
                    dataclear(temp2);
                    datacopy(temp2,response,string_pos,string_len);
                    temp2[string_len]=0;
                    var_result_long(temp1,0);
                    strerase(temp1,len-5,5);
                    strcat(temp1,"_TEXT");
                    var_result_string(temp1,temp2);
                  }
                  else {
                    tabget(temp2,"MUL");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      ator(real_temp2,"0");
                      if (realcomp(real_temp1,"==",real_temp2))
                      {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Multiplication with Zero.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      realmul(value_real,real_temp1);
                    }
                    tabget(temp2,"DIV");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      ator(real_temp2,"0");
                      if (realcomp(real_temp1,"==",real_temp2))
                      {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Division by Zero.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      realdiv(value_real,real_temp1);
                    }
                    tabget(temp2,"ADD");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      realadd(value_real,real_temp1);
                    }
                    var_result_real(temp1,value_real);
                  }
                }

                strerase(temp1,len-5,5);
                strcat(temp1,"_EINH");
                tabget(temp2,"EINHEIT");
                var_result_string(temp1,temp2);

                strerase(temp1,len-5,5);
                strcat(temp1,"_INFO");
                tabget(temp2,"INFO");
                var_result_string(temp1,temp2);
              } // else Text
            } // else Data
          } // else Bitfeld
        } // else Hex String
      } // else Diskreter Wert
    } // else Digitaler Wert
    if (res_table_flag==TRUE) {
      tabset("SG_Funktionen");
      tabseek(argument_string,argument_name);
      tabget(temp2,"RES_TABELLE");
      tabset(temp2);
      line_res_table++;
      if (!tabline(line_res_table)) res_table_flag=FALSE;
    }
  } while (res_table_flag==TRUE);

  if (datalen(response) != n) {
    temp1="Too much data.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_MUCH_DATA";
    set_trap_mask(0);
    return;
  }
  JOB_STATUS = "OKAY";
  set_trap_mask(0);
}
// end of : #include "UDS_2F_STEUERN_IO.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_31_STEUERN_ROUTINE.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_ROUTINE
// -------------------------------------------------------------------
// Globale Konstanten : TA
//                      UNCHECK_LEN_IDENTIFIER_LIST[]
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 31.05.2006  rd  V0.01 Erstellung
// 31.05.2006  rd  V0.10 Header überarbeitet
// 12.06.2006  rd  V0.11 Datentyp integer dazu
// 20.06.2006  rd  V0.12 Datentyp BITFIELD dazu
//                 V0.12 Fehlermeldung bei string überarbeitet
//                 V0.12 Unterschiedliche Result- und Argumentauswertung
//                 V0.12 für STR, STPR, RRR
// 22.06.2006  rd  V0.20 Serviceüberprüfung dazu
// 24.07.2006  rd  V0.21 '0-n' _WERT- Results nicht erlaubt
// 04.09.2006  rd  V0.22 Erstes Result führt zu keiner Fehlermeldung
//                 V0.22 wenn RESULTNAME und DATENTYP und EINHEIT == '-'
// 06.03.2007  rd  V0.50 Bei diskretem Argument. Wenn Argument nicht
//             rd  V0.50 in Spalte Text gefunden wird,
//             rd  V0.50 dann auch in Spalte WERT suchen
// 27.03.2007  rd  V0.60 Serviceüberprüfung aktiv
//             rd  V0.60 Resultname beginnend mit _stat_ jetzt erlaubt
// 22.05.2007  rd  V0.75 Bug Bitfeld-Maske behoben
// 04.09.2007  rd  V0.80 Bug Analoger Wert unsigned long / long behoben
// 06.12.2007  rd  V1.00 Freigabe
// 22.11.2010  rd  V2.00 Einheit DATA, TEXT dazu
//                 V2.00 Anforderung VH-53 Waegner
//                 V2.00 Integration DUMMY_ bei Einheit DATA
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Integration Entfall Längenprüfung
//                 V2.00 Anforderung EA-410 Lorch
//                 V2.00 Freigabe
// *******************************************************************
// UDS_31_STEUERN_ROUTINE.B2S @(#)@ V2.00 @(#)@
// *******************************************************************
job ( name      :       STEUERN_ROUTINE;
      comment   :       Vorgeben eines Status;
      comment   :       UDS  : $31 RoutineControl;

      argument  :       ARGUMENT_SPALTE;
        type    :       string;
        comment :       'ARG', 'ID', 'LABEL';

      argument  :       STATUS;
        type    :       string;
        comment :       Siehe table SG_Funktionen ARG ID RES_TABELLE ARG_TABELLE;

      argument  :       STEUERPARAMETER;
        type    :       string;
        comment :       'STR'  = startRoutine;
        comment :       'STPR' = stopRoutine;
        comment :       'RRR'  = requestRoutineResults;

      argument  :       WERT;
        type    :       string;
        comment :       Argumente siehe table SG_Funktionen ARG_TABELLE;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x31};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned char argument_name[];
  unsigned char argument_string[];
  unsigned char temp1[];
  unsigned char temp2[];
  unsigned char control_parameter;
  unsigned char control_parameter_response;
  unsigned int  k;
  unsigned int  n;
  unsigned int  id;
  unsigned int  id_response;
  unsigned int  len;
  unsigned int  anz_arg;
  unsigned int  anz_arg_offset;
  unsigned int  found_flag;
  unsigned int  data_len;
  unsigned int  unsigned_long_flag;
  unsigned int  data_flag;
  unsigned int  data_pos;
  unsigned int  string_flag;
  unsigned int  string_pos;
  unsigned int  string_len;
  unsigned int  hex_len;
  unsigned int  res_table_flag;
  unsigned int  line_res_table;
  unsigned int  line_res_table_offset;
  unsigned int  first_result_flag;
  unsigned int  size_bitfield;
  unsigned int  size_bitfield_old;
  unsigned int  line_bitfield_table;
  unsigned int  gefunden_flag;
  unsigned long argument_unsigned;
           long value;
           long value_unsigned;
           long maske;
           real value_real;
           real real_temp1;
           real real_temp2;

// ---------------- Argumente des Jobs auswerten ---------------------
  if (exist(ARGUMENT_SPALTE)) {
    argument_string = ARGUMENT_SPALTE;
    strupper(argument_string);
    if ((strcmp(argument_string,"ARG")!=0) &&
        (strcmp(argument_string,"ID")!=0) &&
        (strcmp(argument_string,"LABEL")!=0)) {
      temp1="Argument ARGUMENT_SPALTE='";strcat(temp1,argument_string);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
  }
  else {
    var_result_string("JOB_MESSAGE","Argument ARGUMENT_SPALTE missing ('ARG', 'ID', 'LABEL').");
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

  if (!exist(STATUS)) {
    temp1="Argument STATUS missing.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

// ---------------- Request erzeugen ---------------------------------
  set_trap_mask(0x400);
  tabset("SG_Funktionen");
  if (get_error(10)) {
    var_result_string("JOB_MESSAGE","Table 'SG_Funktionen' not found.");
    JOB_STATUS = "ERROR_TABLE";
    set_trap_mask(0);
    return;
  }

  n=1;
  if (exist(STEUERPARAMETER)) {
    temp2 = STEUERPARAMETER;
    strupper(temp2);
    if ((strcmp(temp2,"STR")!=0) &&
        (strcmp(temp2,"STPR")!=0) &&
        (strcmp(temp2,"RRR")!=0)) {
      temp1="Argument STEUERPARAMETER='";strcat(temp1,temp2);strcat(temp1,"' not valid.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      return;
    }
    else {
      if (strcmp(temp2,"STR")  ==0) control_parameter = 0x01;
      if (strcmp(temp2,"STPR") ==0) control_parameter = 0x02;
      if (strcmp(temp2,"RRR")  ==0) control_parameter = 0x03;
      request[n++] = control_parameter;
    }
  }
  else {
    var_result_string("JOB_MESSAGE","Argument STEUERPARAMETER missing ('STR', 'STPR', 'RRR').");
    JOB_STATUS = "ERROR_ARGUMENT";
    return;
  }

  argument_name=STATUS;
  if (strcmp(argument_name,"-")==0) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not valid.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  if (!tabseek(argument_string,argument_name)) {
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"' not found.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ARGUMENT";
    set_trap_mask(0);
    return;
  }
  tabget(temp2,"SERVICE");
  if (strcmp(temp2,"-")!=0) {
    strupper(temp2);
    k=0;
    gefunden_flag=FALSE;
    while (temp2[k]!=0){
      if (temp2[k]=='3') {
        if (temp2[k+1]=='1') {
          gefunden_flag=TRUE;
          break;
        }
      }
      k++;
    }
    if (gefunden_flag==FALSE) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);
      strcat(temp1,"' not valid. Service '31' not found in Table 'SG_Funktionen' column 'SERVICE'='");
      tabget(temp2,"SERVICE");
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }
  tabget(temp2,"ID");
  id = atoi(temp2);
  request[n++] = id >> 8;
  request[n++] = id & 0xFF;

  tabget(argument_string,"ARG_TABELLE");
  if ((control_parameter != 0x03) && (strcmp(argument_string,"-")!=0)) {
    // nur StartRoutine oder StopRoutine und Tabelle vorhanden
    tabset(argument_string);
    if (get_error(10)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Argument table not found='");
      strcat(temp1,argument_string);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    if (WERT); // damit die Compilerwarnung entfällt
    anz_arg=0;
    anz_arg_offset=0;
    while (tabline(anz_arg + anz_arg_offset)) {
      if (control_parameter == 0x01) tabget(temp2,"STR");
      if (control_parameter == 0x02) tabget(temp2,"STPR");
      if (get_error(10)) temp2="+"; // falls Spalte nicht existiert
      if ((strcmp(temp2,"+")!=0) && (strcmp(temp2,"-")!=0)) {
        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
        if (control_parameter == 0x01) {
          strcat(temp1,"'. STR not valid='");
          tabget(temp2,"STR");
        }
        if (control_parameter == 0x02) {
          strcat(temp1,"'. STPR not valid='");
          tabget(temp2,"STPR");
        }
        strcat(temp1,temp2);strcat(temp1,"' ('+', '-').");
        var_result_string("JOB_MESSAGE",temp1);
        JOB_STATUS = "ERROR_TABLE";
        set_trap_mask(0);
        return;
      }
      if (strcmp(temp2,"+")==0) {
        if (!get_argument(argument_name,anz_arg+4)) {
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if (strcmp(temp1,"string")!=0) { // Leerstring erlauben
            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);
            strcat(temp1,"] missing. Argument table='");strcat(temp1,argument_string);
            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ARGUMENT";
            set_trap_mask(0);
            return;
          }
        }
        tabget(temp1,"EINHEIT");
        strlower(temp1);
        if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
          aitor(value_real,argument_name);
          value=atoi(argument_name);
          if ((strcmp(argument_name,"0")!=0) && (strcmp(argument_name,"1")!=0)) {
            temp1="Argument WERT[";
            itoad(temp2,anz_arg+1);
            strcat(temp1,temp2);strcat(temp1,"] Digital value not valid='");
            strcat(temp1,argument_name);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ARGUMENT";
            set_trap_mask(0);
            return;
          }
          tabget(temp1,"MIN");
          if (strcmp(temp1,"-")!=0) {
            aitor(real_temp1,temp1);
            if (realcomp(value_real,"<",real_temp1)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Out of range. '");
              strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
          }
          tabget(temp1,"MAX");
          if (strcmp(temp1,"-")!=0) {
            aitor(real_temp1,temp1);
            if (realcomp(value_real,">",real_temp1)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Out of range. '");
              strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
          }
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            request[n] = value;
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L')) {
                request[n]   = value;
                request[n+1] = value>>8;
              }
              else {
                request[n+1] = value;
                request[n]   = value>>8;
              }
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                  request[n]   = value;
                  request[n+1] = value>>8;
                  request[n+2] = value>>16;
                  request[n+3] = value>>24;
                }
                else {
                  request[n+3] = value;
                  request[n+2] = value>>8;
                  request[n+1] = value>>16;
                  request[n]   = value>>24;
                }
                n=n+4;
              }
              else {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
          }
        }
        else {
          if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
            tabget(temp2,"NAME");
            if (strcmp(temp2,"-")==0) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. NAME not valid='");tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            tabset(temp2);
            if (get_error(10)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              tabset(argument_string);tabline(anz_arg + anz_arg_offset);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Discrete value table not found='");
              tabget(temp2,"NAME");strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            found_flag=tabseek("TEXT",argument_name);
            if (get_error(10)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              tabset(argument_string);tabline(anz_arg + anz_arg_offset);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Discrete value table='");
              tabget(temp2,"NAME");strcat(temp1,temp2);
              strcat(temp1,"'. Column 'TEXT' not found.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            if (found_flag!=TRUE) {
              // Wenn nicht in Spalte Text gefunden, dann auch in Spalte Wert als Zahl suchen
              if (is_hex_string(argument_name) || is_unsigned_string(argument_name)) {
                argument_unsigned = atoi(argument_name);
                found_flag=tab_suche_unsigned("WERT",argument_unsigned);
                if (get_error(10)) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  tabset(argument_string);tabline(anz_arg + anz_arg_offset);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. Discrete value table='");
                  tabget(temp2,"NAME");strcat(temp1,temp2);
                  strcat(temp1,"'. Column 'WERT' not found.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
            }
            if (found_flag!=TRUE) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              tabset(argument_string);tabline(anz_arg + anz_arg_offset);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Discrete table='");
              tabget(temp2,"NAME");strcat(temp1,temp2);
              strcat(temp1,"'. Argument not found.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ARGUMENT";
              set_trap_mask(0);
              return;
            }
            tabget(temp1,"WERT");
            aitor(value_real,temp1);
            value=atoi(temp1);
            if (get_error(10)) {
              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
              tabset(argument_string);tabline(anz_arg + anz_arg_offset);
              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
              strcat(temp1,"'. Discrete value table='");
              tabget(temp2,"NAME");strcat(temp1,temp2);
              strcat(temp1,"'. Column 'WERT' not found.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            // wieder zurück zur Tabelle
            tabset(argument_string);
            tabline(anz_arg + anz_arg_offset);
            tabget(temp1,"MIN");
            if (strcmp(temp1,"-")!=0) {
              aitor(real_temp1,temp1);
              if (realcomp(value_real,"<",real_temp1)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Out of range. '");
                strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
            }
            tabget(temp1,"MAX");
            if (strcmp(temp1,"-")!=0) {
              aitor(real_temp1,temp1);
              if (realcomp(value_real,">",real_temp1)) {
                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                strcat(temp1,"'. Out of range. '");
                strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_ARGUMENT";
                set_trap_mask(0);
                return;
              }
            }
            tabget(temp1,"DATENTYP");
            strlower(temp1);
            if ((strcmp(temp1,"char")==0) ||
                (strcmp(temp1,"unsigned char")==0) ||
                (strcmp(temp1,"signed char")==0)) {
              request[n] = value;
              n++;
            }
            else {
              if ((strcmp(temp1,"int")==0) ||
                  (strcmp(temp1,"integer")==0) ||
                  (strcmp(temp1,"unsigned int")==0) ||
                  (strcmp(temp1,"unsigned integer")==0) ||
                  (strcmp(temp1,"signed int")==0) ||
                  (strcmp(temp1,"signed integer")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                  request[n]   = value;
                  request[n+1] = value>>8;
                }
                else {
                  request[n+1] = value;
                  request[n]   = value>>8;
                }
                n=n+2;
              }
              else {
                if ((strcmp(temp1,"long")==0) ||
                    (strcmp(temp1,"unsigned long")==0) ||
                    (strcmp(temp1,"signed long")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L')) {
                    request[n]   = value;
                    request[n+1] = value>>8;
                    request[n+2] = value>>16;
                    request[n+3] = value>>24;
                  }
                  else {
                    request[n+3] = value;
                    request[n+2] = value>>8;
                    request[n+1] = value>>16;
                    request[n]   = value>>24;
                  }
                  n=n+4;
                }
                else {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
            }
          }
          else {
            if (strcmp(temp1,"hex")==0) {
// Hex String
              aitor(value_real,argument_name);
              value=atoi(argument_name);
              tabget(temp1,"MIN");
              if (strcmp(temp1,"-")!=0) {
                aitor(real_temp1,temp1);
                if (realcomp(value_real,"<",real_temp1)) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. Out of range. '");
                  strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              tabget(temp1,"MAX");
              if (strcmp(temp1,"-")!=0) {
                aitor(real_temp1,temp1);
                if (realcomp(value_real,">",real_temp1)) {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. Out of range. '");
                  strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ARGUMENT";
                  set_trap_mask(0);
                  return;
                }
              }
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              if ((strcmp(temp1,"char")==0) ||
                  (strcmp(temp1,"unsigned char")==0) ||
                  (strcmp(temp1,"signed char")==0)) {
                request[n] = value;
                n++;
              }
              else {
                if ((strcmp(temp1,"int")==0) ||
                    (strcmp(temp1,"integer")==0) ||
                    (strcmp(temp1,"unsigned int")==0) ||
                    (strcmp(temp1,"unsigned integer")==0) ||
                    (strcmp(temp1,"signed int")==0) ||
                    (strcmp(temp1,"signed integer")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L')) {
                    request[n]   = value;
                    request[n+1] = value>>8;
                  }
                  else {
                    request[n+1] = value;
                    request[n]   = value>>8;
                  }
                  n=n+2;
                }
                else {
                  if ((strcmp(temp1,"long")==0) ||
                      (strcmp(temp1,"unsigned long")==0) ||
                      (strcmp(temp1,"signed long")==0)) {
                    tabget(temp2,"L/H");
                    if ((temp2[0]=='l') || (temp2[0]=='L')) {
                      request[n]   = value;
                      request[n+1] = value>>8;
                      request[n+2] = value>>16;
                      request[n+3] = value>>24;
                    }
                    else {
                      request[n+3] = value;
                      request[n+2] = value>>8;
                      request[n+1] = value>>16;
                      request[n]   = value>>24;
                    }
                    n=n+4;
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
              }
            }
            else {
// Analoger Wert
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              len = strlen(temp1);
              temp2="?????";
              strncpy(temp2,temp1,5);
              if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                temp2=temp1;
                strerase(temp2,len-1,1);
                strerase(temp2,0,5);
                data_len=atoi(temp2);
                if ((data_len > 0) && (data_len < 256)) {
                  len=strlen(argument_name);
                  if (len == 2*data_len) {
                    ascii2hex(request,argument_name,n);
                    n=n+data_len;
                    if (datalen(request) != n) {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Invalid characters in argument. Valid characters=0123456789ABCDEF.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    if (len < 2*data_len)
                      strcat(temp1,"'. Too less data. Expected argument string len='");
                    else
                      strcat(temp1,"'. Too much data. Expected argument string len='");
                    itoad(temp2,2*data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ARGUMENT";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                  strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
              else {
                len = strlen(temp1);
                temp2="???????";
                strncpy(temp2,temp1,7);
                if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,7);
                  data_len=atoi(temp2);
                  if ((data_len > 0) && (data_len < 256)) {
                    len=strlen(argument_name);
                    if (len == data_len) {
                      datacat(request,argument_name);
                      dataerase(request,n+data_len,1);  // String end character '0x00' entfernen
                      n=n+data_len;
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      if (len < data_len)
                        strcat(temp1,"'. Too less data. Expected argument string len='");
                      else
                        strcat(temp1,"'. Too much data. Expected argument string len='");
                      itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                    strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  if (strcmp(temp1,"string")==0) {
                    data_len=strlen(argument_name)+1; // String end character '0x00'
                    if ((data_len > 0) && (data_len < 256)) {
                      datacat(request,argument_name);
                      n=n+data_len;
                    }
                    else {
                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                      strcat(temp1,"'. Len out of range (1..255)='");itoad(temp2,data_len);strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ARGUMENT";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    aitor(value_real,argument_name);
                    tabget(temp1,"MIN");
                    if (strcmp(temp1,"-")!=0) {
                      aitor(real_temp1,temp1);
                      if (realcomp(value_real,"<",real_temp1)) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        strcat(temp1,argument_name);strcat(temp1,"' < MIN='");tabget(temp2,"MIN");strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    tabget(temp1,"MAX");
                    if (strcmp(temp1,"-")!=0) {
                      aitor(real_temp1,temp1);
                      if (realcomp(value_real,">",real_temp1)) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        strcat(temp1,argument_name);strcat(temp1,"' > MAX='");tabget(temp2,"MAX");strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    tabget(temp2,"MUL");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      ator(real_temp2,"0");
                      if (realcomp(real_temp1,"==",real_temp2))
                      {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. Multiplication with Zero.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      realmul(value_real,real_temp1);
                    }
                    tabget(temp2,"DIV");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      ator(real_temp2,"0");
                      if (realcomp(real_temp1,"==",real_temp2))
                      {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. Division by Zero.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      realdiv(value_real,real_temp1);
                    }
                    tabget(temp2,"ADD");
                    if (strcmp(temp2,"-")!=0) {
                      aitor(real_temp1,temp2);
                      realadd(value_real,real_temp1);
                    }
                    tabget(temp1,"DATENTYP");
                    strlower(temp1);
                    if ((strcmp(temp1,"char")==0) ||
                        (strcmp(temp1,"signed char")==0)) {
                      value=rtoi_round(value_real);
                      if (value < -128) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -128.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                      if (value > 127) {
                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                        strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                        strcat(temp1,"'. Out of range. '");
                        itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 127.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ARGUMENT";
                        set_trap_mask(0);
                        return;
                      }
                      request[n] = value;
                      n++;
                    }
                    else {
                      if (strcmp(temp1,"unsigned char")==0) {
                        value=rtoi_round(value_real);
                        if (value < 0) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        if (value > 255) {
                          temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                          strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                          strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                          strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                          strcat(temp1,"'. Out of range. '");
                          itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 255.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_ARGUMENT";
                          set_trap_mask(0);
                          return;
                        }
                        request[n] = value;
                        n++;
                      }
                      else {
                        if ((strcmp(temp1,"int")==0) ||
                            (strcmp(temp1,"integer")==0) ||
                            (strcmp(temp1,"signed int")==0) ||
                            (strcmp(temp1,"signed integer")==0)) {
                          value=rtoi_round(value_real);
                          if (value < -32768) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < -32768.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          if (value > 32767) {
                            temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                            strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                            strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                            strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                            strcat(temp1,"'. Out of range. '");
                            itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 32767.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_ARGUMENT";
                            set_trap_mask(0);
                            return;
                          }
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L')) {
                            request[n]   = value;
                            request[n+1] = value>>8;
                          }
                          else {
                            request[n+1] = value;
                            request[n]   = value>>8;
                          }
                          n=n+2;
                        }
                        else {
                          if ((strcmp(temp1,"unsigned int")==0) ||
                              (strcmp(temp1,"unsigned integer")==0)) {
                            value=rtoi_round(value_real);
                            if (value < 0) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            if (value > 65535) {
                              temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                              strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                              strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                              strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                              strcat(temp1,"'. Out of range. '");
                              itoad(temp2,value);strcat(temp1,temp2);strcat(temp1,"' > 65535.");
                              var_result_string("JOB_MESSAGE",temp1);
                              JOB_STATUS = "ERROR_ARGUMENT";
                              set_trap_mask(0);
                              return;
                            }
                            tabget(temp2,"L/H");
                            if ((temp2[0]=='l') || (temp2[0]=='L')) {
                              request[n]   = value;
                              request[n+1] = value>>8;
                            }
                            else {
                              request[n+1] = value;
                              request[n]   = value>>8;
                            }
                            n=n+2;
                          }
                          else {
                            if ((strcmp(temp1,"long")==0) ||
                                (strcmp(temp1,"signed long")==0)) {
                              ator(real_temp1,"-2147483648");
                              if (realcomp(value_real,"<",real_temp1)) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -2147483648.");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              ator(real_temp1,"2147483647");
                              if (realcomp(value_real,">",real_temp1)) {
                                temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                strcat(temp1,"'. Out of range. '");
                                rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 2147483647.");
                                var_result_string("JOB_MESSAGE",temp1);
                                JOB_STATUS = "ERROR_ARGUMENT";
                                set_trap_mask(0);
                                return;
                              }
                              value=rtoi_round(value_real);
                              tabget(temp2,"L/H");
                              if ((temp2[0]=='l') || (temp2[0]=='L')) {
                                request[n]   = value;
                                request[n+1] = value>>8;
                                request[n+2] = value>>16;
                                request[n+3] = value>>24;
                              }
                              else {
                                request[n+3] = value;
                                request[n+2] = value>>8;
                                request[n+1] = value>>16;
                                request[n]   = value>>24;
                              }
                              n=n+4;
                            }
                            else {
                              if (strcmp(temp1,"unsigned long")==0) {
                                ator(real_temp1,"0");
                                if (realcomp(value_real,"<",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < 0.");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                ator(real_temp1,"4294967295");
                                if (realcomp(value_real,">",real_temp1)) {
                                  temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                  strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                  strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                  strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                  strcat(temp1,"'. Out of range. '");
                                  rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 4294967295.");
                                  var_result_string("JOB_MESSAGE",temp1);
                                  JOB_STATUS = "ERROR_ARGUMENT";
                                  set_trap_mask(0);
                                  return;
                                }
                                value=rtoi_round(value_real);
                                tabget(temp2,"L/H");
                                if ((temp2[0]=='l') || (temp2[0]=='L')) {
                                  request[n]   = value;
                                  request[n+1] = value>>8;
                                  request[n+2] = value>>16;
                                  request[n+3] = value>>24;
                                }
                                else {
                                  request[n+3] = value;
                                  request[n+2] = value>>8;
                                  request[n+1] = value>>16;
                                  request[n]   = value>>24;
                                }
                                n=n+4;
                              }
                              else {
                                if ((strcmp(temp1,"float")==0) ||
                                    (strcmp(temp1,"intel float")==0)) {
                                  ator(real_temp1,"-3.4028234663852884E+038");
                                  if (realcomp(value_real,"<",real_temp1)) {
                                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                    strcat(temp1,"'. Out of range. '");
                                    rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_ARGUMENT";
                                    set_trap_mask(0);
                                    return;
                                  }
                                  ator(real_temp1,"3.4028234663852884E+038");
                                  if (realcomp(value_real,">",real_temp1)) {
                                    temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                    strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                    strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                    strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                    strcat(temp1,"'. Out of range. '");
                                    rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_ARGUMENT";
                                    set_trap_mask(0);
                                    return;
                                  }
                                  ator(real_temp1,"0");
                                  if (realcomp(value_real,">",real_temp1)) {
                                    ator(real_temp1,"1.1754943508222877E-038");
                                    if (realcomp(value_real,"<",real_temp1)) {
                                      value_real=real_temp1;
                                    }
                                  }
                                  ator(real_temp1,"0");
                                  if (realcomp(value_real,"<",real_temp1)) {
                                    ator(real_temp1,"-1.1754943508222877E-038");
                                    if (realcomp(value_real,">",real_temp1)) {
                                      value_real=real_temp1;
                                    }
                                  }
                                  real_to_data(request,value_real,n,0,0);
                                  n=n+4;
                                }
                                else {
                                  if (strcmp(temp1,"motorola float")==0) {
                                    ator(real_temp1,"-3.4028234663852884E+038");
                                    if (realcomp(value_real,"<",real_temp1)) {
                                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                      strcat(temp1,"'. Out of range. '");
                                      rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' < -3.4028234663852884E+038");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_ARGUMENT";
                                      set_trap_mask(0);
                                      return;
                                    }
                                    ator(real_temp1,"3.4028234663852884E+038");
                                    if (realcomp(value_real,">",real_temp1)) {
                                      temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                      strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                      strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                      strcat(temp1,"'. DATENTYP='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);
                                      strcat(temp1,"'. Out of range. '");
                                      rtoa(temp2,value_real,0);strcat(temp1,temp2);strcat(temp1,"' > 3.4028234663852884E+038");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_ARGUMENT";
                                      set_trap_mask(0);
                                      return;
                                    }
                                    ator(real_temp1,"0");
                                    if (realcomp(value_real,">",real_temp1)) {
                                      ator(real_temp1,"1.1754943508222877E-038");
                                      if (realcomp(value_real,"<",real_temp1)) {
                                        value_real=real_temp1;
                                      }
                                    }
                                    ator(real_temp1,"0");
                                    if (realcomp(value_real,"<",real_temp1)) {
                                      ator(real_temp1,"-1.1754943508222877E-038");
                                      if (realcomp(value_real,">",real_temp1)) {
                                        value_real=real_temp1;
                                      }
                                    }
                                    real_to_data(request,value_real,n,0,1);
                                    n=n+4;
                                  }
                                  else {
                                    if ((strcmp(temp1,"double")==0) ||
                                        (strcmp(temp1,"intel double")==0)) {
                                      real_to_data(request,value_real,n,1,0);
                                      n=n+8;
                                    }
                                    else {
                                      if (strcmp(temp1,"motorola double")==0) {
                                        real_to_data(request,value_real,n,1,1);
                                        n=n+8;
                                      }
                                      else {
                                        temp1="Argument WERT[";itoad(temp2,anz_arg+1);strcat(temp1,temp2);strcat(temp1,"]='");strcat(temp1,argument_name);
                                        strcat(temp1,"'. Argument table='");strcat(temp1,argument_string);
                                        strcat(temp1,"'. Argument='");tabget(temp2,"ARG");strcat(temp1,temp2);
                                        strcat(temp1,"'. DATENTYP not valid='");tabget(temp2,"DATENTYP");strcat(temp1,temp2);strcat(temp1,"'.");
                                        var_result_string("JOB_MESSAGE",temp1);
                                        JOB_STATUS = "ERROR_TABLE";
                                        set_trap_mask(0);
                                        return;
                                      } // else Analog motorola double
                                    } // else Analog (intel) double
                                  } // else Analog motorola float
                                } // else Analog (intel) float
                              } // else Analog unsigned long
                            } // else Analog (signed) long
                          } // else Analog unsigned int
                        } // else Analog (signed) int
                      } // else Analog unsigned char
                    } // else Analog (signed) char
                  } // else Analog string
                } // else Analog string[x]
              } // else Analog data[x]
            } // else Hex String
          } // else Diskreter Wert
        } // else Digitaler Wert
        anz_arg++;
      } // temp2 == "+" ?
      else {
        anz_arg_offset++;
      }
    }
    if (get_argument(temp1,anz_arg+4)) {
      temp1="Argument WERT[";
      itoad(temp2,anz_arg+1);
      strcat(temp1,temp2);strcat(temp1,"]='");
      get_argument(temp2,anz_arg+4);
      strcat(temp1,temp2);strcat(temp1,"'. Too many arguments. Number of arguments='");
      itoad(temp2,anz_arg);strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  } //  if ((control_parameter != 0x03) && (strcmp(argument_string,"-")!=0))
  else {
    k=0;
    while (!get_argument(temp1,k+4)) {
      if (k >= 31) break;
      k++;
    }
    if (strlen(temp1) > 0) {
      temp1="Argument WERT[";
      itoad(temp2,k+1);
      strcat(temp1,temp2);strcat(temp1,"]='");
      get_argument(temp2,k+4);
      strcat(temp1,temp2);strcat(temp1,"'. Too many arguments. Number of arguments='0'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_ARGUMENT";
      set_trap_mask(0);
      return;
    }
  }

// ---------------- Kommunikation ------------------------------------
  if (_REQUEST) _REQUEST = request;
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "_RESPONSE", 2)) {
    set_trap_mask(0);
    return;
  }

// ---------------- Response auswerten -------------------------------
  if (datalen(response) < 4) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
    set_trap_mask(0);
    return;
  }
  control_parameter_response = response[1];
  if (control_parameter_response != control_parameter) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response io control parameter. Expected='");
    itoax(temp2,control_parameter);strerase(temp2,2,6);
    strcat(temp1,temp2);strcat(temp1,"' != Response='");
    itoax(temp2,control_parameter_response);strerase(temp2,2,6);
    strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_ROUTINE_CONTROL_TYPE";
    set_trap_mask(0);
    return;
  }
  id_response = (response[2]<<8)+response[3];
  if (id_response != id) {
    argument_name=STATUS;
    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Incorrect response data identifier. Expected='");
    itoax(temp2,id);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"' != Response='");
    itoax(temp2,id_response);strerase(temp2,2,4);
    strcat(temp1,temp2);strcat(temp1,"'.");
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_INCORRECT_DATA_IDENTIFIER";
    set_trap_mask(0);
    return;
  }
  n=4;
  tabset("SG_Funktionen");
  argument_string = ARGUMENT_SPALTE;
  argument_name=STATUS;
  tabseek(argument_string,argument_name);

  res_table_flag=FALSE;
  tabget(temp2,"RES_TABELLE");
  if (strcmp(temp2,"-")!=0) {
    tabset(temp2);
    if (get_error(10)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Result table not found='");
      tabset("SG_Funktionen");
      tabseek(argument_string,argument_name);
      tabget(temp2,"RES_TABELLE");
      strcat(temp1,temp2);strcat(temp1,"'.");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    res_table_flag=TRUE;
    line_res_table=0;
    line_res_table_offset=0;
    tabline(line_res_table + line_res_table_offset);
  }
  first_result_flag=TRUE;
  do {
    if (control_parameter == 0x01) tabget(temp2,"STR");
    if (control_parameter == 0x02) tabget(temp2,"STPR");
    if (control_parameter == 0x03) tabget(temp2,"RRR");
    if (get_error(10)) temp2="+"; // falls Spalte nicht existiert
    if ((strcmp(temp2,"+")!=0) && (strcmp(temp2,"-")!=0)) {
      temp1="Argument STATUS='";strcat(temp1,argument_name);
      if (control_parameter == 0x01) {
        strcat(temp1,"'. STR not valid='");
        tabget(temp2,"STR");
      }
      if (control_parameter == 0x02) {
        strcat(temp1,"'. STPR not valid='");
        tabget(temp2,"STPR");
      }
      if (control_parameter == 0x03) {
        strcat(temp1,"'. RRR not valid='");
        tabget(temp2,"RRR");
      }
      strcat(temp1,temp2);strcat(temp1,"' ('+', '-').");
      var_result_string("JOB_MESSAGE",temp1);
      JOB_STATUS = "ERROR_TABLE";
      set_trap_mask(0);
      return;
    }
    if (strcmp(temp2,"+")==0) {
      if (first_result_flag == TRUE) {
        tabget(temp1,"RESULTNAME");
        if (strcmp(temp1,"-")==0) {
          tabget(temp1,"DATENTYP");
          if (strcmp(temp1,"-")==0) {
            tabget(temp1,"EINHEIT");
            if (strcmp(temp1,"-")==0) break;
          }
        }
        first_result_flag=FALSE;
      }
      // Längenprüfung abschalten ?
      // nur wenn keine Restdaten vorhanden
      if (datalen(response) == n) {
        len = datalen(UNCHECK_LEN_IDENTIFIER_LIST) / 2 ; // 1 Integer = 2 Byte
        k=0;
        do {
          if (UNCHECK_LEN_IDENTIFIER_LIST[k] != 0) {
            if (UNCHECK_LEN_IDENTIFIER_LIST[k] == id) {
              // Zu wenig Daten. Restliche Results werden nicht erzeugt
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data. UNCHECK_LEN_IDENTIFIER_LIST contains ID='");
              itoax(temp2,id);strerase(temp2,2,4);
              strcat(temp1,temp2);strcat(temp1,"'. WARNING: Remaining results are not created.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "OKAY";
              set_trap_mask(0);
              return;
            }
          }
          k++;
        } while (k<len);
      }
      tabget(temp1,"EINHEIT");
      strlower(temp1);
      if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert
        tabget(temp1,"DATENTYP");
        strlower(temp1);
        if ((strcmp(temp1,"char")==0) ||
            (strcmp(temp1,"unsigned char")==0) ||
            (strcmp(temp1,"signed char")==0)) {
          value = response[n];
          n++;
        }
        else {
          if ((strcmp(temp1,"int")==0) ||
              (strcmp(temp1,"integer")==0) ||
              (strcmp(temp1,"unsigned int")==0) ||
              (strcmp(temp1,"unsigned integer")==0) ||
              (strcmp(temp1,"signed int")==0) ||
              (strcmp(temp1,"signed integer")==0)) {
            tabget(temp2,"L/H");
            if ((temp2[0]=='l') || (temp2[0]=='L'))
              value = (response[n+1]<<8)+response[n];
            else
              value = (response[n]<<8)+response[n+1];
            n=n+2;
          }
          else {
            if ((strcmp(temp1,"long")==0) ||
                (strcmp(temp1,"unsigned long")==0) ||
                (strcmp(temp1,"signed long")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
              else
                value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
              n=n+4;
            }
            else {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
              tabget(temp2,"DATENTYP");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
        }
        if (datalen(response) < n) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
          set_trap_mask(0);
          return;
        }
        tabget(temp1,"RESULTNAME");
        len=strlen(temp1);
        if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
          tabget(temp2,"RESULTNAME");
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_TABLE";
          set_trap_mask(0);
          return;
        }
        if (len >= 5) {
          temp2="";
          temp2[0] = temp1[len-5];
          temp2[1] = temp1[len-4];
          temp2[2] = temp1[len-3];
          temp2[3] = temp1[len-2];
          temp2[4] = temp1[len-1];
          temp2[5] = 0;
          strlower(temp2);
          if (strcmp(temp2,"_wert")==0) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
        temp2="";
        if (len >= 5) {
          temp2[0] = temp1[0];
          temp2[1] = temp1[1];
          temp2[2] = temp1[2];
          temp2[3] = temp1[3];
          temp2[4] = temp1[4];
          temp2[5] = 0;
          strlower(temp2);
        }
        if (strcmp(temp2,"stat_")!=0) {
          if (len >= 6) {
            temp2[5] = temp1[5];
            temp2[6] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_stat_")!=0) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
        }
        var_result_long(temp1,value);
        strcat(temp1,"_INFO");
        tabget(temp2,"INFO");
        var_result_string(temp1,temp2);
        if ((value!=0) && (value!=1)) {
          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Digital value not valid='");
          itoad(temp2,value);
          strcat(temp1,temp2);strcat(temp1,"'.");
          var_result_string("JOB_MESSAGE",temp1);
          JOB_STATUS = "ERROR_ECU_RESPONSE_VALUE_OUT_OF_RANGE";
          set_trap_mask(0);
          return;
        }
      }
      else {
        if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert
          unsigned_long_flag=FALSE;
          tabget(temp1,"DATENTYP");
          strlower(temp1);
          if ((strcmp(temp1,"char")==0) ||
              (strcmp(temp1,"unsigned char")==0) ||
              (strcmp(temp1,"signed char")==0)) {
            value = response[n];
            value_unsigned = value;
            if (strcmp(temp1,"unsigned char")!=0)
              if (value & 0x80) value = value | 0xFFFFFF00;
            n++;
          }
          else {
            if ((strcmp(temp1,"int")==0) ||
                (strcmp(temp1,"integer")==0) ||
                (strcmp(temp1,"unsigned int")==0) ||
                (strcmp(temp1,"unsigned integer")==0) ||
                (strcmp(temp1,"signed int")==0) ||
                (strcmp(temp1,"signed integer")==0)) {
              tabget(temp2,"L/H");
              if ((temp2[0]=='l') || (temp2[0]=='L'))
                value = (response[n+1]<<8)+response[n];
              else
                value = (response[n]<<8)+response[n+1];
              value_unsigned = value;
              if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                if (value & 0x8000) value = value | 0xFFFF0000;
              n=n+2;
            }
            else {
              if ((strcmp(temp1,"long")==0) ||
                  (strcmp(temp1,"unsigned long")==0) ||
                  (strcmp(temp1,"signed long")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L'))
                  value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                else
                  value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                value_unsigned = value;
                n=n+4;
                if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
              }
              else {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
          }
          if (datalen(response) < n) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
            set_trap_mask(0);
            return;
          }
          tabget(temp1,"RESULTNAME");
          len=strlen(temp1);
          if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[len-5];
            temp2[1] = temp1[len-4];
            temp2[2] = temp1[len-3];
            temp2[3] = temp1[len-2];
            temp2[4] = temp1[len-1];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"_wert")==0) {
            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
            tabget(temp2,"RESULTNAME");
            strcat(temp1,temp2);strcat(temp1,"'.");
            var_result_string("JOB_MESSAGE",temp1);
            JOB_STATUS = "ERROR_TABLE";
            set_trap_mask(0);
            return;
          }
          temp2="";
          if (len >= 5) {
            temp2[0] = temp1[0];
            temp2[1] = temp1[1];
            temp2[2] = temp1[2];
            temp2[3] = temp1[3];
            temp2[4] = temp1[4];
            temp2[5] = 0;
            strlower(temp2);
          }
          if (strcmp(temp2,"stat_")!=0) {
            if (len >= 6) {
              temp2[5] = temp1[5];
              temp2[6] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"_stat_")!=0) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
          }
          if (unsigned_long_flag == TRUE)
            var_result_unsigned_long(temp1,value);
          else
            var_result_long(temp1,value);

          strcat(temp1,"_EINH");
          tabget(temp2,"EINHEIT");
          var_result_string(temp1,temp2);

          strerase(temp1,len,5);
          strcat(temp1,"_INFO");
          tabget(temp2,"INFO");
          var_result_string(temp1,temp2);

          tabget(temp2,"NAME");
          if (strcmp(temp2,"-")!=0) {
            tabset(temp2);
            if (get_error(10)) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table + line_res_table_offset);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            tab_suche_unsigned("WERT",value_unsigned);
            if (get_error(10)) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table + line_res_table_offset);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            tabget(temp2,"TEXT");
            if (get_error(10)) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
              if (res_table_flag==FALSE) {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
              }
              else {
                tabset("SG_Funktionen");
                tabseek(argument_string,argument_name);
                tabget(temp2,"RES_TABELLE");
                tabset(temp2);
                tabline(line_res_table + line_res_table_offset);
              }
              tabget(temp2,"NAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            strerase(temp1,len,5);
            strcat(temp1,"_TEXT");
            var_result_string(temp1,temp2);
          }
        }
        else {
          if (strcmp(temp1,"hex")==0) {
// Hex String
            unsigned_long_flag=FALSE;
            tabget(temp1,"DATENTYP");
            strlower(temp1);
            if ((strcmp(temp1,"char")==0) ||
                (strcmp(temp1,"unsigned char")==0) ||
                (strcmp(temp1,"signed char")==0)) {
              value = response[n];
              hex_len=2;
              n++;
            }
            else {
              if ((strcmp(temp1,"int")==0) ||
                  (strcmp(temp1,"integer")==0) ||
                  (strcmp(temp1,"unsigned int")==0) ||
                  (strcmp(temp1,"unsigned integer")==0) ||
                  (strcmp(temp1,"signed int")==0) ||
                  (strcmp(temp1,"signed integer")==0)) {
                tabget(temp2,"L/H");
                if ((temp2[0]=='l') || (temp2[0]=='L'))
                  value = (response[n+1]<<8)+response[n];
                else
                  value = (response[n]<<8)+response[n+1];
                hex_len=4;
                n=n+2;
              }
              else {
                if ((strcmp(temp1,"long")==0) ||
                    (strcmp(temp1,"unsigned long")==0) ||
                    (strcmp(temp1,"signed long")==0)) {
                  tabget(temp2,"L/H");
                  if ((temp2[0]=='l') || (temp2[0]=='L'))
                    value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                  else
                    value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                  hex_len=8;
                  n=n+4;
                }
                else {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                  tabget(temp2,"DATENTYP");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
              }
            }
            if (datalen(response) < n) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
              set_trap_mask(0);
              return;
            }
            tabget(temp1,"RESULTNAME");
            len=strlen(temp1);
            if (len > 63) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            temp2="";
            if (len >= 5) {
              temp2[0] = temp1[len-5];
              temp2[1] = temp1[len-4];
              temp2[2] = temp1[len-3];
              temp2[3] = temp1[len-2];
              temp2[4] = temp1[len-1];
              temp2[5] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"_wert")!=0) {
              temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
              tabget(temp2,"RESULTNAME");
              strcat(temp1,temp2);strcat(temp1,"'.");
              var_result_string("JOB_MESSAGE",temp1);
              JOB_STATUS = "ERROR_TABLE";
              set_trap_mask(0);
              return;
            }
            temp2="";
            if (len >= 5) {
              temp2[0] = temp1[0];
              temp2[1] = temp1[1];
              temp2[2] = temp1[2];
              temp2[3] = temp1[3];
              temp2[4] = temp1[4];
              temp2[5] = 0;
              strlower(temp2);
            }
            if (strcmp(temp2,"stat_")!=0) {
              if (len >= 6) {
                temp2[5] = temp1[5];
                temp2[6] = 0;
                strlower(temp2);
              }
              if (strcmp(temp2,"_stat_")!=0) {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                tabget(temp2,"RESULTNAME");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
            itoax(temp2,value);
            strerase(temp2,0,10-hex_len);
            strupper(temp2);
            var_result_string(temp1,temp2);

            strerase(temp1,len-5,5);
            strcat(temp1,"_EINH");
            tabget(temp2,"EINHEIT");
            var_result_string(temp1,temp2);

            strerase(temp1,len-5,5);
            strcat(temp1,"_INFO");
            tabget(temp2,"INFO");
            var_result_string(temp1,temp2);
          }
          else {
            if (strcmp(temp1,"bit")==0) {
// Bitfeld
              tabget(temp1,"DATENTYP");
              strlower(temp1);
              if (strcmp(temp1,"bitfield")==0) {
                tabget(temp2,"NAME");
                tabset(temp2);
                if (get_error(10)) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. bitfield table not found='");
                  if (res_table_flag==FALSE) {
                    tabset("SG_Funktionen");
                    tabseek(argument_string,argument_name);
                  }
                  else {
                    tabset("SG_Funktionen");
                    tabseek(argument_string,argument_name);
                    tabget(temp2,"RES_TABELLE");
                    tabset(temp2);
                    tabline(line_res_table + line_res_table_offset);
                  }
                  tabget(temp2,"NAME");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }
                size_bitfield=0;
                size_bitfield_old=0;
                line_bitfield_table=0;
                tabline(line_bitfield_table);
                do {
                  tabget(temp1,"EINHEIT");
                  strlower(temp1);
                  if (strcmp(temp1,"0/1")==0) {
// Digitaler Wert im Bitfeld
                    tabget(temp1,"DATENTYP");
                    strlower(temp1);
                    if ((strcmp(temp1,"char")==0) ||
                        (strcmp(temp1,"unsigned char")==0) ||
                        (strcmp(temp1,"signed char")==0)) {
                      value = response[n];
                      size_bitfield=1;
                    }
                    else {
                      if ((strcmp(temp1,"int")==0) ||
                          (strcmp(temp1,"integer")==0) ||
                          (strcmp(temp1,"unsigned int")==0) ||
                          (strcmp(temp1,"unsigned integer")==0) ||
                          (strcmp(temp1,"signed int")==0) ||
                          (strcmp(temp1,"signed integer")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<8)+response[n+1];
                        size_bitfield=2;
                      }
                      else {
                        if ((strcmp(temp1,"long")==0) ||
                            (strcmp(temp1,"unsigned long")==0) ||
                            (strcmp(temp1,"signed long")==0)) {
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L'))
                            value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                          else
                            value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                          size_bitfield=4;
                        }
                        else {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                          tabget(temp2,"DATENTYP");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                    }
                    if (size_bitfield_old != size_bitfield) {
                      if (size_bitfield_old == 0) {
                        size_bitfield_old = size_bitfield;
                      }
                      else {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table + line_res_table_offset);
                        }
                        tabget(temp2,"NAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    if (datalen(response) < (n+size_bitfield)) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                      set_trap_mask(0);
                      return;
                    }
                    tabget(temp1,"MASKE");
                    maske=atoi(temp1);
                    if ((maske & value) == maske)
                      value=1;
                    else
                      value=0;
                    tabget(temp1,"RESULTNAME");
                    len=strlen(temp1);
                    if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                    if (len >= 5) {
                      temp2="";
                      temp2[0] = temp1[len-5];
                      temp2[1] = temp1[len-4];
                      temp2[2] = temp1[len-3];
                      temp2[3] = temp1[len-2];
                      temp2[4] = temp1[len-1];
                      temp2[5] = 0;
                      strlower(temp2);
                      if (strcmp(temp2,"_wert")==0) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    temp2="";
                    if (len >= 5) {
                      temp2[0] = temp1[0];
                      temp2[1] = temp1[1];
                      temp2[2] = temp1[2];
                      temp2[3] = temp1[3];
                      temp2[4] = temp1[4];
                      temp2[5] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"stat_")!=0) {
                      if (len >= 6) {
                        temp2[5] = temp1[5];
                        temp2[6] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"_stat_")!=0) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    var_result_long(temp1,value);
                    strcat(temp1,"_INFO");
                    tabget(temp2,"INFO");
                    var_result_string(temp1,temp2);
                  }
                  else {
                    if (strcmp(temp1,"0-n")==0) {
// Diskreter Wert im Bitfeld
                      unsigned_long_flag=FALSE;
                      tabget(temp1,"DATENTYP");
                      strlower(temp1);
                      if ((strcmp(temp1,"char")==0) ||
                          (strcmp(temp1,"unsigned char")==0) ||
                          (strcmp(temp1,"signed char")==0)) {
                        value = response[n];
                        value_unsigned = value;
                        if (strcmp(temp1,"unsigned char")!=0)
                          if (value & 0x80) value = value | 0xFFFFFF00;
                        size_bitfield=1;
                      }
                      else {
                        if ((strcmp(temp1,"int")==0) ||
                            (strcmp(temp1,"integer")==0) ||
                            (strcmp(temp1,"unsigned int")==0) ||
                            (strcmp(temp1,"unsigned integer")==0) ||
                            (strcmp(temp1,"signed int")==0) ||
                            (strcmp(temp1,"signed integer")==0)) {
                          tabget(temp2,"L/H");
                          if ((temp2[0]=='l') || (temp2[0]=='L'))
                            value = (response[n+1]<<8)+response[n];
                          else
                            value = (response[n]<<8)+response[n+1];
                          value_unsigned = value;
                          if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                            if (value & 0x8000) value = value | 0xFFFF0000;
                          size_bitfield=2;
                        }
                        else {
                          if ((strcmp(temp1,"long")==0) ||
                              (strcmp(temp1,"unsigned long")==0) ||
                              (strcmp(temp1,"signed long")==0)) {
                            tabget(temp2,"L/H");
                            if ((temp2[0]=='l') || (temp2[0]=='L'))
                              value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                            else
                              value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                            value_unsigned = value;
                            size_bitfield=4;
                            if (strcmp(temp1,"unsigned long")==0) unsigned_long_flag = TRUE;
                          }
                          else {
                            temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                            tabget(temp2,"DATENTYP");
                            strcat(temp1,temp2);strcat(temp1,"'.");
                            var_result_string("JOB_MESSAGE",temp1);
                            JOB_STATUS = "ERROR_TABLE";
                            set_trap_mask(0);
                            return;
                          }
                        }
                      }
                      if (size_bitfield_old != size_bitfield) {
                        if (size_bitfield_old == 0) {
                          size_bitfield_old = size_bitfield;
                        }
                        else {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Different bitfield size in table='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table + line_res_table_offset);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      if (datalen(response) < (n+size_bitfield)) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                        set_trap_mask(0);
                        return;
                      }
                      tabget(temp1,"MASKE");
                      maske=atoi(temp1);
                      value = maske & value;
                      value_unsigned = maske & value_unsigned;
                      tabget(temp1,"RESULTNAME");
                      len=strlen(temp1);
                      if (len > 58) { // 63 maximal RESULTNAME + '_INFO'
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      temp2="";
                      if (len >= 5) {
                        temp2[0] = temp1[len-5];
                        temp2[1] = temp1[len-4];
                        temp2[2] = temp1[len-3];
                        temp2[3] = temp1[len-2];
                        temp2[4] = temp1[len-1];
                        temp2[5] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"_wert")==0) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                        tabget(temp2,"RESULTNAME");
                        strcat(temp1,temp2);strcat(temp1,"'.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_TABLE";
                        set_trap_mask(0);
                        return;
                      }
                      temp2="";
                      if (len >= 5) {
                        temp2[0] = temp1[0];
                        temp2[1] = temp1[1];
                        temp2[2] = temp1[2];
                        temp2[3] = temp1[3];
                        temp2[4] = temp1[4];
                        temp2[5] = 0;
                        strlower(temp2);
                      }
                      if (strcmp(temp2,"stat_")!=0) {
                        if (len >= 6) {
                          temp2[5] = temp1[5];
                          temp2[6] = 0;
                          strlower(temp2);
                        }
                        if (strcmp(temp2,"_stat_")!=0) {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                          tabget(temp2,"RESULTNAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                      }
                      if (unsigned_long_flag == TRUE)
                        var_result_unsigned_long(temp1,value);
                      else
                        var_result_long(temp1,value);

                      strcat(temp1,"_EINH");
                      tabget(temp2,"EINHEIT");
                      var_result_string(temp1,temp2);

                      strerase(temp1,len,5);
                      strcat(temp1,"_INFO");
                      tabget(temp2,"INFO");
                      var_result_string(temp1,temp2);

                      tabget(temp2,"NAME");
                      if (strcmp(temp2,"-")!=0) {
                        tabset(temp2);
                        if (get_error(10)) {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table + line_res_table_offset);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        tab_suche_unsigned("WERT",value_unsigned);
                        if (get_error(10)) {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'WERT' not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table + line_res_table_offset);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        tabget(temp2,"TEXT");
                        if (get_error(10)) {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Discrete value table column 'TEXT' not found='");
                          if (res_table_flag==FALSE) {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                          }
                          else {
                            tabset("SG_Funktionen");
                            tabseek(argument_string,argument_name);
                            tabget(temp2,"RES_TABELLE");
                            tabset(temp2);
                            tabline(line_res_table + line_res_table_offset);
                          }
                          tabget(temp2,"NAME");
                          strcat(temp1,temp2);strcat(temp1,"'.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        strerase(temp1,len,5);
                        strcat(temp1,"_TEXT");
                        var_result_string(temp1,temp2);

                        // wieder zurück
                        if (res_table_flag==FALSE) {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                        }
                        else {
                          tabset("SG_Funktionen");
                          tabseek(argument_string,argument_name);
                          tabget(temp2,"RES_TABELLE");
                          tabset(temp2);
                          tabline(line_res_table + line_res_table_offset);
                        }
                        tabget(temp2,"NAME");
                        tabset(temp2);
                      }
                    }
                    else {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  line_bitfield_table++;
                } while (tabline(line_bitfield_table));
                n = n + size_bitfield;
              }
              else {
                temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                tabget(temp2,"DATENTYP");
                strcat(temp1,temp2);strcat(temp1,"'.");
                var_result_string("JOB_MESSAGE",temp1);
                JOB_STATUS = "ERROR_TABLE";
                set_trap_mask(0);
                return;
              }
            }
            else {
              if (strcmp(temp1,"data")==0) {
// Data
                tabget(temp1,"DATENTYP");
                strlower(temp1);
                len = strlen(temp1);
                temp2="?????";
                strncpy(temp2,temp1,5);
                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                  temp2=temp1;
                  strerase(temp2,len-1,1);
                  strerase(temp2,0,5);
                  data_len=atoi(temp2);
                  if ((data_len > 0) && (data_len < 256)) {
                    data_pos=n;
                    n=n+data_len;
                  }
                  else {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                    tabget(temp2,"DATENTYP");
                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                    itoad(temp2,data_len);
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                }
                else {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                  tabget(temp2,"DATENTYP");
                  strcat(temp1,temp2);strcat(temp1,"'.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_TABLE";
                  set_trap_mask(0);
                  return;
                }

                if (datalen(response) < n) {
                  temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                  var_result_string("JOB_MESSAGE",temp1);
                  JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                  set_trap_mask(0);
                  return;
                }
                tabget(temp1,"RESULTNAME");
                len=strlen(temp1);

                temp2="";
                if (len >= 6) {
                  temp2[0] = temp1[0];
                  temp2[1] = temp1[1];
                  temp2[2] = temp1[2];
                  temp2[3] = temp1[3];
                  temp2[4] = temp1[4];
                  temp2[5] = temp1[5];
                  temp2[6] = 0;
                  strlower(temp2);
                }
                if (strcmp(temp2,"dummy_")==0) {
                  // Warnung bei Dummy_
                  var_result_string("JOB_MESSAGE","Warning: RESULTNAME 'DUMMY_..' ignored.");
                }
                else {
                  if (len > 63) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_data")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  dataclear(temp2);
                  datacopy(temp2,response,data_pos,data_len);
                  var_result_data(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                }
              }
              else {
                if (strcmp(temp1,"text")==0) {
// Text
                  tabget(temp1,"DATENTYP");
                  strlower(temp1);
                  len = strlen(temp1);
                  temp2="???????";
                  strncpy(temp2,temp1,7);
                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                    temp2=temp1;
                    strerase(temp2,len-1,1);
                    strerase(temp2,0,7);
                    string_len=atoi(temp2);
                    if ((string_len > 0) && (string_len < 256)) {
                      string_pos=n;
                      n=n+string_len;
                    }
                    else {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                      itoad(temp2,string_len);
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }
                  else {
                    if (strcmp(temp1,"string")==0) {
                      k=0;
                      string_flag=FALSE;
                      while ((n+k) < datalen(response)) {
                        if (response[n+k]==0) {
                          string_flag=TRUE;
                          string_pos=n;
                          string_len=k+1;
                          n=n+string_len;
                          break;
                        }
                        k++;
                      }
                      if (string_flag==FALSE) {
                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                        tabget(temp2,"DATENTYP");
                        strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                        var_result_string("JOB_MESSAGE",temp1);
                        JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                        set_trap_mask(0);
                        return;
                      }
                    }
                    else {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                      tabget(temp2,"DATENTYP");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  if (datalen(response) < n) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                    set_trap_mask(0);
                    return;
                  }
                  tabget(temp1,"RESULTNAME");
                  len=strlen(temp1);
                  if (len > 63) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_text")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  dataclear(temp2);
                  datacopy(temp2,response,string_pos,string_len);
                  temp2[string_len]=0;
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                }
                else {
// Analoger Wert
                  data_flag=FALSE;
                  string_flag=FALSE;
                  tabget(temp1,"DATENTYP");
                  strlower(temp1);
                  if ((strcmp(temp1,"char")==0) ||
                      (strcmp(temp1,"unsigned char")==0) ||
                      (strcmp(temp1,"signed char")==0)) {
                    value = response[n];
                    if (strcmp(temp1,"unsigned char")!=0)
                      if (value & 0x80) value = value | 0xFFFFFF00;
                    itor(value_real,value);
                    n++;
                  }
                  else {
                    if ((strcmp(temp1,"int")==0) ||
                        (strcmp(temp1,"integer")==0) ||
                        (strcmp(temp1,"unsigned int")==0) ||
                        (strcmp(temp1,"unsigned integer")==0) ||
                        (strcmp(temp1,"signed int")==0) ||
                        (strcmp(temp1,"signed integer")==0)) {
                      tabget(temp2,"L/H");
                      if ((temp2[0]=='l') || (temp2[0]=='L'))
                        value = (response[n+1]<<8)+response[n];
                      else
                        value = (response[n]<<8)+response[n+1];
                      if ((strcmp(temp1,"unsigned int")!=0) && (strcmp(temp1,"unsigned integer")!=0))
                        if (value & 0x8000) value = value | 0xFFFF0000;
                      itor(value_real,value);
                      n=n+2;
                    }
                    else {
                      if ((strcmp(temp1,"long")==0) ||
                          (strcmp(temp1,"unsigned long")==0) ||
                          (strcmp(temp1,"signed long")==0)) {
                        tabget(temp2,"L/H");
                        if ((temp2[0]=='l') || (temp2[0]=='L'))
                          value = (response[n+3]<<24)+(response[n+2]<<16)+(response[n+1]<<8)+response[n];
                        else
                          value = (response[n]<<24)+(response[n+1]<<16)+(response[n+2]<<8)+response[n+3];
                        itor(value_real,value);
                        if (strcmp(temp1,"unsigned long")==0) {
                          if (value & 0x80000000) {
                            ator(real_temp1,"4294967296");
                            realadd(value_real,real_temp1);
                          }
                        }
                        n=n+4;
                      }
                      else {
                        if ((strcmp(temp1,"float")==0) ||
                            (strcmp(temp1,"intel float")==0)) {
                          data_to_real(value_real,response,n,0,0);
                          n=n+4;
                        }
                        else {
                          if (strcmp(temp1,"motorola float")==0) {
                            data_to_real(value_real,response,n,0,1);
                            n=n+4;
                          }
                          else {
                            if ((strcmp(temp1,"double")==0) ||
                                (strcmp(temp1,"intel double")==0)) {
                              data_to_real(value_real,response,n,1,0);
                              n=n+8;
                            }
                            else {
                              if (strcmp(temp1,"motorola double")==0) {
                                data_to_real(value_real,response,n,1,1);
                                n=n+8;
                              }
                              else {
                                len = strlen(temp1);
                                temp2="?????";
                                strncpy(temp2,temp1,5);
                                if ((strcmp(temp2,"data[")==0) && temp1[len-1]==']') {
                                  temp2=temp1;
                                  strerase(temp2,len-1,1);
                                  strerase(temp2,0,5);
                                  data_len=atoi(temp2);
                                  if ((data_len > 0) && (data_len < 256)) {
                                    data_flag=TRUE;
                                    data_pos=n;
                                    n=n+data_len;
                                  }
                                  else {
                                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                    tabget(temp2,"DATENTYP");
                                    strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                    itoad(temp2,data_len);
                                    strcat(temp1,temp2);strcat(temp1,"'.");
                                    var_result_string("JOB_MESSAGE",temp1);
                                    JOB_STATUS = "ERROR_TABLE";
                                    set_trap_mask(0);
                                    return;
                                  }
                                }
                                else {
                                  len = strlen(temp1);
                                  temp2="???????";
                                  strncpy(temp2,temp1,7);
                                  if ((strcmp(temp2,"string[")==0) && temp1[len-1]==']') {
                                    temp2=temp1;
                                    strerase(temp2,len-1,1);
                                    strerase(temp2,0,7);
                                    string_len=atoi(temp2);
                                    if ((string_len > 0) && (string_len < 256)) {
                                      string_flag=TRUE;
                                      string_pos=n;
                                      n=n+string_len;
                                    }
                                    else {
                                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                      tabget(temp2,"DATENTYP");
                                      strcat(temp1,temp2);strcat(temp1,"'. Len out of range (1..255)='");
                                      itoad(temp2,string_len);
                                      strcat(temp1,temp2);strcat(temp1,"'.");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_TABLE";
                                      set_trap_mask(0);
                                      return;
                                    }
                                  }
                                  else {
                                    if (strcmp(temp1,"string")==0) {
                                      k=0;
                                      string_flag=FALSE;
                                      while ((n+k) < datalen(response)) {
                                        if (response[n+k]==0) {
                                          string_flag=TRUE;
                                          string_pos=n;
                                          string_len=k+1;
                                          n=n+string_len;
                                          break;
                                        }
                                        k++;
                                      }
                                      if (string_flag==FALSE) {
                                        temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP '");
                                        tabget(temp2,"DATENTYP");
                                        strcat(temp1,temp2);strcat(temp1,"'. String end character '0x00' not found.");
                                        var_result_string("JOB_MESSAGE",temp1);
                                        JOB_STATUS = "ERROR_ECU_RESPONSE_NO_STRING_END_CHAR";
                                        set_trap_mask(0);
                                        return;
                                      }
                                    }
                                    else {
                                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. DATENTYP not valid='");
                                      tabget(temp2,"DATENTYP");
                                      strcat(temp1,temp2);strcat(temp1,"'.");
                                      var_result_string("JOB_MESSAGE",temp1);
                                      JOB_STATUS = "ERROR_TABLE";
                                      set_trap_mask(0);
                                      return;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (datalen(response) < n) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Too less data.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_LESS_DATA";
                    set_trap_mask(0);
                    return;
                  }
                  tabget(temp1,"RESULTNAME");
                  len=strlen(temp1);
                  if (len > 63) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME to long='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[len-5];
                    temp2[1] = temp1[len-4];
                    temp2[2] = temp1[len-3];
                    temp2[3] = temp1[len-2];
                    temp2[4] = temp1[len-1];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"_wert")!=0) {
                    temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                    tabget(temp2,"RESULTNAME");
                    strcat(temp1,temp2);strcat(temp1,"'.");
                    var_result_string("JOB_MESSAGE",temp1);
                    JOB_STATUS = "ERROR_TABLE";
                    set_trap_mask(0);
                    return;
                  }
                  temp2="";
                  if (len >= 5) {
                    temp2[0] = temp1[0];
                    temp2[1] = temp1[1];
                    temp2[2] = temp1[2];
                    temp2[3] = temp1[3];
                    temp2[4] = temp1[4];
                    temp2[5] = 0;
                    strlower(temp2);
                  }
                  if (strcmp(temp2,"stat_")!=0) {
                    if (len >= 6) {
                      temp2[5] = temp1[5];
                      temp2[6] = 0;
                      strlower(temp2);
                    }
                    if (strcmp(temp2,"_stat_")!=0) {
                      temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. RESULTNAME not valid='");
                      tabget(temp2,"RESULTNAME");
                      strcat(temp1,temp2);strcat(temp1,"'.");
                      var_result_string("JOB_MESSAGE",temp1);
                      JOB_STATUS = "ERROR_TABLE";
                      set_trap_mask(0);
                      return;
                    }
                  }

                  if (data_flag==TRUE) {
                    dataclear(temp2);
                    datacopy(temp2,response,data_pos,data_len);
                    var_result_long(temp1,0);
                    strerase(temp1,len-5,5);
                    strcat(temp1,"_DATA");
                    var_result_data(temp1,temp2);
                  }
                  else {
                    if (string_flag==TRUE) {
                      dataclear(temp2);
                      datacopy(temp2,response,string_pos,string_len);
                      temp2[string_len]=0;
                      var_result_long(temp1,0);
                      strerase(temp1,len-5,5);
                      strcat(temp1,"_TEXT");
                      var_result_string(temp1,temp2);
                    }
                    else {
                      tabget(temp2,"MUL");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Multiplication with Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realmul(value_real,real_temp1);
                      }
                      tabget(temp2,"DIV");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        ator(real_temp2,"0");
                        if (realcomp(real_temp1,"==",real_temp2))
                        {
                          temp1="Argument STATUS='";strcat(temp1,argument_name);strcat(temp1,"'. Division by Zero.");
                          var_result_string("JOB_MESSAGE",temp1);
                          JOB_STATUS = "ERROR_TABLE";
                          set_trap_mask(0);
                          return;
                        }
                        realdiv(value_real,real_temp1);
                      }
                      tabget(temp2,"ADD");
                      if (strcmp(temp2,"-")!=0) {
                        aitor(real_temp1,temp2);
                        realadd(value_real,real_temp1);
                      }
                      var_result_real(temp1,value_real);
                    }
                  }

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_EINH");
                  tabget(temp2,"EINHEIT");
                  var_result_string(temp1,temp2);

                  strerase(temp1,len-5,5);
                  strcat(temp1,"_INFO");
                  tabget(temp2,"INFO");
                  var_result_string(temp1,temp2);
                } // else Text
              } // else Data
            } // else Bitfeld
          } // else Hex String
        } // else Diskreter Wert
      } // else Digitaler Wert
      line_res_table++;
    } // temp2 == "+" ?
    else {
      line_res_table_offset++;
    }
    if (res_table_flag==TRUE) {
      tabset("SG_Funktionen");
      tabseek(argument_string,argument_name);
      tabget(temp2,"RES_TABELLE");
      tabset(temp2);
      if (!tabline(line_res_table + line_res_table_offset)) res_table_flag=FALSE;
    }
  } while (res_table_flag==TRUE);

  if (datalen(response) != n) {
    temp1="Too much data.";
    var_result_string("JOB_MESSAGE",temp1);
    JOB_STATUS = "ERROR_ECU_RESPONSE_TOO_MUCH_DATA";
    set_trap_mask(0);
    return;
  }
  JOB_STATUS = "OKAY";
  set_trap_mask(0);
}
// end of : #include "UDS_31_STEUERN_ROUTINE.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_85_02_FS_SPERREN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_SPERREN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult,DigitalArgument
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 13.12.2005  gr  V0.001 Ersterstellung
// 02.02.2006  gr  V0.002 STD_DIGI ersetzt UDS_TAB_DIGITAL_ARGUMENT
// *******************************************************************
// UDS_85_02_FS_SPERREN.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       FS_SPERREN;
      comment   :       Sperren bzw. Freigeben des Fehlerspeichers;
      comment   :       UDS  : $85 ControlDTCSetting;
      comment   :       UDS  : $?? Sperren ($02) / Freigabe ($01);
      comment   :       Modus: Default;

      argument  :       SPERREN;
        type    :       string;
        comment :       "ja"   -> Fehlerspeicher sperren;
        comment :       "nein" -> Fehlerspeicher freigeben;
        comment :       table DigitalArgument TEXT;
        comment :       Default: "ja";

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x85, 0x02};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
           int  LIErgebnis;

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_STD_DIGI_B2S_NOT_FOUND;

// ---------------- Argumente des Jobs auswerten ---------------------

  if (exist(SPERREN))
  {
        if (!check_digital_argument("SPERREN" , 1, LIErgebnis, 2)) return;
  
        if (LIErgebnis != 1) // 'Nein' angegeben 
                request[1] = 0x01; // Fehlerspeicher wieder freigeben
  }

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_85_02_FS_SPERREN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_20_00_IS_LESEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : IS_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult, IOrtTexte, IArtTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 05.12.2005  gr  V0.001 Erstellung
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Tabellen-Name)
// 22.06.2006  gh  V0.003 Angleichung der Auswertung an Job FS_LESEN
// 15.09.2008  gr  V0.004 Ausgabe des F_HEX_CODE korrigiert (dataclear(temp))
// *******************************************************************
// UDS_22_20_00_IS_LESEN.B2S @(#)@ V0.004 @(#)@
// *******************************************************************
job ( name      :       IS_LESEN;
      comment   :       Sekundaerer Fehlerspeicher lesen (alle Fehler / Ort und Art);
      comment   :       UDS  : $22   ReadDataByIdentifierRequestServiceID;
      comment   :       UDS  : $2000 DataIdentifier sekundaerer Fehlerspeicher;
      comment   :       Modus: Default;

      result    :       F_VERSION;
        type    :       int;
        defrslt :       3;
        comment :       Typ des Fehlerspeichers;
        comment :       Fuer UDS immer 3;

      result    :       F_HEX_CODE;
        type    :       data;
        comment :       Fehlerdaten pro Fehler als Hexcode;

      result    :       F_ORT_NR;
        type    :       long;
        comment :       Index fuer Fehlerort;

      result    :       F_ORT_TEXT;
        type    :       string;
        comment :       Fehlerort als Text;
        comment :       table FOrtTexte ORTTEXT;

      result    :       F_EREIGNIS_DTC;
        type    :       int;
        comment :       0: DTC kein Ereignis DTC;
        comment :       1: DTC ist Ereignis DTC;
        comment :       table FOrtTexte EREIGNIS_DTC;

      result    :       F_READY_NR;
        type    :       int;
        comment :       Readyness Flag (Standard-Fehlerart) als Zahl;

      result    :       F_READY_TEXT;
        type    :       string;
        comment :       Readyness Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_VORHANDEN_NR;
        type    :       int;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Zahl;

      result    :       F_VORHANDEN_TEXT;
        type    :       string;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_WARNUNG_NR;
        type    :       int;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Zahl;

      result    :       F_WARNUNG_TEXT;
        type    :       string;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0x20, 0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

  // Variablen fuer Job  
  unsigned char temp[];
  unsigned char text[];
           int  anzahl;
           int  index;
           int  offset;
           long wert;
           int  LIStatusDTC = 0x00;

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_UDS_TAB_IArtTexte_B2S_NOT_FOUND;
               
// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  index = 0;
  offset = 3;      
  anzahl = (datalen(response) - 3) / 4;


  // Verifikation der Datenlaenge
  if (datalen(response) != (3 + (anzahl*4))) { // Rundungsfehler bei Berechnung der ANZAHL
    if (_REQUEST)              
      _REQUEST = request;

    if (_RESPONSE)
      _RESPONSE = response;

    JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";

    return;
  }

  while (index < anzahl) {
    LIStatusDTC = response[offset + 3] & 0x4D; // Auslesen des Status Bytes. Für die Auswertung sind die Bits 0,2,3,6 entscheidend
        
    if (F_HEX_CODE) {
      dataclear(temp);
      datacopy(temp, response, offset, 4);
      F_HEX_CODE = temp;
    }

    if (F_ORT_NR || F_ORT_TEXT || F_EREIGNIS_DTC || F_READY_NR || F_READY_TEXT || F_VORHANDEN_NR || F_VORHANDEN_TEXT || F_WARNUNG_NR || F_WARNUNG_TEXT) {
      // Ausgabe Fehlerort 
      wert = (response[offset] << 16) + (response[offset + 1] <<  8) + response[offset + 2];
      F_ORT_NR = wert;

      // Dazugehoeriger Fehlertext
      tabset("IOrtTexte");
      tab_suche_unsigned("ORT", wert);
      tabget(text, "ORTTEXT");
      F_ORT_TEXT = text;

      // Ereignis-DTC ja / nein        
      tabget(text, "EREIGNIS_DTC");
      F_EREIGNIS_DTC = atoi(text);

      // Gibt an, ob Test seit dem letzten loeschen einmal komplett durchlaufen wurde; Offset 0x10 wird addiert, um Tabelle FArtTexte verwenden zu können
      wert = ((response[offset+3] >> 4)  & 0x01) + 0x10;
      F_READY_NR = wert;

      tabset("IArtTexte");
      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_READY_TEXT = text;

      // Fehler aktuell vorhanden? Bit 0 und Bit 6 muessen beide 1 beinhalten, dann ist Fehler aktuell vorhanden
      F_VORHANDEN_NR = LIStatusDTC;

      tab_suche_unsigned("ARTNR", LIStatusDTC);
      tabget(text, "ARTTEXT");
      F_VORHANDEN_TEXT = text;

      // Geht eine Warnlampe an oder nicht
      wert = ((response[offset+3] >> 7) & 0x01) + 0x80;
      F_WARNUNG_NR = wert;

      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_WARNUNG_TEXT = text;
    }

    new_set_of_results(); // neuer Ergebnissatz

    index++;
    offset += 4;
  }

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_20_00_IS_LESEN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_20_00_IS_LESEN_DETAIL.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// ACHTUNG: Es wird davon ausgegangen, dass in der SG-Antwort
//          vor den 3 Bytes Fehlerort 1 Byte DTCSeverity kommt !
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 gestestet mit Simulation
// 16.02.2006  gh  V0.003 Zuweisung "response1 = response;" integriert
// 20.02.2006  gh  V0.004 Umbenennung F_UW_ZEIT_DATUM => F_UW_DATUM_ZEIT
// 22.02.2006  gh  V0.005 Integration Subtabellen Tab_<Index>
// 23.02.2006  gh  V0.005 Korrektur Variablendefinition: unsigned !
// 24.03.2006  gh  V0.006 Zuweisung Result F_HEX_CODE integriert
// 24.03.2006  gh  V0.006 Sonderfälle 0xFFFFFF(FF) bei F_UW_KM / F_UW_DATUM_ZEIT
// 24.03.2006  gh  V0.006 _RESPONSE_* auch bei Abbruch
// 27.03.2006  gh  V0.007 Abbruch, wenn zu wenig Daten in SG-Antwort
// 28.03.2006  gh  V0.007 Abbruch, wenn Anzahl der Daten in SG-Antwort falsch
// 23.06.2006  gh  V0.008 Integration Severity-Byte
// 28.06.2006  gh  V0.009 Result "F_UW_DATUM_ZEIT" entfernt
// 29.06.2006  gh  V0.010 Results bzgl. Severity-Byte in Satz 1
// 15.11.2006  gh  V0.011 Wegen $19 $04: Anzahl UWB-Sätze einstellbar und 
//             gh  V0.011       $19 $04: komplexe UWB: Ausgabe als Text (string)
//             gh  V0.011 sind folgende Variablen erforderlich: uw_satz_anzahl, uw_typ_text
//             gh  V0.011 da gemeinsame Sub-Includes fuer FS/IS benutzt werden!
// 22.03.2007  gh  V0.012 Sonderfall "anzahl_snapshotRecord = 0" ohne Error "Division by Zero"
// 14.03.2008  gr  V0.013 Variable LIHlzValid hinzu 
// *******************************************************************
// UDS_22_20_00_IS_LESEN_DETAIL.B2S @(#)@ V0.013 @(#)@
// *******************************************************************
job ( name      :       IS_LESEN_DETAIL;
      comment   :       sekundären Fehlerspeicher lesen (Info-Meldungen / Ort und Art);
      comment   :       UDS  : $22 ReadDataByIdentifier;
      comment   :       UDS  : $20 dataIdentifier;
      comment   :       UDS  : $00 alle Info-Meldungen;
      comment   :       anschließend;
      comment   :       UDS  : $20 dataIdentifier;
      comment   :       UDS  : $nn Details zur Info-Meldung an der Position n;
      comment   :       Modus: Default;

      argument  :       F_CODE;
        type    :       long;
        defrslt :       ;
        comment :       gewaehlter Infocode;
        comment :       Wenn dieser Parameter angegeben wird,;
        comment :       wird die Position automatisch ermittelt.;
        comment :       Es darf dann nicht argument F_POS angegeben werden;

      argument  :       F_POS;
        type    :       int;
        defrslt :       ;
        comment :       gewaehlter Eintrag;
        comment :       Wenn dieser Parameter angegeben wird,;
        comment :       wird die Position benutzt.;
        comment :       Wertebereich 1 - 255;
        comment :       Es darf dann nicht argument F_CODE angegeben werden;

      result    :       F_VERSION;
        type    :       int;
        defrslt :       3;
        comment :       Typ des Fehlerspeichers;
        comment :       Fuer UDS immer 3;

      result    :       F_HEX_CODE;
        type    :       data;
        comment :       Fehlerdaten pro Fehler als Hexcode;

      result    :       F_ORT_NR;
        type    :       long;
        comment :       Index fuer Fehlerort;

      result    :       F_ORT_TEXT;
        type    :       string;
        comment :       Fehlerort als Text;
        comment :       table FOrtTexte ORTTEXT;

      result    :       F_EREIGNIS_DTC;
        type    :       int;
        comment :       0: DTC kein Ereignis DTC;
        comment :       1: DTC ist Ereignis DTC;
        comment :       table FOrtTexte EREIGNIS_DTC;        

      result    :       F_READY_NR;
        type    :       int;
        comment :       Readyness Flag (Standard-Fehlerart) als Zahl;

      result    :       F_READY_TEXT;
        type    :       string;
        comment :       Readyness Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_VORHANDEN_NR;
        type    :       int;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Zahl;

      result    :       F_VORHANDEN_TEXT;
        type    :       string;
        comment :       Fehler vorhanden (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_WARNUNG_NR;
        type    :       int;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Zahl;

      result    :       F_WARNUNG_TEXT;
        type    :       string;
        comment :       Warnlampen Flag (Standard-Fehlerart) als Text;
        comment :       table FArtTexte ARTTEXT;

      result    :       F_HFK;
        type    :       int;
        comment :       Haufigkeitszaehler als Zahl;
        comment :       Wertebereich 0 - 255;
        comment :       Bei mehr als 255 bleibt Zaehler stehen. Kein Ueberlauf;

      result    :       F_HLZ;
        type    :       int;
        comment :       Heilungsszaehler als Zahl;
        comment :       Wertebereich 0 - 255;
        comment :       -1: ohne Haufigkeitszaehler;

      result    :       F_UEBERLAUF;
        type    :       int;
        comment :       0: Kein Ueberlauf des Fehlerspeichers;
        comment :       1: Ueberlauf des Fehlerspeichers;
        
      result    :       F_FEHLERKLASSE_NR;
        type    :       int;
        comment :       0: Keine Fehlerklasse verfuegbar;
        comment :       1: Ueberpruefung bei naechstem Werkstattbesuch;
        comment :       2: Ueberpruefung bei naechstem Halt;        
        comment :       4: Ueberpruefung sofort erforderlich !;

      result    :       F_FEHLERKLASSE_TEXT;
        type    :       string;
        comment :       Ausgabe der Fehlerklasse als Text;
        comment :       table Fehlerklasse TEXT;        

      result    :       F_UW_ANZ;
        type    :       int;
        comment :       Anzahl der Umweltbedingungen;
        comment :       Je nach dieser Anzahl i (i = 1, 2, ...);
        comment :       existieren i mal folgende Results:;
        comment :       (long)   F_UWi_NR   Index   der i. Umweltbedingung;
        comment :       (string) F_UWi_TEXT Text    zur i. Umweltbedingung;
        comment :       (real)   F_Uwi_WERT Wert    der i. Umweltbedingung;
        comment :       (string) F_UWi_EINH Einheit der i. Umweltbedingung;

      result    :       F_UW_KM;
        type    :       long;
        comment :       Umweltbedingung Kilometerstand (3 Byte);
        comment :       Wertebereich: 0 - 16777215 km;
        comment :                    -1, wenn Kilometerstand nicht zur Verfuegung steht;

      result    :       F_UW_ZEIT;
        type    :       long;
        comment :       Umweltbedingung Absolute Zeit (4 Byte);
        comment :       Genauigkeit: in Sekunden;
        comment :       -1, wenn Absolute Zeit nicht zur Verfuegung steht;
/*
      result    :       F_UW_DATUM_ZEIT;
        type    :       string;
        comment :       Umweltbedingung Absolute Zeit im Datumsformat DD.MM.YYYY  hh:mm:ss;
        comment :       Beginn: 01.01.2000  00:00:00;
*/
      result    :       F_SAE_CODE;
        type    :       unsigned int;
        comment :       Wertebereich 0x000000 - 0xFFFFFF;
        comment :       externe Tabelle T_SCOD;

      result    :       F_SAE_CODE_STRING;
        type    :       string;
        comment :       5 stelliger Text in der Form 'Sxxxx';

      result    :       F_SAE_CODE_TEXT;
        type    :       string;
        comment :       Text zu F_SAE_CODE;

      result    :       _RESPONSE_2000;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _RESPONSE_200X;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;
    )
{
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned  int LIStatusDTC = 0x00;
  unsigned char temp[];
  unsigned char text[];           
  unsigned char text1[];
  unsigned char response1[];           

           long wert;
  unsigned long code;  
  unsigned  int offset;
  unsigned  int LILaengeData;
  unsigned long LLData;
  unsigned long zeit_aktuell;

            // Variablen für die Basis-Infos des DTC    
            int LIExtendedRecordNumber;
            int LIUWErweitertExist;
            int LIHlzExist;
            int LIHlzValid;
            int LISaeCodeExist;
            int severity_exist;
  unsigned char severity_byte;

/*          // Variablen zur Zeitberechnung
  unsigned  int LIJahr;
  unsigned  int LIMonat;
  unsigned  int LITag;
  unsigned  int LIStunden;
  unsigned  int LIMinuten;
  unsigned  int LISekunden;
  unsigned  int LIAbbruch;
  unsigned  int LISchaltjahr;
*/
           // Variablen fuer die Umweltsaetze
  unsigned  int LIIdentifier;
  unsigned  int LICounterUW;
  unsigned  int LIAnzUW;
//unsigned long LLAnzahlSnapshotIdentifier;
//unsigned  int LISnapshotNumber;
//unsigned  int LICounterIdentifier;
            int uw_satz_anzahl;

  unsigned int  dtc_gefunden;     // Flag, ob der Info-Eintrags (DTC) gefunden wurde
  unsigned int  dtc_pos;          // Position des Info-Eintrags (DTC)
  unsigned int  is_anz;           // Anzahl der Eintraege im Infospeicher

  unsigned int  laenge_ExtendedData;   // Länge der Extended Data (2 oder 3 Byte)
  unsigned int  laenge_snapshotRecord; // Länge eines snapshot records
  unsigned int  anzahl_snapshotRecord; // Anzahl der snapshot records

  unsigned int  laenge_snapshot;  // temporäre Länge eines snapshot records (Variable für while-Schleife)
  unsigned int  pos_start;        // Offset-Position beim Start der while-Schleife
  unsigned int  pos_ende;         // Offset-Position beim Ende  der while-Schleife

  unsigned int  uw_sub_index;     // Index der Sub-UW
  unsigned int  uw_sub_anz;       // Anzahl der Sub-UWs
  unsigned int  identifier_sub;   // Identifier der Sub-UW

  unsigned int  offset_start;     // Startwert bei Extended Data

  unsigned int  uw_laenge;        // Laenge der einzelnen UW [Bytes]            

  unsigned char uw_gueltig;       // Flag, ob UW gueltig d.h. "offset < daten_laenge"

  unsigned long uw_mask;          // Maske fuer digitale bzw. diskrete UW

  unsigned long uw_wert_mask;     // Puffer fuer F_UWn_WERT (Bitmaske: digital / diskret)
           long uw_wert;          // Puffer fuer F_UWn_WERT (long)
           real uw_wert_real;     // Puffer fuer F_UWn_WERT (real)

           real uw_mul_real;      // fuer Berechnung analoger UW
           real uw_div_real;      // fuer Berechnung analoger UW
           real uw_add_real;      // fuer Berechnung analoger UW

  unsigned int  daten_laenge;     // "datalen(daten)" (kommt mehrfach vor)

  unsigned int  uw_typ;           // ODER-Verknuefpung von UW-Typ-Flags

  unsigned int  uw_typ_digital  = 0x0001;   // Flag fuer digitale UW                               (Grundtyp / Zuweisung )
  unsigned int  uw_typ_diskret  = 0x0002;   // Flag fuer diskrete UW                               (Grundtyp / Zuweisung )
  unsigned int  uw_typ_analog   = 0x0004;   // Flag fuer analoge  UW (long)                        (Grundtyp / Zuweisung )

  unsigned int  uw_typ_float    = 0x0008;   // Flag fuer analoge  UW (real / float)                (Zusatz   / Veroderung)
  unsigned int  uw_typ_double   = 0x0010;   // Flag fuer analoge  UW (real / double)               (Zusatz   / Veroderung)

  unsigned int  uw_typ_signed   = 0x0020;   // Flag fuer Vorzeichen der UW (unsigned / signed)     (Zusatz   / Veroderung)
  unsigned int  uw_typ_Motorola = 0x0040;   // Flag fuer Prozessor (Intel / Motorola)              (Zusatz   / Veroderung)
  unsigned int  uw_typ_low_high = 0x0080;   // Flag fuer Reihenfolge (high/low, low/high)          (Zusatz   / Veroderung)

  unsigned int  uw_typ_hex      = 0x0100;   // Flag fuer hexadezimale UW (1, 2, 4 Byte => string)  (Grundtyp / Zuweisung )
  unsigned  int uw_typ_text     = 0x0200;   // Flag fuer UW als Text (string mit n Bytes)          (Grundtyp / Zuweisung )

  unsigned char request[] = {0x22,0x20,0x00};

// ---------------- Ueberpruefung ob Tabellen includiert sind --------

  INCLUDE_UDS_TAB_IArtTexte_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_DTCExtendedDataRecordNumber_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_DTCSnapshotIdentifier_B2S_NOT_FOUND;
  INCLUDE_UDS_TAB_Fehlerklasse_B2S_NOT_FOUND;
  
// ---------------- Argumente des Jobs auswerten ---------------------

  if ((!exist(F_CODE)) && (!exist(F_POS)))
    return_with_message("?F0?", "1 ARGUMENT NECESSARY - EITHER F_CODE OR F_POS", response, "", 0);

  if (exist(F_CODE) && exist(F_POS))
    return_with_message("?F0?", "ONLY 1 ARGUMENT ALLOWED - EITHER F_CODE OR F_POS", response, "", 0);

// ---------------- 1. Kommunikation (nur bei Argument F_CODE) -------

  if (exist(F_CODE)) {
    code = F_CODE;

    dataclear(response);
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) {
      if (_RESPONSE_2000) _RESPONSE_2000 = response;
      return;
    }
    response1 = response;    // zwischenpuffern, da erst am Ende des Jobs benötigt

// ---------------- 1. Interpretation (nur bei Argument F_CODE) ------

    dtc_gefunden = 0;        // Flag, ob der Info-Eintrags (DTC) gefunden wurde
    dtc_pos      = 1;        // Position des Info-Eintrags (DTC)
    is_anz       = (datalen(response) - 3) / 4;   // Anzahl der Eintraege im Infospeicher
    offset       = 3;        // Startwert

    while (is_anz > 0) {
      if ((((response[offset] << 16) & 0x00FF0000) + ((response[offset+1] << 8) & 0x0000FF00) + response[offset+2]) == code) {
        dtc_gefunden = 1;
        break;
      }

      offset = offset + 4;
      ++dtc_pos;
      --is_anz;
    }

    if (dtc_gefunden == 0)   // Abbruch, wenn Info-Eintrag nicht vorkommt
      return_with_message("?10?", "ERROR-CODE NOT STORED IN SHADOW-MEMORY", response, "_RESPONSE_2000", 0);
  }

// ---------------- Position direkt (nur bei Argument F_POS) ---------

  if (exist(F_POS)) {
    dtc_pos = F_POS;         // Position des Info-Eintrags (DTC)
    if ((dtc_pos < 0x01) || (dtc_pos > 0x1FF)) {
      JOB_STATUS = "ERROR_F_POS";
      return;
    }
  }

// ---------------- 2. Kommunikation (immer !) -----------------------

  dataclear(response);

  request[2] = dtc_pos;      // DTC-Position
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) {
    if (_RESPONSE_2000) _RESPONSE_2000 = response1;
    if (_RESPONSE_200X) _RESPONSE_200X = response;
    return;
  }

// ................ Zuweisung F_HEX_CODE .............................

  if (F_HEX_CODE) {
    text = response;         // Snapshots + Extended Data
    dataerase(text, 0, 3);
    F_HEX_CODE = text;
  }

// ---------------- 2. Interpretation --------------------------------

// ................ Test Fehlercode (nur bei Argument F_CODE) ........

  if (exist(F_CODE)) {
    if (code != ((response[4] << 16) + (response[5] << 8) + response[6])) {
      if (_RESPONSE_2000) _RESPONSE_2000 = response1;
      return_with_message("?10?", "ERROR-CODE RESPONSE IS NOT ERROR-CODE REQUEST", response, "_RESPONSE_200X", 0);
    }
  }

// ................ Test Fehlerposition (nur bei Argument F_POS) .....

  if (exist(F_POS)) {
    if (dtc_pos != response[2]) {
      if (_RESPONSE_2000) _RESPONSE_2000 = response1;
      return_with_message("?13?", "POSITION RESPONSE IS NOT POSITION REQUEST", response, "_RESPONSE_200X", 0);
    }
    code = (response[4] << 16) + (response[5] << 8) + response[6];   // Fehlercode aus SG-Antwort !
  }

// ---------------- Auswertung XDetailStruktur -----------------------

#define DetailStruktur  "IDetailStruktur"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_DetailStruktur.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 23.06.2006  gh  V0.003 Integration Flag "severity_exist"
// 29.06.2006  gh  V0.004 Fehlerbehandlung Flags
// 18.10.2006  gh  V0.020 neues Konfigurationselement: F_UWB_SATZ
// 14.03.2007  gr  V0.021 neues Konfigurationselement: F_HLZ_VIEW
// *******************************************************************
// UDS_FS_DetailStruktur.B2S @(#)@ V0.021 @(#)@
// *******************************************************************

// ---------------- Auswertung XDetailStruktur -----------------------

   tabset(DetailStruktur);        // Tabelle nicht vorhanden muss noch abgefangen werden (bei Generator immer vorhanden!)
     
// ................ Auswertung Umweltbedingungen erweitert ...........

   if (tabseek("NAME", "F_UWB_ERW")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LIUWErweitertExist = 0;
      else         
         LIUWErweitertExist = 1;
   }
   else
      LIUWErweitertExist = 0;
   

// ................ Auswertung Umweltbedingungs-Sätze ................

   if (tabseek("NAME", "F_UWB_SATZ")) {
      tabget(temp, "TYP");

      uw_satz_anzahl = atoi(temp);
   }
   else
      uw_satz_anzahl = 2;
   

// ................ Auswertung SAE-Codes .............................

   dataclear(temp);
   if (tabseek("NAME", "F_SAE_CODE")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LISaeCodeExist = 0;
      else         
         LISaeCodeExist = 1;
   }
   else
      LISaeCodeExist = 0;

// ................ Auswertung Heilungszähler ........................

   dataclear(temp);
   if (tabseek("NAME", "F_HLZ")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E) {         // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         LIHlzExist = 0;
                
         if (F_HLZ)
            F_HLZ = -1;
      }                
      else         
         LIHlzExist = 1;
   }
   else
      LIHlzExist = 0;

// ................ Auswertung Severity-Byte .........................

   dataclear(temp);
   if (tabseek("NAME", "F_SEVERITY")) {
      tabget(temp, "TYP");

      temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
         severity_exist = 0;
      else         
         severity_exist = 1;
   }
   else
      severity_exist = 0;
   

// ................ Auswertung Heilungszähler gültig .........................

   // Parameter ist solange erfoderlich, bis das Problem mit dem HLZ im Standard-Core gelöst ist	
   dataclear(temp);
   if (tabseek("NAME", "F_HLZ_VIEW")) {
      tabget(temp, "TYP");

      if (temp[0] == 0x2D)	// Handelt es sich bei diesem Zeichen um ein '-'?
      	LIHlzValid = 1; 	// Wenn nichts angebenen wird, dann richtet sich die Auswertung allein nach F_HLZ
      else
      {	 	
      	temp[0] = temp[0] | 0x20;      // erstes Zeichen in Kleinschrift

      	if (temp[0] == 0x6E)           // Handelt es sich bei dem ersten Zeichen um ein "n" ?
        	LIHlzValid = 0;
      	else         
        	LIHlzValid = 1;
       }
   }
   else
      LIHlzValid = 1; // Wenn nichts angebenen wird, dann richtet sich die Auswertung allein nach F_HLZ 

// End of file

// end of : #include "UDS_FS_DetailStruktur.b2s"

#undef  DetailStruktur

// ---------------- Auswertung Severity-Byte -------------------------

  if (severity_exist)
    severity_byte = (response[3] >> 5) & 0x07;  // Es werden nur die obersten 3 Bit benötigt.
  else
    severity_byte = 0;                          // There is no severity information available.

  if (F_FEHLERKLASSE_NR)
    F_FEHLERKLASSE_NR = severity_byte;

  if (F_FEHLERKLASSE_TEXT) {
    tabset("Fehlerklasse");
    tab_suche_unsigned("NR", severity_byte);
    tabget(text,"TEXT");
    F_FEHLERKLASSE_TEXT = text;               
  }        

// ---------------- Zuweisung F-Ort, F-Arten   -----------------------

  offset = 7;   // Startpunkt: Byte "statusOfDTC"

#define OrtTexte        "IOrtTexte"
#define ArtTexte        "IArtTexte"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Ort_Art.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 16.02.2006  gh  V0.003 Zuweisung "response1 = response;" entfernt
// 24.03.2006  gh  V0.004 Zuweisung Result F_HEX_CODE entfernt
// *******************************************************************
// UDS_FS_Ort_Art.B2S @(#)@ V0.004 @(#)@
// *******************************************************************

// ................ Rückgabe buffer löschen ..........................

   dataclear(temp);
   dataclear(text);           
   dataclear(text1);

// ................ Rückgabe Basis-Infos .............................

   LIStatusDTC = response[offset] & 0x4D;   // Auslesen des Status Bytes. Für die Auswertung sind die Bits 0,2,3,6 entscheidend

   if (F_ORT_NR || F_ORT_TEXT || F_EREIGNIS_DTC || F_READY_NR || F_READY_TEXT || F_VORHANDEN_NR || F_VORHANDEN_TEXT || F_WARNUNG_NR || F_WARNUNG_TEXT) {
      dataclear(temp);

      F_ORT_NR = code;                 // Ausgabe Fehlerort

      tabset(OrtTexte);                // Dazugehoeriger Fehlertext
      tab_suche_unsigned("ORT", code);
      tabget(temp, "ORTTEXT");
      F_ORT_TEXT = temp;

                        
      tabget(temp, "EREIGNIS_DTC");    // Ereignis-DTC ja / nein
      F_EREIGNIS_DTC = atoi(temp);


      wert = ((response[offset] >> 4)  & 0x01) + 0x10;     // Gibt an, ob Test seit dem letzten Löschen einmal komplett durchlaufen wurde
      F_READY_NR = wert;                                   // Offset 0x10 wird addiert, um Tabelle FArtTexte verwenden zu können
      
      tabset(ArtTexte);
      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_READY_TEXT = text;

                
      F_VORHANDEN_NR = LIStatusDTC;                   // Fehler aktuell vorhanden? (siehe Matrix in XArtTexte)

      tab_suche_unsigned("ARTNR", LIStatusDTC);
      tabget(text, "ARTTEXT");
      F_VORHANDEN_TEXT = text;

                
      wert = ((response[offset] >> 7) & 0x01) + 0x80; // Geht eine Warnlampe an oder nicht
      F_WARNUNG_NR = wert;

      tab_suche_unsigned("ARTNR", wert);
      tabget(text, "ARTTEXT");
      F_WARNUNG_TEXT = text;
   }

// end of : #include "UDS_FS_Ort_Art.b2s"

#undef  OrtTexte
#undef  ArtTexte

// ---------------- Auswertung Längen --------------------------------

  daten_laenge = datalen(response);

// ................ Länge Extended Data bestimmen ....................

  if (LIHlzExist == 1)
    laenge_ExtendedData = 6;   // 2 mal 3 (RN EX RN EX RN EX)
  else
    laenge_ExtendedData = 4;   // 2 mal 2 (RN EX RN EX)

// ................ Länge SnapshotRecord bestimmen ...................

  anzahl_snapshotRecord = response[8];   // DTCSnapshotRecordCount aus SG-Antwort
  if (anzahl_snapshotRecord == 0) {
    new_set_of_results();
    if (_RESPONSE_2000) _RESPONSE_2000 = response1;
    return_with_message("?08?", "TOO LESS DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_200X", 0);
  }
  else
     laenge_snapshotRecord = (datalen(response) - 9 - laenge_ExtendedData) / anzahl_snapshotRecord;
  
// ---------------- Abbruch, wenn zu wenig Daten in SG-Antwort -------

  if (laenge_snapshotRecord < 11) {      // 2 Byte ID + 3 Byte KM / 2 Byte ID + 4 Byte Zeit
    new_set_of_results();
    if (_RESPONSE_2000) _RESPONSE_2000 = response1;
    return_with_message("?12?", "OBLIGATORY SNAPSHOTS (MILAGE / TIME) ARE MISSING", response,"_RESPONSE_200X", 0);
  }
        
// ---------------- Auswertung Extended Data -------------------------

  offset = 9 + (anzahl_snapshotRecord * laenge_snapshotRecord);

  offset_start = offset;

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Extended_Data.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 20.02.2006  gh  V0.003 Entfernung "new_set_of_results();"
// 14.03.2008  gr  V0.004 Abfrage, ob Heilungszähler angezeigt werden soll
// *******************************************************************
// UDS_FS_Extended_Data.B2S @(#)@ V0.004 @(#)@
// *******************************************************************

// ................ Solange noch Einträge vorhanden sind .............

   while (offset < (datalen(response))) {
      LIExtendedRecordNumber = response[offset];

      tabset("DTCExtendedDataRecordNumber");
      tab_suche_unsigned("WERT", LIExtendedRecordNumber);
      tabget(temp, "ANZ_BYTE");
        
      LILaengeData = atoi(temp);
        
      LLData = 0;        
      while (LILaengeData > 0) {  // Anzahl der Bytes
         offset = offset + 1;
         LLData = LLData + (response[offset] << ((LILaengeData - 1) * 8));
        
         LILaengeData--;
      }
        
      if (LIExtendedRecordNumber == 0x01) { // Condition-Byte ist Pflicht
         if (F_UEBERLAUF)
            F_UEBERLAUF = LLData & 0x01;
      }

      if (LIExtendedRecordNumber == 0x02) { // Haeufigkeitszaehler ist Pflicht
         if (F_HFK)
            F_HFK = LLData;
      }

      if ((LIExtendedRecordNumber == 0x03) && (LIHlzExist == 1) && (LIHlzValid == 1)) {  // Heilungszähler (optional)
         if (F_HLZ)
            F_HLZ = LLData;
      }
      
      offset = offset + 1;
   }

// end of : #include "UDS_FS_Extended_Data.b2s"

  // Abfrage, nach LIHlzValid darf nicht gemacht werden, da sonst Telegrammlänge nicht mehr stimmt.   
  if (((LIHlzExist == 1) && ((datalen(response) - offset_start) != 6)) ||
      ((LIHlzExist != 1) && ((datalen(response) - offset_start) != 4))) {
    new_set_of_results();
    if (_RESPONSE_2000) _RESPONSE_2000 = response1;
    return_with_message("?12?", "INCORRECT NUMBER OF DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_200X", 0);
  }

// ---------------- Auswertung Snapshots -----------------------------

  offset = 9;      // Startpunkt: High-Byte des dataIdentifier (DID)

  while (anzahl_snapshotRecord > 0) {
    LIAnzUW = 0;   // Anzahl der zusaetzlichen Umweltbedingungen zuruecksetzen
    LICounterUW = 1;    // Zähler der Umweltbedingungen zurück setzen
    uw_gueltig = 1;

    laenge_snapshot = laenge_snapshotRecord;
    while (laenge_snapshot > 0) {
      pos_start = offset;

#define UmweltTexte  "IUmweltTexte"

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_FS_Snapshot.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, FOrtTexte, FArtTexte, FDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      FUmweltTexte
// -------------------------------------------------------------------
// Jobname            : IS_LESEN_DETAIL
// -------------------------------------------------------------------
// Globale Tabellen   : JobResult, IOrtTexte, IArtTexte, IDetailStruktur
//                      DTCExtendedDataRecordNumber,
//                      DTCSnapshotIdentifier
//
// Optionale Tabelle bei SAE-Codes
//                      SAECodeTexte
//
// Optionale Tabelle bei zusaetzlichen Umweltbedingungen
//                      IUmweltTexte
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// Hinweise allgemein:
// (1)  : JOB_STATUS = "ERROR_TABLE"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           erkannt wird, dass eine Tabelle falsch befuellt ist.
// (2)  : JOB_STATUS = "ERROR_INTERPRETATION"
//        -> Dieser Fehler wird gemeldet, wenn bei der Job-Bearbeitung
//           ein Fall auftritt, der undefiniert ist.
//           (Dies sollte normalerweise nie passieren !)
// (1),(2): Das Result "ERROR_MESSAGE" enthaelt zusaetzliche Hinweise.
//
// (3)  : EDIABAS_BIP_0010 / CONSTANT DATA ACCESS ERROR
//        -> Dieser EDIABAS-Fehler tritt auf, wenn im Job eine Tabellen-
//           Spalte, die in der SGBD benutzt wird, nicht existiert
//           (z.B. bei fehlerhaft dimensionierten Tabellen).
//           Es entsteht deshalb eine EDIABAS-Fehlermeldung, da die
//           Ueberpruefung der Tabellen-Spalten erst zur Laufzeit
//           geschieht.
// -------------------------------------------------------------------
// History:
// 09.02.2006  gh  V0.001 Erstellung
// 15.02.2006  gh  V0.002 getestet mit Simulation
// 20.02.2006  gh  V0.003 Umbenennung F_UW_ZEIT_DATUM => F_UW_DATUM_ZEIT
// 22.02.2006  gh  V0.004 Integration Subtabellen Tab_<Index>
// 24.03.2006  gh  V0.005 Sonderfall   0xFFFFFF bei F_UW_KM
// 24.03.2006  gh  V0.005 Sonderfall 0xFFFFFFFF bei F_UW_DATUM_ZEIT
// 24.03.2006  gh  V0.005 Korrektur Schaltjahrberechnung
// 27.03.2006  gh  V0.006 diskrete UW: real bei F_UWi_WERT, zusammengesetzter Text bei F_UWi_TEXT
// 27.03.2006  gh  V0.006 Format bei F_UW_DATUM_ZEIT optimiert
// 29.03.2006  gh  V0.006 Trace-Meldungen bzgl. return_with_message optimiert
// 28.06.2006  gh  V0.007 Zuweisung Result "F_UW_DATUM_ZEIT" auskommentiert
// 19.10.2006  gh  V0.020 $19 $04: komplexe UWB: Ausgabe als Text (string)
// 03.12.2007  rd  V0.021 Bug behoben bei hex, text Abfrage
// 21.02.2008  gr  V0.022 Auskommentierten Teil F_UW_DATUM_ZEIT entfernt 
// 21.02.2008  gr  V0.022 Bei SAE-Codes von Tabelle T_SCOD auf Tabelle T_PCOD umgestellt
// 21.02.2008  gr  V0.022 Bei SAE-Codes werden nur die ersten beiden Byte verwendet
// 21.02.2008  gr  V0.022 Zusätzliche Einträge der Tabelle DTCSnapshotIdentifier möglich
// 12.03.2010  gh  V0.030 Sub-Tabellen für diskrete UW: Spaltenname "UWTEXT" oder "TEXT" möglich
// *******************************************************************
// UDS_FS_Snapshot.B2S @(#)@ V0.030 @(#)@
// *******************************************************************

   uw_laenge = 0; // Laenge der Umweltbedingung zuruecksetzen
   uw_typ    = 0x00;       

   LIIdentifier = (response[offset] << 8) + response[offset+1];

   offset = offset + 2;   // bei digitaler oder diskreter UW nicht grundsätzlich weiterschalten !!! 

   // Einlesen des Identifier
   tabset("DTCSnapshotIdentifier");
   if (tab_suche_unsigned("UWNR", LIIdentifier) == 0) { // Falls der Identifier nicht in der Standard-UW-Tabelle enthalten ist, muss die spezielle Tabelle ausgewertet werden
      if (LIUWErweitertExist == 1) {
         tabset(UmweltTexte);
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0) { // Falls der Identifier auch nicht in der speziellen UW-Tabelle enthalten ist => Fehler
            temp = UmweltTexte;
            if (!strcmp(temp, "FUmweltTexte")) {
               new_set_of_results();
               var_result_data("_RESPONSE_EXTENDED_DATA", response1);
               return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_SNAPSHOT", 0);
            }
            else {
               new_set_of_results();
               var_result_data("_RESPONSE_2000", response1);
               return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_200X", 0);
            }
         }
      }                                                
      else  {
         temp = UmweltTexte;
         if (!strcmp(temp, "FUmweltTexte")) {
            new_set_of_results();
            var_result_data("_RESPONSE_EXTENDED_DATA", response1);
            return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_SNAPSHOT", 0);
         }
         else {
            new_set_of_results();
            var_result_data("_RESPONSE_2000", response1);
            return_with_message("?12?", "IDENTIFIER NOT DEFINED", response,"_RESPONSE_200X", 0);
         }
      }
   } // Ende 'if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)'

// ... Standard-Identifier (KM, Zeit, SAE-Code) ......................

   if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1702) {
      if (LIIdentifier == 0x1700) { // KM-Stand
         uw_laenge = 3;
         LLData = (response[offset] << 16) + (response[offset+1] << 8) + (response[offset+2]);
         if (LLData == 0xFFFFFF)  // Bei 0xFFFFFF steht der KM-Stand nicht zur Verfügung.
            LLData = -1;          // Hier soll analog zu F_UW_ZEIT der Wert -1 kommen.

         if (F_UW_KM)
            var_result_long("F_UW_KM", LLData);
      }

      // Auswertung des Datensatzes
      if (LIIdentifier == 0x1701) { // Absolute Zeit
         uw_laenge = 4;
         LLData = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] << 8) + (response[offset+3]);   // Angabe der Zeit seit 01.01.2000
         zeit_aktuell = LLData;
                          
         if (F_UW_ZEIT)
            var_result_long("F_UW_ZEIT", zeit_aktuell);
      } // Ende 'if (LIIdentifier == 0x1701)'
          
      // Auswertung des Datensatzes
      if (LIIdentifier == 0x1702) { // SAE-Code
         uw_laenge = 3;

	// alte Zuordnung
        // LLData = (response[offset] << 16) + (response[offset+1] << 8) + (response[offset+2]);
        
        // Bei den SAE-Codes werden doch nur die ersten beiden Bytes belegt 
        // Da ein 3-Byte-Wert geliefert wird, wird das letzte Byte abgeschnitten
	LLData = (response[offset] << 8) + response[offset+1];                      
	                          
         if (F_SAE_CODE)
            F_SAE_CODE = LLData;

         tabsetext("T_PCOD","PCodeTexte");
         tab_suche_unsigned("PCODE", LLData);

         if (F_SAE_CODE_STRING) {
            tabget(text, "STRING");                
            F_SAE_CODE_STRING = text;      
         }
                  
         if (F_SAE_CODE_TEXT) {
            tabget(text, "TEXT");                
            F_SAE_CODE_TEXT = text;                                       
         }
      }               
   } // Ende IF-Zweig 'if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1703)'

// ... SG-spezifischer Identifier ....................................

   else {
      uw_sub_index = 0;

// . . für alle Sub-Identifier . . . . . . . . . . . . . . . . . . . .

      do {

// . . nur beim ersten Mal . . . . . . . . . . . . . . . . . . . . . .

         if (uw_sub_index == 0) {
            identifier_sub = LIIdentifier;
            set_trap_mask(0x0400);     // Trap-Bit für Tabellenzugriff setzen

            strcpy(text, "Tab_");
            itoax(temp, identifier_sub);
            dataerase(temp, 2, 4);
            strcat(text, temp);
            tabset(text);              // Erweiterungsmatrix öffnen

            set_trap_mask(0);          // Trap-Bit für Tabellenzugriff ruecksetzen

            if (get_error(10)) {       // Sub-Tabelle existiert nicht
               uw_sub_index = 0;       // keine Aktion
            }
            else {                     // Sub-Tabelle existiert
               ++uw_sub_index;         // 1. Wert: uw_sub_index = 1;
               tabline(0);          
               tabget(text1, "UW_ANZ");
               uw_sub_anz = atoi(text1);
            }
         }

// . . ab dem ersten Mal . . . . . . . . . . . . . . . . . . . . . . .

         if (uw_sub_index > 0) {
            if (uw_sub_index <= uw_sub_anz) {    // Suchen in Zusatz-Matrix
               strcpy(text, "Tab_");
               itoax(temp, identifier_sub);
               dataerase(temp, 2, 4);
               strcat(text, temp);
               tabset(text);                     // Erweiterungsmatrix öffnen

               tabline(0);
               itoad(temp, uw_sub_index);
               strinsert(temp, "UW", 0);
               strcat(temp, "_NR");
               tab2fix(LIIdentifier, temp);      // neue "uw_nr" aus Zusatz-Matrix

               if (uw_sub_index == uw_sub_anz) {      // ! letzter digit./diskr. Wert
//                ++uw_sub_anz;
                  uw_sub_index = 0;
               }
               else                                   // sonst: weiterschalten !
                  ++uw_sub_index;
            }
            else {     // !!! darf eigentlich nie vorkommen
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?12?", "INCREMENT (++uw_sub_index)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?12?", "INCREMENT (++uw_sub_index)", response,"_RESPONSE_200X", 0);
               }
            }
         }

// . . UW normal abarbeiten  . . . . . . . . . . . . . . . . . . . . .

         LIAnzUW++; // Anzahl der echten UW-Bedingungen hochzaehlen

         text = "F_UW";

         itoad(text1, LIAnzUW);
         strinsert(text1, text , 0);

         // Es wird zuerst die Standard-Tabelle durchsucht
         tabset("DTCSnapshotIdentifier");
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)
         	tabset(UmweltTexte);                         // Wenn in der Standard-Tabelle der Eintrag nicht enthalten ist, dann wird auf die spezifische UW-Daten gegangen
         	
         tab_suche_unsigned("UWNR", LIIdentifier);    // (wieder) in die richtige Zeile springen
         tabget(text, "UW_EINH");            // !!! >> "text" wird noch gebraucht (F_UWn_EINH)

         if (!strcmp(text, "0/1"))
            uw_typ = uw_typ_digital;          // ! Typ -> digital
         else if (!strcmp(text, "0-n"))
            uw_typ = uw_typ_diskret;          // ! Typ -> diskret
         else {
            temp = text;
            temp[0] = temp[0] | 0x20;      // ! Kleinschrift (1. Zeichen)  h  t
            temp[1] = temp[1] | 0x20;      // ! Kleinschrift (2. Zeichen)  e  e
            temp[2] = temp[2] | 0x20;      // ! Kleinschrift (3. Zeichen)  x  x
            if (temp[3] != 0x00) // V0.021
              temp[3] = temp[3] | 0x20;    // ! Kleinschrift (4. Zeichen) \0  t

            if (!strcmp(temp, "hex"))
               uw_typ = uw_typ_hex;            // ! Typ -> hex (neu)
            else if (!strcmp(temp, "text"))
               uw_typ = uw_typ_text;           // ! Typ -> text (neu)
            else
               uw_typ = uw_typ_analog;         // ! Typ -> analog (evtl. -> real (siehe unten))
         } // Ende ELSE-Zweig    !strcmp(text

// . . Zuweisung Result "F_UWn_NR" . . . . . . . . . . . . . . . . . .

         temp = text1;
         strcat(temp, "_NR");
         var_result_long(temp, LIIdentifier);

// . . Zuweisung Result "F_UWn_TEXT" . . . . . . . . . . . . . . . . .
/***
         tabget(text, "UWTEXT");
         temp = text1;
         strcat(temp, "_TEXT");
         var_result_string(temp, text);
***/
// . . Zuweisung Result "F_UWn_EINH" . . . . . . . . . . . . . . . . .

         tabget(text, "UW_EINH");        
         temp = text1;
         strcat(temp, "_EINH");
         var_result_string(temp, text);

// . . Aufschluesselung des Types um die Laenge der UW zu ermitteln

         tabget(text, "UWTYP");
         if ((uw_typ & uw_typ_analog) || (uw_typ & uw_typ_hex)) {
            get_token(temp, text, " ", 1);

            temp[0] = temp[0] | 0x20;          // ! immer Kleinschrift
            if (temp[0] == 's')                  // unsigned / signed
               uw_typ = uw_typ | uw_typ_signed;     // ! hier : "ODER"
            if (temp[0] == 'm')                  // Intel / Motorola
               uw_typ = uw_typ | uw_typ_Motorola;   // ! hier : "ODER"

// . . Feststellen der Art der UW (3) Datentyp -> "uw_laenge"  . . . .

            get_token(temp, text, " ", 2);

            temp[0] = temp[0] | 0x20;     // ! immer Kleinschrift
            if (temp[0] == 'c')             // char
               uw_laenge = 1;
            else if (temp[0] == 'i')        // int
               uw_laenge = 2;
            else if (temp[0] == 'l')        // long
               uw_laenge = 4;
            else if (temp[0] == 'f') {      // float
               uw_laenge = 4;
               uw_typ = uw_typ | uw_typ_float;      // ! Typ -> float  (! hier : "ODER")
            }
            else if (temp[0] == 'd') {      // double
               uw_laenge = 8;
               uw_typ = uw_typ | uw_typ_double;     // ! Typ -> double (! hier : "ODER")
            }
            else {                          // ! Default: FEHLER
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?0A?", "NOT DEFINED TYPE (use: char, int, long, float, double)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?0A?", "NOT DEFINED TYPE (use: char, int, long, float, double)", response,"_RESPONSE_200X", 0);
               }
            }
         }

         else if (uw_typ & uw_typ_text)
            uw_laenge = atoi(text);  // Fehlerbehandlung ?

         else if ((uw_typ & uw_typ_digital) || (uw_typ & uw_typ_diskret)) 
            uw_laenge = (strlen(text) - 2) / 2;
            // z.B.: 0x4321 => 1.) strlen()-2=4 (ohne "0x")
            //                 2.) 4       /2=2 (2 Hex-Ziffern pro Byte)
            // else FEHLERMELDUNG
            // ---------------------------------
            // Zuweisung WERT

// . . Puffer für Ergebnis zuweisen (uw_wert_real, uw_wert_mask, uw_wert, ...)

         if (uw_gueltig == 1) { //Nur bei gueltiger UW
            if ((uw_typ & uw_typ_float) || (uw_typ & uw_typ_double)) // analoger Wert (real)
               data_to_real(uw_wert_real, response, offset, uw_laenge-4, uw_typ & uw_typ_Motorola);

            else if (uw_typ & uw_typ_text) {         // string mit n Bytes
               tabget(temp, "L/H");                  // Auswertung Byte-Order

               temp[0] = temp[0] | 0x20;             // ! immer Kleinschrift
               if (temp[0] == 'l')
                  uw_typ = uw_typ | uw_typ_low_high;      // ! hier : "ODER"
            }

            else { // Analogwert (long) oder digitaler/diskreter Wert . . . . . .
               tabget(temp, "L/H");                    // Auswertung Byte-Order

               temp[0] = temp[0] | 0x20;             // ! immer Kleinschrift
               if (temp[0] == 'l')
                  uw_typ = uw_typ | uw_typ_low_high;      // ! hier : "ODER"

               switch (uw_laenge) {
                  case 4: // signed long / ! unsigned long NICHT moeglich
                     // Sonderfall: Fuer Bitmasken unsigned erforderlich falls das hoechste Bit gesetzt ist
                     if ((uw_typ & uw_typ_digital) || (uw_typ & uw_typ_diskret)) {
                        if (uw_typ & uw_typ_low_high)  // low / middle_l / middle_h / high
                           uw_wert_mask =  response[offset]+ (response[offset+1] <<  8) + (response[offset+2] << 16) + (response[offset+3] << 24);
                        else                          // high / middle_h / middle_l / low
                           uw_wert_mask = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] <<  8) + response[offset+3];
                     }
                     else {                                // Normalfall: analoger Wert (signed)
                        if (uw_typ & uw_typ_low_high) // low / middle_l / middle_h / high 
                           uw_wert =  response[offset] + (response[offset+1] << 8) + (response[offset+2] << 16) + (response[offset+3] << 24);
                        else                      // high / middle_h / middle_l / low
                           uw_wert = (response[offset] << 24) + (response[offset+1] << 16) + (response[offset+2] << 8) + response[offset+3];
                     }
                     break;

                  case 2:                                  // unsigned int
                     if (uw_typ & uw_typ_low_high)  // low / high
                        uw_wert =  response[offset] + (response[offset+1] << 8);
                     else 
                        uw_wert = (response[offset  ] << 8) + response[offset+1];
   
                     if (uw_typ & uw_typ_signed) {         // -> signed
                        if (uw_wert > 32767)
                           uw_wert = uw_wert - 65536;
                     }

                     uw_wert_mask = uw_wert;               // bei int kein Unterschied
                     break;

                  case 1:                                  // unsigned char
                     uw_wert = response[offset];
   
                     if (uw_typ & uw_typ_signed) {         // -> signed
                        if (uw_wert > 127)
                           uw_wert = uw_wert - 256;
                     }

                     uw_wert_mask = uw_wert;               // bei char kein Unterschied
                     break;

                  default:                                 // ! Default: FEHLER
                     temp = UmweltTexte;
                     if (!strcmp(temp, "FUmweltTexte")) {
                        new_set_of_results();
                        var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                        return_with_message("?0A?", "LENGTH (BYTES) OF ENVIRONMENT CONDITION NOT ALLOWED", response,"_RESPONSE_SNAPSHOT", 0);
                     }
                     else {
                        new_set_of_results();
                        var_result_data("_RESPONSE_2000", response1);
                        return_with_message("?0A?", "LENGTH (BYTES) OF ENVIRONMENT CONDITION NOT ALLOWED", response,"_RESPONSE_200X", 0);
                     }
               } // Ende 'switch (uw_laenge)'
            } // Ende else Zweig von 'if ((uw_typ & uw_typ_float) || (uw_typ & uw_typ_double))'

// . . 1. Fall: digitale UW  . . . . . . . . . . . . . . . . . . . . .

            if (uw_typ & uw_typ_digital) {
               tabget(temp, "UWTYP");
               if (uw_laenge == 4) {                                       // ! Ein Wert vom Typ "unsigned long" kann        !
                  text = temp;                  // ! mit "atoi" nicht direkt interpretiert werden !
                  strerase(temp, 6, 4);         // ! -> (1) Aufteilung in 2 "int"-Werte           !
                  uw_mask = atoi(temp) & 0xFFFF;// ! -> (2) anschliessend zusammensetzen          !
                  uw_mask = uw_mask << 16;

                  strerase(text, 2, 4);
                  uw_mask = uw_mask | (atoi(text) & 0xFFFF);
               }
               else                                 // Normalfall: direkte Wandlung
                  uw_mask = atoi(temp);

               if ((uw_wert_mask & uw_mask) == uw_mask)
                  uw_wert = 1;
               else
                  uw_wert = 0;

               itor(uw_wert_real, uw_wert);         // -> real
            } // Ende 'if (uw_typ & uw_typ_digital)'

// . . 2. Fall: diskrete UW  . . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_diskret) {
               // !        tab2fix(uw_mask, "UWTYP");           // ! funktioniert nicht fuer hoechstes Bit

               tabget(temp, "UWTYP");
               if (uw_laenge == 4) {             // ! Ein Wert vom Typ "unsigned long" kann        !
                  strerase(temp, 6, 4);          // ! mit "atoi" nicht direkt interpretiert werden !
                  uw_mask = atoi(temp) & 0xFFFF; // ! -> (1) Aufteilung in 2 "int"-Werte           !
                  uw_mask = uw_mask << 16;       // ! -> (2) anschliessend zusammensetzen          !

                  tabget(temp, "UWTYP");
                  strerase(temp, 2, 4);
                  uw_mask = uw_mask | (atoi(temp) & 0xFFFF);
               }
               else                              // Normalfall: direkte Wandlung
                  uw_mask = atoi(temp);

               tabget(text, "NAME");             // Zusatztabelle <Name>

               set_trap_mask(0x0400);     // Trap-Bit für Tabellenzugriff setzen
               tabset(text);              // Tabelle bzgl. diskreter Werte oeffnen
               if (get_error(10)) {
                  text1 = "Table  not found";
                  strinsert(text1, text, 6);

                  temp = UmweltTexte;
                  if (!strcmp(temp, "FUmweltTexte")) {
                     new_set_of_results();
                     var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                     return_with_message("?0A?", text1, response,"_RESPONSE_SNAPSHOT", 0);
                  }
                  else {
                     new_set_of_results();
                     var_result_data("_RESPONSE_2000", response1);
                     return_with_message("?0A?", text1, response,"_RESPONSE_200X", 0);
                  }
               }
               set_trap_mask(0);          // Trap-Bit für Tabellenzugriff ruecksetzen

               uw_wert_mask = uw_wert_mask & uw_mask;   // ! beide Masken unsigned int
               itor(uw_wert_real, uw_wert_mask);        // -> real (für F_UWi_WERT)  /*** ***/
               tab_suche_unsigned("WERT", uw_wert_mask);

               set_trap_mask(0x0400);                   // Trap-Bit für Tabellenzugriff setzen
               tabget(text, "UWTEXT");                  // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
               set_trap_mask(0);                        // Trap-Bit für Tabellenzugriff ruecksetzen
               
               if (get_error(10))
                  tabget(text, "TEXT");                 // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
            
            } // Ende 'else if (uw_typ & uw_typ_diskret)'  !!! >> "text"  wird noch gebraucht (F_UWn_TEXT)

// . . 3 Fall: UW vom Typ Hex . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_hex) {
               itoax(text, uw_wert);                    // !!! >> "text1" wird noch gebraucht (F_UWn_WERT)
               strerase(text, 0, 10 - (2 * uw_laenge)) ;    // Anzahl: 2 + (8 - (2 * uw_laenge))
            }

// . . 4 Fall: UW vom Typ text .  . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_text) {
               ;  // keine Ergebnisberechnung erforderlich
            }

// . . 5 Fall: analoge UW . . . . . . . . . . . . . . . . . . . . . .

            else if (uw_typ & uw_typ_analog) {
               // ! nur bei long: d.h. nicht float / nicht double
               if (!(uw_typ & uw_typ_float) && !(uw_typ & uw_typ_double))       
                  itor(uw_wert_real, uw_wert);       // <Bytes aus SG-Antwort> -> real

               tabget(temp, "MUL");               // Multiplikator MUL
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "1";                                    // Default : 1
               ator(uw_mul_real, temp);           // -> real

               tabget(temp, "DIV");               // Divisor       DIV
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "1";                                    // Default : 1
               ator(uw_div_real, temp);           // -> real

               ator(uw_add_real, "0.0");          // uw_add_real kurzfristig als (real) 0.0
               if (realcomp(uw_div_real, "==", uw_add_real)) {   // ! FEHLER (Division durch "0")
                  temp = UmweltTexte;
                  if (!strcmp(temp, "FUmweltTexte")) {
                     new_set_of_results();
                     var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                     return_with_message("?0A?", "DIVISION BY ZERO", response,"_RESPONSE_SNAPSHOT", 0);
                  }
                  else {
                     new_set_of_results();
                     var_result_data("_RESPONSE_2000", response1);
                     return_with_message("?0A?", "DIVISION BY ZERO", response,"_RESPONSE_200X", 0);
                  }
               }

               tabget(temp, "ADD");               // Offset        ADD
               if (!strcmp(temp, "-") || !strcmp(temp, "--"))    // bei "-" oder "--"
                  temp = "0";                                    // Default : 0
               ator(uw_add_real, temp);           // -> real

               realmul (uw_wert_real, uw_mul_real); // uw_wert_real = ( uw_wert_real * uw_mul_real
               realdiv (uw_wert_real, uw_div_real); //                               / uw_div_real)
               realadd (uw_wert_real, uw_add_real); //                               + uw_add_real;
            } // Ende 'else if (uw_typ & uw_typ_analog'

// . . 6 Fall: Fehler, da nichts passt  . . . . . . . . . . . . . . .

            else {
               temp = UmweltTexte;
               if (!strcmp(temp, "FUmweltTexte")) {
                  new_set_of_results();
                  var_result_data("_RESPONSE_EXTENDED_DATA", response1);
                  return_with_message("?12?", "TYPE uw_typ NOT DEFINED (1)", response,"_RESPONSE_SNAPSHOT", 0);
               }
               else {
                  new_set_of_results();
                  var_result_data("_RESPONSE_2000", response1);
                  return_with_message("?12?", "TYPE uw_typ NOT DEFINED (1)", response,"_RESPONSE_200X", 0);
               }
            }

// . . Zuweisung Result "F_UWn_WERT" . . . . . . . . . . . . . . . . .

            temp = text1;
            strcat(temp, "_WERT");
/***
            if ((uw_typ & uw_typ_diskret) || (uw_typ & uw_typ_hex))    // (string) bei diskreten UW (string) bei UW vom Typ "Hex"
               var_result_string(temp, text);    // !!! << text1 wieder frei
            else                                 // (real)   bei sonstigen UW
               var_result_real(temp, uw_wert_real);
***/
            if (uw_typ & uw_typ_hex)             // (string) bei UW vom Typ "Hex"
               var_result_string(temp, text);

            else if (uw_typ & uw_typ_text) {     // (string) mit VS (Hr. Graf) abgestimmt !
               dataclear(temp);
               datacopy(temp, response, offset, uw_laenge); 

               if (uw_typ & uw_typ_low_high)
                 datarevers(temp);

               hex2ascii(text, temp, 0, uw_laenge);
                 
               temp = text1;
               strcat(temp, "_WERT");

               var_result_string(temp, text);
            }

            else                                 // (real)   bei sonstigen UW
               var_result_real(temp, uw_wert_real);
              		
               

// . . Zuweisung Result "F_UWn_TEXT" . . . . . . . . . . . . . . . . .   /*** ***/

            temp = text1;                                // !!! << text1 wieder frei
            strcat(temp, "_TEXT");

         // Es wird zuerst die Standard-Tabelle durchsucht
         tabset("DTCSnapshotIdentifier");
         if (tab_suche_unsigned("UWNR", LIIdentifier) == 0)
         	tabset(UmweltTexte);                         // Wenn in der Standard-Tabelle der Eintrag nicht enthalten ist, dann wird auf die spezifische UW-Daten gegangen

            tab_suche_unsigned("UWNR", LIIdentifier);    // (wieder) in die richtige Zeile springen
            tabget(text1, "UWTEXT");

            if (uw_typ & uw_typ_diskret) {
               strcat(text1, ": ");
               strcat(text1, text);
            }
            var_result_string(temp, text1);

         } // Ende 'if (uw_gueltig  == 1) '

      } while (uw_sub_index);     // für alle Sub-Identifier abarbeiten !

   } // Ende else-Zweig von 'if (LIIdentifier == 0x1700 || LIIdentifier == 0x1701 || LIIdentifier == 0x1703)'

   offset = offset + uw_laenge;   // bei digitaler oder diskreter UW nicht grundsätzlich weiterschalten !!!


// End of File

// end of : #include "UDS_FS_Snapshot.b2s"

#undef  UmweltTexte

      if (offset > daten_laenge) { // Der neue Offset ist länger als die Datenlänge
        uw_gueltig = 0;            // ! keine Resultbildung mehr
        new_set_of_results();
        if (_RESPONSE_2000) _RESPONSE_2000 = response1;
        return_with_message("?0A?", "TOO MUCH DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_200X", 0);
      }
      else
        LICounterUW++;

      pos_ende = offset;
      laenge_snapshot -= (pos_ende - pos_start);  // Ausgangslänge - Länge des Snapshots
    }
    if (F_UW_ANZ)  // Anzahl der zusaetzlichen Umweltbedingungen ausgeben
      F_UW_ANZ = LIAnzUW;
                
    new_set_of_results();    // neuer Ergebnissatz ???

    anzahl_snapshotRecord--;
  }

// ---------------- JOB_STATUS, _RESPONSE* ---------------------------

  if (_RESPONSE_2000)
    _RESPONSE_2000 = response1;

  if (_RESPONSE_200X)
    _RESPONSE_200X = response;
        
  if ((offset - (daten_laenge - laenge_ExtendedData)) == 0)
    JOB_STATUS = "OKAY";
  else
    return_with_message("?12?", "INCORRECT NUMBER OF DATA IN RESPONSE-TELEGRAM", response,"_RESPONSE_200X", 0);
}


// End of File

// end of : #include "UDS_22_20_00_IS_LESEN_DETAIL.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_31_01_0F_06_IS_LOESCHEN.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : IS_LOESCHEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gueltig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 22.03.2005  gh  V0.001 Erstellung
// 28.07.2005  gh  V0.002 Namensänderung dieser Datei
// 28.07.2005  gh  V0.002 Entfernung defrslt
// 05.12.2005  gr  V0.003 Anpassungen an send_and_receive_uds
// 01.02.2006  gr  V0.004 Korrektur Auftragstelegramm
// *******************************************************************
// UDS_31_01_0F_06_IS_LOESCHEN.B2S @(#)@ V0.004 @(#)@
// *******************************************************************
job ( name      :       IS_LOESCHEN;
      comment   :       Infospeicher loeschen;
      comment   :       UDS  : $31   RoutineControl;
      comment   :       UDS  : $01   startRoutine;
      comment   :       UDS  : $0F06 ClearSecondaryDTCMemory;
      comment   :       Modus: Default;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x31, 0x01, 0x0F, 0x06};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_31_01_0F_06_IS_LOESCHEN.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : HERSTELLINFO_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult, Lieferanten
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 12.12.2005  gr  V0.001 Erstellung
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Tabellen-Name)
// 20.03.2007  gh  V0.010 Service $F18A jetzt optional
// *******************************************************************
// UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S @(#)@ V0.010 @(#)@
// *******************************************************************
job ( name      :       HERSTELLINFO_LESEN;
      comment   :       Lieferant und Herstelldatum lesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $F18A SystemSupplierIdentifier;
      comment   :       UDS  : $F18B ECUManufactoringData;
      comment   :       Modus: Default;

      result    :       ID_LIEF_NR;
        type    :       long;
        comment :       Lieferantennummer;
        comment :       0xFFFFFF, falls nicht vorhanden;

      result    :       ID_LIEF_TEXT;
        type    :       string;
        comment :       Text zu ID_LIEF_NR;
        comment :       table Lieferanten LIEF_TEXT;
        comment :       unbekannter Hersteller, falls nicht vorhanden;

      result    :       ID_DATUM;
        type    :       string;
        comment :       Herstelldatum (DD.MM.YY);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
        
      result    :       _REQUEST_2;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE_2;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22, 0xF1, 0x8A};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
           long LLData;
           char temp[];
           char temp2[];
           
// ---------------- Ueberpruefung ob Tabellen includiert sind --------
   INCLUDE_UDS_Lieferanten_B2S_NOT_FOUND;

// -------------------------------------------------------------------
// Lieferant auslesen (optional)

   if (ID_LIEF_NR || ID_LIEF_TEXT || _REQUEST || _RESPONSE) {
      send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2);
      if (response[0] == 0x62)
         LLData = (response[3] << 16) + (response[4] << 8) + (response[5]);
      else
         LLData = 0xFFFFFF;
        
      if (ID_LIEF_NR)
         ID_LIEF_NR = LLData;
                
      if (ID_LIEF_TEXT) {
         tabset("Lieferanten");
         tab_suche_unsigned("LIEF_NR", LLData);
         tabget(temp, "LIEF_TEXT");
         ID_LIEF_TEXT = temp;
      }        

      if (_REQUEST)              
         _REQUEST = request;

      if (_RESPONSE)
         _RESPONSE = response;
   }

// -------------------------------------------------------------------
// Herstelldatum auslesen (Pflicht)

   if (ID_DATUM || _REQUEST_2 || _RESPONSE_2) {

      if (ID_DATUM) {
         dataclear(response);
         dataclear(temp);
         dataclear(temp2);
                                
         request = {0x22,0xF1,0x8B};    
         if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

         bcd2ascii(temp, response, 5, 1);
         strcat(temp, ".");

         bcd2ascii(temp2, response, 4, 1);
         strcat(temp, temp2);
         strcat(temp, ".");

         bcd2ascii(temp2, response, 3, 1);
         strcat(temp, temp2);

         ID_DATUM = temp;        
      }  
      if (_REQUEST_2)              
         _REQUEST_2 = request;

      if (_RESPONSE_2)
         _RESPONSE_2 = response;
   }

   JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_F1_8A_8B_HERSTELLINFO_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_3E_DIAGNOSE_AUFRECHT.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : DIAGNOSE_AUFRECHT
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 16.12.2005  gr  V0.001 Ersterstellung
// 02.02.2006  gr  V0.002 STD_DIGI ersetzt UDS_TAB_DIGITAL_ARGUMENT
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_3E_DIAGNOSE_AUFRECHT.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       DIAGNOSE_AUFRECHT;
      comment   :       Diagnosemode des SG aufrecht erhalten;
      comment   :       UDS  : $3E TesterPresent;
      comment   :       UDS  : $?0 suppressPosRspMsgIndication;
      comment   :       Modus: Default;

      argument  :       SG_ANTWORT;
        type    :       string;
        comment :       "ja"   -> SG soll antworten;
        comment :       "nein" -> SG soll nicht antworten;
        comment :       table DigitalArgument TEXT;
        comment :       Default:  SG soll antworten;
        
      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x3E, 0xFF};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
            int LIErgebnis;

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_STD_DIGI_B2S_NOT_FOUND;
  
// ---------------- Argumente des Jobs auswerten ---------------------
  if (!check_digital_argument("SG_ANTWORT", 1, LIErgebnis, 1)) return;
  
  if (LIErgebnis)
        request[1] = 0x00;
  else
        request[1] = 0x80; // SG soll nicht antworten
                           // Bit7 suppressPosRspMsgIndicationBit -> 0x00 Antwort, 0x80 keine Antwort     

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------
  
  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_3E_DIAGNOSE_AUFRECHT.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_10_DIAGNOSE_MODE.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : DIAGNOSE_MODE
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 18.11.2005  gr  V0.001 Erstellung
// 02.02.2006  gr  V0.002 STD_DIGI ersetzt UDS_TAB_DIGITAL_ARGUMENT
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Tabellen-Name)
// *******************************************************************
// UDS_10_DIAGNOSE_MODE.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       DIAGNOSE_MODE;
      comment   :       SG in bestimmten Diagnosemode bringen;
      comment   :       UDS  : $10 StartDiagnosticSession;
      comment   :       Modus: einstellbar mit diesem Job;

      argument  :       MODE;
        type    :       string;
        comment :       gewuenschter Diagnose-Modus;
        comment :       table DiagMode MODE MODE_TEXT;
        comment :       Defaultwert: DEFAULT (DefaultMode);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{                                 // defaultSession
  unsigned char request[] = {0x10, 0x01};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  unsigned char temp[];     
  unsigned char arg[];  

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_UDS_TAB_DiagMode_B2S_NOT_FOUND;

// ---------------- Argumente des Jobs auswerten ---------------------
  if (exist(MODE)) 
  {
        tabset("DiagMode");
        arg = MODE;
        if (tabseek("MODE", arg)) 
        {
                tabget(temp, "NR");
                request[1] = atoi(temp);
        }
        else 
        {
                JOB_STATUS = "ERROR_MODE";
                return;
        }
  }

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_10_DIAGNOSE_MODE.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_11_04_SLEEP_MODE.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : SLEEP_MODE
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 16.12.2005  gr  V0.001 Erstellung
// *******************************************************************
// UDS_11_04_SLEEP_MODE.B2S @(#)@ V0.001 @(#)@
// *******************************************************************
job ( name      :       SLEEP_MODE;
      comment   :       SG in Sleep-Mode versetzen;
      comment   :       UDS  : $11 ECUReset;
      comment   :       UDS  : $04 EnableRapidPowerShutDown;
      comment   :       Modus: Default;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
   )
{
  unsigned char request[] = {0x11, 0x04};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_11_04_SLEEP_MODE.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_31_01_0F_0C_ENERGIESPARMODE.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : ENERGIESPARMODE
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 05.12.2005  gr  V0.001 Erstellung
// 20.12.2005  gr  V0.002 Zusammenfassung der Argumente
// 01.02.2006  gr  V0.003 Interne Variable fuer Argument hinzu
// *******************************************************************
// UDS_31_01_0F_0C_ENERGIESPARMODE.B2S @(#)@ V0.003 @(#)@
// *******************************************************************
job ( name      :       ENERGIESPARMODE;
      comment   :       Einstellen des Energiesparmodes;
      comment   :       UDS   : $31   RoutineControlRequestServiceID;
      comment   :       UDS   : $01   startRoutine;
      comment   :       UDS   : $0F0C DataIdentifier ControlEnergySavingMode;
      comment   :       UDS   : $??   Mode;
      comment   :       Modus : Default;

      argument  :       MODE;
        type    :       int;
        comment :       0x00: Normalmode;
        comment :       0x01: Fertigungsmode;
        comment :       0x02: Transportmode;
        comment :       0x03: Flashmode;
      
      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;
      
      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x31, 0x01, 0x0F, 0x0C, 0xFF};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
            int arg;    

// ---------------- Argumente des Jobs auswerten ---------------------

  arg = MODE;
  
  if ((exist(MODE)) && (arg < 4))
        request[4] = arg;
  else
  {
        JOB_STATUS = "ERROR_ARGUMENT";
        return;
  }
  

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_31_01_0F_0C_ENERGIESPARMODE.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_10_0A_STATUS_ENERGIESPARMODE.b2s"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STATUS_ENERGIESPARMODE
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 12.12.2005  gr  V0.001 Ersterstellung 
// 04.04.2006  rd  V0.002 Rechtschreibfehler behoben
// *******************************************************************
// UDS_22_10_0A_STATUS_ENERGIESPARMODE.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       STATUS_ENERGIESPARMODE;
      comment   :       Energy-Saving-Mode auslesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $100A DataIdentifier EnergySavingMode;
      comment   :       Modus: Default;

      result    :       STAT_ENERGIESPARMODE_WERT;
        type    :       int;
        comment :       Ausgabe des Energiesparmodes;
        comment :        0: Kein Energiesparmode gesetzt;
        comment :        1: Produktionsmode gesetzt;
        comment :        2: Transportmode gesetzt;        
        comment :        3: Flashmode gesetzt;        
        comment :       -1: Mode ungueltig;

      result    :       STAT_ENERGIESPARMODE_TEXT;
        type    :       string;
        comment :       Text zu STAT_ENERGIESPARMODE_WERT;

      result    :       STAT_PRODUKTIONSMODE_EIN;
        type    :       int;
        comment :       0: Produktionsmode nicht aktiv;
        comment :       1: Produktionsmode aktiv;

      result    :       STAT_TRANSPORTMODE_EIN;
        type    :       int;
        comment :       0: Transportmode nicht aktiv;
        comment :       1: Transportmode aktiv;

      result    :       STAT_FLASHMODE_EIN;
        type    :       int;
        comment :       0: Flashmode nicht aktiv;
        comment :       1: Flashmode aktiv;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22, 0x10, 0x0A};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (response[3] == 0x00)
  {
        if(STAT_PRODUKTIONSMODE_EIN) 
                STAT_PRODUKTIONSMODE_EIN = 0;

        if(STAT_TRANSPORTMODE_EIN) 
                STAT_TRANSPORTMODE_EIN = 0;

        if(STAT_FLASHMODE_EIN) 
                STAT_FLASHMODE_EIN = 0;
        
        if (STAT_ENERGIESPARMODE_WERT)
                STAT_ENERGIESPARMODE_WERT = 0;

        if (STAT_ENERGIESPARMODE_TEXT)  
                STAT_ENERGIESPARMODE_TEXT = "Energiesparmode nicht aktiv";
  }
  else if (response[3] == 0x01)
  {
        if(STAT_PRODUKTIONSMODE_EIN) 
                STAT_PRODUKTIONSMODE_EIN = 1;

        if(STAT_TRANSPORTMODE_EIN) 
                STAT_TRANSPORTMODE_EIN = 0;

        if(STAT_FLASHMODE_EIN) 
                STAT_FLASHMODE_EIN = 0;
        
        if (STAT_ENERGIESPARMODE_WERT)
                STAT_ENERGIESPARMODE_WERT = 1;

        if (STAT_ENERGIESPARMODE_TEXT)  
                STAT_ENERGIESPARMODE_TEXT = "Produktionsmode";
  }
  else if (response[3] == 0x02)
  {
        if(STAT_PRODUKTIONSMODE_EIN) 
                STAT_PRODUKTIONSMODE_EIN = 0;

        if(STAT_TRANSPORTMODE_EIN) 
                STAT_TRANSPORTMODE_EIN = 1;

        if(STAT_FLASHMODE_EIN) 
                STAT_FLASHMODE_EIN = 0;
        
        if (STAT_ENERGIESPARMODE_WERT)
                STAT_ENERGIESPARMODE_WERT = 2;

        if (STAT_ENERGIESPARMODE_TEXT)  
                STAT_ENERGIESPARMODE_TEXT = "Transportmode";
  }
  else if (response[3] == 0x03)
  {
        if(STAT_PRODUKTIONSMODE_EIN) 
                STAT_PRODUKTIONSMODE_EIN = 0;

        if(STAT_TRANSPORTMODE_EIN) 
                STAT_TRANSPORTMODE_EIN = 0;

        if(STAT_FLASHMODE_EIN) 
                STAT_FLASHMODE_EIN = 1;
        
        if (STAT_ENERGIESPARMODE_WERT)
                STAT_ENERGIESPARMODE_WERT = 3;

        if (STAT_ENERGIESPARMODE_TEXT)  
                STAT_ENERGIESPARMODE_TEXT = "Flashmode";
  }
  else
  {
        if(STAT_PRODUKTIONSMODE_EIN) 
                STAT_PRODUKTIONSMODE_EIN = 0;

        if(STAT_TRANSPORTMODE_EIN) 
                STAT_TRANSPORTMODE_EIN = 0;

        if(STAT_FLASHMODE_EIN) 
                STAT_FLASHMODE_EIN = 0;
        
        if (STAT_ENERGIESPARMODE_WERT)
                STAT_ENERGIESPARMODE_WERT = -1;

        if (STAT_ENERGIESPARMODE_TEXT)  
                STAT_ENERGIESPARMODE_TEXT = "Mode ungültig";
  }

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_10_0A_STATUS_ENERGIESPARMODE.b2s"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_16_00_SENSOREN_ANZAHL_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : SENSOREN_ANZAHL_LESEN
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 12.12.2005  gr  V0.001 Ersterstellung auf Basis STD22160
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_22_16_00_SENSOREN_ANZAHL_LESEN.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       SENSOREN_ANZAHL_LESEN;
      comment   :       Anzahl der intelligenten Subbussensoren lesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $1600 Identifier NumberofSubbusMembers;
      comment   :       Modus: Default;

      result    :       SENSOR_ANZAHL;
        type    :       long;
        comment :       Anzahl der intelligenten Subbussensoren;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22, 0x16, 0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (SENSOR_ANZAHL) 
        SENSOR_ANZAHL = response[3];

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_16_00_SENSOREN_ANZAHL_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_16_XX_SENSOREN_IDENT_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : SENSOREN_IDENT_LESEN
// -------------------------------------------------------------------
//
// Globale Tabellen   : JobResult,VerbauortTabelle,PartNrTabelle
//
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 12.12.2005  gr  V0.001 Ersterstellung auf Basis STD2216X
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// 23.10.2006  rd  V0.003 Verbauort mit SG-Adresse verknüpft
// 04.02.2007  gr  V0.004 Auswertung optionaler LIN-Daten hinzu
// 03.07.2007  gh  V0.005 neues Result "SENSOR_VERBAUORT_NR", Anforderer: Robert Lorenz, TI-431
// 21.02.2008  gr  V0.006 Argument um VERBAUORT erweitert, damit Auswahl eines bestimmten Sensors möglich
// 21.02.2008  gr  V0.006 Bei *W_RELEASE umgestellt von BCD-Dekodierung auf HEX-Anzeige (nach Rücksprache mit Hrn. Thierauf)
// *******************************************************************
// UDS_22_16_XX_SENSOREN_IDENT_LESEN.B2S @(#)@ V0.006 @(#)@
// *******************************************************************   
job ( name      :       SENSOREN_IDENT_LESEN;
      comment   :       Identifikation der intelligenten Subbussensoren lesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $1600 Identifier NumberofSubbusMembers;
      comment   :       UDS  : $16xx SubbusMemberSerialNumber;
      comment   :       Modus: Default;

      argument  :       SENSOR_NR;
        type    :       long;
        comment :       optionales Argument;
        comment :       gewuenschter Sensor xx (0x01 - 0xFF);
        comment :       oder VERBAUORT eines bestimmten Sensors (table VerbauortTabelle ORT);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       SENSOR_VERBAUORT;
        type    :       string;
        comment :       Verbauort des Sensors;
        comment :       table VerbauortTabelle ORTTEXT;

      result    :       SENSOR_VERBAUORT_NR;
        type    :       long;
        comment :       Verbauort-Nummer des Sensors;

      result    :       SENSOR_BMW_NR;
        type    :       string;
        comment :       BMW-Teilenummer des Sensors;

      result    :       SENSOR_PART_NR;
        type    :       string;
        comment :       Teilenummer des Sensors;
        comment :       optional wenn SENSOR_BMW_NR gueltig;
        comment :       wenn Teilenummer vom Sensor nicht verfuegbar dann '--';

      result    :       SENSOR_LIN_2_0_FORMAT;
        type    :       int;
        comment :       1: Die optionalen Daten des Sensors (Hersteller, Seriennummer, ...) werden in LIN_2_Format geliefert;
        comment :       0: Optionale Daten nicht im LIN_2_Format (nur Defaultwerte werden ausgegeben);
        
      result    :       SENSOR_HERSTELLER_NR;
        type    :       long;
        comment :       Lieferantennummer des Herstellers;
        comment :       wenn Hersteller-Nummer nicht verfuegbar, dann 0;
        
      result    :       SENSOR_HERSTELLER_TEXT;
        type    :       string;
        comment :       Textausgabe Lieferant;
        comment :       wenn Softwarestand nicht verfuegbar, dann 'Information nicht verfuegbar';
        
      result    :       SENSOR_FUNKTIONS_NR;
        type    :       long;
        comment :       Funktionsnummer des Sensors;
        comment :       wenn Funktions-Nummer nicht verfuegbar, dann 0;
        
      result    :       SENSOR_VARIANTEN_NR;
        type    :       long;
        comment :       Variantennummer des Sensors;
        comment :       wenn Varianten-Nummer nicht verfuegbar, dann 0;        
  
      result    :       SENSOR_PROD_DATUM;
        type    :       string;
        comment :       Produnktionsdatum (DD.MM.YY) des Sensors;
        comment :       wenn Produktions-Datum nicht verfuegbar, dann '--';        
     
      result    :       SENSOR_SERIEN_NR;
        type    :       string;
        comment :       Seriennummer des Sensors;
        comment :       wenn Serien-Nummer nicht verfuegbar, dann '--';        
        
      result    :       SENSOR_SW_RELEASE_NR;
        type    :       string;
        comment :       Softwarestand des Sensors;
        comment :       wenn Softwarestand nicht verfuegbar, dann '--';
        
      result    :       SENSOR_HW_RELEASE_NR;
        type    :       string;
        comment :       Hardwarestand des Sensors;
        comment :       wenn Softwarestand nicht verfuegbar, dann '--';        

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;

      result    :       _REQUEST_2;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE_2;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22, 0x16, 0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
//unsigned char buffer[];
  unsigned char buffer2[];
  unsigned char temp[];
  unsigned char temp2[];
           int  retval;
           long sensor_nr = 0;
           long LLSensorVerbauort = 0;           
  unsigned int  k;
  unsigned int  anzahl;
  unsigned int  LIData = 0;
   unsigned int  LBFound = 0;

// ---------------- Ueberpruefung ob Tabellen includiert sind --------
  INCLUDE_STD_ISEN_B2S_NOT_FOUND;
  INCLUDE_UDS_LieferantenLIN_B2S_NOT_FOUND; // Tabelle für LIN-Teilnehmer

// ---------------- Argumente des Jobs auswerten ---------------------

  if (exist(SENSOR_NR)) 
  {
  	// Zuerst die Abfrage, ob es sich um einen Sensor aus der Tabelle 'VerbauOrtTabelle' handelt
        LLSensorVerbauort = SENSOR_NR;
        tabset("VerbauortTabelle");
        if ((tab_suche_unsigned("ORT", LLSensorVerbauort)) == TRUE) // Es handelt sich bei dem Argument um einen Verbauort
	{
	
	}
  	else // Es handelt sich um eine Sensor-Nummer
        { 
        	LLSensorVerbauort = 0xFFFFFFFF;
        	sensor_nr = SENSOR_NR;
        	if (sensor_nr < 1 || sensor_nr > 255) 
        	{
                	JOB_STATUS = "ERROR_ARGUMENT";
                	return;
        	}
        }
  }
  else
  {
  	LBFound = 1;
  	LLSensorVerbauort = 0xFFFFFFFF;
  }
// ---------------- Anzahl ermitteln ---------------------------------
// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;


// ---------------- Interpretation -----------------------------------
  if (response[3] == 0)
  {
    JOB_STATUS = "OKAY";
    return;
  }

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;

// ---------------- Seriennummern lesen ------------------------------
// ---------------- Kommunikation ------------------------------------
  if (sensor_nr == 0) 
  {
        k      = 1;
        anzahl = response[3];
  }
  else 
  {
        anzahl = sensor_nr;
        k      = sensor_nr;
  }

  while (k <= anzahl) 
  {
        request = {0x22,0x16,0x00};
        request[2] = k;
        
        retval = send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2);
        
        // ---------------- Interpretation -----------------------------------

        if (retval == 1) 
        {

                tabset("VerbauortTabelle");
                if (!tab_suche_unsigned("ORT", (SA_response<<16) + (response[3]<<8) + response[4]))
                tab_suche_unsigned("ORT", (response[3]<<8) + response[4]);
                tabget(buffer2, "ORTTEXT");
                tabget(temp,"LIN_2_FORMAT");



                //  Keine bestimmte Sensor-Abfrage   oder bestimmte Sensor-Abfrage und Sensor gefunden
 		if ((LLSensorVerbauort == 0xFFFFFFFF) || ((LLSensorVerbauort != 0xFFFFFFFF) &&(((response[3] << 8) + response[4]) == LLSensorVerbauort)))
		{		
			 
                	if (SENSOR_VERBAUORT)
                  		SENSOR_VERBAUORT = buffer2;
                
                	if (SENSOR_VERBAUORT_NR)
                  		SENSOR_VERBAUORT_NR = (response[3] << 8) + response[4];


                	// Abfrage ob Daten im LIN 2.0 Format oder nicht
                
                	if (strcmp(temp,"1") == 0) // Sensor liefert die Daten nach 2.0-Standard
                	{       
                        	// Sollten zuwenig Daten kommen, dann wird abgebrochen
                        	if (datalen(response) < 27)
                              	  return_with_message("?12?", "INCORRECT NUMBER OF DATA IN RESPONSE-TELEGRAM", response,buffer2, 1);      

                        	if (SENSOR_LIN_2_0_FORMAT)
                              	  SENSOR_LIN_2_0_FORMAT = 1;

                        	if (SENSOR_BMW_NR) 
                       	 	{       // Offen ist noch, was mit dem ersten Byte passieren soll,
                               		// da vom LIN an sich nur 5 Byte kommen und das 6. Byte vom Master befüllt wird
                                	// Die Frage ist nur, wie? Klärung AK Diagnose
                                	hex2ascii(temp,response,5,6);
                                	if (strcmp(temp,"FFFFFFFFFFFF") == 0) 
                                	{
                                       	 if (datalen(response) > 11) 
                                       	 {
                                                hex2ascii(temp,response,11,datalen(response)-11);
                                                tabset("PartNrTabelle");
                                                tabseek("PART_NR", temp);
                                                tabget(buffer2, "BMW_NR");
                                         }
                                         else 
                                         {
                                                buffer2 = "--";
                                         }
                                         SENSOR_BMW_NR = buffer2;
                                 }
                                 else
                                 {
                                        dataclear(temp);
                                        datacopy(temp,response, 5, 6);
                                        BRstandard(buffer2,temp);
                                 }
                                        SENSOR_BMW_NR = buffer2;
                        	}                       
                        
                        	if (SENSOR_HERSTELLER_NR)
                        	{                               // 2 Byte Herstellernummer
                                	SENSOR_HERSTELLER_NR = (response[11] << 8) + response[12];      
                        	}
                        
                        	if (SENSOR_HERSTELLER_TEXT)
                        	{       // Text kommt aus Tabelle die aus Informationen von der LIN-Homepage erstellt wurden
                                	dataclear(temp);
                                
                                	LIData = (response[11] << 8) + response[12];    
                                
                                	tabset("LieferantenLIN");
                                	tab_suche_unsigned("LIEF_NR", LIData);
                                	tabget(temp, "LIEF_TEXT");
                                
                                	SENSOR_HERSTELLER_TEXT = temp;
                        	}

                        
                        	if (SENSOR_FUNKTIONS_NR)
                        	{               // Funktionsnummer des Sensors (wird bei Kommunikation Master / Slave benötigt)
                                	SENSOR_FUNKTIONS_NR  = (response[13] << 8) + response[14];      
                        	}
                        
                        	if (SENSOR_VARIANTEN_NR)        
                        	{               // Variantennummer (wird ebenfalls bei der Kommunikation gebraucht)
                                	SENSOR_VARIANTEN_NR = response[15];
                        	}
                        
                        	if (SENSOR_PROD_DATUM)
                        	{       // Das Produktionsdatum wird in 3 Byte geliefert
                                	// Reihenfolge im Telegramm YY.MM.DD
                                	dataclear(temp);
                                	dataclear(temp2);
                                	bcd2ascii(temp, response, 18, 1); // Tag
                                	strcat(temp, ".");

                                	bcd2ascii(temp2, response, 17, 1); //Monat
                                	strcat(temp, temp2);
                                	strcat(temp, ".");

                                	bcd2ascii(temp2, response, 16, 1); //Jahr
                                	strcat(temp, temp2);

                                	SENSOR_PROD_DATUM = temp;        
                        	}       
                        
                        	if (SENSOR_SERIEN_NR)
                        	{       // Seriennummer muss laut Hr. Thierauf (LIN-Spezialist) nicht konvertiert werden
                                	dataclear(temp);
                                	hex2ascii(temp,response,19,4);
                                	SENSOR_SERIEN_NR = temp;
                        	}
                        
                        	if (SENSOR_SW_RELEASE_NR)
                        	{       // 1. Byte: Hauptversionsnummer
                                	// 2. Byte: Nebenversionsnummer
                                	dataclear(temp);
                                	dataclear(temp2);
                                	hex2ascii(temp, response, 23, 1); // Hauptversionsnummer
                                	strcat(temp, ".");

                                	hex2ascii(temp2, response, 24, 1); //Nebenversionsnummer
                                	strcat(temp, temp2);
                                
                               	 	SENSOR_SW_RELEASE_NR = temp;
                        	}
                        
                        	if (SENSOR_HW_RELEASE_NR)
                        	{       // 1. Byte: Hauptversionsnummer
                                	// 2. Byte: Nebenversionsnummer
                                	dataclear(temp);
                                	dataclear(temp2);
                                	hex2ascii(temp, response, 25, 1); // Hauptversionsnummer
                                	strcat(temp, ".");

                                	hex2ascii(temp2, response, 26, 1); //Nebenversionsnummer
                                	strcat(temp, temp2);
                                
                                	SENSOR_HW_RELEASE_NR = temp;
                        	} 
                	}       
                	else
                	{
                        	if (SENSOR_BMW_NR) 
                        	{
                                	hex2ascii(temp,response,5,6);
                                	if (strcmp(temp,"FFFFFFFFFFFF") == 0) 
                                	{
                                        	if (datalen(response) > 11) 
                                        	{
                                                	hex2ascii(temp,response,11,datalen(response)-11);
                                                	tabset("PartNrTabelle");
                                                	tabseek("PART_NR", temp);
                                                	tabget(buffer2, "BMW_NR");
                                        	}
                                        	else 
                                        	{
                                                	buffer2 = "--";
                                        	}
                                        	SENSOR_BMW_NR = buffer2;
                                	}
                                	else
                                	{
                                        	dataclear(temp);
                                        	datacopy(temp,response, 5, 6);
                                        	BRstandard(buffer2,temp);
                                	}
                                        	SENSOR_BMW_NR = buffer2;
                        	}

                        	// Sofern keine BMW-Teilenummer vorhanden ist

                        	if (SENSOR_PART_NR) 
                        	{
                                	if (datalen(response) > 11) 
                                	{
                                        	hex2ascii(buffer2,response,11,datalen(response)-11);
                                        	SENSOR_PART_NR = buffer2;
                                	}
                                	else 
                                	{
                                        	SENSOR_PART_NR = "--";
                                	}
                        	}

                        
                        	// Informationen aus LIN 2.0- Format sind nicht verfuegbar
                        	if (SENSOR_LIN_2_0_FORMAT)
                                	SENSOR_LIN_2_0_FORMAT = 0;


                        	if (SENSOR_HERSTELLER_NR)
                                	SENSOR_HERSTELLER_NR = 0;       
                        
                        	if (SENSOR_HERSTELLER_TEXT)
                                	SENSOR_HERSTELLER_TEXT = "--";
                        
                        	if (SENSOR_FUNKTIONS_NR)
                                	SENSOR_FUNKTIONS_NR  = 0;
                        
                        	if (SENSOR_VARIANTEN_NR)
                                	SENSOR_VARIANTEN_NR = 0;
                        
                        	if (SENSOR_PROD_DATUM)
                                	SENSOR_PROD_DATUM = "--";
                        
                        	if (SENSOR_SERIEN_NR)
                                	SENSOR_SERIEN_NR = "--";
                        
                        	if (SENSOR_SW_RELEASE_NR)
                                	SENSOR_SW_RELEASE_NR = "--";
                        
                        	if (SENSOR_HW_RELEASE_NR)
                                	SENSOR_HW_RELEASE_NR = "--";
                        
                        
                } // Ende ELSE-Zweig if (strcmp(temp,"1") == 0)
                
                if (_REQUEST_2)              
                        _REQUEST_2 = request;

                if (_RESPONSE_2)
                        _RESPONSE_2 = response;
		
                JOB_STATUS = "OKAY";
                }
        }
    
        if (sensor_nr != 0) return;
        new_set_of_results();
        if ((LLSensorVerbauort != 0xFFFFFFFF) &&(((response[3] << 8) + response[4]) == LLSensorVerbauort))
        {
        	LBFound = 1;
        	k = anzahl;
        }
        k++;
        } // while (k <= anzahl)

  	if (LBFound == 0)
  		JOB_STATUS = "SENSOR_NOT_ASSEMBLED_OR_WRONG_ARGUMENT";
  	else
  		JOB_STATUS = "OKAY";
  
}
// end of : #include "UDS_22_16_XX_SENSOREN_IDENT_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_11_STEUERGERAETE_RESET.B2S"
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERGERAETE_RESET
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8
//                     SAP 10000786
// -------------------------------------------------------------------
// History:
// 05.12.2005  gr  V0.001 Erstellung
// 02.02.2006  gh  V0.002 Include-Name geändert (wie Job-Name)
// *******************************************************************
// UDS_11_STEUERGERAETE_RESET.B2S @(#)@ V0.002 @(#)@
// *******************************************************************
job ( name      :       STEUERGERAETE_RESET;
      comment   :       Harter Reset des Steuergeraets;
      comment   :       UDS  : $11 EcuReset;
      comment   :       UDS  : $01 HardReset;
      comment   :       Modus: Default;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x11, 0x01};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
        _REQUEST = request;

  if (_RESPONSE)
        _RESPONSE = response;
        
  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_11_STEUERGERAETE_RESET.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_JOBS_ROE.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// optinale Standardjobs Unified Diagnostic Services (UDS) nach ISO 14229
// (Response on event)
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 04.12.2006  an  V0.001 Erstellung (Patrick Hess, TI-430)
// *******************************************************************
// UDS_JOBS_ROE.B2S @(#)@ V0.001@(#)@
// *******************************************************************

// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_86_00_02_STEUERN_ROE_STOP.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_ROE_STOP
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 30.11.2006  an  V0.001 Erstellung (Tobias Kraeker, EI-71, Albrecht Neff, EI-71)
// *******************************************************************
// UDS_86_00_02_STEUERN_ROE_STOP.B2S @(#)@ V0.001@(#)@
// *******************************************************************




job ( name      :       STEUERN_ROE_STOP;
      comment   :       Temporaeres Deaktivieren der;
      comment   :       aktiven Fehlermeldung;
      comment   :       UDS   : $86 ResponseOnEvent;
      comment   :               $00 Stop;
      comment   :               $02 (EventWindowTime);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{

  // Variablen fuer Kommunikation
  unsigned char request[] = {0x86,0x00,0x02};
  unsigned char expectedResponse[] = {0xC6,0x00,0x00,0x02};
  unsigned char response[];
  unsigned char SA_response;
  unsigned char TA_response;

  //KONSTANTEN
  unsigned char EXPECTED_RESPONSE_LENGTH = 4;
// ---------------- Argumente des Jobs auswerten ---------------------

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;


// ---------------- Interpretation -----------------------------------
	if (_REQUEST)
		_REQUEST = request;

	if (_RESPONSE)
        _RESPONSE = response;

	if(datalen(response) != EXPECTED_RESPONSE_LENGTH)
	{
	        JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";
			return;
	}
	else if(datacmp(expectedResponse,response)!=0)
	{
            JOB_STATUS = "ERROR_INTERPRETATION";
			return;
	}
	else
	{
		JOB_STATUS = "OKAY";
	}
}

// end of : #include "UDS_86_00_02_STEUERN_ROE_STOP.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_86_04_STATUS_ROE_REPORT.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STATUS_ROE_REPORT
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-32
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 30.11.2006  an  V0.001 Erstellung (Tobias Kraeker, EI-71, Albrecht Neff, EI-71)
// 28.11.2011  MiH V0.002 Michael Holzner, RUETZ TECHNOLOGIES GmbH für BMW EI-32
//                         - Update RoE-Status, Toleranz für Response ohne StoreEvent-Flag gesetzt
//                         - 35up kompatibilität: falls 86 04 zu INCORRECT_LENGTH führt, wird 86 04 02
//                         ausgeführt, wie ab DM LH V11 gefordert (UDS-konform)
//                         - Robustheitsmassnahmen
// *******************************************************************
// UDS_86_04_STATUS_ROE_REPORT.B2S @(#)@ V0.002@(#)@
// *******************************************************************

job ( name      :  STATUS_ROE_REPORT;
      comment   :  Abfrage Status der Aktivierung der aktiven Fehlermeldung;
      comment   :  UDS: $86 ResponseOnEvent;
      comment   :  $04 report activated events;
      comment   :  [$02 eventWindowTime - infinite (nur 35up)];

	result     :    STAT_ROE_AKTIV;
        type  :    char;
		comment :	 0x00  = Aktive Fehlermeldung deaktiviert;
		comment : 	 0x01  = Aktive Fehlermeldung aktiviert;
		comment : 	 0xFF  = Status der aktiven Fehlermeldung nicht feststellbar;

	result  :     	 STAT_ROE_AKTIV_TEXT;
     type  :       string;
	comment :		 Interpretation von STAT_ROE_AKTIV;
   comment :       table UDS_TAB_ROE_AKTIV TEXT;

   result  :       JOB_STATUS;
     type  :       string;
   comment :       OKAY, wenn fehlerfrei;
   comment :       table JobResult STATUS_TEXT;

//      result    :       STATE_35UP;
//        type    :       string;
//        comment :       NO, falls SG nach LH DM V9 (LG,LK,LU,LI) - antwortet korrekt auf 86 04;
//        comment :       35UP, falls SG nach LH DM >V11 (35UP) - antwortet korrekt auf 86 04 02;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{

  // Variablen fuer Kommunikation
  unsigned char request[]     = {0x86,0x04};
  unsigned char request35up[] = {0x86,0x04,0x02};
//  unsigned char expectedResponseActivated[]     = {0xC6,0x04,0x01,0x43,0x02,0x17,0x04,0x22,0x17,0x04};
//  unsigned char expectedResponseActivatedTemp[] = {0xC6,0x04,0x01,0x03,0x02,0x17,0x04,0x22,0x17,0x04};
  
  unsigned char expectedResponseDeactivated[] = {0xC6,0x04,0x00};
  
  unsigned char response[];
  unsigned char interpretation[];
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char index;
  unsigned char TryRequest860402;
  
  //KONSTANTEN
  unsigned char EXPECTED_RESPONSE_LENGTH_ACTIVATED = 10;
  unsigned char EXPECTED_RESPONSE_LENGTH_DEACTIVATED = 3;
// ---------------- Argumente des Jobs auswerten ---------------------

// ---------------- Kommunikation ------------------------------------
  TryRequest860402 = 0;
    
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) 
  { // also NOK..
      if ((0x7F == response[0]) &&
          (0x86 == response[1]) &&
          (0x13 == response[2]))    // 7F 86 13  INVALID LENGTH
      {
         request = request35up;
         if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;
         TryRequest860402 = 1;
      }
      else
         return;
  }

// ---------------- Interpretation -----------------------------------
	if (_REQUEST)
		_REQUEST = request;

	if (_RESPONSE)
        _RESPONSE = response;

	if((datalen(response) == EXPECTED_RESPONSE_LENGTH_ACTIVATED) &&
//	    ((datacmp(expectedResponseActivated,response)==0) ||
//		   (datacmp(expectedResponseActivatedTemp,response)==0)) )  // Änderung 28.11.2011 MiH
      (0xC6 == response[0]) &&
      (0x04 == response[1]) &&
      (0x01 == response[2]) &&
      ((!TryRequest860402 && (0x03==response[3])) || (0x43 == response[3])) &&
      (0x02 == response[4]))
	{
		if(STAT_ROE_AKTIV)
			STAT_ROE_AKTIV = 1;

//	   if (STATE_35UP)
//	   {
//	      if (0 == TryRequest860402)
//   	      STATE_35UP = "NO";	
//	      else
//   	      STATE_35UP = "35UP";
//   	}
	
		if(STAT_ROE_AKTIV_TEXT)
		{
         tabset("UDS_TAB_ROE_AKTIV");
   		index = 1;
			tab_suche_unsigned("NR",index);
			tabget(interpretation,"TEXT");
			STAT_ROE_AKTIV_TEXT = interpretation;
		}
	   JOB_STATUS = "OKAY";
	   return;
	}
	else if((datalen(response) == EXPECTED_RESPONSE_LENGTH_DEACTIVATED) &&
			(datacmp(expectedResponseDeactivated,response)==0))
	{
		if(STAT_ROE_AKTIV)
			STAT_ROE_AKTIV = 0;
	
//		if (STATE_35UP)
//	   {
//	      if (0 == TryRequest860402)
//   	      STATE_35UP = "NO";	
//	      else
//	         STATE_35UP = "35UP";
//   	}
	
		if(STAT_ROE_AKTIV_TEXT)
		{
        	tabset("UDS_TAB_ROE_AKTIV");
			index = 0;
			tab_suche_unsigned("NR",index);
			tabget(interpretation,"TEXT");
			STAT_ROE_AKTIV_TEXT = interpretation;
		}
		JOB_STATUS = "OKAY";
		return;
	}
	else
	{
	   if(STAT_ROE_AKTIV)
			STAT_ROE_AKTIV = 0xFF;

		if(STAT_ROE_AKTIV_TEXT)
		{
        	tabset("UDS_TAB_ROE_AKTIV");
			index = 0xFF;
			tab_suche_unsigned("NR",index);
			tabget(interpretation,"TEXT");
			STAT_ROE_AKTIV_TEXT = interpretation;
		}
		JOB_STATUS = "OKAY";
		return;
	}
   
   JOB_STATUS = "ERROR_INTERPRETATION";
	return;	
}
// end of : #include "UDS_86_04_STATUS_ROE_REPORT.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_86_05_02_STEUERN_ROE_START.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_ROE_START
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 30.11.2006  an  V0.001 Erstellung (Tobias Kraeker, EI-71, Albrecht Neff, EI-71)
// *******************************************************************
// UDS_86_05_02_STEUERN_ROE_START.B2S @(#)@ V0.001@(#)@
// *******************************************************************




job ( name      :       STEUERN_ROE_START;
      comment   :       Temporaeres Aktivieren;
	  comment   :       der aktiven Fehlermeldung;
      comment   :       UDS   : $86 ResponseOnEvent;
      comment   :               $05 Start;
      comment   :               $02 (EventWindowTime);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{

  // Variablen fuer Kommunikation
  unsigned char request[] = {0x86,0x05,0x02};
  unsigned char expectedResponse[] = {0xC6,0x05,0x00,0x02};
  unsigned char response[];
  unsigned char SA_response;
  unsigned char TA_response;

  //KONSTANTEN
  unsigned char EXPECTED_RESPONSE_LENGTH = 4;
// ---------------- Argumente des Jobs auswerten ---------------------

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;


// ---------------- Interpretation -----------------------------------
	if (_REQUEST)
		_REQUEST = request;

	if (_RESPONSE)
        _RESPONSE = response;

	if(datalen(response) != EXPECTED_RESPONSE_LENGTH)
	{
	        JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";
			return;
	}
	else if(datacmp(expectedResponse,response)!=0)
	{
            JOB_STATUS = "ERROR_INTERPRETATION";
			return;
	}
	else
	{
		JOB_STATUS = "OKAY";
	}
}

// end of : #include "UDS_86_05_02_STEUERN_ROE_START.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_86_40_02_STEUERN_ROE_PERSISTENT_STOP.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_ROE_PERSISTENT_STOP
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 30.11.2006  an  V0.001 Erstellung (Tobias Kraeker, EI-71, Albrecht Neff, EI-71)
// *******************************************************************
// UDS_86_40_02_STEUERN_ROE_PERSISTENT_STOP.B2S @(#)@ V0.001@(#)@
// *******************************************************************




job ( name      :       STEUERN_ROE_PERSISTENT_STOP;
      comment   :       Persistentes Deaktivieren;
      comment   :       der aktiven Fehlermeldung;
      comment   :       an den Diagnosemaster ueber TAS;
      comment   :       UDS   : $86 ResponseOnEvent;
      comment   :               $40 Stop persistent;
      comment   :               $02 (EventWindowTime);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{

  // Variablen fuer Kommunikation
  unsigned char TAS_address = 0xF0;
  unsigned char request_to_TAS[] = {0x31,0x01,0x0f,0x0b,0xFF,0x00,0x03,0x86,0x40,0x02};
  unsigned char expectedResponse[] = {0x71,0x01,0x0f,0x0b,0xFF,0x00,0x04,0xC6,0x40,0x00,0x02};
  unsigned char response[];
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char jobResultNegativeResponse[];
  unsigned char index;

  //KONSTANTEN
  unsigned char EXPECTED_RESPONSE_LENGTH = 11;
  unsigned char NEGATIVE_RESPONSE_LENGTH = 10;

  request_to_TAS[4] = TA;
  expectedResponse[4] = TA;
// ---------------- Argumente des Jobs auswerten ---------------------

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TAS_address, TA_TYPE_PHYSICAL, request_to_TAS, SA_response, TA_response, response, "", 2)) return;


// ---------------- Interpretation -----------------------------------
	if (_REQUEST)
		_REQUEST = request_to_TAS;

	if (_RESPONSE)
        _RESPONSE = response;

    if(datalen(response) == NEGATIVE_RESPONSE_LENGTH)
	{
        if((response[7] = 0x7f) && (response[8] = 0x86))
		{
			tabset("JobResult");
			index = response[9];
			tab_suche_unsigned("SB",index);
			tabget(jobResultNegativeResponse,"STATUS_TEXT");
			JOB_STATUS = jobResultNegativeResponse;
			return;
		}

	}

	if(datalen(response) != EXPECTED_RESPONSE_LENGTH)
	{
	        JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";
			return;
	}
	else if(datacmp(expectedResponse,response)!=0)
	{
            JOB_STATUS = "ERROR_INTERPRETATION";
			return;
	}
	else
	{
		JOB_STATUS = "OKAY";
	}
}

// end of : #include "UDS_86_40_02_STEUERN_ROE_PERSISTENT_STOP.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_86_45_02_STEUERN_ROE_PERSISTENT_START.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERAENDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : STEUERN_ROE_PERSISTENT_START
// -------------------------------------------------------------------
// Verantwortung      : BMW AG, Tobias Kraeker, EI-71
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnosemaster
// -------------------------------------------------------------------
// History:
// 30.11.2006  an  V0.001 Erstellung (Tobias Kraeker, EI-71, Albrecht Neff, EI-71)
// *******************************************************************
// UDS_86_45_02_STEUERN_ROE_PERSISTENT_START.B2S @(#)@ V0.001@(#)@
// *******************************************************************




job ( name      :       STEUERN_ROE_PERSISTENT_START;
      comment   :       Persistentes Aktivieren;
      comment   :       der aktiven Fehlermeldung;
      comment   :       an den Diagnosemaster ueber TAS;
      comment   :       UDS   : $86 ResponseOnEvent;
      comment   :               $45 Start persistent;
      comment   :               $02 (EventWindowTime);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{

  // Variablen fuer Kommunikation
  unsigned char TAS_address = 0xF0;
  unsigned char request_to_TAS[] = {0x31,0x01,0x0f,0x0b,0xFF,0x00,0x03,0x86,0x45,0x02};
  unsigned char expectedResponse[] = {0x71,0x01,0x0f,0x0b,0xFF,0x00,0x04,0xC6,0x45,0x00,0x02};
  unsigned char response[];
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char jobResultNegativeResponse[];
  unsigned char index;

  //KONSTANTEN
  unsigned char EXPECTED_RESPONSE_LENGTH = 11;
  unsigned char NEGATIVE_RESPONSE_LENGTH = 10;

  request_to_TAS[4] = TA;
  expectedResponse[4] = TA;
// ---------------- Argumente des Jobs auswerten ---------------------

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TAS_address, TA_TYPE_PHYSICAL, request_to_TAS, SA_response, TA_response, response, "", 2)) return;


// ---------------- Interpretation -----------------------------------
	if (_REQUEST)
		_REQUEST = request_to_TAS;

	if (_RESPONSE)
        _RESPONSE = response;

	if(datalen(response) == NEGATIVE_RESPONSE_LENGTH)
	{
        if((response[7] = 0x7f) && (response[8] = 0x86))
		{
			tabset("JobResult");
			index = response[9];
			tab_suche_unsigned("SB",index);
			tabget(jobResultNegativeResponse,"STATUS_TEXT");
			JOB_STATUS = jobResultNegativeResponse;
			return;
		}

	}

	if(datalen(response) != EXPECTED_RESPONSE_LENGTH)
	{
	        JOB_STATUS = "ERROR_ECU_INCORRECT_LEN";
			return;
	}
	else if(datacmp(expectedResponse,response)!=0)
	{
            JOB_STATUS = "ERROR_INTERPRETATION";
			return;
	}
	else
	{
		JOB_STATUS = "OKAY";
	}
}

// end of : #include "UDS_86_45_02_STEUERN_ROE_PERSISTENT_START.B2S"

// end of : #include "UDS_JOBS_ROE.B2S"

// Standard Codier-Jobs
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_37_FE_CPS_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : CPS_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8 (SAP 10000786)
// -------------------------------------------------------------------
// History:
// 15.02.2006  gh  V0.001 Erstellung
// 15.03.2007  rd  V0.002 dataclear hinzu
// *******************************************************************
// UDS_22_37_FE_CPS_LESEN.B2S @(#)@ V0.002@(#)@
// *******************************************************************
job ( name      :       CPS_LESEN;
      comment   :       Codierpruefstempel lesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $37FE DataIdentifier Codierpruefstempel;
      comment   :       Modus: Default;

      result    :       CPS;
        type    :       string;
        comment :       Codierpruefstempel 7-stellig;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0x37, 0xFE};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  
  // Variablen fuer Job
  unsigned char cps_temp[];

// ---------------- Kommunikation ------------------------------------
  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;

  if (CPS) {
    dataclear(cps_temp);
    datacopy(cps_temp, response, 3, 7);
    CPS = cps_temp;
  }

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_37_FE_CPS_LESEN.B2S"

// Standard Flash-Jobs
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_F1_86_DIAG_SESSION_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : DIAG_SESSION_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Anforderer         : W 2.4, Richard Kolbeck (fuer LDM)
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8             (SAP 10000786)
// Lastenheft L6 Flash-Programmierung Teil 5 (SAP 10000970)
// -------------------------------------------------------------------
// History:
// 12.03.2007  gh  V0.001 Erstellung
// 26.03.2007  gh  V0.002 Entfernung Argument SG_Adresse
// *******************************************************************
// UDS_22_F1_86_DIAG_SESSION_LESEN.B2S @(#)@ V0.002@(#)@
// *******************************************************************
job ( name      :       DIAG_SESSION_LESEN;
      comment   :       Aktive Diagnose-Session auslesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $F186 ActiveDiagnosticSession;
      comment   :       Modus: Default;

      result    :       DIAG_SESSION_WERT;
        type    :       int;
        comment :       Diagnose-Session (1 Byte);

      result    :       DIAG_SESSION_TEXT;
        type    :       string;
        comment :       Diagnose-Session als Text;

      result    :       DIAG_DETAIL_WERT;
        type    :       int;
        comment :       Details zur Diagnose-Session (1 Byte);

      result    :       DIAG_DETAIL_TEXT;
        type    :       string;
        comment :       Details zur Diagnose-Session als Text;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0xF1, 0x86};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];

  // spezifische Variablen
  unsigned int  diag_session;
  unsigned int  diag_detail;
  unsigned char diag_text[];
  
// ---------------- Kommunikation ------------------------------------

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;


  diag_session = response[3];

  if (DIAG_SESSION_WERT)
    DIAG_SESSION_WERT = diag_session;


  diag_detail  = response[4];

  if (DIAG_DETAIL_WERT)
    DIAG_DETAIL_WERT = diag_detail;


  if (DIAG_SESSION_TEXT) {
    if (diag_session == 0x00)
      diag_text = "ISO SAE reserved";
    else if (diag_session == 0x01)
      diag_text = "Default Session";
    else if (diag_session == 0x02)
      diag_text = "Programming Session";
    else if (diag_session == 0x03)
      diag_text = "Extended Diagnostic Session";
    else if (diag_session == 0x04)
      diag_text = "Savety System Diagnostic Session";
    else if ((diag_session >= 0x05) && (diag_session <= 0x3F))
      diag_text = "ISO SAE reserved";
    else if (diag_session == 0x41)
      diag_text = "Coding Session";
    else if (diag_session == 0x42)
      diag_text = "SWT Session";
    else if ((diag_session >= 0x43) && (diag_session <= 0x5F))
      diag_text = "Vehicle Manufaturer Specific";
    else if ((diag_session >= 0x60) && (diag_session <= 0x7E))
      diag_text = "System Supplier Specific";
    else      
      diag_text = "Fehler: unerlaubter Wert (reserved)";

    DIAG_SESSION_TEXT = diag_text;
  }

  if (DIAG_DETAIL_TEXT) {
    if (diag_session == 0x01) {        // Default Session
      if (diag_detail == 0x00)
        diag_text = "Bootloader";
      else if ((diag_detail >= 0x01) && (diag_detail <= 0x80))
        diag_text = "reservierter Bereich";
      else if (diag_detail == 0x81)
        diag_text = "Applikation: Flash-Mode deaktiviert";
      else if (diag_detail == 0x82)
        diag_text = "Applikation: Flash-Mode aktiviert";
      else
        diag_text = "reservierter Bereich";
    }

    else if (diag_session == 0x02) {   // Programming Session
      if (diag_detail == 0x00)
        diag_text = "reservierter Bereich";
      else if (diag_detail == 0x01)
        diag_text = "verriegelt";
      else if (diag_detail == 0x02)
        diag_text = "entriegelt";
      else if (diag_detail == 0x03)
        diag_text = "Fingerprint geschrieben";
      else if (diag_detail == 0x04)
        diag_text = "Speicher geloescht";
      else if (diag_detail == 0x05)
        diag_text = "Download gestartet";
      else if (diag_detail == 0x06)
        diag_text = "Transfer Data";
      else if (diag_detail == 0x07)
        diag_text = "Download abgeschlossen";
      else if (diag_detail == 0x08)
        diag_text = "Speicher ueberprueft";
      else if (diag_detail == 0x09)
        diag_text = "Programmier-Abhaengigkeiten ueberprueft";
      else if ((diag_detail >= 0x0A) && (diag_detail <= 0x7F))
        diag_text = "reservierter Bereich";
      else
        diag_text = "unerlaubter Wert";
    }

    else if (diag_session == 0x03) {   // Extended Diagnostic Session
      if (diag_detail == 0x00)
        diag_text = "Bootloader";
      else if ((diag_detail >= 0x01) && (diag_detail <= 0x7F))
        diag_text = "reservierter Bereich";
      else if (diag_detail == 0x80)
        diag_text = "Applikation: reservierter Bereich";
      else if (diag_detail == 0x81)
        diag_text = "Applikation: Extended Session gestartet";
      else if (diag_detail == 0x82)
        diag_text = "Applikation: Extended Session DTCOff_1";
      else if (diag_detail == 0x83)
        diag_text = "Applikation: Extended Session NDC disabled";
      else if (diag_detail == 0x84)
        diag_text = "Applikation: Extended Session Flash-Mode aktiviert";
      else if (diag_detail == 0x85)
        diag_text = "Applikation: Extended Session DTCOff_2";
      else if ((diag_detail >= 0x86) && (diag_detail <= 0xFE))
        diag_text = "Applikation: reservierter Bereich";
      else
        diag_text = "Applikation: else application state";
    }

    else
      diag_text = "keine Detail-Information vorhanden";
    
    DIAG_DETAIL_TEXT = diag_text;
  }


  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_F1_86_DIAG_SESSION_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_25_04_FLASH_TP_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : FLASH_TP_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Anforderer         : W 2.4, Richard Kolbeck (fuer LDM)
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8             (SAP 10000786)
// Lastenheft L6 Flash-Programmierung Teil 5 (SAP 10000970)
// -------------------------------------------------------------------
// History:
// 12.03.2007  gh  V0.001 Erstellung
// 26.03.2007  gh  V0.002 Entfernung Argument SG_Adresse
// 28.03.2007  gh  V0.003 mit/ohne Format-Byte
// 04.04.2007  gh  V0.004 Reihenfolge bei 18-Byte-Antwort korrigiert
// *******************************************************************
// UDS_22_25_04_FLASH_TP_LESEN.B2S @(#)@ V0.004@(#)@
// *******************************************************************
job ( name      :       FLASH_TP_LESEN;
      comment   :       Flash Timing Parameter auslesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $2504 FlashTimingParameter;
      comment   :       Modus: Default;

      result    :       FLASH_LOESCHEN;
        type    :       int;
        comment :       EraseMemoryTime (2 Byte);

      result    :       FLASH_TEST;
        type    :       int;
        comment :       CheckMemoryTime (2 Byte);

      result    :       FLASH_BOOT;
        type    :       int;
        comment :       BootloaderInstallationTime (2 Byte);

      result    :       FLASH_AUTHENT;
        type    :       int;
        comment :       AuthenticationTime (2 Byte);

      result    :       FLASH_RESET;
        type    :       int;
        comment :       ResetTime (2 Byte);

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0x25, 0x04};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  
  // spezifische Variablen
  unsigned int  format_byte;

// ---------------- Kommunikation ------------------------------------

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;


  if (datalen(response) == 13)  // ohne Format-Byte
     format_byte = 0;
  else if (datalen(response) == 18)
     format_byte = 1;
  else {
     JOB_STATUS = "ERROR_INTERPRETATION";
     return;
  }

// Reihenfolge nach LH Flash-Programmierung Teil 5 (SAP 10000970) V07:
// Antwort mit 13 Bytes:
// 1. FLASH_LOESCHEN
// 2. FLASH_TEST
// 3. FLASH_BOOT
// 4. FLASH_AUTHENT
// 5. FLASH_RESET
//
// Antwort mit 18 Bytes:
// 1. FLASH_LOESCHEN
// 2. FLASH_TEST
// 3. FLASH_AUTHENT
// 4. FLASH_RESET
// 5. FLASH_BOOT

  if (FLASH_LOESCHEN) {
    if (format_byte)
      FLASH_LOESCHEN = (response[4]  << 8) + response[5];     // 1.
    else
      FLASH_LOESCHEN = (response[3]  << 8) + response[4];     // 1.
  }

  if (FLASH_TEST) {
    if (format_byte)
      FLASH_TEST     = (response[7]  << 8) + response[8];     // 2.
    else
      FLASH_TEST     = (response[5]  << 8) + response[6];     // 2.
  }

  if (FLASH_BOOT) {
    if (format_byte)
      FLASH_BOOT     = (response[16]  << 8) + response[17];   // 5.
    else
      FLASH_BOOT     = (response[7]  << 8) + response[8];     // 3.
  }

  if (FLASH_AUTHENT) {
    if (format_byte)
      FLASH_AUTHENT  = (response[10]  << 8) + response[11];   // 3.
    else
      FLASH_AUTHENT  = (response[9]  << 8) + response[10];    // 4.
  }

  if (FLASH_RESET) {
    if (format_byte)
      FLASH_RESET    = (response[13] << 8) + response[14];    // 4.
    else
      FLASH_RESET    = (response[11] << 8) + response[12];    // 5.
  }

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_25_04_FLASH_TP_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_25_02_PROG_ZAEHLER_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : PROG_ZAEHLER_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Anforderer         : W 2.4, Richard Kolbeck (fuer LDM)
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8             (SAP 10000786)
// Lastenheft L6 Flash-Programmierung Teil 5 (SAP 10000970)
// -------------------------------------------------------------------
// History:
// 12.03.2007  gh  V0.001 Erstellung
// 26.03.2007  gh  V0.002 Entfernung Argument SG_Adresse
// 26.03.2007  gh  V0.002 2 zusätzliche Results bzgl. PROG_ZAEHLER_STATUS
// 26.03.2007  gh  V0.002 Korrektur Resultzuweisung PROG_ZAEHLER
// *******************************************************************
// UDS_22_25_02_PROG_ZAEHLER_LESEN.B2S @(#)@ V0.002@(#)@
// *******************************************************************
job ( name      :       PROG_ZAEHLER_LESEN;
      comment   :       Programmierzaehler lesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $2502 ProgrammingCounter;
      comment   :       Modus: Default;

      result    :       PROG_ZAEHLER_STATUS_WERT;
        type    :       int;
        comment :       Status, wie oft das SG programmierbar ist;

      result    :       PROG_ZAEHLER_STATUS_TEXT;
        type    :       string;
        comment :       Status, wie oft das SG programmierbar ist;

      result    :       PROG_ZAEHLER;
        type    :       int;
        comment :       Programmierzaehler;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0x25, 0x02};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  
  // spezifische Variablen
  unsigned int  prog_zaehler_stat;
  unsigned char prog_zaehler_stat_text[];

// ---------------- Kommunikation ------------------------------------

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;


  prog_zaehler_stat  = response[4];

  if (PROG_ZAEHLER_STATUS_WERT)
    PROG_ZAEHLER_STATUS_WERT = prog_zaehler_stat;

  if (PROG_ZAEHLER_STATUS_TEXT) {
    if (prog_zaehler_stat == 0x00)
      prog_zaehler_stat_text = "Status grün: SG mehrfach programmierbar";
    else if (prog_zaehler_stat == 0x01)
      prog_zaehler_stat_text = "Status gelb: SG mindestens einmal programmierbar";
    else if (prog_zaehler_stat == 0x02)
      prog_zaehler_stat_text = "Status rot: SG nicht mehr programmierbar";
    else      
      prog_zaehler_stat_text = "Fehler: unerlaubter Wert (reserved)";

    PROG_ZAEHLER_STATUS_TEXT = prog_zaehler_stat_text;
  }

  if (PROG_ZAEHLER)
    PROG_ZAEHLER = (response[5] << 8) + response[6];


  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_25_02_PROG_ZAEHLER_LESEN.B2S"
// start of : #include "X:\REFERENZ\EDIABAS\INCLUDE\UDS_22_25_03_PROG_MAX_LESEN.B2S"
// *******************************************************************
//
// ! ! ! ! ! DIESE DATEI DARF  N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
//
// -------------------------------------------------------------------
// Jobname            : PROG_MAX_LESEN
// -------------------------------------------------------------------
// Globale Tabelle    : JobResult
// -------------------------------------------------------------------
// Anforderer         : W 2.4, Richard Kolbeck (fuer LDM)
// -------------------------------------------------------------------
// Gültig:
// Lastenheft Diagnose Ausgabe 8             (SAP 10000786)
// Lastenheft L6 Flash-Programmierung Teil 5 (SAP 10000970)
// -------------------------------------------------------------------
// History:
// 12.03.2007  gh  V0.001 Erstellung
// 26.03.2007  gh  V0.002 Entfernung Argument SG_Adresse
// 11.10.2007  gh  V0.003 Result PROG_MAX: int => long
// *******************************************************************
// UDS_22_25_03_PROG_MAX_LESEN.B2S @(#)@ V0.003@(#)@
// *******************************************************************
job ( name      :       PROG_MAX_LESEN;
      comment   :       Anzahl der maximal möglichen Programmiervorgänge auslesen;
      comment   :       UDS  : $22   ReadDataByIdentifier;
      comment   :       UDS  : $2503 ProgrammingCounter;
      comment   :       Modus: Default;

      result    :       PROG_MAX;
        type    :       long;
        comment :       maximal mögliche Programmiervorgänge;
        comment :       Sonderfall 0xFFFF: Anzahl der Programmiervorgänge unbegrenzt;

      result    :       JOB_STATUS;
        type    :       string;
        comment :       OKAY, wenn fehlerfrei;
        comment :       table JobResult STATUS_TEXT;

      result    :       _REQUEST;
        type    :       data;
        comment :       Hex-Auftrag an SG;

      result    :       _RESPONSE;
        type    :       data;
        comment :       Hex-Antwort von SG;
    )
{
  // Variablen fuer Kommunikation
  unsigned char request[] = {0x22, 0x25, 0x03};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char response[];
  
// ---------------- Kommunikation ------------------------------------

  if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------

  if (_REQUEST)              
    _REQUEST = request;

  if (_RESPONSE)
    _RESPONSE = response;

  if (PROG_MAX)
    PROG_MAX = (response[3] << 8) + response[4];

  JOB_STATUS = "OKAY";
}

// end of : #include "UDS_22_25_03_PROG_MAX_LESEN.B2S"


// *******************************************************************
// automatisch generierte Jobs
// *******************************************************************


// *******************************************************************
// SG-spezifische Jobs
// *******************************************************************

// start of : #include "_STATUS_BUILDID_JOBS.b2s"
// start of : #include "_STATUS_BUILD_ID_JOBS.b2s"
/*********************** _STATUS_BUILD_ID_JOBS.b2s ******************************
// ! ! ! ! !  DIESE DATEI DARF N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
// Ersteller: Martin Flach MicroNova AG i.A. BMW EA-412 +49 89 382 28852
*/
//*******************************************************************
// Jobname            : _STATUS_BUILD_ID
//-------------------------------------------------------------------
// Globale Variable   : tbd
//-------------------------------------------------------------------
// Globale Tabelle   : tbd
//-------------------------------------------------------------------
// Gueltig:
//-------------------------------------------------------------------
//*******************************************************************
job (
    name      : _STATUS_BUILD_ID;
    comment   : Gibt die Software-Id zurück (EntwicklerJob);

    result    : STAT_HWEL_MC0_TEXT;
    type      : string;
    comment   : HWEL-Nr vom mc0;

    result    : STAT_BTLD_MC0_TEXT;
    type      : string;
    comment   : BTLD-Nr vom mc0;

    result    : STAT_SWEL1_MC0_TEXT;
    type      : string;
    comment   : SoftwareNr vom mc0;

    result    : STAT_SWEL2_MC0_TEXT;
    type      : string;
    comment   : DatenNr vom mc0;

    result    : STAT_BUILDID_MC0_TEXT;
    type      : string;
    comment   : BuildId vom mc0;

    result    : STAT_BUILDDATE_MC0_TEXT;
    type      : string;
    comment   : Datum vom mc0-Softwarebuild;

    result    : STAT_BUILDPC_MC0_TEXT;
    type      : string;
    comment   : Name des Rechners auf dem der mc0-Build durchgeführt wurde;

    result    : STAT_BUILDUSER_MC0_TEXT;
    type      : string;
    comment   : Name des Erstellers des mc0-Builds;

    result    : STAT_BUILDVERSION_MC0_TEXT;
    type      : string;
    comment   : Interne Build-Version vom mc0;
    


    
    result    : STAT_HWEL_MC2_TEXT;
    type      : string;
    comment   : HWEL-Nr vom mc2;

    result    : STAT_BTLD_MC2_TEXT;
    type      : string;
    comment   : BTLD-Nr vom mc2;

    result    : STAT_SWEL1_MC2_TEXT;
    type      : string;
    comment   : SoftwareNr vom mc2;

    result    : STAT_SWEL2_MC2_TEXT;
    type      : string;
    comment   : DatenNr vom mc2;

    result    : STAT_BUILDID_MC2_TEXT;
    type      : string;
    comment   : BuildId vom mc2;

    result    : STAT_BUILDDATE_MC2_TEXT;
    type      : string;
    comment   : Datum vom mc2-Softwarebuild;

    result    : STAT_BUILDPC_MC2_TEXT;
    type      : string;
    comment   : Name des Rechners auf dem der mc2-Build durchgeführt wurde;

    result    : STAT_BUILDUSER_MC2_TEXT;
    type      : string;
    comment   : Name des Erstellers des mc2-Builds;

    result    : STAT_BUILDVERSION_MC2_TEXT;
    type      : string;
    comment   : Interne Build-Version vom mc2;
    
    
    result    : JOB_STATUS;
    type      : string;
    comment   : "OKAY", wenn fehlerfrei;

    result    : _REQUEST;
    type      : data;
    comment   : Hex-Auftrag an SG;

    result    : _RESPONSE;
    type      : data;
    comment   : Hex-Antwort von SG;
)

{
//      ---------------- Variablendeklaration ------------------------------------
    unsigned char SA_response;
    unsigned char TA_response;
    unsigned char request[];
    unsigned char response[];
    char temp0[];
    char temp[];
    unsigned int tmp_uint;
    unsigned int pos;
    unsigned long ul_wert0;

//      ---------   Haupt-Telegramm -------------
    request  = {0x22,0x40,0x0B};

//      ---------------- Kommunikation ------------------------------------
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;
    if (_REQUEST)
        _REQUEST = request;
    if (_RESPONSE)
        _RESPONSE = response;

//***************************************************** MC0        
        
    //+++++++++++++++++++++++++++++++ HWEL mc0
    // hw-klasse
    tmp_uint=0;
    pos = 3;
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_HWEL_MC0_TEXT)
    {
        STAT_HWEL_MC0_TEXT = temp0;
    }



    //+++++++++++++++++++++++++++++++++++++++++ BTLD mc0
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;
    
    if (STAT_BTLD_MC0_TEXT)
    {
        STAT_BTLD_MC0_TEXT = temp0;
    }

    //++++++++++++++++++++++++++++++++++++++++++ SWLE1 mc0
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_SWEL1_MC0_TEXT)
    {
        STAT_SWEL1_MC0_TEXT = temp0;
    }

    //++++++++++++++++++++++++++++++++++++++++++++++++ SWLE2 mc0
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_SWEL2_MC0_TEXT)
    {
        STAT_SWEL2_MC0_TEXT = temp0;
    }
    
    
    if (STAT_BUILDVERSION_MC0_TEXT)
    {
        ul_wert0 = response[pos];
        pos = pos+1;
        ul_wert0 = ul_wert0<<8;
        ul_wert0 |= response[pos];
        pos = pos+1;
        uitoad(temp0, ul_wert0);

        STAT_BUILDVERSION_MC0_TEXT = temp0;
    }




    
    //BuildId mc0
    tmp_uint=0;
    while(tmp_uint<20)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDID_MC0_TEXT)
    {
        STAT_BUILDID_MC0_TEXT = temp0;
    }
    pos = pos+20;
    
    //BuildDate mc0
    tmp_uint=0;
    while(tmp_uint<11)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDDATE_MC0_TEXT)
    {
        STAT_BUILDDATE_MC0_TEXT = temp0;
    }
    pos = pos+11;

    //BuildPC mc0
    tmp_uint=0;
    while(tmp_uint<11)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDPC_MC0_TEXT)
    {
        STAT_BUILDPC_MC0_TEXT = temp0;
    }
    pos = pos+11;

    //BuildUser mc0
    tmp_uint=0;
    while(tmp_uint<9)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDUSER_MC0_TEXT)
    {
        STAT_BUILDUSER_MC0_TEXT = temp0;
    }
    pos = pos+9;

    
    

//******************************************************************** MC2




    //+++++++++++++++++++++++++++++++ HWEL mc2
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_HWEL_MC2_TEXT)
    {
        STAT_HWEL_MC2_TEXT = temp0;
    }



    //+++++++++++++++++++++++++++++++++++++++++ BTLD mc2
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;
    
    if (STAT_BTLD_MC2_TEXT)
    {
        STAT_BTLD_MC2_TEXT = temp0;
    }

    //++++++++++++++++++++++++++++++++++++++++++ SWLE1 mc2
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_SWEL1_MC2_TEXT)
    {
        STAT_SWEL1_MC2_TEXT = temp0;
    }

    //++++++++++++++++++++++++++++++++++++++++++++++++ SWLE2 mc2
    // hw-klasse
    tmp_uint=0;
    dataclear(temp0);
    while(tmp_uint<4)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    strcat(temp0,".");
    pos = pos+4;
    
    //sgbm-id
    dataclear(temp);
    hex2ascii(temp, response, pos, 4); // Abholen der Daten 
    strcat(temp0,temp);
    strcat(temp0,".");
    pos = pos+4;
    
    //Hauptversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Nebenversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    strcat(temp0,".");    
    pos = pos+1;
    
    //Patchversionsnummer
    dataclear(temp);
    itoad(temp, response[pos]);
    if (strlen(temp) == 1)
      strinsert(temp, "00", 0); 
    if (strlen(temp) == 2)
      strinsert(temp, "0", 0); 
    strcat(temp0,temp);
    pos = pos+1;

    if (STAT_SWEL2_MC2_TEXT)
    {
        STAT_SWEL2_MC2_TEXT = temp0;
    }
    
    
    if (STAT_BUILDVERSION_MC2_TEXT)
    {
        ul_wert0 = response[pos];
        pos = pos+1;
        ul_wert0 = ul_wert0<<8;
        ul_wert0 |= response[pos];
        pos = pos+1;
        uitoad(temp0, ul_wert0);

        STAT_BUILDVERSION_MC2_TEXT = temp0;
    }




    
    //BuildId mc2
    tmp_uint=0;
    while(tmp_uint<20)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDID_MC2_TEXT)
    {
        STAT_BUILDID_MC2_TEXT = temp0;
    }
    pos = pos+20;
    
    //BuildDate mc2
    tmp_uint=0;
    while(tmp_uint<11)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDDATE_MC2_TEXT)
    {
        STAT_BUILDDATE_MC2_TEXT = temp0;
    }
    pos = pos+11;

    //BuildPC mc2
    tmp_uint=0;
    while(tmp_uint<11)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDPC_MC2_TEXT)
    {
        STAT_BUILDPC_MC2_TEXT = temp0;
    }
    pos = pos+11;

    //BuildUser mc2
    tmp_uint=0;
    while(tmp_uint<9)
    {
         temp0[tmp_uint] = response[pos+tmp_uint];
         tmp_uint = tmp_uint+1;
    }
    if (STAT_BUILDUSER_MC2_TEXT)
    {
        STAT_BUILDUSER_MC2_TEXT = temp0;
    }
    pos = pos+9;

    
    
    JOB_STATUS = "OKAY";
}



// end of : #include "_STATUS_BUILD_ID_JOBS.b2s"

// end of : #include "_STATUS_BUILDID_JOBS.b2s"

// start of : #include "STATUS_EWS.b2s"
// -------------------------------------------------------------------
// Jobname            : STATUS_EWS
// -------------------------------------------------------------------
// Globale Tabelle    : StatClientAuthTxt
//                      StatFreeSkTxt
//                      StatEwsVerTxt
// -------------------------------------------------------------------
// Gültig:
// Lastenheft EWS4_Funktionsbeschreibung (SAP 10001217)
// -------------------------------------------------------------------
// History:
// 09.07.2006 Schl V0.01 Erstellung fuer UDS
// 11.02.2007 Schl V0.02 Argument hinzu, das SG-Adresse selektiert
// 02.05.2007 Schl V0.03 STAT_VERSION für CASCADE sichtbar gemacht
// 24.03.2008 Schl V1.01 STAT_DH_ACTIVE und STAT_E_LABEL_ACTIVE hinzu
//                       EME hinzu
// 01.07.2008 Schl V1.02 Text Zündung, Einspritzung, Motorlauf entfernt
//                       "direkt schreiben" in "schreiben" geändert
// *******************************************************************
// UDS_22_C0_00_STATUS_EWS.B2S @(#)@ V0.001 @(#)@
// *******************************************************************
job ( name      : STATUS_EWS;
      comment   : Zurücklesen verschiedener interner Stati für EWS;
      comment   : UDS   : $22   ReadDataByIdentifier;
      comment   : UDS   : $C000 Sub-Parameter;

      argument  : DIAGSG;
        type    : string;
        defrslt : ;
        comment : Diagnose Steuergerät zulässig DME, DME2, EGS, EME;
        comment : ohne Eintrag wird Original-Diagnoseadresse verwendet;
        comment : Argument kann in endgültiger SGBD entfernt werden;

      result    : STAT_EWS3_CAPABLE;
        type    : int;
        comment : 0 Das SG beherrscht kein EWS3;
        comment : 1 Das SG beherrscht EWS3;

      result    : STAT_EWS4_CAPABLE;
        type    : int;
        comment : 0 Das SG beherrscht kein EWS4;
        comment : 1 Das SG beherrscht EWS4;

      result    : STAT_EWS3_ACTIVE;
        type    : int;
        comment : 0 EWS3 ist nicht (mehr) aktiv;
        comment : 1 EWS3 ist aktiv (oder lässt sich aktivieren);

      result    : STAT_EWS4_ACTIVE;
        type    : int;
        comment : 0 EWS4 ist nicht aktiv;
        comment : 1 EWS4 ist aktiv;

      result    : STAT_EWS4_SERVER_SK_LOCKED;
        type    : int;
        comment : 0 SecretKey server lässt sich noch schreiben;
        comment : 1 SecretKey server lässt sich nicht mehr schreiben/lesen;

      result    : STAT_EWS4_CLIENT_SK_LOCKED;
        type    : int;
        comment : 0 SecretKey client lässt sich noch schreiben;
        comment : 1 SecretKey client lässt sich nicht mehr schreiben/lesen;

      result    : STAT_CLIENT_AUTHENTICATED;
        type    : int;
        comment : 0 Freigabe (noch) nicht erteilt (noch nicht versucht oder Kommunikation gestört);
        comment : 1 Freigabe erteilt (Challenge-Response erfolgreich);
        comment : 2 Freigabe abgelehnt (Challenge-Response fehlgeschlagen, falsche Response, Kommunikation i.O.);
        comment : 3 nicht definiert;

      result    : STAT_CLIENT_AUTHENTICATED_TXT;
        type    : string;
        comment : Text zu Status Wert;
  
      result    : STAT_DH_ACTIVE;
        type    : int;
        defrslt : ;
        comment : 0 Diffie-Hellman-Abgleich nicht aktiv;
        comment : 1 Diffie-Hellman-Abgleich aktiv;

      result    : STAT_E_LABEL_ACTIVE;
        type    : int;
        defrslt : ;
        comment : 0 E-Label ist nicht aktiv;
        comment : 1 E-Label ist aktiv;
		
      result    : STAT_FREE_SK0;
        type    : int;
        comment : 0..0xFD Freie Flashablagen;
        comment : 0xFE    Freie Flashablage nicht begrenzt;
        comment : 0xFF    Fehlerkennzeichnung;

      result    : _STAT_FREE_SK0_TXT;
        type    : string;
        comment : Freie Plaetze;
  
      result    : STAT_FREE_SK1;
        type    : int;
        comment : 0..0xFD Freie Flashablagen;
        comment : 0xFE    Freie Flashablage nicht begrenzt;
        comment : 0xFF    Fehlerkennzeichnung;

      result    : _STAT_FREE_SK1_TXT;
        type    : string;
        comment : Freie Plaetze;
  
      result    : STAT_VERSION;
        type    : int;
        comment : 0x01 Direktschreiben des SecretKey;
        comment : 0x02 Direktschreiben des SecretKey und DH-Abgleich;

      result    : _STAT_VERSION_TXT;
        type    : string;
        comment : Version;

      result    : JOB_STATUS;
        type    : string;
        comment : "OKAY", wenn fehlerfrei;

	  result    : _REQUEST;
        type    : data;
        comment : Hex-Auftrag an SG;
  
      result    : _RESPONSE;
        type    : data;
        comment : Hex-Antwort von SG;
    )
{
  unsigned char request[] = {0x22,0xC0,0x00};
  unsigned char SA_response;
  unsigned char TA_response;
  unsigned char TA_copy;
  unsigned char response[];

  unsigned char stmp[];
           int  tmp;
  unsigned char datenbytes_local[];
		   
		   
// ---------------- Argumente des Jobs auswerten ---------------------
	TA_copy = TA;
	
	if (exist(DIAGSG))
	{
		datenbytes_local = DIAGSG;
		if (!datacmp(datenbytes_local, "DME"))
		{
			TA_copy = 0x12;
		}
		else if (!datacmp(datenbytes_local, "DME2"))
		{
			TA_copy = 0x13;
		}
		else if (!datacmp(datenbytes_local, "EGS"))
		{
			TA_copy = 0x18;
		}
		else if (!datacmp(datenbytes_local, "EME"))
		{
			TA_copy = 0x3A;
		}
		else
		{
			JOB_STATUS = "ERROR_DIAGSG";
			return;
		}
	}

// ---------------- Kommunikation ------------------------------------
	if (!send_and_receive_uds(SA, TA_copy, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;

// ---------------- Interpretation -----------------------------------
	if (STAT_EWS3_CAPABLE)
	{
		STAT_EWS3_CAPABLE = 0;
	}

	if (STAT_EWS4_CAPABLE)
	{
		STAT_EWS4_CAPABLE = 1;
	}

	if (STAT_EWS3_ACTIVE)
	{
		STAT_EWS3_ACTIVE  = 0;
	}

	if (STAT_EWS4_ACTIVE)
	{
		STAT_EWS4_ACTIVE  = 1;
	}

	if (STAT_EWS4_SERVER_SK_LOCKED)
	{
		STAT_EWS4_SERVER_SK_LOCKED = (response[3+0]>>7)&1;
	}

	if (STAT_EWS4_CLIENT_SK_LOCKED)
	{
		STAT_EWS4_CLIENT_SK_LOCKED = (response[3+0]>>7)&1;
	}

	if (STAT_CLIENT_AUTHENTICATED)
	{
		STAT_CLIENT_AUTHENTICATED = response[3+0]&3;
	}

	if (STAT_CLIENT_AUTHENTICATED_TXT)
	{
		tmp = response[3+0]&3;
		tabset("StatClientAuthTxt");
		tab_suche_index("SB", tmp);
		tabget(stmp, "TEXT");
		STAT_CLIENT_AUTHENTICATED_TXT = stmp;
	}

	if (STAT_DH_ACTIVE)
	{
		STAT_DH_ACTIVE = (response[3+1]>>0)&1;
	}

	if (STAT_E_LABEL_ACTIVE)
	{
		STAT_E_LABEL_ACTIVE = (response[3+1]>>1)&1;
	}

	if (STAT_FREE_SK0)
	{
		STAT_FREE_SK0 = response[3+8];
	}

	if (_STAT_FREE_SK0_TXT)
	{
		tmp = response[3+8];
		tabset("StatFreeSkTxt");
		tab_suche_index("SB", tmp);
		tabget(stmp, "TEXT");
		_STAT_FREE_SK0_TXT = stmp;
	}

	if (STAT_FREE_SK1)
	{
		STAT_FREE_SK1 = response[3+9];
	}

	if (_STAT_FREE_SK1_TXT)
	{
		tmp = response[3+9];
		tabset("StatFreeSkTxt");
		tab_suche_index("SB", tmp);
		tabget(stmp, "TEXT");
		_STAT_FREE_SK1_TXT = stmp;
	}

	if (STAT_VERSION)
	{
		STAT_VERSION = response[3+15];
	}

	if (_STAT_VERSION_TXT)
	{
		tmp = response[3+15];
		tabset("StatEwsVerTxt");
		tab_suche_index("SB", tmp);
		tabget(stmp, "TEXT");
		_STAT_VERSION_TXT = stmp;
	}

	if (_REQUEST)              
		_REQUEST = request;

	if (_RESPONSE)
		_RESPONSE = response;

	JOB_STATUS = "OKAY";

}


// end of : #include "STATUS_EWS.b2s"

// start of : #include "STEUERN_MONTAGEMODUS_JOBS.b2s"
/*********************** STEUERN_MONTAGEMODUS.b2s ******************************
// ! ! ! ! !  DIESE DATEI DARF N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
// Ersteller: Berger Carsten P&Z EA-410 089-382-37279
// Datum der Erstellung: 14.04.10 11:33
*/
//******************************************************************* 
// Jobname            : STEUERN_MONTAGEMODUS 
//------------------------------------------------------------------- 
// Globale Variable   : tbd 
//------------------------------------------------------------------- 
// Globale Tabelle   : tbd 
//------------------------------------------------------------------- 
// Gueltig: 
//------------------------------------------------------------------- 
//******************************************************************* 

job (
  name : STEUERN_MONTAGEMODUS;
  comment: 0x3101F043 STEUERN_MONTAGEMODUS;
  comment  : Ansteuern Montage-Modus. ;
  result  : JOB_STATUS;
  type : string; defrslt : ;
  comment : "OKAY", wenn fehlerfrei;
  result : _REQUEST;
  type : data; defrslt : ;
  comment : Hex-Auftrag an SG;
  result : _RESPONSE;
  type : data; defrslt : ;
  comment : Hex-Antwort von SG;
)
{
    unsigned char SA_response;
    unsigned char TA_response;
    unsigned char request[];
    unsigned char response[];
// ---------   Haupt-Telegramm -------------
    request  = {0x31,0x01,0xf0,0x43};
// ------ BEGINN Argumente -------------------------------------------
// ------ ENDE Argumente ---------------------------------------------
// ---------------- Kommunikation ------------------------------------
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;
    if (_REQUEST) _REQUEST = request;
    if (_RESPONSE) _RESPONSE = response;
		// ------ BEGINN Results ---------------------------------------------
// ------ ENDE Results -----------------------------------------------
    JOB_STATUS = "OKAY";
}

// end of : #include "STEUERN_MONTAGEMODUS_JOBS.b2s"

// start of : #include "STEUERN_ENDE_MONTAGEMODUS_JOBS.b2s"
/*********************** STEUERN_ENDE_MONTAGEMODUS.b2s ******************************
// ! ! ! ! !  DIESE DATEI DARF N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
// Ersteller: Berger Carsten P&Z EA-410 089-382-37279
// Datum der Erstellung: 14.04.10 11:33
*/
//******************************************************************* 
// Jobname            : STEUERN_ENDE_MONTAGEMODUS 
//------------------------------------------------------------------- 
// Globale Variable   : tbd 
//------------------------------------------------------------------- 
// Globale Tabelle   : tbd 
//------------------------------------------------------------------- 
// Gueltig: 
//------------------------------------------------------------------- 
//******************************************************************* 
job (
  name : STEUERN_ENDE_MONTAGEMODUS;
  comment: 0x3102F043 STEUERN_ENDE_MONTAGEMODUS;
  comment  : Ende Montage-Modus;
  result  : JOB_STATUS;
  type : string; defrslt : ;
  comment : "OKAY", wenn fehlerfrei;
  result : _REQUEST;
  type : data; defrslt : ;
  comment : Hex-Auftrag an SG;
  result : _RESPONSE;
  type : data; defrslt : ;
  comment : Hex-Antwort von SG;
)
{
    unsigned char SA_response;
    unsigned char TA_response;
    unsigned char request[];
    unsigned char response[];
// ---------   Haupt-Telegramm -------------
    request  = {0x31,0x02,0xf0,0x43};
// ------ BEGINN Argumente -------------------------------------------
// ------ ENDE Argumente ---------------------------------------------
// ---------------- Kommunikation ------------------------------------
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;
    if (_REQUEST) _REQUEST = request;
    if (_RESPONSE) _RESPONSE = response;
		// ------ BEGINN Results ---------------------------------------------
// ------ ENDE Results -----------------------------------------------
    JOB_STATUS = "OKAY";
}

// end of : #include "STEUERN_ENDE_MONTAGEMODUS_JOBS.b2s"

// start of : #include "STATUS_MONTAGEMODUS_JOBS.b2s"
/*********************** STATUS_MONTAGEMODUS.b2s ******************************
// ! ! ! ! !  DIESE DATEI DARF N I C H T  VERÄNDERT WERDEN  ! ! ! ! !
// Ersteller: Berger Carsten P&Z EA-410 089-382-37279
// Datum der Erstellung: 14.04.10 11:33
*/
//******************************************************************* 
// Jobname            : STATUS_MONTAGEMODUS 
//------------------------------------------------------------------- 
// Globale Variable   : tbd 
//------------------------------------------------------------------- 
// Globale Tabelle   : tbd 
//------------------------------------------------------------------- 
// Gueltig: 
//------------------------------------------------------------------- 
//******************************************************************* 

job (
  name : STATUS_MONTAGEMODUS;
  comment: 0x3103F043 STATUS_MONTAGEMODUS;
  comment  : Auslesen Montage-Modus;
  result   : STAT_FS_MONTAGEMODUS_TEXT;
  type     : string; defrslt  : ;
  comment  : FUNKTIONSSTATUS MONTAGEMODUS;
  comment  : 1BYTE FUNKTIONSSTATUS  ;
  result   : STAT_FS_MONTAGEMODUS_WERT;
  type     : int; defrslt  : ;
  comment  : FUNKTIONSSTATUS MONTAGEMODUS;
  comment  : 1BYTE FUNKTIONSSTATUS  ;
  result   : STAT_ST_MONTAGE_MODUS_TEXT;
  type     : string; defrslt  : ;
  comment  : Status Montage-Modus aktiv/inaktiv;
  comment  : 1BYTE STATUS MONTAGE_MODUS  ;
  result   : STAT_ST_MONTAGE_MODUS_WERT;
  type     : int; defrslt  : ;
  comment  : Status Montage-Modus aktiv/inaktiv;
  comment  : 1BYTE STATUS MONTAGE_MODUS  ;
  result  : JOB_STATUS;
  type : string; defrslt : ;
  comment : "OKAY", wenn fehlerfrei;
  result : _REQUEST;
  type : data; defrslt : ;
  comment : Hex-Auftrag an SG;
  result : _RESPONSE;
  type : data; defrslt : ;
  comment : Hex-Antwort von SG;
)
{
    unsigned char SA_response;
    unsigned char TA_response;
    unsigned char request[];
    unsigned char response[];
	unsigned char text[];
    unsigned long wert_ulong;
// ---------   Haupt-Telegramm -------------
    request  = {0x31,0x03,0xf0,0x43};
// ------ BEGINN Argumente -------------------------------------------
// ------ ENDE Argumente ---------------------------------------------
// ---------------- Kommunikation ------------------------------------
    if (!send_and_receive_uds(SA, TA, TA_TYPE_PHYSICAL, request, SA_response, TA_response, response, "", 2)) return;
    if (_REQUEST) _REQUEST = request;
    if (_RESPONSE) _RESPONSE = response;
		// ------ BEGINN Results ---------------------------------------------
            if (STAT_FS_MONTAGEMODUS_TEXT || STAT_FS_MONTAGEMODUS_WERT) {
                wert_ulong = response[4];
                STAT_FS_MONTAGEMODUS_WERT = wert_ulong;
                tabset("TAB_AE_FUNKSTAT_MONTAGEMODUS");
                tab_suche_unsigned("WERT",wert_ulong);
                tabget(text,"TEXT");
                STAT_FS_MONTAGEMODUS_TEXT= text;
            }                    
            if (STAT_ST_MONTAGE_MODUS_TEXT || STAT_ST_MONTAGE_MODUS_WERT) {
                wert_ulong = response[5];
                STAT_ST_MONTAGE_MODUS_WERT = wert_ulong;
                tabset("TAB_AE_STAT_MONTAGEMODUS");
                tab_suche_unsigned("WERT",wert_ulong);
                tabget(text,"TEXT");
                STAT_ST_MONTAGE_MODUS_TEXT= text;
            }                    
// ------ ENDE Results -----------------------------------------------
    JOB_STATUS = "OKAY";
}

// end of : #include "STATUS_MONTAGEMODUS_JOBS.b2s"


// --- eof ---
