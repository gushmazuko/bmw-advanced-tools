;**************************************************************
;
;
; @(#)BEST2 BMW LIB Version 2.25 (2007) BMW AG@(#)
;
;
; each Library entry has the following Format
;  functionname: parmater declaration
;       opcode [[<nr of parameter>|CONSTANT ] [,<nr of parameter>|CONSTANT ]]]
;  ;end
;
; each library function may use: L0,L1, F0,F1 and S1
; each library function must push a long value on the stack
; each non string Parameter is a long value
;
; parameter description:
;  ##
;  |^
;  ||
;  |+--> access:
;  |       W = write access (variable)
;  |       R = read access (variable)
;  |       X = read access (constant value or variable)
;  |       E = result access (constant value or variable)
;  |
;  +---> data type:
;         V  = char, int or long
;         A  = string
;         F  = real
;
;***************************************************************

;---------------------------------------------------------------
rtoi_round: FR
            move        <1>,F0
            a2flt       F1,"4294967295.5"
            fcomp       F0,F1            ; F0 >= ?
            jge         %4               ; ja -> goto %4
            a2flt       F1,"-2147483648.5"
            fcomp       F0,F1            ; F0 <= ?
            jle         %4               ; ja -> goto %4
            fix2flt     F1,#0.l
            fcomp       F0,F1            ; F0 >= 0
            jge         %1               ; ja -> goto %1
            a2flt       F1,"0.5"
            fsub        F0,F1            ; realsubb(F0,F1)
            jump        %2

%1:         a2flt       F1,"0.5"         ; ator(F1,"0.5")
            fadd        F0,F1            ; realadd(F0,F1)
            a2flt       F1,"2147483648"
            fcomp       F0,F1            ; F0 < ?
            jle         %2               ; ja -> goto %2
            a2flt       F1,"4294967297"
            fsub        F0,F1            ; realsubb(F0,F1)

%2:         fix2flt     F1,#$7FFFFFFF.l  ; itor(F1,2147483647)
            fcomp       F0,F1            ; F0 < 2147483647 ?
            jl          %3               ; ja -> goto %3
            fix2flt     F0,#$7FFFFFFF.l

%3:         fix2flt     F1,#$80000000.l  ; itor(F1,-2147483648)
            fcomp       F0,F1            ; F0 > -2147483648 ?
            jg          %4               ; ja -> goto %4
            fix2flt     F0,#$80000000.l

%4:         flt2fix     L0,F0
            push        L0
;end

;---------------------------------------------------------------
aitor: FW AR
            move        S1,<2>
            comp        S1[#0],#'0'      ; beginnt mit '0' ?
            jnz         %3               ; nein -> goto %3
            comp        S1[#1],#'x'      ; gefolgt von 'x' ?
            jz          %1               ; ja -> goto %1
            comp        S1[#1],#'X'      ; gefolgt von 'X' ?
            jz          %1               ; ja -> goto %1
            jump        %3

%1:         a2fix       L0,S1            ; L0=atoi(S1)
            fix2flt     F0,L0            ; itor(F0,L0)
            fix2flt     F1,#0            ; itor(F1,0)
            fcomp       F0,F1            ; F0 < 0 ?
            jge         %2               ; nein -> goto %2
            a2flt       F1,"4294967296"  ; ator(F1,4294967296)
            fadd        F0,F1            ; realadd(F0,F1)

%2:         move        <1>,F0
            jump        %4

%3:         a2flt       <1>,S1           ; ator(<1>,S1)
%4:         push        L0
;end

;---------------------------------------------------------------
var_result_unsigned_long: AE VX
            move        l0,<2>
            ergd        <1>,l0
            push        #1.L
;end

;---------------------------------------------------------------
getk2idblock: AX VW VX AW VW
            clear       <4>
            move        s1,<1>
            move        l0,<2>          ;lade ...
            move        b7,b0           ;statusbyte in B7
            move        l0,<3>          ;lade ...
            move        b6,b0           ;blocknumber in B6

            clear       l0
            move        i0,#4           ;Blockzeiger
            move        b5,#1           ;Blockzaehler

%1:         comp        s1[i0,#2],b7    ;Abfrage auf statusbyte
            jnz         %2              ;Sprung wenn falsches statusbyte
            move        b2,s1[i0]       ;i1 (b2,b3) : Blocklaenge
            comp        b5,b6
            jz          %3

            adds        b5,#1           ;Blockzaehler++
            adds        i0,i1
            adds        i0,#1           ;da Keybytedaten mit ETX
            jump        %1

%2:         move        <5>,#0
            clear       l1
            move        b4,s1[i0,#2]
            move        <2>,l1          ;nicht korrektes Statusbyte
            push        #0.l
            jump        %4

%3:         adds        i0,#3
            subb        b2,#3
            move        <4>,s1[i0]i1
            clear       l1
            move        b4,b2
            move        <5>,l1
            push        #1.l
%4:
;end

;---------------------------------------------------------------
getk2block: AX VW VX AW VW
            clear       <4>
            move        s1,<1>
            move        l0,<2>          ;lade ...
            move        b7,b0           ;statusbyte in B7
            move        l0,<3>          ;lade ...
            move        b6,b0           ;blocknumber in B6

            clear       l0
            move        i0,#0           ;Blockzeiger
            move        b5,#1           ;Blockzaehler

%1:         comp        s1[i0,#2],b7    ;Abfrage auf statusbyte
            jnz         %2              ;Sprung wenn falsches statusbyte
            move        b2,s1[i0]       ;i1 (b2,b3) : Blocklaenge
            comp        b5,b6
            jz          %3

            adds        b5,#1           ;Blockzaehler++
            adds        i0,i1
            jump        %1

%2:         move        <5>,#0
            clear       l1
            move        b4,s1[i0,#2]
            move        <2>,l1          ;nicht korrektes Statusbyte
            push        #0.l
            jump        %4

%3:         adds        i0,#3
            subb        b2,#3
            move        <4>,s1[i0]i1
            clear       l1
            move        b4,b2
            move        <5>,l1
            push        #1.l
%4:
;end

;---------------------------------------------------------------
getanalog: AX VX VX VW AW
            clear       l1
            clear       s1
            move        s1,<1>
            tabseek     "SNAME",s1
            jz          %3
            tabget      <5>,"EINH"
            move        l0,<2>          ;Highbyte des Status
            move        b5,b0
            move        l0,<3>          ;Lowbyte  des Status
            move        b4,b0
            tabget      s1,"TYP"
            a2fix       i0,s1
            comp        i0,#1           ;wenn Typ ungleich 1 dann...
            jnz         %1              ;Umrechnung ueber Tabelle
            tabget      s1,"FAKT_A"
            a2fix       l0,s1
            mult        l1,l0
            tabget      s1,"FAKT_B"
            a2fix       l0,s1
            adds        l1,l0
            move        <4>,l1
            jump        %2
%1:         move        <4>,#1234
%2:         push        #1.L
            jump        %4
%3:         push        #0.L
%4:
;end

;---------------------------------------------------------------
betriebswlesen: AX AW FW AW

; <1> Betriebswertname        IN
; <2> Empfangstelegramm       OUT
; <3> Ergebnis                OUT
; <4> Einheit                 OUT

; Arbeitsregisterbelegung:
; s1  <1>, Sendetelegramm, BYTE (Tab), DATA_TYPE (Tab), COMPU_TYPE (Tab), Umrechnungstabelle,
;     Ergebnis als Hex-String, Ergebnis aus Umrechnungstabelle, FAKT_A aus Tabelle,
;     FAKT_B aus Tabelle

; l0
;   i0  Position der Adresse, Position des Ergebnisses
;   i1  Länge der Adresse,

; l1
;   i2
;     b4  Temp. Puffer, Adresse, Ergebnis
;     b5  Temp. Puffer, Adresse, Ergebnis
;   i3
;     b6  Temp. Puffer, Adresse

; f0 float-Ergebnis

; Betriebswert in Tabelle suchen
            clear       s1
            move        s1,<1>
            tabset      "BetriebswTab"    ; Tabelle: BetriebswTab
            tabseek     "NAME", s1
            jz          %endnio           ; Tabelleneintrag nicht gefunden

; Sendetelegramm aufbauen
            clear       <2>
            clear       s1
            tabget      <2>,"TELEGRAM"    ; Basistelegramm aus Tabelle

                                          ; z.B. "123456" -> 0x12,0x34,0x56
            clear       l0                ; i0 is position in destination
                                          ; i1 is position in source

%1:         move        b4,<2>[i1]        ;test, if char is in range
            comp        b4,#0
            jz          %10
            comp        b4,#$61
            jae         %2
            comp        b4,#$41
            jae         %3
            comp        b4,#$30
            jae         %4
            jump        %endnio

%2:         comp        b4,#$66
            jbe         %5
            jump        %endnio
%3:         comp        b4,#$46
            jbe         %6
            jump        %endnio
%4:         comp        b4,#$39
            jbe         %7
            jump        %endnio

%5:         subb        b4,#$57
            jump        %8
%6:         subb        b4,#$37
            jump        %8
%7:         subb        b4,#$30

%8:         test        i1,#$01
            jnz         %9

            move        b6,b4
            adds        i1,#1
            jump        %1

%9:         move        b5,b4
            adds        i1,#1

            lsl         b6,#4           ; higher nibble
            move        s1[i0],b6
            adds        s1[i0],b5
            adds        i0,#1
            jump        %1

%10:        clear       l0
            clear       l1

            tabget      <2>,"POS_ADR"     ; Position der Adresse aus der Tabelle
            a2fix       i0,<2>            ; Position speichern in i0

            tabget      <2>,"LEN_ADR"     ; Laenge der Adresse aus der Tabelle
            a2fix       i1,<2>            ; Laenge speichern in i1

            tabget      <2>,"ADR"         ; Adresse aus der Tabelle
            a2fix       l1,<2>            ; Adresse speichern in l1

%len3:      comp        i1,#3
            jnz         %len2
            move        s1[i0],b6         ; Adr High
            subc        i1,#1
            addc        i0,#1

%len2:      comp        i1,#2
            jnz         %len1
            move        s1[i0],b5         ; Adr Middle
            subc        i1,#1
            addc        i0,#1

%len1:      comp        i1,#1
            jnz         %len0
            move        s1[i0],b4         ; Adr Low
            subc        i1,#1

%len0:      comp        i1,#0
            jnz         %endnio


; Telegramm senden und Antwort empfangen
            clear       <2>               ; Puffer für Empfangstelegramm loeschen
            xsend       <2>,s1            ; senden und empfangen

%meas:      tabget      <4>,"MEAS"        ; Einheit aus Tabelle

; Ergebnis aus dem Antworttelegramm herausholen
%ausw:      tabget      s1,"BYTE"         ; Position des Ergebnisses aus Tabelle
            a2fix       i0,s1             ; Position speichern in i0

            tabget      s1,"DATA_TYPE"    ; Datentyp aus Tabelle
%tbit:      scmp        s1,"1"             ; Bitwert
            jnz         %tbyteu
            move        b4,<2>[i0]
            move        b5,#0
            jump        %bittest

%tbyteu:     scmp        s1,"2"           ; Unsigned-Byte-Wert
            jnz         %tbytes
            move        b4,<2>[i0]
            move        b5,#0
            jump        %cmpbu

%tbytes:     scmp        s1,"3"            ; Signed-Byte-Wert
            jnz         %tintlohiu
            move        b4,<2>[i0]
            move        b5,#0
            jump        %cmpbs

%tintlohiu: scmp        s1,"4"             ; Unsigned-Int-Wert low-high
            jnz         %tinthilou
            move        b4,<2>[i0]
            addc        i0,#1
            move        b5,<2>[i0]
            jump        %cmpiu

%tinthilou: scmp        s1,"5"             ; Unsigned-Int-Wert high-low
            jnz         %tintlohis
            move        b5,<2>[i0]
            addc        i0,#1
            move        b4,<2>[i0]
            jump        %cmpiu

%tintlohis: scmp        s1,"6"             ; Signed-Int-Wert low-high
            jnz         %tinthilos
            move        b4,<2>[i0]
            addc        i0,#1
            move        b5,<2>[i0]
            jump        %cmpis

%tinthilos: scmp        s1,"7"             ; Signed-Int-Wert high-low
            jnz         %endnio
            move        b5,<2>[i0]
            addc        i0,#1
            move        b4,<2>[i0]
            jump        %cmpis

; Umrechnung Unsigned-Byte
%cmpbu:     fix2flt     <3>,i2            ; Wert als float
            jump        %compu

; Umrechnung Signed-Byte
%cmpbs:     fix2flt     <3>,b4            ; Wert als float
            jump        %compu

; Umrechnung Unsigned-Int
%cmpiu:     clear       i3
            fix2flt     <3>,l1            ; Wert als float
            jump        %compu

; Umrechnung Signed-Int
%cmpis:     fix2flt     <3>,i2            ; Wert als float
            jump        %compu

; Umrechnung
%compu:     tabget      s1,"COMPU_TYPE"   ; Umrechnungsart wird ausgewaehlt
            scmp        s1,"--"
            jz          %axbu             ; -> Ax+B
            jump        %tab              ; -> mit Unrechnungstabelle

%axbu:      tabget      s1,"FACT_A"       ; s1 :Multiplikant
            a2flt       f0,s1             ;
            fmul        <3>,f0            ; A*x
            tabget      s1,"FACT_B"       ; s1 :Summant
            a2flt       f0,s1             ;
            fadd        <3>,f0            ; +B
            jump        %endio

%tab:       tabset      s1
            fix2hex     s1,i2
            tabseek     "WERT",s1
            tabget      s1,"ERGEBNIS"     ; s1 :ERGEBNIS
            a2flt       <3>,s1
            jump        %endio

%bittest:
            tabget      s1,"MASK"      ;hole die maske
            a2fix       i0,s1          ;in i0
            move        b3,b0          ;nach b3
            tabget      s1,"VALUE"     ;hole den Sollwert
            a2fix       i0,s1          ;in i0
            and         b4,b3          ;mask the bits wanted
            xor         b4,b0          ;xor with value

            jnz         %bt1           ;not true
            a2flt       <3>,"1.0"             ;
            jump        %endio         ;to end
%bt1:       a2flt       <3>,"0.0"             ;
            jump        %endio         ;to end

%endio:     push        #1.L
            jump        %end
%endnio:    push        #0.L
            jump        %end
%end:
;end

;---------------------------------------------------------------
betriebswlesenK2: AX AW FW AW
            xawlen      {1.i,0.i}         ;1 Antwortblock
            clear       l0
            clear       l1
            clear       s1
            move        s1,<1>
            tabset      "BetriebswMatrix" ;Tabelle: BetriebswMatrix
            tabseek     "NAME", s1
            jz          %19              ;Tabelleneintrag nicht gefunden

;die richtigen Telegramme werden ausgewaehlt
            tabget      s1,"QUELLE"
            scmp        s1,"RAM"
            jz          %1
            scmp        s1,"ROM"
            jz          %2
            scmp        s1,"ADC"
            jz          %3
            jump        %19              ;Eintrag nicht gefunden

%1:         clear       s1
            clear       <2>
            move        s1,{6,0,1,2,0,0}

;die richtigen Speicherzellen (Kanaele) werden eingetragen
            tabget      <2>,"ZELLE"
            a2fix       i0,<2>
            clear       <2>
            move        s1[#5],b0         ;Adr Hi
            move        s1[#4],b1         ;Adr Lo
            jump        %4

%2:         clear       s1
            clear       <2>
            move        s1,{6,0,3,2,0,0}
            tabget      <2>,"ZELLE"
            a2fix       i0,<2>
            clear       <2>
            move        s1[#5],b0         ;Adr Hi
            move        s1[#4],b1         ;Adr Lo
            jump        %4

%3:         clear       s1
            clear       <2>
            move        s1,{4,0,8,0}
            tabget      <2>,"ZELLE"
            a2fix       i0,<2>
            clear       <2>
            move        s1[#3],b0         ;ADC-Kanalnummer

;die zwei Antwortbytes werden nach i0 kopiert
%4:         xsend       <2>,s1
            comp        <2>[#2],#251
            jz          %11
            comp        <2>[#2],#253
            jz          %11
            comp        <2>[#2],#254
            jz          %11
            jump        %19
%11:        tabget      s1,"ORD"            ;2 Antwortbytes werden nach i0 kopiert
            scmp        s1,"--"
            jnz          %12
            move        b0,<2>[#3]
            move        b1,#0
            jump        %15
%12:        scmp        s1,"LH"
            jnz         %13
            move        b0,<2>[#3]
            move        b1,<2>[#4]
            jump        %15
%13:        scmp        s1,"HL"
            jnz         %19                 ;Eintrag nicht gefunden
            move        b0,<2>[#4]
            move        b1,<2>[#3]
%15:        tabget      <4>,"EINH"          ;Ausgabe der Einheit
            tabget      s1,"TYP"            ;Umrechnungsart wird ausgewaehlt
            scmp        s1,"1"
            jz          %16                 ;-> Ax+B
            scmp        s1,"2"
            jz          %17                 ;-> Tabelle
            jump        %19                 ;Eintrag nicht gefunden
%16:        fix2flt     <3>,i0              ;Wert als float
            tabget      s1,"FAKT_A"         ;s1 :FAKT_A
            a2flt       f0,s1               ;
            fmul        <3>,f0              ;Ax
            tabget      s1,"FAKT_B"         ;s1 :FAKT_B
            a2flt       f0,s1               ;
            fadd        <3>,f0              ;+B
            jump        %18                 ;->Ready
%17:        tabget      s1,"FAKT_A"         ;s1 :Tabelle
            tabset      s1
            fix2hex     s1,i0
            tabseek     "WERT",s1
            tabget      s1,"ERGEBNIS"       ;s1 :ERGEBNIS
            a2flt       <3>,s1              ;->Ready
%18:        push        #1.L
            jump        %20
%19:        push        #0.L
            jump        %20
%20:
;end

;---------------------------------------------------------------
betriebswlesenDS2: AX AW FW AW VX
            xawlen      {-1.i,0.i}         ;1 Antwortblock
            clear       l0
            clear       l1
            clear       s1
            move        s1,<1>
            tabset      "BetriebswMatrix" ;Tabelle: BetriebswMatrix
            tabseek     "NAME", s1
            jz          %13               ;Tabelleneintrag nicht gefunden
            clear       <2>               ;Telegramme werden ausgewaehlt
            tabget      s1,"QUELLE"
            scmp        s1,"RAM1I"
            jnz         %1
            move        s1,{0,9,6,4,0,0,0,2}
            jump        %9
%1:         scmp        s1,"RAM1E"
            jnz         %2
            move        s1,{0,9,6,5,0,0,0,2}
            jump        %9
%2:         scmp        s1,"RAM2I"
            jnz         %3
            move        s1,{0,9,6,11,0,0,0,2}
            jump        %9
%3:         scmp        s1,"RAM2E"
            jnz         %4
            move        s1,{0,9,6,12,0,0,0,2}
            jump        %9
%4:         scmp        s1,"EPROM1"
            jnz         %5
            move        s1,{0,9,6,2,0,0,0,2}
            jump        %9
%5:         scmp        s1,"EEPROM1"
            jnz         %6
            move        s1,{0,9,6,3,0,0,0,2}
            jump        %9
%6:         scmp        s1,"EPROM2"
            jnz         %7
            move        s1,{0,9,6,9,0,0,0,2}
            jump        %9
%7:         scmp        s1,"EEPROM2"
            jnz         %77
            move        s1,{0,9,6,10,0,0,0,2}
            jump        %9
%77:        scmp        s1,"LINRAM"
            jnz         %8
            move        s1,{0,9,6,0,0,0,0,2}
            jump        %9
%8:         scmp        s1,"ADC"
            jnz         %19                 ;->Eintrag nicht gefunden
            move        s1,{0,6,11,2,0}     ; hier nur ADC-Lesen
            tabget      <2>,"ZELLE"
            a2fix       i0,<2>
            move        s1[#4],b0           ; ADC-Kanalnummer
            jump        %10

%9:         tabget      <2>,"ZELLE"         ; hier RAM/ROM/EPROM Daten lesen
            a2fix       l0,<2>
            move        s1[#4],b2           ;Adr High
            move        s1[#5],b1           ;Adr Middle
            move        s1[#6],b0           ;Adr Low
            jump        %10

%10:        clear       <2>
            move        l0,<5>
            move        s1[#0],b0           ;SG Adresse eintrage
            xsend       <2>,s1
            comp        <2>[#2],#$A0
            jz          %11
            jump        %19
%11:        tabget      s1,"ORD"            ;2 Antwortbytes werden nach i0 kopiert
            scmp        s1,"--"
            jnz          %12
            move        b0,<2>[#3]
            move        b1,#0
            jump        %15
%12:        scmp        s1,"LH"
            jnz         %13
            move        b0,<2>[#3]
            move        b1,<2>[#4]
            jump        %15
%13:        scmp        s1,"HL"
            jnz         %19                 ;Eintrag nicht gefunden
            move        b0,<2>[#4]
            move        b1,<2>[#3]
%15:        tabget      <4>,"EINH"          ;Ausgabe der Einheit
            tabget      s1,"TYP"            ;Umrechnungsart wird ausgewaehlt
            scmp        s1,"1"
            jz          %16                 ;-> Ax+B
            scmp        s1,"2"
            jz          %17                 ;-> Tabelle
            jump        %19                 ;Eintrag nicht gefunden
%16:        fix2flt     <3>,i0              ;Wert als float
            tabget      s1,"FAKT_A"         ;s1 :FAKT_A
            a2flt       f0,s1               ;
            fmul        <3>,f0              ;Ax
            tabget      s1,"FAKT_B"         ;s1 :FAKT_B
            a2flt       f0,s1               ;
            fadd        <3>,f0              ;+B
            jump        %18                 ;->Ready
%17:        tabget      s1,"FAKT_A"         ;s1 :Tabelle
            tabset      s1
            fix2hex     s1,i0
            tabseek     "WERT",s1
            tabget      s1,"ERGEBNIS"       ;s1 :ERGEBNIS
            a2flt       <3>,s1              ;->Ready
%18:        push        #1.L
            jump        %20
%19:        push        #0.L
            jump        %20
%20:
;end

;---------------------------------------------------------------
standard_ident: VX AW
            move        l0,<1>             ;standard_ident
            xawlen      {-1.i,0.i}         ;1 Antwortblock
            clear       s1
            move        s1,{$00,$04,$00}
            move        s1[#0],b0
            xsend       <2>,s1

            tabset      "JobResult"        ;Jobstatus auswerten
            fix2hex     s1,<2>[#2]
            tabseek     "SB", s1
            tabget      s1,"STATUS_TEXT"
            ergs        "JOB_STATUS",s1

            scmp        s1,"OKAY"          ;Im Fehlerfall eoj
            jz          %1
            clear       s1
            jump        %15

%1:         etag        %6,"ID_BMW_NR"
            clear       s1
            move        i1,#0           ; i1 is write pos
            move        i2,#3           ; i2 is position
            move        i3,#4           ; i3 is count
            jump        %4              ; erstes Nibble ueberspringen
%2:         move        b0,<2>[i2]       ;
            lsr         b0,#4           ; higher nibble
            or          b0,#48          ; to bcd
            comp        b0,#58          ;
            jb          %3              ;
            move        b0,#42          ; correct '*'
%3:         move        s1[i1],b0       ; write hexbyte
            adds        i1,#1           ; inc write pos
%4:         move        b0,<2>[i2]       ;
            and         b0,#$0f         ; lower nibble
            or          b0,#48          ; to bcd
            comp        b0,#58          ;
            jb          %5              ;
            move        b0,#42          ; correct '*'
%5:         move        s1[i1],b0      ; write hexbyte
            adds        i1,#1           ; inc write pos
            adds        i2,#1           ; readpos++
            subb        i3,#1           ; count--
            jnz         %2              ;
            scat        s1,""          ; add \0
            ergs        "ID_BMW_NR",s1

%6:         etag        %7,"ID_HW_NR"
            move        b0,<2>[#7]
            move        b1,<2>[#7]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_HW_NR",i0

%7:         etag        %8,"ID_COD_INDEX"
            move        b0,<2>[#8]
            move        b1,<2>[#8]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_COD_INDEX",i0

%8:         etag        %9,"ID_DIAG_INDEX"
            move        b0,<2>[#9]
            move        b1,<2>[#9]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_DIAG_INDEX",i0

%9:         etag        %10,"ID_BUS_INDEX"
            move        b0,<2>[#10]
            move        b1,<2>[#10]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_BUS_INDEX",i0

%10:        etag        %11,"ID_DATUM_KW"
            move        b0,<2>[#11]
            move        b1,<2>[#11]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_DATUM_KW",i0

%11:        etag        %12,"ID_DATUM_JAHR"
            move        b0,<2>[#12]
            move        b1,<2>[#12]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_DATUM_JAHR",i0

%12:        etag        %13,"ID_LIEF_NR"
            move        b0,<2>[#13]
            move        b1,<2>[#13]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_LIEF_NR",i0

%13:        etag        %14,"ID_LIEF_TEXT"
            tabset      "Lieferanten"
            fix2hex     s1,<2>[#13]
            tabseek     "LIEF_NR",s1
            tabget      s1,"LIEF_TEXT"
            ergs        "ID_LIEF_TEXT",s1

%14:        etag        %15,"ID_SW_NR"
            move        b0,<2>[#14]
            move        b1,<2>[#14]
            lsr         b0,#4
            and         b0,#$0f
            and         b1,#$0f
            mult        b0,#10
            adds        b0,b1
            clear       b1
            ergw        "ID_SW_NR",i0
%15:        push        #1.L
;end

;---------------------------------------------------------------
ax_plus_b: AX FW VW AX AX
            fix2flt     f1,<3>          ; ax_plus_b
            a2flt       f0,<4>
            fmul        f1,f0
            a2flt       f0,<5>
            fadd        f1,f0
            move        <2>,f1          ; Ergebnis zuweisen
            clear       s1
            move        s1,<1>
            comp        s1[#0],#0
            jz          %1
            ergr        <1>,f1
%1:         push        #1.L
;end

;---------------------------------------------------------------
write_global_data: AX
            shmset      "",<1>          ;write global data
            push        #1.L
;end

;---------------------------------------------------------------
read_global_data: AW
            shmget      <1>,""          ;read global data
            push        #1.L
;end

;---------------------------------------------------------------
carbSource: AW AX VX
            move        l1,#1
            tabset      "CARBSOURCE"        ;set table to bytefield
            move        s1,<2>
            move        b0,s1[#2]
            fix2hex     s1,b0
            tabseek     "ADRESS",s1
            pushf
            tabget      <1>,"ECU"
            popf
            jnz         %1
            move        l1,<3>
            move        b0,s1[#2]
            move        <1>[l1],b0
            move        b0,s1[#3]
            adds        l1,#1
            move        <1>[l1],b0
            move        l1,#0
%1:         push        l1
;end

;---------------------------------------------------------------
carbChecksum: AW
            clear       i0
            move        i1,#0           ;Checksum
            move        i2,#0           ;Index
            slen        i3,<1>          ;Maximum
%1:         move        b0,<1>[i2]      ;Get Byte
            adds        i1,i0           ;add Checksum
            adds        i2,#1           ;inc Index
            comp        i2,i3           ;Last Byte ?
            jnz         %1              ;no
            move        <1>[i3],b2
            move        i0,i1
            clear       i1
            push        l0
;end

;---------------------------------------------------------------
; check_digital_argument(Argumentname, Argumentnummer, Ergebnis, Mode)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx                                                                   xx xx xx xx
;
; L0           Temp
; L6           trapmask
; S1           Puffer
check_digital_argument: AE VX VW VX
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            pars        S1,<2>                 ; Puffer = Argument <2>
            jnz         %1                     ; if (exist(ARGUMENT)) %1

            move        L0,<4>                 ; Temp = mode
            test        L0,#2                  ; Temp & 2
            jnz         %endnio                ; if ((Temp & 2)==0
            and         L0,#1                  ; Temp = Temp & 1
            move        <3>,L0                 ; Ergebnis = Temp
            jump        %endio                 ; Okay

%1:         move        L0,#0                  ; Temp = 0
%2:         comp        S1[L0],#0              ; Puffer[Temp] == 0
            jz          %3                     ; Stringende erreicht ?
            or          S1[L0],#$20            ; Puffer[i] = Puffer[i] | 0x20 --> Kleinbuchstabe
            adds        L0,#1                  ; i++
            jump        %2                     ; goto %2

%3:         tabset      "DigitalArgument"      ; tabset("DigitalArgument")
            jt          %nio_table,#10         ; Tabelle nicht gefunden ?
            tabseek     "TEXT",S1              ; tabseek("TEXT", Puffer)
            jz          %endnio                ; nicht gefunden ?
            tabget      S1,"WERT"              ; tabget(Puffer, "WERT")
            a2fix       <3>,S1                 ; Ergebnis = atoi(Puffer);
;           jump        %endio

%endio:     push        #1.L                   ; TRUE
            jump        %end

%nio_table: push        #0.L                   ; FALSE
            ergs        "JOB_MESSAGE","Table DigitalArgument not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            jump        %end

%endnio:    push        #0.L                   ; FALSE
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; check_multiple_argument(Argumentname, Argumentnummer, Ergebnis, Tablename)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;                                                                               xx xx xx xx
;
; L6           trapmask
; S1           Puffer
check_multiple_argument: AE VX VW AX
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            pars        S1,<2>                 ; Puffer = Argument <2>
            jz          %endnio                ; if (!exist(ARGUMENT)) %endnio

            tabset      <4>                    ; tabset(Tablename)
            jt          %nio_table,#10         ; Tabelle nicht gefunden ?
            tabseek     "TEXT",S1              ; tabseek("TEXT", Puffer)
            jz          %endnio                ; nicht gefunden ?
            tabget      S1,"WERT"              ; tabget(Puffer, "WERT")
            a2fix       <3>,S1                 ; Ergebnis = atoi(Puffer);
;           jump        %endio

%endio:     push        #1.L                   ; TRUE
            jump        %end

%nio_table: push        #0.L                   ; FALSE
            ergs        "JOB_MESSAGE","Table not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            jump        %end

%endnio:    push        #0.L                   ; FALSE
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; send_and_receive_uds(SA_request, TA_request, TA_TYPE_request, Data_request, SA_response, TA_response, Data_response, Result_Name, repeat_counter)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  <--- 5 --->  <--- 6 --->  <--- 7 --->  xx xx xx xx  xx xx xx xx  xx xx xx
;
; B0 (L0)  temp
;     L0   temp2
; I2 (L1)  len antwort
; I3 (L1)  datalen_auftrag
;     L2   <2>
;     L3   <5>
;     L4   <6>
; IA (L5)  datalen_antwort
; IB (L5)  len_check
;     L6   trapmask
; IE (L7)  BusyCount
; AE (L7)  offset antwort
; S1       Puffer
send_and_receive_uds: VX VX VX AX VW VW AW AE VX
            gettmr      L6               ; trapmask=get_trap_mask()
            move        AD,#0            ; BusyCount = 0 ( high )
            move        AC,<9>           ; BusyCount = Wiederholzaehler
            adds        IE,#1            ; BusyCount = BusyCount + 1

%1a:        clear       <7>              ; response loeschen
            clear       S1               ; dataclear(S1)
            slen        I3,<4>           ; datalen_auftrag = datalen(request)
            comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %1f              ; ja -> senden
            move        S1,<4>           ; Puffer = request
            comp        I3,#63           ; datalen_auftrag <= 63 ?
            jle         %1b              ; ja -> kurzer header dazu
            comp        I3,#255          ; datalen_auftrag <= 255 ?
            jle         %1c              ; ja -> header dazu
            jump        %1d

%1b:        spaste      S1[#0],{$80.B,$0.B,$0.B}                 ; FMT TGT SRC
            adds        S1[#0],B6
            jump        %1e

%1c:        spaste      S1[#0],{$80.B,$0.B,$0.B,$0.B}            ; FMT TGT SRC LEN
            move        S1[#3],B6
            jump        %1e

%1d:        spaste      S1[#0],{$80.B,$0.B,$0.B,$0.B,$0.B,$0.B}  ; FMT TGT SRC LEN LENHigh LENLow
            move        S1[#4],B7
            move        S1[#5],B6
            jump        %1e

%1e:        move        L0,<2>           ; temp2 = TA_request
            move        S1[#1],B0        ; Puffer[1]=TA_request
            move        B0,<1>           ; temp = SA_request
            move        S1[#2],B0        ; Puffer[2]=SA_request
            move        B0,<3>           ; temp = TA_TYPE_request
            comp        B0,#0            ; TA_TYPE_request == 0 ?
            jz          %1f              ; ja -> physikalisch
            adds        S1[#0],#$40      ; Functional

%1f:        xsend       <7>,S1           ; senden
            slen        IA,<7>           ; datalen_antwort = datalen(antwort)
            comp        IA,#0            ; datalen_antwort == 0 ?
            jz          %nio_resp        ; ja -> Fehler

            move        AE,#3            ; offset = 3
            move        I2,<7>[#0]       ; len = antwort[0]
            and         I2,#$3F          ; len = len & 0x3F
            comp        I2,#0            ; len == 0 ?
            jnz         %3               ; nein -> goto %3
            move        AE,#4            ; offset = 4
            move        I2,<7>[#3]       ; len = antwort[3]
            and         I2,#$FF          ; len = len & 0xFF
            comp        I2,#0            ; len == 0 ?
            jnz         %3               ; nein -> goto %3
            move        AE,#6            ; offset = 6
            move        B5,<7>[#4]       ; lenh= antwort[4]
            move        B4,<7>[#5]       ; lenl= antwort[5]

%3:         move        IB,#1            ; len_check = 1 ( Checksumme )
            adds        A6,AE            ; len_check = len_check + offset
            adds        IB,I2            ; len_check = len_check + len
            comp        IB,IA            ; len_check == datalen_antwort ?
            jz          %3a              ; ja -> goto %3a
            jump        %nio_len         ; Fehler

%3a:        move        <5>,<7>[#2]      ; SA_response = antwort[2]
            and         <5>,#$FF.L       ; nur Low Byte
            move        <6>,<7>[#1]      ; TA_response = antwort[1]
            and         <6>,#$FF.L       ; nur Low Byte

%3b:        serase      <7>[#0],AE       ; dataerase(response,0,offset) Header entfernt
            serase      <7>[I2],#1       ; dataerase(response,len,1)    Checksumme entfernt
            clear       S1
            move        S1,<8>
            scmp        S1,""            ; RESULT <8> == "" ?
            jz          %3c              ; ja -> goto %3c
            etag        %3c,<8>          ; wenn RESULT <8> angefordert
            ergy        <8>,<7>          ; response nach RESULT <8>

%3c:        settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "JobResult"      ; tabset("JobResult")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?
            comp        <7>[#0],#$7F     ; response[0] == 0x7F ?
            jnz         %5               ; nein -> goto %5

            comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %4a              ; ja -> goto %4a

            move        B0,<3>           ; temp = TA_TYPE_request
            comp        B0,#0            ; TA_TYPE_request == 0 ?
            jnz         %4a              ; nein -> goto %4a

            comp        <7>[#2],#$21     ; NegResponseCode == BusyRepeatRequest ?
            jz          %4c              ; ja -> goto %4c
            jump        %4a              ; goto %4a

%4c:        comp        IE,#1            ; BusyCount == 1 ?
            jz          %4b              ; ja -> goto %4b
            wait        #1               ; wait (1)

%4b:        subb        IE,#1            ; BusyCount --
            jnz         %1a              ; BusyCount > 0 -> goto %1a

%4a:        fix2hex     S1,<7>[#2]       ;
            tabseek     "SB",S1          ; tab_suche_index("SB",response[2])
            tabget      S1,"STATUS_TEXT" ;
            ergs        "JOB_STATUS",S1  ;
            jump        %endnio          ; Fehler !

%5:         comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %8               ; ja -> goto %8

            move        B0,<4>[#0]       ; temp = request[0]
            adds        B0,#$40          ; temp = temp+ 0x40
            comp        <7>[#0],B0       ; response[0] == SID ?
            jz          %6               ; ja -> goto %6
            jump        %nio_id          ; Fehler

%6:         comp        <6>,<1>          ; TA_response = SA_request
            jz          %7               ; ja -> goto %7
            jump        %nio_TA_SA       ; Fehler

%7:         move        B0,<3>           ; temp = TA_TYPE_request
            comp        B0,#0            ; TA_TYPE_request == TA_TYPE_PHYSICAL
            jnz         %8               ; nein -> functional
            comp        <5>,<2>          ; SA_response = TA_request
            jz          %8               ; ja -> goto %8
            jump        %nio_SA_TA       ; Fehler

%8:         push        #1.L             ; TRUE
            jump        %end

%nio_resp:  ergs        "JOB_STATUS","ERROR_ECU_NO_RESPONSE"
            jump        %endnio

%nio_len:   ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LEN"
            jump        %endnio

%nio_id:    ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_RESPONSE_ID"
            jump        %endnio

%nio_ta_sa: ergs        "JOB_STATUS","ERROR_ECU_TA_RESPONSE_NOT_SA_REQUEST"
            jump        %endnio

%nio_sa_ta: ergs        "JOB_STATUS","ERROR_ECU_SA_RESPONSE_NOT_TA_REQUEST"
            jump        %endnio

%nio_table: ergs        "JOB_MESSAGE","Table JobResult not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio

%endnio:    push        #0.L             ; FALSE
%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; send_and_receive_kwp2000(Antwort, Auftrag, Daten, ResultName, Wiederholzaehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx                               xx xx xx xx
;
; B0 (L0)  temp
; B1 (L0)  SID
; B2 (L0)  offset antwort
; B3 (L0)  PosSID auftrag
; I2 (L1)  len    antwort
; I3 (L1)  datalen_auftrag
; I4 (L2)  datalen_antwort
; I5 (L2)  len_check
; I6 (L3)  BusyCount
; BE (L3)  temp2
; L6       trapmask
; S1       Puffer
send_and_receive_kwp2000: AW AW AW AE VX
            gettmr      L6               ; trapmask=get_trap_mask()
            move        BD,#0            ; BusyCount = 0 ( high )
            move        BC,<5>           ; BusyCount = Wiederholzaehler
            adds        I6,#1            ; BusyCount = BusyCount + 1
%1a:        clear       <1>              ; antwort loeschen
            clear       <3>              ; daten loeschen
            xsend       <1>,<2>          ; senden
            slen        I3,<2>           ; datalen_auftrag = datalen(auftrag)
            slen        I4,<1>           ; datalen_antwort = datalen(antwort)
            comp        I4,#0            ; datalen_antwort == 0 ?
            jz          %endnio          ; ja -> Fehler

            move        S1,<4>
            scmp        S1,""            ; RESULT <4> == "" ?
            jz          %1               ; ja -> goto %1
            etag        %1,<4>           ; wenn RESULT <4> angefordert
            ergy        <4>,<1>          ; antwort nach RESULT <4>

%1:         move        B2,#3            ; offset = 3
            move        B0,<1>[#0]       ; temp = antwort[0]
            and         B0,#$C0          ; temp = temp & 0xC0
            comp        B0,#0            ; temp == 0 ?
            jnz         %2               ; nein -> goto %2
            move        B2,#1            ; offset = 1

%2:         move        I2,<1>[#0]       ; len = antwort[0]
            and         I2,#$3F          ; len = len & 0x3F
            comp        I2,#0            ; len == 0 ?
            jnz         %3               ; nein -> goto %3
            move        I2,<1>[B2]       ; len = antwort[offset]
            and         I2,#$FF          ; len = len & 0xFF
            adds        B2,#1            ; offset = offset + 1

%3:         move        I5,#1            ; len_check = 1 ( Checksumme )
            adds        BA,B2            ; len_check = len_check + offset
            adds        I5,I2            ; len_check = len_check + len
            comp        I5,I4            ; len_check == datalen_antwort ?
            jz          %4               ; ja -> goto %4
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LEN"
            jump        %endnio          ; Fehler !

%4:         move        <3>,<1>[B2]I2    ; daten=antwort[offset] len
            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "JobResult"      ; tabset("JobResult")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?
            comp        <1>[B2],#$7F     ; antwort[offset] == 0x7F ?
            jnz         %5               ; nein -> goto %5

            move        B0,B2            ; temp = offset ( antwort )
            adds        B0,#2            ; temp = temp + 2

            comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %4a              ; ja -> goto %4a

            move        BE,<2>[#0]       ; temp2 = auftrag[0]
            and         BE,#$C0          ; temp2 = temp2 & 0xC0
            comp        BE,#$C0          ; temp2 == 0xC0 ?
            jz          %4a              ; ja -> goto %4a

            comp        <1>[B0],#$21     ; NegResponseCode == BusyRepeatRequest ?
            jz          %4c              ; ja -> goto %4c
            comp        <1>[B0],#$23     ; NegResponseCode == RoutineNotComplete ?
            jz          %4c              ; ja -> goto %4c
            jump        %4a              ; goto %4a

%4c:        comp        I6,#1            ; BusyCount == 1 ?
            jz          %4b              ; ja -> goto %4b
            wait        #1               ; wait (1)

%4b:        subb        I6,#1            ; BusyCount --
            jnz         %1a              ; BusyCount > 0 -> goto %1a

%4a:        fix2hex     S1,<1>[B0]       ;
            tabseek     "SB",S1          ; tab_suche_index("SB",antwort[offset+2])
            tabget      S1,"STATUS_TEXT" ;
            ergs        "JOB_STATUS",S1  ;
            jump        %endnio          ; Fehler !

%5:         comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %8               ; ja -> goto %8

            move        B3,#3            ; PosSID = 3
            move        B0,<2>[#0]       ; temp = auftrag[0]
            and         B0,#$C0          ; temp = temp & 0xC0
            comp        B0,#0            ; temp == 0 ?
            jnz         %6               ; nein -> goto %6
            move        B3,#1            ; PosSID = 1

%6:         move        B0,<2>[#0]       ; temp = auftrag[0]
            and         B0,#$3F          ; temp = temp & 0x3F
            comp        B0,#0            ; temp == 0 ?
            jnz         %7               ; nein -> goto %7
            adds        B3,#1            ; PosSID = PosSID + 1

%7:         move        B1,<2>[B3]       ; SID = auftrag[PosSID]
            adds        B1,#$40          ; SID = SID + 0x40
            comp        <1>[B2],B1       ; antwort[offset] == SID ?
            jz          %8               ; ja -> goto %8
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_RESPONSE_ID"
            jump        %endnio          ; Fehler !

%8:         push        #1.L             ; TRUE
            jump        %end

%nio_table: push        #0.L             ; FALSE
            ergs        "JOB_MESSAGE","Table JobResult not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %end

%endnio:    push        #0.L             ; FALSE
%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; send_and_receive_kwp2000_star(Antwort, Auftrag, Daten, ResultName, Wiederholzaehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx                               xx xx xx xx
;
; B0 (L0)  temp
; B1 (L0)  SID
; B2 (L0)  offset antwort
; B3 (L0)  PosSID auftrag
; I2 (L1)  len    antwort
; I3 (L1)  datalen_auftrag
; I4 (L2)  datalen_antwort
; I5 (L2)  len_check
; I6 (L3)  BusyCount
; BE (L3)  temp2
; L6       trapmask
; S1       Puffer
send_and_receive_kwp2000_star: AW AW AW AE VX
            gettmr      L6               ; trapmask=get_trap_mask()
            move        BD,#0            ; BusyCount = 0 ( high )
            move        BC,<5>           ; BusyCount = Wiederholzaehler
            adds        I6,#1            ; BusyCount = BusyCount + 1
%1a:        clear       <1>              ; antwort loeschen
            clear       <3>              ; daten loeschen
            xsend       <1>,<2>          ; senden
            slen        I3,<2>           ; datalen_auftrag = datalen(auftrag)
            slen        I4,<1>           ; datalen_antwort = datalen(antwort)
            comp        I4,#0            ; datalen_antwort == 0 ?
            jz          %endnio          ; ja -> Fehler

            move        S1,<4>
            scmp        S1,""            ; RESULT <4> == "" ?
            jz          %1               ; ja -> goto %1
            etag        %1,<4>           ; wenn RESULT <4> angefordert
            ergy        <4>,<1>          ; antwort nach RESULT <4>

%1:         move        B2,#3            ; offset = 3
;            move        B0,<1>[#0]       ; temp = antwort[0]
;            and         B0,#$C0          ; temp = temp & 0xC0
;            comp        B0,#0            ; temp == 0 ?
;            jnz         %2               ; nein -> goto %2
;            move        B2,#1            ; offset = 1

;%2:         move        I2,<1>[#0]       ; len = antwort[0]
;            and         I2,#$3F          ; len = len & 0x3F
;            comp        I2,#0            ; len == 0 ?
;            jnz         %3               ; nein -> goto %3
            move        I2,<1>[B2]       ; len = antwort[offset]
            and         I2,#$FF          ; len = len & 0xFF
            adds        B2,#1            ; offset = offset + 1

%3:         move        I5,#1            ; len_check = 1 ( Checksumme )
            adds        BA,B2            ; len_check = len_check + offset
            adds        I5,I2            ; len_check = len_check + len
            comp        I5,I4            ; len_check == datalen_antwort ?
            jz          %4               ; ja -> goto %4
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LEN"
            jump        %endnio          ; Fehler !

%4:         move        <3>,<1>[B2]I2    ; daten=antwort[offset] len
            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "JobResult"      ; tabset("JobResult")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?
            comp        <1>[B2],#$7F     ; antwort[offset] == 0x7F ?
            jnz         %5               ; nein -> goto %5

            move        B0,B2            ; temp = offset ( antwort )
            adds        B0,#2            ; temp = temp + 2

            comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %4a              ; ja -> goto %4a

;            move        BE,<2>[#0]       ; temp2 = auftrag[0]
;            and         BE,#$C0          ; temp2 = temp2 & 0xC0
;            comp        BE,#$C0          ; temp2 == 0xC0 ?
;            jz          %4a              ; ja -> goto %4a

            comp        <1>[B0],#$21     ; NegResponseCode == BusyRepeatRequest ?
            jz          %4c              ; ja -> goto %4c
            comp        <1>[B0],#$23     ; NegResponseCode == RoutineNotComplete ?
            jz          %4c              ; ja -> goto %4c
            jump        %4a              ; goto %4a

%4c:        comp        I6,#1            ; BusyCount == 1 ?
            jz          %4b              ; ja -> goto %4b
            wait        #1               ; wait (1)

%4b:        subb        I6,#1            ; BusyCount --
            jnz         %1a              ; BusyCount > 0 -> goto %1a

%4a:        fix2hex     S1,<1>[B0]       ;
            tabseek     "SB",S1          ; tab_suche_index("SB",antwort[offset+2])
            tabget      S1,"STATUS_TEXT" ;
            ergs        "JOB_STATUS",S1  ;
            jump        %endnio          ; Fehler !

%5:         comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %8               ; ja -> goto %8

            move        B3,#3            ; PosSID = 3
;            move        B0,<2>[#0]       ; temp = auftrag[0]
;            and         B0,#$C0          ; temp = temp & 0xC0
;            comp        B0,#0            ; temp == 0 ?
;            jnz         %6               ; nein -> goto %6
;            move        B3,#1            ; PosSID = 1

;%6:         move        B0,<2>[#0]       ; temp = auftrag[0]
;            and         B0,#$3F          ; temp = temp & 0x3F
;            comp        B0,#0            ; temp == 0 ?
;            jnz         %7               ; nein -> goto %7
            adds        B3,#1            ; PosSID = PosSID + 1

%7:         move        B1,<2>[B3]       ; SID = auftrag[PosSID]
            adds        B1,#$40          ; SID = SID + 0x40
            comp        <1>[B2],B1       ; antwort[offset] == SID ?
            jz          %8               ; ja -> goto %8
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_RESPONSE_ID"
            jump        %endnio          ; Fehler !

%8:         push        #1.L             ; TRUE
            jump        %end

%nio_table: push        #0.L             ; FALSE
            ergs        "JOB_MESSAGE","Table JobResult not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %end

%endnio:    push        #0.L             ; FALSE
%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; send_and_receive_ds2(Antwort, Auftrag, Daten, ResultName, Wiederholzaehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;              xx xx xx xx  xx xx xx xx  xx xx xx xx                            xx xx xx xx
;
; I2 (L1)  len    antwort
; I3 (L1)  datalen_auftrag
; I4 (L2)  datalen_antwort
; I6 (L3)  BusyCount
; I7 (L3)  temp
; L6       trapmask
; S1       Puffer
send_and_receive_ds2: AW AW AW AE VX
            gettmr      L6               ; trapmask=get_trap_mask()
            move        BD,#0            ; BusyCount = 0 ( high )
            move        BC,<5>           ; BusyCount = Wiederholzaehler
            adds        I6,#1            ; BusyCount = BusyCount + 1
%1:         clear       <1>              ; antwort loeschen
            clear       <3>              ; daten loeschen
            xsend       <1>,<2>          ; senden
            slen        I3,<2>           ; datalen_auftrag = datalen(auftrag)
            slen        I4,<1>           ; datalen_antwort = datalen(antwort)
            comp        I4,#0            ; datalen_antwort == 0 ?
            jz          %endnio          ; ja -> Fehler

            move        S1,<4>
            scmp        S1,""            ; RESULT <4> == "" ?
            jz          %2               ; ja -> goto %2
            etag        %2,<4>           ; wenn RESULT <4> angefordert
            ergy        <4>,<1>          ; antwort nach RESULT <4>

%2:         move        I2,<1>[#1]       ; len = antwort[1]
            and         I2,#$FF          ; len = len & 0xFF
            comp        I2,I4            ; len == datalen_antwort ?
            jz          %3               ; ja -> goto %3
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LEN"
            jump        %endnio          ; Fehler !

%3:         comp        I2,#4            ; len >= 4 ?
            jge         %4               ; ja -> goto %4
            ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LEN"
            jump        %endnio          ; Fehler !

%4:         move        I7,I2            ; temp=datalen_antwort
            subb        I7,#4            ; temp=temp-4
            move        <3>,<1>[#3]I7    ; daten=antwort[3] len-4
            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "JobResult"      ; tabset("JobResult")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?

            comp        <1>[#2],#$A0     ; antwort[2] == Acknowledge ?
            jz          %5               ; ja -> goto %5

            comp        I3,#0            ; datalen_auftrag == 0 ?
            jz          %4a              ; ja -> goto %4a

            comp        <1>[#2],#$A1     ; NegResponseCode == Busy ?
            jz          %4c              ; ja -> goto %4c
            jump        %4a              ; goto %4a

%4c:        comp        I6,#1            ; BusyCount == 1 ?
            jz          %4b              ; ja -> goto %4b
            wait        #1               ; wait (1)

%4b:        subb        I6,#1            ; BusyCount --
            jnz         %1               ; BusyCount > 0 -> goto %1

%4a:        fix2hex     S1,<1>[#2]       ;
            tabseek     "SB",S1          ; tab_suche_index("SB",antwort[2])
            tabget      S1,"STATUS_TEXT" ;
            ergs        "JOB_STATUS",S1  ;
            jump        %endnio          ; Fehler !

%5:         comp        I3,#0            ; datalen_auftrag == 0 ?
            push        #1.L             ; TRUE
            jump        %end

%nio_table: push        #0.L             ; FALSE
            ergs        "JOB_MESSAGE","Table JobResult not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %end

%endnio:    push        #0.L             ; FALSE
%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_error_memory_kwp2000(Daten, FehlerIndex, AnzahlBytesProFehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;                                                     xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L6 , IC , A8 Temp
;      I9 , A2 Fart
;      I8      Fcode
; L5           trapmask
; L7           FehlerIndex * AnzahlBytesProFehler + 2
; S1           Puffer
decode_error_memory_kwp2000: AX VX VX
            gettmr      L5                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            move        L6,<3>                 ; Anzahl nach Temp
            move        L7,<2>
            mult        L7,L6                  ; Index = Fehlerindex * Anzahl Bytes Pro Fehler
            adds        L7,#2.L                ; Index = Index + 2

            move        L6,L7                  ; Temp = Index
            move        A1,<1>[L6]             ; FCode (High) = daten(2 + Index)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        A0,<1>[L6]             ; FCode (Low ) = daten(3 + Index)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        I9,#0                  ; Fart = 0
            move        A2,<1>[L6]             ; Fart = daten(4 + Index)

            etag        %1,"F_HEX_CODE"        ; if (F_HEX_CODE)
            clear       S1                     ; dataclear ( Puffer )
            move        S1,<1>[L7]<3>          ; Puffer = daten[2 +Index] len
            ergy        "F_HEX_CODE",S1        ; F_HEX_CODE=Puffer

%1:         etag        %2,"F_ORT_NR"          ; if (F_ORT_NR)
            move        L6,#0                  ; Temp = 0
            move        IC,I8                  ; Temp = FCode
            ergl        "F_ORT_NR",L6          ; F_ORT_NR = Temp

%2:         etag        %3,"F_ORT_TEXT"        ; if (F_ORT_TEXT)
            tabset      "FOrtTexte"            ; tabset("FOrtTexte")
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            tabget      S1,"ORTTEXT"           ; tabget(Puffer,"ORTTEXT")
            ergs        "F_ORT_TEXT",S1        ; F_ORT_TEXT=Puffer

%3:         etag        %3a,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            jump        %3b                    ; Weiter
%3a:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

%3b:        tabset      "FDetailStruktur"      ; tabset("FDetailStruktur")
            jt          %4                     ; Tabelle nicht gefunden ? Weiter mit normaler Interpretation
;           jt          %nio_3,#10             ; Tabelle nicht gefunden ? Fehlermeldung

            move        S1, "F_ART_IND"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_IND")
            jz          %4                     ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %5a                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %5a                    ; Wenn 'y'
            jump        %4                     ; Weiter mit normaler Interpretation

%5a:        tabset      "FArtTyp"              ; tabset("FArtTyp")
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?
            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F

            comp        IC,#$00                ; Bit gesetzt
            jnz         %5b                    ; Wenn nicht gleich
            move        S1, "0x0000"           ; Wenn keine Spalte zuordenbar und Wert 0
            jump        %5g                    ; Weiter

%5b:        comp        IC,#$01                ; Bit gesetzt ?
            jnz         %5c                    ; Wenn nicht gleich
            tabget      S1, "MAX"              ; tabget(Puffer,"MAX")
            jump        %5g                    ; Tabellenspalte gefunden

%5c:        comp        IC,#$02                ; Bit gesetzt ?
            jnz         %5d                    ; Wenn nicht gleich
            tabget      S1, "MIN"              ; tabget(Puffer,"MIN")
            jump        %5g                    ; Tabellenspalte gefunden

%5d:        comp        IC,#$04                ; Bit gesetzt ?
            jnz         %5e                    ; Wenn nicht gleich
            tabget      S1, "SIG"              ; tabget(Puffer,"SIG")
            jump        %5g                    ; Tabellenspalte gefunden

%5e:        comp        IC,#$08                ; Bit gesetzt ?
            jnz         %5f                    ; Wenn nicht gleich
            tabget      S1, "PLAUS"            ; tabget(Puffer,"PLAUS")
            jump        %5g                    ; Tabellenspalte gefunden

%5f:        move        S1, "0xFFFF"           ; Wenn keine Spalte zuordenbar und Wert nicht gültig
            jump        %5g                    ; Weiter

%5g:        etag        %5h,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            a2fix       IC,S1                  ; atoi(Puffer)
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5h:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

            tabset      "FArtTexteIndividuell" ; tabset("FArtTexteIndividuell")
            jt          %nio_5,#10             ; Tabelle nicht gefunden ?

            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer
            jump        %6                     ; weiter mit readyness

%4:         clrt                               ; Trapregister löschen
            tabset      "FArtTexte"            ; tabset("FArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?

            etag        %5,"F_SYMPTOM_NR"      ; if (F_SYMPTOM_NR)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5:         etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer

%6:         tabset      "FArtTexte"            ; tabset("FArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?
            etag        %7,"F_READY_NR"        ; if (F_READY_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            ergi        "F_READY_NR",IC        ; F_READY_NR=Temp

%7:         etag        %8,"F_READY_TEXT"      ; if (F_READY_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_READY_TEXT",S1      ; F_READY_TEXT=Puffer

%8:         etag        %9,"F_VORHANDEN_NR"    ; if (F_VORHANDEN_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            ergi        "F_VORHANDEN_NR",IC    ; F_VORHANDEN_NR=Temp

%9:         etag        %10,"F_VORHANDEN_TEXT" ; if (F_VORHANDEN_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_VORHANDEN_TEXT",S1  ; F_VORHANDEN_TEXT=Puffer

%10:        etag        %11,"F_WARNUNG_NR"     ; if (F_WARNUNG_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            ergi        "F_WARNUNG_NR",IC      ; F_WARNUNG_NR=Temp

%11:        etag        %12,"F_WARNUNG_TEXT"   ; if (F_WARNUNG_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_WARNUNG_TEXT",S1    ; F_WARNUNG_TEXT=Puffer

%12:        push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Table FOrtTexte not found"
            jump        %nio_table

%nio_2:     ergs        "JOB_MESSAGE","Table FArtTexte not found"
            jump        %nio_table

%nio_3:     ergs        "JOB_MESSAGE","Table FDetailStruktur not found"
            jump        %nio_table

%nio_4:     ergs        "JOB_MESSAGE","Table FArtTyp not found"
            jump        %nio_table

%nio_5:     ergs        "JOB_MESSAGE","Table FArtTexteIndividuell not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L5                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_shadow_memory_kwp2000(Daten, Position, AnzahlBytesProFehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;                                                     xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L6 , IC , A8 Temp
;      I9 , A2 Fart
;      I8      Fcode
; L5           trapmask
; L7           position
; S1           Puffer
decode_shadow_memory_kwp2000: AX VX VX
            gettmr      L5                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            move        L7,<2>                 ; position = Position

            move        L6,L7                  ; Temp = position
            move        A1,<1>[L6]             ; FCode (High) = daten(position)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        A0,<1>[L6]             ; FCode (Low ) = daten(position+1)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        I9,#0                  ; Fart = 0
            move        A2,<1>[L6]             ; Fart = daten(position+1)

            etag        %1,"F_HEX_CODE"        ; if (F_HEX_CODE)
            clear       S1                     ; dataclear ( Puffer )
            move        S1,<1>[L7]<3>          ; Puffer = daten[Position] len
            ergy        "F_HEX_CODE",S1        ; F_HEX_CODE=Puffer

%1:         etag        %2,"F_ORT_NR"          ; if (F_ORT_NR)
            move        L6,#0                  ; Temp = 0
            move        IC,I8                  ; Temp = FCode
            ergl        "F_ORT_NR",L6          ; F_ORT_NR = Temp

%2:         etag        %3,"F_ORT_TEXT"        ; if (F_ORT_TEXT)
            tabset      "IOrtTexte"            ; tabset("IOrtTexte")
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            tabget      S1,"ORTTEXT"           ; tabget(Puffer,"ORTTEXT")
            ergs        "F_ORT_TEXT",S1        ; F_ORT_TEXT=Puffer

%3:         etag        %3a,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            jump        %3b                    ; Weiter
%3a:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

%3b:        tabset      "IDetailStruktur"      ; tabset("IDetailStruktur")
            jt          %4                     ; Tabelle nicht gefunden ? Weiter mit normaler Interpretation
;           jt          %nio_3,#10             ; Tabelle nicht gefunden ? Fehlermeldung

            move        S1, "F_ART_IND"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_IND")
            jz          %4                     ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %5a                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %5a                    ; Wenn 'y'
            jump        %4                     ; Weiter mit normaler Interpretation

%5a:        tabset      "IArtTyp"              ; tabset("IArtTyp")
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?
            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F

            comp        IC,#$00                ; Bit gesetzt
            jnz         %5b                    ; Wenn nicht gleich
            move        S1, "0x0000"           ; Wenn keine Spalte zuordenbar und Wert 0
            jump        %5g                    ; Weiter

%5b:        comp        IC,#$01                ; Bit gesetzt ?
            jnz         %5c                    ; Wenn nicht gleich
            tabget      S1, "MAX"              ; tabget(Puffer,"MAX")
            jump        %5g                    ; Tabellenspalte gefunden

%5c:        comp        IC,#$02                ; Bit gesetzt ?
            jnz         %5d                    ; Wenn nicht gleich
            tabget      S1, "MIN"              ; tabget(Puffer,"MIN")
            jump        %5g                    ; Tabellenspalte gefunden

%5d:        comp        IC,#$04                ; Bit gesetzt ?
            jnz         %5e                    ; Wenn nicht gleich
            tabget      S1, "SIG"              ; tabget(Puffer,"SIG")
            jump        %5g                    ; Tabellenspalte gefunden

%5e:        comp        IC,#$08                ; Bit gesetzt ?
            jnz         %5f                    ; Wenn nicht gleich
            tabget      S1, "PLAUS"            ; tabget(Puffer,"PLAUS")
            jump        %5g                    ; Tabellenspalte gefunden

%5f:        move        S1, "0xFFFF"           ; Wenn keine Spalte zuordenbar und Wert nicht gültig
            jump        %5g                    ; Weiter

%5g:        etag        %5h,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            a2fix       IC,S1                  ; atoi(Puffer)
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5h:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

            tabset      "IArtTexteIndividuell" ; tabset("IArtTexteIndividuell")
            jt          %nio_5,#10             ; Tabelle nicht gefunden ?

            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer
            jump        %6                     ; weiter mit readyness

%4:         clrt                               ; Trapregister löschen
            tabset      "IArtTexte"            ; tabset("IArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?

            etag        %5,"F_SYMPTOM_NR"      ; if (F_SYMPTOM_NR)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5:         etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer

%6:         tabset      "IArtTexte"            ; tabset("IArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?
            etag        %7,"F_READY_NR"        ; if (F_READY_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            ergi        "F_READY_NR",IC        ; F_READY_NR=Temp

%7:         etag        %8,"F_READY_TEXT"      ; if (F_READY_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_READY_TEXT",S1      ; F_READY_TEXT=Puffer

%8:         etag        %9,"F_VORHANDEN_NR"    ; if (F_VORHANDEN_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            ergi        "F_VORHANDEN_NR",IC    ; F_VORHANDEN_NR=Temp

%9:         etag        %10,"F_VORHANDEN_TEXT" ; if (F_VORHANDEN_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_VORHANDEN_TEXT",S1  ; F_VORHANDEN_TEXT=Puffer

%10:        etag        %11,"F_WARNUNG_NR"     ; if (F_WARNUNG_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            ergi        "F_WARNUNG_NR",IC      ; F_WARNUNG_NR=Temp

%11:        etag        %12,"F_WARNUNG_TEXT"   ; if (F_WARNUNG_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_WARNUNG_TEXT",S1    ; F_WARNUNG_TEXT=Puffer

%12:        push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Table IOrtTexte not found"
            jump        %nio_table

%nio_2:     ergs        "JOB_MESSAGE","Table IArtTexte not found"
            jump        %nio_table

%nio_3:     ergs        "JOB_MESSAGE","Table IDetailStruktur not found"
            jump        %nio_table

%nio_4:     ergs        "JOB_MESSAGE","Table IArtTyp not found"
            jump        %nio_table

%nio_5:     ergs        "JOB_MESSAGE","Table IArtTexteIndividuell not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L5                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_history_memory_kwp2000(Daten, Position, AnzahlBytesProFehler)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;                                                     xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L6 , IC , A8 Temp
;      I9 , A2 Fart
;      I8      Fcode
; L5           trapmask
; L7           position
; S1           Puffer
decode_history_memory_kwp2000: AX VX VX
            gettmr      L5                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            move        L7,<2>                 ; position = Position

            move        L6,L7                  ; Temp = position
            move        A1,<1>[L6]             ; FCode (High) = daten(position)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        A0,<1>[L6]             ; FCode (Low ) = daten(position+1)
            adds        L6,#1.L                ; Temp = Temp + 1
            move        I9,#0                  ; Fart = 0
            move        A2,<1>[L6]             ; Fart = daten(position+1)

            etag        %1,"F_HEX_CODE"        ; if (F_HEX_CODE)
            clear       S1                     ; dataclear ( Puffer )
            move        S1,<1>[L7]<3>          ; Puffer = daten[Position] len
            ergy        "F_HEX_CODE",S1        ; F_HEX_CODE=Puffer

%1:         etag        %2,"F_ORT_NR"          ; if (F_ORT_NR)
            move        L6,#0                  ; Temp = 0
            move        IC,I8                  ; Temp = FCode
            ergl        "F_ORT_NR",L6          ; F_ORT_NR = Temp

%2:         etag        %3,"F_ORT_TEXT"        ; if (F_ORT_TEXT)
            tabset      "HOrtTexte"            ; tabset("HOrtTexte")
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            tabget      S1,"ORTTEXT"           ; tabget(Puffer,"ORTTEXT")
            ergs        "F_ORT_TEXT",S1        ; F_ORT_TEXT=Puffer

%3:         etag        %3a,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            jump        %3b                    ; Weiter
%3a:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

%3b:        tabset      "HDetailStruktur"      ; tabset("HDetailStruktur")
            jt          %4                     ; Tabelle nicht gefunden ? Weiter mit normaler Interpretation
;           jt          %nio_3,#10             ; Tabelle nicht gefunden ? Fehlermeldung

            move        S1, "F_ART_IND"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_IND")
            jz          %4                     ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %5a                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %5a                    ; Wenn 'y'
            jump        %4                     ; Weiter mit normaler Interpretation

%5a:        tabset      "HArtTyp"              ; tabset("HArtTyp")
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?
            fix2hex     S1,I8                  ; itoax(Puffer,Fcode) --> 0x1234
            tabseek     "ORT",S1               ; tabseek("ORT",Puffer)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F

            comp        IC,#$00                ; Bit gesetzt
            jnz         %5b                    ; Wenn nicht gleich
            move        S1, "0x0000"           ; Wenn keine Spalte zuordenbar und Wert 0
            jump        %5g                    ; Weiter

%5b:        comp        IC,#$01                ; Bit gesetzt ?
            jnz         %5c                    ; Wenn nicht gleich
            tabget      S1, "MAX"              ; tabget(Puffer,"MAX")
            jump        %5g                    ; Tabellenspalte gefunden

%5c:        comp        IC,#$02                ; Bit gesetzt ?
            jnz         %5d                    ; Wenn nicht gleich
            tabget      S1, "MIN"              ; tabget(Puffer,"MIN")
            jump        %5g                    ; Tabellenspalte gefunden

%5d:        comp        IC,#$04                ; Bit gesetzt ?
            jnz         %5e                    ; Wenn nicht gleich
            tabget      S1, "SIG"              ; tabget(Puffer,"SIG")
            jump        %5g                    ; Tabellenspalte gefunden

%5e:        comp        IC,#$08                ; Bit gesetzt ?
            jnz         %5f                    ; Wenn nicht gleich
            tabget      S1, "PLAUS"            ; tabget(Puffer,"PLAUS")
            jump        %5g                    ; Tabellenspalte gefunden

%5f:        move        S1, "0xFFFF"           ; Wenn keine Spalte zuordenbar und Wert nicht gültig
            jump        %5g                    ; Weiter

%5g:        etag        %5h,"F_SYMPTOM_NR"     ; if (F_SYMPTOM_NR)
            a2fix       IC,S1                  ; atoi(Puffer)
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5h:        etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)

            tabset      "HArtTexteIndividuell" ; tabset("HArtTexteIndividuell")
            jt          %nio_5,#10             ; Tabelle nicht gefunden ?

            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer
            jump        %6                     ; weiter mit readyness

%4:         clrt                               ; Trapregister löschen
            tabset      "HArtTexte"            ; tabset("HArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?

            etag        %5,"F_SYMPTOM_NR"      ; if (F_SYMPTOM_NR)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            ergw        "F_SYMPTOM_NR",IC      ; F_SYMPTOM_NR=Temp

%5:         etag        %6,"F_SYMPTOM_TEXT"    ; if (F_SYMPTOM_TEXT)
            move        IC,I9                  ; Temp = Fart
            and         IC,#$F                 ; Temp =Temp & 0x0F
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_SYMPTOM_TEXT",S1    ; F_SYMPTOM_TEXT=Puffer

%6:         tabset      "HArtTexte"            ; tabset("HArtTexte")
            jt          %nio_2,#10             ; Tabelle nicht gefunden ?
            etag        %7,"F_READY_NR"        ; if (F_READY_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            ergi        "F_READY_NR",IC        ; F_READY_NR=Temp

%7:         etag        %8,"F_READY_TEXT"      ; if (F_READY_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#4                  ; Temp = Temp >> 4
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$10                ; Temp = Temp + 0x10
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_READY_TEXT",S1      ; F_READY_TEXT=Puffer

%8:         etag        %9,"F_VORHANDEN_NR"    ; if (F_VORHANDEN_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            ergi        "F_VORHANDEN_NR",IC    ; F_VORHANDEN_NR=Temp

%9:         etag        %10,"F_VORHANDEN_TEXT" ; if (F_VORHANDEN_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#5                  ; Temp = Temp >> 5
            and         IC,#3                  ; Temp = Temp & 0x03
            adds        IC,#$20                ; Temp = Temp + 0x20
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_VORHANDEN_TEXT",S1  ; F_VORHANDEN_TEXT=Puffer

%10:        etag        %11,"F_WARNUNG_NR"     ; if (F_WARNUNG_NR)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            ergi        "F_WARNUNG_NR",IC      ; F_WARNUNG_NR=Temp

%11:        etag        %12,"F_WARNUNG_TEXT"   ; if (F_WARNUNG_TEXT)
            move        IC,I9                  ; Temp = Fart
            lsr         IC,#7                  ; Temp = Temp >> 7
            and         IC,#1                  ; Temp = Temp & 0x01
            adds        IC,#$30                ; Temp = Temp + 0x30
            fix2hex     S1,A8                  ; itoax(Puffer,Temp) --> 0x12
            tabseek     "ARTNR",S1             ; tabseek("ARTNR",Puffer)
            tabget      S1,"ARTTEXT"           ; tabget(Puffer,"ARTTEXT")
            ergs        "F_WARNUNG_TEXT",S1    ; F_WARNUNG_TEXT=Puffer

%12:        push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Table HOrtTexte not found"
            jump        %nio_table

%nio_2:     ergs        "JOB_MESSAGE","Table HArtTexte not found"
            jump        %nio_table

%nio_3:     ergs        "JOB_MESSAGE","Table HDetailStruktur not found"
            jump        %nio_table

%nio_4:     ergs        "JOB_MESSAGE","Table HArtTyp not found"
            jump        %nio_table

%nio_5:     ergs        "JOB_MESSAGE","Table HArtTexteIndividuell not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L5                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_error_memory_kwp2000_detail(Daten, Offset, UW_Erw, Max_UW_Satz)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx                            xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L0           temp
; L1           max_uw_satz
; L2           datenlaenge
; IA (L5)      i
; A6 (L5)      n
; A7 (L5)      f_art_anz
; L6           trapmask
; L7           offset
; S1           puffer
;---------------------------------------------------------------
decode_error_memory_kwp2000_detail: AX VW VW VW
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            tabset      "FDetailStruktur"
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            move        L1,#3.L                ; max_uw_satz = 3
            move        L7,#5.L                ; offset = 5
            slen        L2,<1>                 ; datenlaenge = datalen(daten)
            move        S1, "F_ART_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_ERW")
            jz          %nio_2                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %11                    ; Wenn nicht 'n'

            etag        %21,"F_ART_ANZ"        ; if (F_ART_ANZ)
            ergi        "F_ART_ANZ",#0.I       ; F_ART_ANZ=0
            jump        %21                    ; weiter mit F_P_CODE

%11:        etag        %19,"F_ART_ANZ"        ; if (F_ART_ANZ)
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %18                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %18                    ; Wenn 'y'

            strlen      L0,S1
            comp        L0,#8                  ; strlen(puffer)=8
            jnz         %nio_3                 ; Wenn nicht 8

            move        A7,#$30                ; f_art_anz='0'
            move        IA,#0                  ; i=0

%12:        comp        IA,#8                  ; while
            jz          %14

            comp        S1[IA],#$30            ; Puffer[i] = '0'=30
            jl          %nio_3                 ; Wenn kleiner '0'
            comp        S1[IA],#$38            ; Puffer[i] = '8'=38
            jg          %nio_3                 ; Wenn groesser '8'

            comp        S1[IA],A7              ; Puffer[i] = Fart_anz
            jle         %13                    ; Fart_anz kleiner als Puffer
            move        A7,S1[IA]              ; Fart_anz = Puffer

%13:        adds        IA,#1.I                ; i++
            jump        %12                    ; end while

%14:        move        I0,#0                  ; temp=0
            move        B0,A7                  ; temp=f_art_anz
            subb        B0,#$30                ; temp=temp-'0'
            ergi        "F_ART_ANZ",I0         ; F_ART_ANZ=temp

            move        S1[#1000],S1[#0]#9     ; Maske nach hinten schieben

            tabset      "FArtTexteErweitert"
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?

            move        A6,#$31                ; n='1'
%15:        comp        A6,A7                  ; while
            jg          %19

            move        S1,"xxxxxxxx"          ; Puffer="xxxxxxxx"
            move        IA,#0                  ; i=0

%16:        comp        IA,#8                  ; while
            jz          %17

            move        I0,#1000               ; temp=1000 (Maskenoffset)
            adds        I0,IA                  ; temp=temp+i
            comp        S1[I0],A6              ; Puffer[temp]=n
            jnz         %16a                   ; wenn nicht n

            move        I0,#7                  ; temp=7
            subb        I0,IA                  ; temp=temp-i

            move        B2,<1>[L7]             ; temp2 = daten[offset]
            lsr         B2,I0                  ; temp2 >> temp
            and         B2,#1                  ; temp2 & 01
            adds        B2,#$30                ; temp2 + '0'

            move        S1[IA],B2              ; Puffer[i]=temp2

%16a:       adds        IA,#1.I                ; i++
            jump        %16                    ; end while

%17:        tabseek     "ARTMASKE",S1          ; tabseek("ARTMASKE",text)
            tabget      S1,"ARTNR"             ; tabget(Puffer, "ARTNR")
            a2fix       L0,S1                  ; temp=atoi(Puffer)
            move        S1,"F_ARTi_NR"         ; text="F_ARTi_NR"
            move        S1[#5],A6              ; text[5]=temp
            ergl        S1,L0                  ; F_ARTi_NR=temp

            tabget      S1,"ARTTEXT"           ; tabget(Puffer, "ARTTEXT")

            strlen      L0,S1                  ; temp=strlen(S1)
            adds        L0,#1                  ; temp++
            comp        L0,#500
            jg          %nio_5                 ; string zu lang ?

            move        S1[#500],S1[#0]L0      ; Arttext nach hinten schieben
            move        S1,"F_ARTi_TEXT"       ; text="F_ARTi_TEXT"
            move        S1[#5],A6              ; text[5]=n
            ergs        S1,S1[#500]L0          ; F_ARTi_TEXT=Puffer(L0)

            adds        A6,#1                  ; n++
            jump        %15                    ; end while

%18:        ergi        "F_ART_ANZ",#1.I       ; F_ART_ANZ=1
            move        L0,#0                  ; temp=0
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            ergl        "F_ART1_NR",L0         ; F_ART1_NR=temp
            ergs        "F_ART1_TEXT","--"
;           jump        %19

%19:        adds        L7,#1.L                ; offset ++
;           jump        %21                    ; weiter mit F_P_CODE

%21:        tabset      "FDetailStruktur"
            move        S1, "F_PCODE"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE")
            jz          %21i                   ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %21f                   ; Wenn nicht 'n'

%21i:       etag        %21h,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",#0.I         ; F_PCODE = 0
%21h:       etag        %21g,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            ergs        "F_PCODE_STRING","--"  ; F_PCODE_STRING = "--"
%21g:       etag        %210,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
            ergs        "F_PCODE_TEXT",""      ; F_PCODE_TEXT = ""
            jump        %210                   ; weiter mit F_PCODE7

%21f:       move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %21e,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",I0           ; F_PCODE = daten[offset]

%21e:       etag        %21d,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            jump        %21c                   ; ja
%21d:       etag        %21b,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
;           jump        %21c                   ; ja

%21c:       tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %21b2,"F_PCODE_STRING" ; if (F_PCODE_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE_STRING",S1    ; F_PCODE_STRING=Puffer

%21b2:      etag        %21b1,"F_PCODE_TEXT"   ; if (F_PCODE_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE_TEXT",S1      ; F_PCODE_TEXT=Puffer

%21b1:      tabset      "FDetailStruktur"      ; wieder zurueck

%21b:       adds        L7,#2.L                ; offset = offset + 2
;           jump        %210                   ; weiter mit F_PCODE7

%210:       tabset      "FDetailStruktur"
            move        S1, "F_PCODE7"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE7")
            jz          %210i                  ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %210f                  ; Wenn nicht 'n'

%210i:      etag        %210h,"F_PCODE7"       ; if (F_PCODE7)
            ergw        "F_PCODE7",#0.I        ; F_PCODE7 = 0
%210h:      etag        %210g,"F_PCODE7_STRING"; if (F_PCODE_STRING7)
            ergs        "F_PCODE7_STRING","--" ; F_PCODE7_STRING = "--"
%210g:      etag        %21a,"F_PCODE7_TEXT"   ; if (F_PCODE7_TEXT)
            ergs        "F_PCODE7_TEXT",""     ; F_PCODE7_TEXT = ""
            jump        %21a                   ; weiter mit F_HFK

%210f:      move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %210e,"F_PCODE7"       ; if (F_PCODE)
            ergw        "F_PCODE7",I0          ; F_PCODE7 = daten[offset]

%210e:      etag        %210d,"F_PCODE7_STRING"; if (F_PCODE7_STRING)
            jump        %210c                  ; ja
%210d:      etag        %210b,"F_PCODE7_TEXT"  ; if (F_PCODE7_TEXT)
;           jump        %210c                  ; ja

%210c:      tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %210b2,"F_PCODE7_STRING" ; if (F_PCODE7_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE7_STRING",S1   ; F_PCODE7_STRING=Puffer

%210b2:     etag        %210b1,"F_PCODE7_TEXT" ; if (F_PCODE7_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE7_TEXT",S1     ; F_PCODE7_TEXT=Puffer

%210b1:     tabset      "FDetailStruktur"      ; wieder zurueck

%210b:      adds        L7,#2.L                ; offset = offset + 2
;           jump        %21a                   ; weiter mit F_HFK

%21a:       move        S1, "F_HFK"
            tabseek     "NAME",S1              ; tabseek("NAME","F_HFK")
            jz          %nio_6                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %22                    ; Wenn nicht 'n'
            etag        %31,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",#$FFFF.I       ; F_HFK=-1
            jump        %31                    ; weiter mit F_LZ

%22:        move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            comp        B0,#1                  ; F_HFK == 1 ?
            jnz         %23                    ; Wenn nicht 1
            move        L1,#1.L                ; max_uw_satz = 1
%23:        comp        B0,#2                  ; F_HFK == 2 ?
            jnz         %24                    ; Wenn nicht 2
            move        L1,#2.L                ; max_uw_satz = 2
%24:        etag        %25,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",I0             ; F_HFK=daten[offset]
%25:        adds        L7,#1.L                ; offset ++
;           jump        %31                    ; weiter mit F_LZ

%31:        move        S1, "F_LZ"
            tabseek     "NAME",S1              ; tabseek("NAME","F_LZ")
            jz          %nio_7                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %32                    ; Wenn nicht 'n'
            etag        %41,"F_LZ"             ; if (F_LZ)
            ergi        "F_LZ",#$FFFF.I        ; F_LZ=-1
            jump        %41                    ; weiter mit F_UWB_ERW

%32:        etag        %33,"F_LZ"             ; if (F_LZ)
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            ergi        "F_LZ",I0              ; F_LZ=daten[offset]
%33:        adds        L7,#1.L                ; offset ++
;           jump        %41                    ; weiter mit F_UWB_ERW

%41:        move        S1, "F_UWB_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_UWB_ERW")
            jz          %nio_8                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %44                    ; Wenn nicht 'n'

            move        IA,#0                  ; i=0
%42a:       etag        %42b,"F_UW_ANZ"        ; if (F_UW_ANZ)
            ergi        "F_UW_ANZ",#0.I        ; F_UW_ANZ=0
%42b:       etag        %43,"F_UW_KM"          ; if (F_UW_KM)
            move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;
            move        I1,#0.I                ; Setze Highword=0
            asl         L0,#3.B                ; 3 nach links schieben (*8)
            ergl        "F_UW_KM",L0           ; F_UW_KM   = daten[offset]

%43:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jz          %43a                   ; Wenn gleich dann fertig
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner dann Fehler

            move        L7,L0                  ; offset = temp
            adds        IA,#1                  ; i = i + 1
            comp        IA,#3                  ; i == 3
            jge         %nio_11                ; Fehler

            enewset                            ; new_set_of_results()
            jump        %42a                   ; naechster

%43a:       enewset                            ; new_set_of_results()
            move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%44:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner

            etag        %45,"F_UW_KM"          ; if (F_UW_KM)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "FUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "FUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%45:        etag        %46,"F_UW_ANZ"         ; if (F_UW_ANZ)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "FUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "FUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%46:        move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%endio:     move        <2>,L7                 ; Offset = offset
            move        <4>,L1                 ; Max_UW_Satz = max_uw_satz
            push        #1.L                   ; TRUE
            jump        %end

%nio_1:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table FDetailStruktur not found"
            jump        %nio_table

%nio_2:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table FDetailStruktur not found"
            jump        %nio_table

%nio_3:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table FDetailStruktur wrong format"
            jump        %nio_table

%nio_4:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table FArtTexteErweitert not found"
            jump        %nio_table

%nio_5:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","ARTTEXT in table FArtTexteErweitert string to long"
            jump        %nio_table

%nio_6:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_HFK in table FDetailStruktur not found"
            jump        %nio_table

%nio_7:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_LZ in table FDetailStruktur not found"
            jump        %nio_table

%nio_8:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_UWB_ERW in table FDetailStruktur not found"
            jump        %nio_table

%nio_9:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table FUmweltMatrix not found"
            jump        %nio_table

%nio_10:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table FUmweltTexte not found"
            jump        %nio_table

%nio_11:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Datalen not valid"
            jump        %nio_table

%nio_12:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table PCodeTexte not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_shadow_memory_kwp2000_detail(Daten, Offset, UW_Erw, Max_UW_Satz)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx                            xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L0           temp
; L1           max_uw_satz
; L2           datenlaenge
; IA (L5)      i
; A6 (L5)      n
; A7 (L5)      f_art_anz
; L6           trapmask
; L7           offset
; S1           puffer
;---------------------------------------------------------------
decode_shadow_memory_kwp2000_detail: AX VW VW VW
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            tabset      "IDetailStruktur"
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            move        L1,#3.L                ; max_uw_satz = 3
            move        L7,<2>                 ; offset = Offset
            slen        L2,<1>                 ; datenlaenge = datalen(daten)
            move        S1, "F_ART_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_ERW")
            jz          %nio_2                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %11                    ; Wenn nicht 'n'

            etag        %21,"F_ART_ANZ"        ; if (F_ART_ANZ)
            ergi        "F_ART_ANZ",#0.I       ; F_ART_ANZ=0
            jump        %21                    ; weiter mit F_P_CODE

%11:        etag        %19,"F_ART_ANZ"        ; if (F_ART_ANZ)
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %18                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %18                    ; Wenn 'y'

            strlen      L0,S1
            comp        L0,#8                  ; strlen(puffer)=8
            jnz         %nio_3                 ; Wenn nicht 8

            move        A7,#$30                ; f_art_anz='0'
            move        IA,#0                  ; i=0

%12:        comp        IA,#8                  ; while
            jz          %14

            comp        S1[IA],#$30            ; Puffer[i] = '0'=30
            jl          %nio_3                 ; Wenn kleiner '0'
            comp        S1[IA],#$38            ; Puffer[i] = '8'=38
            jg          %nio_3                 ; Wenn groesser '8'

            comp        S1[IA],A7              ; Puffer[i] = Fart_anz
            jle         %13                    ; Fart_anz kleiner als Puffer
            move        A7,S1[IA]              ; Fart_anz = Puffer

%13:        adds        IA,#1.I                ; i++
            jump        %12                    ; end while

%14:        move        I0,#0                  ; temp=0
            move        B0,A7                  ; temp=f_art_anz
            subb        B0,#$30                ; temp=temp-'0'
            ergi        "F_ART_ANZ",I0         ; F_ART_ANZ=temp

            move        S1[#1000],S1[#0]#9     ; Maske nach hinten schieben

            tabset      "IArtTexteErweitert"
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?

            move        A6,#$31                ; n='1'
%15:        comp        A6,A7                  ; while
            jg          %19

            move        S1,"xxxxxxxx"          ; Puffer="xxxxxxxx"
            move        IA,#0                  ; i=0

%16:        comp        IA,#8                  ; while
            jz          %17

            move        I0,#1000               ; temp=1000 (Maskenoffset)
            adds        I0,IA                  ; temp=temp+i
            comp        S1[I0],A6              ; Puffer[temp]=n
            jnz         %16a                   ; wenn nicht n

            move        I0,#7                  ; temp=7
            subb        I0,IA                  ; temp=temp-i

            move        B2,<1>[L7]             ; temp2 = daten[offset]
            lsr         B2,I0                  ; temp2 >> temp
            and         B2,#1                  ; temp2 & 01
            adds        B2,#$30                ; temp2 + '0'

            move        S1[IA],B2              ; Puffer[i]=temp2

%16a:       adds        IA,#1.I                ; i++
            jump        %16                    ; end while

%17:        tabseek     "ARTMASKE",S1          ; tabseek("ARTMASKE",text)
            tabget      S1,"ARTNR"             ; tabget(Puffer, "ARTNR")
            a2fix       L0,S1                  ; temp=atoi(Puffer)
            move        S1,"F_ARTi_NR"         ; text="F_ARTi_NR"
            move        S1[#5],A6              ; text[5]=temp
            ergl        S1,L0                  ; F_ARTi_NR=temp

            tabget      S1,"ARTTEXT"           ; tabget(Puffer, "ARTTEXT")

            strlen      L0,S1                  ; temp=strlen(S1)
            adds        L0,#1                  ; temp++
            comp        L0,#500
            jg          %nio_5                 ; string zu lang ?

            move        S1[#500],S1[#0]L0      ; Arttext nach hinten schieben
            move        S1,"F_ARTi_TEXT"       ; text="F_ARTi_TEXT"
            move        S1[#5],A6              ; text[5]=n
            ergs        S1,S1[#500]L0          ; F_ARTi_TEXT=Puffer(L0)

            adds        A6,#1                  ; n++
            jump        %15                    ; end while

%18:        ergi        "F_ART_ANZ",#1.I       ; F_ART_ANZ=1
            move        L0,#0                  ; temp=0
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            ergl        "F_ART1_NR",L0         ; F_ART1_NR=temp
            ergs        "F_ART1_TEXT","--"
;           jump        %19

%19:        adds        L7,#1.L                ; offset ++
;           jump        %21                    ; weiter mit F_P_CODE

%21:        tabset      "IDetailStruktur"
            move        S1, "F_PCODE"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE")
            jz          %21i                   ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %21f                   ; Wenn nicht 'n'

%21i:       etag        %21h,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",#0.I         ; F_PCODE = 0
%21h:       etag        %21g,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            ergs        "F_PCODE_STRING","--"  ; F_PCODE_STRING = "--"
%21g:       etag        %210,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
            ergs        "F_PCODE_TEXT",""      ; F_PCODE_TEXT = ""
            jump        %210                   ; weiter mit F_PCODE7

%21f:       move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %21e,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",I0           ; F_PCODE = daten[offset]

%21e:       etag        %21d,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            jump        %21c                   ; ja
%21d:       etag        %21b,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
;           jump        %21c                   ; ja

%21c:       tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %21b2,"F_PCODE_STRING" ; if (F_PCODE_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE_STRING",S1    ; F_PCODE_STRING=Puffer

%21b2:      etag        %21b1,"F_PCODE_TEXT"   ; if (F_PCODE_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE_TEXT",S1      ; F_PCODE_TEXT=Puffer

%21b1:      tabset      "IDetailStruktur"      ; wieder zurueck

%21b:       adds        L7,#2.L                ; offset = offset + 2
;           jump        %210                   ; weiter mit F_PCODE7

%210:       tabset      "IDetailStruktur"
            move        S1, "F_PCODE7"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE7")
            jz          %210i                  ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %210f                  ; Wenn nicht 'n'

%210i:      etag        %210h,"F_PCODE7"       ; if (F_PCODE7)
            ergw        "F_PCODE7",#0.I        ; F_PCODE7 = 0
%210h:      etag        %210g,"F_PCODE7_STRING"; if (F_PCODE_STRING7)
            ergs        "F_PCODE7_STRING","--" ; F_PCODE7_STRING = "--"
%210g:      etag        %21a,"F_PCODE7_TEXT"   ; if (F_PCODE7_TEXT)
            ergs        "F_PCODE7_TEXT",""     ; F_PCODE7_TEXT = ""
            jump        %21a                   ; weiter mit F_HFK

%210f:      move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %210e,"F_PCODE7"       ; if (F_PCODE)
            ergw        "F_PCODE7",I0          ; F_PCODE7 = daten[offset]

%210e:      etag        %210d,"F_PCODE7_STRING"; if (F_PCODE7_STRING)
            jump        %210c                  ; ja
%210d:      etag        %210b,"F_PCODE7_TEXT"  ; if (F_PCODE7_TEXT)
;           jump        %210c                  ; ja

%210c:      tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %210b2,"F_PCODE7_STRING" ; if (F_PCODE7_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE7_STRING",S1   ; F_PCODE7_STRING=Puffer

%210b2:     etag        %210b1,"F_PCODE7_TEXT" ; if (F_PCODE7_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE7_TEXT",S1     ; F_PCODE7_TEXT=Puffer

%210b1:     tabset      "IDetailStruktur"      ; wieder zurueck

%210b:      adds        L7,#2.L                ; offset = offset + 2
;           jump        %21a                   ; weiter mit F_HFK

%21a:       move        S1, "F_HFK"
            tabseek     "NAME",S1              ; tabseek("NAME","F_HFK")
            jz          %nio_6                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %22                    ; Wenn nicht 'n'
            etag        %31,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",#$FFFF.I       ; F_HFK=-1
            jump        %31                    ; weiter mit F_LZ

%22:        move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            comp        B0,#1                  ; F_HFK == 1 ?
            jnz         %23                    ; Wenn nicht 1
            move        L1,#1.L                ; max_uw_satz = 1
%23:        comp        B0,#2                  ; F_HFK == 2 ?
            jnz         %24                    ; Wenn nicht 2
            move        L1,#2.L                ; max_uw_satz = 2
%24:        etag        %25,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",I0             ; F_HFK=daten[offset]
%25:        adds        L7,#1.L                ; offset ++
;           jump        %31                    ; weiter mit F_LZ

%31:        move        S1, "F_LZ"
            tabseek     "NAME",S1              ; tabseek("NAME","F_LZ")
            jz          %nio_7                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %32                    ; Wenn nicht 'n'
            etag        %41,"F_LZ"             ; if (F_LZ)
            ergi        "F_LZ",#$FFFF.I        ; F_LZ=-1
            jump        %41                    ; weiter mit F_UWB_ERW

%32:        etag        %33,"F_LZ"             ; if (F_LZ)
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            ergi        "F_LZ",I0              ; F_LZ=daten[offset]
%33:        adds        L7,#1.L                ; offset ++
;           jump        %41                    ; weiter mit F_UWB_ERW

%41:        move        S1, "F_UWB_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_UWB_ERW")
            jz          %nio_8                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %44                    ; Wenn nicht 'n'

            move        IA,#0                  ; i=0
%42a:       etag        %42b,"F_UW_ANZ"        ; if (F_UW_ANZ)
            ergi        "F_UW_ANZ",#0.I        ; F_UW_ANZ=0
%42b:       etag        %43,"F_UW_KM"          ; if (F_UW_KM)
            move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;
            move        I1,#0.I                ; Setze Highword=0
            asl         L0,#3.B                ; 3 nach links schieben (*8)
            ergl        "F_UW_KM",L0           ; F_UW_KM   = daten[offset]

%43:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jz          %43a                   ; Wenn gleich dann fertig
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner dann Fehler

            move        L7,L0                  ; offset = temp
            adds        IA,#1                  ; i = i + 1
            comp        IA,#3                  ; i == 3
            jge         %nio_11                ; Fehler

            enewset                            ; new_set_of_results()
            jump        %42a                   ; naechster

%43a:       enewset                            ; new_set_of_results()
            move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%44:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner

            etag        %45,"F_UW_KM"          ; if (F_UW_KM)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "IUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "IUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%45:        etag        %46,"F_UW_ANZ"         ; if (F_UW_ANZ)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "IUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "IUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%46:        move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%endio:     move        <2>,L7                 ; Offset = offset
            move        <4>,L1                 ; Max_UW_Satz = max_uw_satz
            push        #1.L                   ; TRUE
            jump        %end

%nio_1:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table IDetailStruktur not found"
            jump        %nio_table

%nio_2:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table IDetailStruktur not found"
            jump        %nio_table

%nio_3:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table IDetailStruktur wrong format"
            jump        %nio_table

%nio_4:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table IArtTexteErweitert not found"
            jump        %nio_table

%nio_5:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","ARTTEXT in table IArtTexteErweitert string to long"
            jump        %nio_table

%nio_6:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_HFK in table IDetailStruktur not found"
            jump        %nio_table

%nio_7:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_LZ in table IDetailStruktur not found"
            jump        %nio_table

%nio_8:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_UWB_ERW in table IDetailStruktur not found"
            jump        %nio_table

%nio_9:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table IUmweltMatrix not found"
            jump        %nio_table

%nio_10:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table IUmweltTexte not found"
            jump        %nio_table

%nio_11:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Datalen not valid"
            jump        %nio_table

%nio_12:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table PCodeTexte not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; decode_history_memory_kwp2000_detail(Daten, Offset, UW_Erw, Max_UW_Satz)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx                            xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L0           temp
; L1           max_uw_satz
; L2           datenlaenge
; IA (L5)      i
; A6 (L5)      n
; A7 (L5)      f_art_anz
; L6           trapmask
; L7           offset
; S1           puffer
;---------------------------------------------------------------
decode_history_memory_kwp2000_detail: AX VW VW VW
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            tabset      "HDetailStruktur"
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?

            move        L1,#3.L                ; max_uw_satz = 3
            move        L7,<2>                 ; offset = Offset
            slen        L2,<1>                 ; datenlaenge = datalen(daten)
            move        S1, "F_ART_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_ART_ERW")
            jz          %nio_2                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %11                    ; Wenn nicht 'n'

            etag        %21,"F_ART_ANZ"        ; if (F_ART_ANZ)
            ergi        "F_ART_ANZ",#0.I       ; F_ART_ANZ=0
            jump        %21                    ; weiter mit F_P_CODE

%11:        etag        %19,"F_ART_ANZ"        ; if (F_ART_ANZ)
            comp        S1[#0],#$6A            ; Puffer[0] = 'j'=6A
            jz          %18                    ; Wenn 'j'
            comp        S1[#0],#$79            ; Puffer[0] = 'y'=79
            jz          %18                    ; Wenn 'y'

            strlen      L0,S1
            comp        L0,#8                  ; strlen(puffer)=8
            jnz         %nio_3                 ; Wenn nicht 8

            move        A7,#$30                ; f_art_anz='0'
            move        IA,#0                  ; i=0

%12:        comp        IA,#8                  ; while
            jz          %14

            comp        S1[IA],#$30            ; Puffer[i] = '0'=30
            jl          %nio_3                 ; Wenn kleiner '0'
            comp        S1[IA],#$38            ; Puffer[i] = '8'=38
            jg          %nio_3                 ; Wenn groesser '8'

            comp        S1[IA],A7              ; Puffer[i] = Fart_anz
            jle         %13                    ; Fart_anz kleiner als Puffer
            move        A7,S1[IA]              ; Fart_anz = Puffer

%13:        adds        IA,#1.I                ; i++
            jump        %12                    ; end while

%14:        move        I0,#0                  ; temp=0
            move        B0,A7                  ; temp=f_art_anz
            subb        B0,#$30                ; temp=temp-'0'
            ergi        "F_ART_ANZ",I0         ; F_ART_ANZ=temp

            move        S1[#1000],S1[#0]#9     ; Maske nach hinten schieben

            tabset      "HArtTexteErweitert"
            jt          %nio_4,#10             ; Tabelle nicht gefunden ?

            move        A6,#$31                ; n='1'
%15:        comp        A6,A7                  ; while
            jg          %19

            move        S1,"xxxxxxxx"          ; Puffer="xxxxxxxx"
            move        IA,#0                  ; i=0

%16:        comp        IA,#8                  ; while
            jz          %17

            move        I0,#1000               ; temp=1000 (Maskenoffset)
            adds        I0,IA                  ; temp=temp+i
            comp        S1[I0],A6              ; Puffer[temp]=n
            jnz         %16a                   ; wenn nicht n

            move        I0,#7                  ; temp=7
            subb        I0,IA                  ; temp=temp-i

            move        B2,<1>[L7]             ; temp2 = daten[offset]
            lsr         B2,I0                  ; temp2 >> temp
            and         B2,#1                  ; temp2 & 01
            adds        B2,#$30                ; temp2 + '0'

            move        S1[IA],B2              ; Puffer[i]=temp2

%16a:       adds        IA,#1.I                ; i++
            jump        %16                    ; end while

%17:        tabseek     "ARTMASKE",S1          ; tabseek("ARTMASKE",text)
            tabget      S1,"ARTNR"             ; tabget(Puffer, "ARTNR")
            a2fix       L0,S1                  ; temp=atoi(Puffer)
            move        S1,"F_ARTi_NR"         ; text="F_ARTi_NR"
            move        S1[#5],A6              ; text[5]=temp
            ergl        S1,L0                  ; F_ARTi_NR=temp

            tabget      S1,"ARTTEXT"           ; tabget(Puffer, "ARTTEXT")

            strlen      L0,S1                  ; temp=strlen(S1)
            adds        L0,#1                  ; temp++
            comp        L0,#500
            jg          %nio_5                 ; string zu lang ?

            move        S1[#500],S1[#0]L0      ; Arttext nach hinten schieben
            move        S1,"F_ARTi_TEXT"       ; text="F_ARTi_TEXT"
            move        S1[#5],A6              ; text[5]=n
            ergs        S1,S1[#500]L0          ; F_ARTi_TEXT=Puffer(L0)

            adds        A6,#1                  ; n++
            jump        %15                    ; end while

%18:        ergi        "F_ART_ANZ",#1.I       ; F_ART_ANZ=1
            move        L0,#0                  ; temp=0
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            ergl        "F_ART1_NR",L0         ; F_ART1_NR=temp
            ergs        "F_ART1_TEXT","--"
;           jump        %19

%19:        adds        L7,#1.L                ; offset ++
;           jump        %21                    ; weiter mit F_P_CODE

%21:        tabset      "HDetailStruktur"
            move        S1, "F_PCODE"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE")
            jz          %21i                   ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %21f                   ; Wenn nicht 'n'

%21i:       etag        %21h,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",#0.I         ; F_PCODE = 0
%21h:       etag        %21g,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            ergs        "F_PCODE_STRING","--"  ; F_PCODE_STRING = "--"
%21g:       etag        %210,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
            ergs        "F_PCODE_TEXT",""      ; F_PCODE_TEXT = ""
            jump        %210                   ; weiter mit F_PCODE7

%21f:       move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %21e,"F_PCODE"         ; if (F_PCODE)
            ergw        "F_PCODE",I0           ; F_PCODE = daten[offset]

%21e:       etag        %21d,"F_PCODE_STRING"  ; if (F_PCODE_STRING)
            jump        %21c                   ; ja
%21d:       etag        %21b,"F_PCODE_TEXT"    ; if (F_PCODE_TEXT)
;           jump        %21c                   ; ja

%21c:       tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %21b2,"F_PCODE_STRING" ; if (F_PCODE_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE_STRING",S1    ; F_PCODE_STRING=Puffer

%21b2:      etag        %21b1,"F_PCODE_TEXT"   ; if (F_PCODE_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE_TEXT",S1      ; F_PCODE_TEXT=Puffer

%21b1:      tabset      "HDetailStruktur"      ; wieder zurueck

%21b:       adds        L7,#2.L                ; offset = offset + 2
;           jump        %210                   ; weiter mit F_PCODE7

%210:       tabset      "HDetailStruktur"
            move        S1, "F_PCODE7"
            tabseek     "NAME",S1              ; tabseek("NAME","F_PCODE7")
            jz          %210i                  ; nicht gefunden ?
            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %210f                  ; Wenn nicht 'n'

%210i:      etag        %210h,"F_PCODE7"       ; if (F_PCODE7)
            ergw        "F_PCODE7",#0.I        ; F_PCODE7 = 0
%210h:      etag        %210g,"F_PCODE7_STRING"; if (F_PCODE_STRING7)
            ergs        "F_PCODE7_STRING","--" ; F_PCODE7_STRING = "--"
%210g:      etag        %21a,"F_PCODE7_TEXT"   ; if (F_PCODE7_TEXT)
            ergs        "F_PCODE7_TEXT",""     ; F_PCODE7_TEXT = ""
            jump        %21a                   ; weiter mit F_HFK

%210f:      move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;

            etag        %210e,"F_PCODE7"       ; if (F_PCODE)
            ergw        "F_PCODE7",I0          ; F_PCODE7 = daten[offset]

%210e:      etag        %210d,"F_PCODE7_STRING"; if (F_PCODE7_STRING)
            jump        %210c                  ; ja
%210d:      etag        %210b,"F_PCODE7_TEXT"  ; if (F_PCODE7_TEXT)
;           jump        %210c                  ; ja

%210c:      tabsetex    "PCodeTexte","T_PCOD"  ; PCode Tabelle laden
            jt          %nio_12,#10            ; Tabelle nicht gefunden ?

            fix2hex     S1,I0                  ; itoax(Puffer,daten[offset]) --> 0x1234
            tabseek     "PCODE",S1             ; tabseek("PCODE",Puffer)

            etag        %210b2,"F_PCODE7_STRING" ; if (F_PCODE7_STRING)
            tabget      S1,"STRING"            ; tabget(Puffer,"STRING")
            ergs        "F_PCODE7_STRING",S1   ; F_PCODE7_STRING=Puffer

%210b2:     etag        %210b1,"F_PCODE7_TEXT" ; if (F_PCODE7_TEXT)
            tabget      S1,"TEXT"              ; tabget(Puffer,"TEXT")
            ergs        "F_PCODE7_TEXT",S1     ; F_PCODE7_TEXT=Puffer

%210b1:     tabset      "HDetailStruktur"      ; wieder zurueck

%210b:      adds        L7,#2.L                ; offset = offset + 2
;           jump        %21a                   ; weiter mit F_HFK

%21a:       move        S1, "F_HFK"
            tabseek     "NAME",S1              ; tabseek("NAME","F_HFK")
            jz          %nio_6                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %22                    ; Wenn nicht 'n'
            etag        %31,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",#$FFFF.I       ; F_HFK=-1
            jump        %31                    ; weiter mit F_LZ

%22:        move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            comp        B0,#1                  ; F_HFK == 1 ?
            jnz         %23                    ; Wenn nicht 1
            move        L1,#1.L                ; max_uw_satz = 1
%23:        comp        B0,#2                  ; F_HFK == 2 ?
            jnz         %24                    ; Wenn nicht 2
            move        L1,#2.L                ; max_uw_satz = 2
%24:        etag        %25,"F_HFK"            ; if (F_HFK)
            ergi        "F_HFK",I0             ; F_HFK=daten[offset]
%25:        adds        L7,#1.L                ; offset ++
;           jump        %31                    ; weiter mit F_LZ

%31:        move        S1, "F_LZ"
            tabseek     "NAME",S1              ; tabseek("NAME","F_LZ")
            jz          %nio_7                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %32                    ; Wenn nicht 'n'
            etag        %41,"F_LZ"             ; if (F_LZ)
            ergi        "F_LZ",#$FFFF.I        ; F_LZ=-1
            jump        %41                    ; weiter mit F_UWB_ERW

%32:        etag        %33,"F_LZ"             ; if (F_LZ)
            move        B0,<1>[L7]             ; Lowbyte = daten[offset]
            move        B1,#0                  ; Highbyte= 0
            ergi        "F_LZ",I0              ; F_LZ=daten[offset]
%33:        adds        L7,#1.L                ; offset ++
;           jump        %41                    ; weiter mit F_UWB_ERW

%41:        move        S1, "F_UWB_ERW"
            tabseek     "NAME",S1              ; tabseek("NAME","F_UWB_ERW")
            jz          %nio_8                 ; nicht gefunden ?

            tabget      S1,"TYP"               ; tabget(puffer, "TYP");
            or          S1[#0],#$20            ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#$6E            ; Puffer[0] = 'n'=6E
            jnz         %44                    ; Wenn nicht 'n'

            move        IA,#0                  ; i=0
%42a:       etag        %42b,"F_UW_ANZ"        ; if (F_UW_ANZ)
            ergi        "F_UW_ANZ",#0.I        ; F_UW_ANZ=0
%42b:       etag        %43,"F_UW_KM"          ; if (F_UW_KM)
            move        I1,<1>[L7]             ; temp = daten[offset]
            move        B0,B3                  ; Tausche Highbyte-Lowbyte
            move        B1,B2                  ;
            move        I1,#0.I                ; Setze Highword=0
            asl         L0,#3.B                ; 3 nach links schieben (*8)
            ergl        "F_UW_KM",L0           ; F_UW_KM   = daten[offset]

%43:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jz          %43a                   ; Wenn gleich dann fertig
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner dann Fehler

            move        L7,L0                  ; offset = temp
            adds        IA,#1                  ; i = i + 1
            comp        IA,#3                  ; i == 3
            jge         %nio_11                ; Fehler

            enewset                            ; new_set_of_results()
            jump        %42a                   ; naechster

%43a:       enewset                            ; new_set_of_results()
            move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%44:        move        L0,L7                  ; temp = offset
            adds        L0,#2.L                ; temp = temp +2 ( km )
            comp        L2,L0                  ; datenlaenge == temp
            jl          %nio_11                ; Wenn kleiner

            etag        %45,"F_UW_KM"          ; if (F_UW_KM)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "HUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "HUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%45:        etag        %46,"F_UW_ANZ"         ; if (F_UW_ANZ)
            move        <3>,#1.L               ; UW_Erw = TRUE
            tabset      "HUmweltMatrix"
            jt          %nio_9,#10             ; Tabelle nicht gefunden ?
            tabset      "HUmweltTexte"
            jt          %nio_10,#10            ; Tabelle nicht gefunden ?
            jump        %endio                 ; Okay

%46:        move        <3>,#0.L               ; UW_Erw = FALSE
            jump        %endio                 ; Okay

%endio:     move        <2>,L7                 ; Offset = offset
            move        <4>,L1                 ; Max_UW_Satz = max_uw_satz
            push        #1.L                   ; TRUE
            jump        %end

%nio_1:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table HDetailStruktur not found"
            jump        %nio_table

%nio_2:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table HDetailStruktur not found"
            jump        %nio_table

%nio_3:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_ART_ERW in table HDetailStruktur wrong format"
            jump        %nio_table

%nio_4:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table HArtTexteErweitert not found"
            jump        %nio_table

%nio_5:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","ARTTEXT in table HArtTexteErweitert string to long"
            jump        %nio_table

%nio_6:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_HFK in table HDetailStruktur not found"
            jump        %nio_table

%nio_7:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_LZ in table HDetailStruktur not found"
            jump        %nio_table

%nio_8:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","F_UWB_ERW in table HDetailStruktur not found"
            jump        %nio_table

%nio_9:     enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table HUmweltMatrix not found"
            jump        %nio_table

%nio_10:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table HUmweltTexte not found"
            jump        %nio_table

%nio_11:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Datalen not valid"
            jump        %nio_table

%nio_12:    enewset                            ; new_set_of_results()
            ergs        "JOB_MESSAGE","Table PCodeTexte not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; return_with_message(ErrorMessage, HelpMessage, Antwort, ResultName, NewSetFlag)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx                                                                   xx xx xx xx
;
; L0           temp
; L6           trapmask
; S1           puffer
;---------------------------------------------------------------
return_with_message: AX AX AX AE VX
            gettmr      L6                     ; trapmask=get_trap_mask()
            settmr      #$400.L                ; set_trap_mask(0x400)
            move        L0,<5>                 ; temp = NewSetFlag
            comp        L0,#0                  ; temp = 0 ?
            jz          %1                     ; Wenn 0
            enewset                            ; new_set_of_results()
%1:         tabset      "JobResultExtended"
            jt          %2,#10                 ; Tabelle nicht gefunden ?
            move        S1,<1>                 ; S1 = ErrorMessage
            tabseek     "SB",S1                ; tabseek("SB",S1)
            jz          %2                     ; nicht gefunden ?
            jump        %3

%2:         clrt                               ; Trapregister löschen
            tabset      "JobResult"
            jt          %nio_1,#10             ; Tabelle nicht gefunden ?
            move        S1,<1>                 ; S1 = ErrorMessage
            tabseek     "SB",S1                ; tabseek("SB",S1)
            jz          %nio_2                 ; Eintrag nicht gefunden ?

%3:         tabget      S1,"STATUS_TEXT"       ; tabget(puffer, "STATUS_TEXT");
            ergs        "JOB_STATUS",S1        ; JOB_STATUS = S1

            move        S1,<2>                 ; S1 = HelpMessage
            comp        S1[#0],#0              ; Puffer[0] = '\0'
            jz          %4                     ; Wenn '\0'
            ergs        "JOB_MESSAGE",S1       ; JOB_MESSAGE = S1

%4:         move        S1,<4>                 ; S1 = ResultName
            comp        S1[#0],#0              ; Puffer[0] = '\0'
            jz          %5                     ; Wenn '\0'
            etag        %5,<4>                 ; wenn RESULT <4> angefordert
            ergy        <4>,<3>                ; antwort nach RESULT <4>

%5:         push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Table JobResultExtended and JobResult not found"
            jump        %nio_table

%nio_2:     ergs        "JOB_MESSAGE","Text in Table JobResultExtended and JobResult not found"
            jump        %nio_table

%nio_table: ergs        "JOB_STATUS","ERROR_TABLE"
            push        #0.L                   ; FALSE
;           jump        %end

%end:       clrt                               ; Trapregister löschen
            settmr      L6                     ; set_trap_mask(trapmask)
            eoj                                ; Jobende ( return )
;end

;---------------------------------------------------------------
; make2of3(Ergebnis, Daten, Offset, Count)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx               xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L0           temp
; L2           datenlaenge
; I6           start1
; I7           start2
; I8           start3
; I9           anz
;---------------------------------------------------------------
make2of3: AW AX VX VX
            clear       <1>                    ; Ergebnis loeschen
            move        L0,<3>                 ; temp = Offset
            comp        L0,#0                  ;
            jl          %nio_1                 ; Wenn < 0
            move        I6,I0                  ; start1 = offset;
            adds        L0,<4>                 ; temp = temp + Count
            move        I7,I0                  ; start2 = offset + Count;
            adds        L0,<4>                 ; temp = temp + Count
            move        I8,I0                  ; start3 = offset + Count + Count;
            adds        L0,<4>                 ; temp = temp + Count
            slen        L2,<2>                 ; datenlaenge = datalen(Daten)
            comp        L0,L2
            jg          %nio_2                 ; Wenn > datenlaenge
            move        L0,<4>                 ; temp = Count
            move        I9,I0                  ; anz =  Count;

            move        IA,I6                  ; pos1 = start1
            move        IB,I7                  ; pos2 = start2
            move        IC,#0                  ; i = 0

%1:         comp <2>[IA],<2>[IB]               ; daten[pos1] == daten[pos2] ?
            jnz         %2                     ; Wenn !=
            adds        IA,#1                  ; pos1 ++
            adds        IB,#1                  ; pos2 ++
            adds        IC,#1                  ; pos2 ++
            comp        IC,I9                  ; i == anz ?
            jl          %1                     ; Wenn i < anz
            move        <1>,<2>[I6]I9          ; Ergebnis = daten[start1],anzahl
            jump        %io                    ; fertig

%2:         move        IA,I6                  ; pos1 = start1
            move        IB,I8                  ; pos2 = start3
            move        IC,#0                  ; i = 0

%3:         comp <2>[IA],<2>[IB]               ; daten[pos1] == daten[pos2] ?
            jnz         %4                     ; Wenn !=
            adds        IA,#1                  ; pos1 ++
            adds        IB,#1                  ; pos2 ++
            adds        IC,#1                  ; pos2 ++
            comp        IC,I9                  ; i == anz ?
            jl          %3                     ; Wenn i < anz
            move        <1>,<2>[I6]I9          ; Ergebnis = daten[start1],anzahl
            jump        %io                    ; fertig

%4:         move        IA,I7                  ; pos1 = start2
            move        IB,I8                  ; pos2 = start3
            move        IC,#0                  ; i = 0

%5:         comp <2>[IA],<2>[IB]               ; daten[pos1] == daten[pos2] ?
            jnz         %nio                   ; Wenn !=
            adds        IA,#1                  ; pos1 ++
            adds        IB,#1                  ; pos2 ++
            adds        IC,#1                  ; pos2 ++
            comp        IC,I9                  ; i == anz ?
            jl          %5                     ; Wenn i < anz
            move        <1>,<2>[I7]I9          ; Ergebnis = daten[start2],anzahl
;           jump        %io                    ; fertig

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Invalid Offset"
            jump        %nio

%nio_2:     ergs        "JOB_MESSAGE","Invalid Count"
            jump        %nio

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; BRstandard(Ergebnis, Daten)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx                        xx xx xx xx
;
; B0           temp
; L2           datenlaenge
; S1           puffer
;---------------------------------------------------------------
BRstandard: AW AX
            clear       <1>                    ; Ergebnis loeschen
            slen        L2,<2>                 ; datenlaenge = datalen(Daten)
            comp        L2,#6
            jnz         %nio_1                 ; Wenn ungleich 6
            move        B0,<2>[#0]             ; 1. Byte nach temp
            comp        B0,#0.B                ; Wenn ungleich 0
            jz          %1                     ; BMW Format

            y2bcd       <1>,<2>[#3]#3          ; Drei Byte BCD nach ASCII
            spaste      <1>[#0],<2>[#0]#3      ; Drei Zeichen ASCII davor
            jump        %io                    ; fertig

%1:         y2bcd       <1>,<2>[#0]#6          ; BCD nach ASCII
            serase      <1>[#0],#5             ; Fuehrende Nullen loeschen
;           jump        %io                    ; fertig

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio_1:     ergs        "JOB_MESSAGE","Invalid Len"
            jump        %nio

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end


;---------------------------------------------------------------
; gettimerticks()
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx xx
;
; L0           temp
; L0           Stunde,  Tag
; L1           Minute,  Monat
; L2           Sekunde, Jahr
; L3           Ergebnis
; S1           puffer
;---------------------------------------------------------------
gettimerticks:
            time        S1                     ; Zeit holen
            move        L0,#0                  ; Std = 0
            move        B0,S1[#0]              ; Std belegen
            mult        L0,#3600               ; Std in [s]

            move        L1,#0                  ; Min = 0
            move        B4,S1[#1]              ; Min belegen
            mult        L1,#60                 ; Min in [s]

            move        L2,#0                  ; Sek = 0
            move        B8,S1[#2]              ; Sek belegen

            move        L3,L2                  ; Erg = Sek
            adds        L3,L1                  ; Erg = Erg + Min
            adds        L3,L0                  ; Erg = Erg + Std

            date        S1                     ; Datum holen
            move        L0,#0                  ; Tag = 0
            move        B0,S1[#0]              ; Tag belegen

            move        L1,#0                  ; Mon = 0
            comp        S1[#1],#1              ; Januar
            jnz         %2                     ; wenn nicht
            move        L1,#0                  ; Mon in [d]
            jump        %20
%2:         comp        S1[#1],#2              ; Februar
            jnz         %3
            move        L1,#31
            jump        %20
%3:         comp        S1[#1],#3              ; Maerz
            jnz         %4
            move        L1,#59
            jump        %20
%4:         comp        S1[#1],#4              ; April
            jnz         %5
            move        L1,#90
            jump        %20
%5:         comp        S1[#1],#5              ; Mai
            jnz         %6
            move        L1,#120
            jump        %20
%6:         comp        S1[#1],#6              ; Juni
            jnz         %7
            move        L1,#151
            jump        %20
%7:         comp        S1[#1],#7              ; Juli
            jnz         %8
            move        L1,#181
            jump        %20
%8:         comp        S1[#1],#8              ; August
            jnz         %9
            move        L1,#212
            jump        %20
%9:         comp        S1[#1],#9              ; September
            jnz         %10
            move        L1,#243
            jump        %20
%10:        comp        S1[#1],#10             ; Oktober
            jnz         %11
            move        L1,#273
            jump        %20
%11:        comp        S1[#1],#11             ; November
            jnz         %12
            move        L1,#304
            jump        %20
%12:        comp        S1[#1],#12             ; Dezember
            jnz         %20
            move        L1,#334
            jump        %20

%20:        move        L2,#0                  ; Jah = 0
            move        B8,S1[#2]              ; Jah belegen
            and         B8,#$0F                ; !! Ueberlauf alle 16 Jahre
            move        A0,B8                  ; temp = Jah
            mult        L2,#365                ; Joh in [d]

            comp        A0,#0                  ; Schaltjahr ?
            jz          %21
            comp        A0,#4                  ; Schaltjahr ?
            jz          %21
            comp        A0,#8                  ; Schaltjahr ?
            jz          %21
            comp        A0,#12                 ; Schaltjahr ?
            jz          %21
            jump        %22
%21:        adds        L2,#1                  ; Schaltjahr

%22:        move        L4,L0                  ; temp = Tag
            adds        L4,L1                  ; temp = temp + Mon
            adds        L4,L2                  ; temp = temp + Jah
            mult        L4,#86400              ; Tag in [s]

            adds        L3,L4                  ; Erg = Erg + Tag

            push        L3
;end

;---------------------------------------------------------------
; is_char_numeric(Wert)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx
;
; L0           temp
;---------------------------------------------------------------
is_char_numeric: VX
            move        L0,<1>                 ; temp = Wert
            comp        B0,#$30
            jl          %nio                   ; < '0'
            comp        B0,#$39
            jg          %nio                   ; > '9'

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; is_char_upper(Wert)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx
;
; L0           temp
;---------------------------------------------------------------
is_char_upper: VX
            move        L0,<1>                 ; temp = Wert
            comp        B0,#$41
            jl          %nio                   ; < 'A'
            comp        B0,#$5A
            jg          %nio                   ; > 'Z'

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; is_char_lower(Wert)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx
;
; L0           temp
;---------------------------------------------------------------
is_char_lower: VX
            move        L0,<1>                 ; temp = Wert
            comp        B0,#$61
            jl          %nio                   ; < 'a'
            comp        B0,#$7A
            jg          %nio                   ; > 'z'

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; strupper(String)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx
;
; I0           i
; I1           len
;---------------------------------------------------------------
strupper: AW
            strlen      I1,<1>           ; len = strlen(String)
            move        I0,#0.I          ; i=0
%1:         comp        I0,I1            ; while
            jz          %io
            comp        <1>[I0],#$61
            jl          %2               ; < 'a'
            comp        <1>[I0],#$7A
            jg          %2               ; > 'z'
            subb        <1>[I0],#$20

%2:         adds        I0,#1.I          ; i++
            jump        %1               ; end while

%io:        push        #1.L             ; TRUE
;end

;---------------------------------------------------------------
; strlower(String)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx
;
; I0           i
; I1           len
;---------------------------------------------------------------
strlower: AW
            strlen      I1,<1>           ; len = strlen(String)
            move        I0,#0.I          ; i=0
%1:         comp        I0,I1            ; while
            jz          %io
            comp        <1>[I0],#$41
            jl          %2               ; < 'A'
            comp        <1>[I0],#$5A
            jg          %2               ; > 'Z'
            adds        <1>[I0],#$20

%2:         adds        I0,#1.I          ; i++
            jump        %1               ; end while

%io:        push        #1.L             ; TRUE
;end

;---------------------------------------------------------------
; get_argument(Argument,Nr)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
;
;---------------------------------------------------------------
get_argument: AW VX
            pars        <1>,<2>
            jz          %nio

%io:        push        #1.L                   ; TRUE
            jump        %end

%nio:       push        #0.L                   ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; convert_kwp2000_to_kwp2000_star(Auftrag)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx
;
; B0 (L0)  temp
; I0 (L0)  temp
; S1       Puffer
;---------------------------------------------------------------
convert_kwp2000_to_kwp2000_star: AW
            slen        I0,<1>           ; temp = datalen(Auftrag)
            comp        I0,#0            ; temp == 0 ?
            jz          %nio             ; ja -> Fehler

            move        B0,<1>[#0]       ; temp = Auftrag[0]
            and         B0,#$3F          ; temp = temp & 0x3F
            comp        B0,#0            ; temp == 0 ?
            jz          %1               ; ja -> goto %1

            clear       S1               ; Puffer loeschen
            move        S1[#0],B0        ; Puffer[0] = temp
            spaste      <1>[#3],s1       ; datainsert(Auftrag,Puffer,3);

%1:         move        <1>[#0],#$B8.B   ; Auftrag[0] = 0xB8

%io:        push        #1.L             ; TRUE
            jump        %end

%nio:       push        #0.L             ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; convert_kwp2000_to_lin_kwp2000(SLAVE_ADRESSE,Auftrag)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx
;
; B0 (L0)  temp
; I0 (L0)  temp
; S1       Puffer
;---------------------------------------------------------------
convert_kwp2000_to_lin_kwp2000: VX AW
            slen        I0,<2>           ; temp = datalen(Auftrag)
            comp        I0,#0            ; temp == 0 ?
            jz          %nio             ; ja -> Fehler

            move        B0,<2>[#0]       ; temp = Auftrag[0]
            and         B0,#$3F          ; temp = temp & 0x3F
            comp        B0,#0            ; temp == 0 ?
            jz          %nio             ; ja -> Fehler
            comp        B0,#60           ; temp > 60 ?
            jg          %nio             ; ja -> Fehler

            clear       S1               ; Puffer loeschen
            move        S1[#0],#$A6      ; Puffer[0] = 0xA6
            move        S1[#1],<1>       ; Puffer[1] = SLAVE_ADRESSE
            move        S1[#2],B0        ; Puffer[2] = temp
            spaste      <2>[#3],s1       ; datainsert(Auftrag,Puffer,3);
            adds        <2>[#0],#3       ; Auftrag[0] = Auftrag[0] + 3

%io:        push        #1.L             ; TRUE
            jump        %end

%nio:       push        #0.L             ; FALSE
            ergs        "JOB_STATUS","ERROR_TELEGRAM_LEN_OUT_OFF_RANGE"
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; generate_data_lin_kwp2000_to_kwp2000(Daten,Auftrag)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx     xx xx                                                            xx xx xx xx
;
; B0 (L0)  temp
; I0 (L0)  temp
; B2 (L0)  SID
; I2 (L1)  datalen_daten
; L6       trapmask
; S1       Puffer
;---------------------------------------------------------------
generate_data_lin_kwp2000_to_kwp2000: AW AW
            gettmr      L6               ; trapmask=get_trap_mask()
            slen        I2,<1>           ; datalen_daten = datalen(daten)
            comp        I2,#0            ; datalen_daten = 0 ?
            jz          %io              ; ja -> iO
            comp        I2,#4            ; datalen_daten < 4 ?
            jl          %nio_1           ; ja -> Fehler

            move        I0,#0            ; temp = 0
            move        B0,<1>[#2]       ; temp = LLEN
            adds        B0,#3            ; temp = temp + 3
            comp        I0,I2            ; temp <> datalen_daten ?
            jnz         %nio_1           ; ja -> Fehler

            serase      <1>[#0],#3       ; Erste 3 Byte löschen

            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "JobResult"      ; tabset("JobResult")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?
            comp        <1>[#0],#$7F     ; daten[0] == 0x7F ?
            jnz         %1               ; nein -> goto %1

            fix2hex     S1,<1>[#2]       ;
            tabseek     "SB",S1          ; tab_suche_index("SB",daten[2])
            tabget      S1,"STATUS_TEXT" ;
            ergs        "JOB_STATUS",S1  ;
            jump        %endnio          ; Fehler !

%1:         slen        I0,<2>           ; temp = datalen(auftrag)
            comp        I0,#0            ; temp = 0 ?
            jz          %io              ; ja -> Keine SID Überprüfung
            comp        <2>[#0],#$B8     ; auftrag[0] == 0xB8 ?
            jz          %2               ; ja -> goto %2

            comp        I0,#7            ; temp < 7 ?
            jl          %io              ; ja -> Keine SID Überprüfung
            move        B2,<2>[#6]       ; SID = auftrag[6]
            adds        B2,#$40          ; SID = SID + 0x40
            comp        <1>[#0],B2       ; daten[0] <> SID ?
            jnz         %nio_2           ; ja -> Fehler
            jump        %io              ; io

%2:         comp        I0,#8            ; temp < 8 ?
            jl          %io              ; ja -> Keine SID Überprüfung
            move        B2,<2>[#7]       ; SID = auftrag[7]
            adds        B2,#$40          ; SID = SID + 0x40
            comp        <1>[#0],B2       ; daten[0] <> SID ?
            jnz         %nio_2           ; ja -> Fehler
;           jump        %io              ; io

%io:        push        #1.L             ; TRUE
            jump        %end

%nio_table: ergs        "JOB_MESSAGE","Table JobResult not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%nio_1:     ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LIN_LEN"
            jump        %endnio          ; Fehler !

%nio_2:     ergs        "JOB_STATUS","ERROR_ECU_INCORRECT_LIN_RESPONSE_ID"
            jump        %endnio          ; Fehler !

%endnio:    push        #0.L             ; FALSE
;           jump        %end

%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; generate_dynamically_data_from_arguments(buffer, argumentspalte)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx                                               xx xx xx xx
;
; B0 (L0)  i
; B1 (L0)  n
; I1 (L0)  size
; I2 (L1)  id
; I3 (L1)  k
; I4 (L2)  anzahl
; L6       trapmask
; S1       Puffer
;---------------------------------------------------------------
generate_dynamically_data_from_arguments: AW AX
            gettmr      L6               ; trapmask=get_trap_mask()
            clear       <1>              ; dataclear(buffer)

            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "MesswerteTab"   ; tabset("MesswerteTab")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?

            move        B0,#2            ; i = 2
            move        I3,#0.I          ; k = 0
            move        I4,#1.I          ; anzahl = 1
%1:         pars        S1,B0            ; Puffer = Argument(i)
            jz          %io              ; if (!exist(Argument) %io

            strcmp      S1,"-"           ; Argument(i) = "-"
            jnz         %nio_arg5        ; Argument nicht gültig ?
            tabseek     <2>,S1           ; tabseek(argumentspalte,Argument(i))
            jt          %nio_table1,#10  ; Tabellenspalte nicht gefunden ?
            jz          %nio_arg2        ; Argument nicht gefunden ?

            move        <1>[I3],#2.B     ; buffer[k] = 2
            move        <1>[I3,#1],B8    ; buffer[k+1] = anzahl

                                         ; Datentyp size ermitteln
            tabget      S1,"DATENTYP"    ; tabget(Puffer, "DATENTYP");
            move        B1,#0            ; n = 0
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            move        I1,#0.I          ; size = 0

            comp        S1[B1],#'u'      ; Puffer[n] = 'u'nsigned
            jnz         %2               ; nein -> goto %2
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %5

%2:         comp        S1[B1],#'s'      ; Puffer[n] = 's'igned
            jnz         %21              ; nein -> goto %21
            move        B1,#7            ; n = 7
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %5

%21:        comp        S1[B1],#'m'      ; Puffer[n] = 'm'otorola
            jnz         %22              ; nein -> goto %22
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %3

%22:        comp        S1[B1],#'i'      ; Puffer[n] = 'i'ntel oder 'i'nteger
            jnz         %3               ; nein -> goto %3
            move        B1,#4            ; n = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[B1],#'l'      ; Puffer[n] = inte'l'
            jnz         %61              ; nein -> goto %61 (integer)
            move        B1,#6            ; n = 6
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %3

%3:         comp        S1[B1],#'f'      ; Puffer[n] = 'f'loat
            jnz         %4               ; nein -> goto %4
            move        I1,#4.I          ; size = 4
            jump        %typ_ok

%4:         comp        S1[B1],#'d'      ; Puffer[n] = 'd'ouble
            jnz         %5               ; nein -> goto %5
            move        I1,#8.I          ; size = 8
            jump        %typ_ok

%5:         comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %6               ; nein -> goto %6
            move        I1,#1.I          ; size = 1
            jump        %typ_ok

%6:         comp        S1[B1],#'i'      ; Puffer[n] = 'i'nteger
            jnz         %7               ; nein -> goto %7
%61:        move        I1,#2.I          ; size = 2
            jump        %typ_ok

%7:         comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            jump        %typ_ok

%typ_ok:    move        <1>[I3,#2],I1    ; buffer[k+2] = size
            adds        I4,I1            ; anzahl = anzahl + size
            comp        I4,#$100         ;
            jg          %nio_arg4        ; anzahl überlauf

                                         ; ID ermitteln
            tabget      S1,"ID"          ; tabget(Puffer, "ID");
            a2fix       I2,S1            ; id = atoi(Puffer);
            move        <1>[I3,#3],B5    ; buffer[k+3] = id(high)
            move        <1>[I3,#4],B4    ; buffer[k+4] = id(Low)

            move        <1>[I3,#5],#1.B  ; buffer[k+5] = 1
            adds        I3,#6            ; k = k + 6

            adds        B0,#1            ; i = i + 1
            comp        B0,#43           ; Maximal 1..43 Argumente
            jle         %1               ; Wenn kleiner gleich 43

            pars        S1,B0            ; Puffer = Argument(i)
            jz          %io              ; if (!exist(Argument) %io
            jump        %nio_arg1        ; Zu viele Argumente

%nio_arg1:  ergs        "JOB_MESSAGE","Too much arguments"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg2:  ergs        "JOB_MESSAGE","Argument not found"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg3:  ergs        "JOB_MESSAGE","Datatype not found"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg4:  ergs        "JOB_MESSAGE","Size overflow"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg5:  ergs        "JOB_MESSAGE","Argument not valid"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%io:        push        #1.L             ; TRUE
            jump        %end

%nio_table: ergs        "JOB_MESSAGE","Table MesswerteTab not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%nio_table1:ergs        "JOB_MESSAGE","Table MesswerteTab column not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%endnio:    push        #0.L             ; FALSE
;           jump        %end

%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; create_dynamically_results_from_data(daten, argumentspalte)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx xx xx  xx xx xx xx  xx xx xx xx  xx xx xx     xx xx xx xx               xx xx xx xx  xx xx xx xx
;
; B0 (L0)  i
; B1 (L0)  n
; I1 (L0)  size
; I2 (L1)  id
; I3 (L1)  datalen_daten
; I4 (L2)  pos
; I5 (L2)  itemp
; I6 (L3)  strlen_einheit
; BE (L3)  datentyp
; I8 (L4)  strlen_text
; I9 (L4)  strlen_info
; L6       trapmask
; L7       temp
; S1       Puffer
;          ab [#400] Zwischenpuffer Float, Double
;          ab [#500] Zwischenpuffer Einheit
;          ab [#600] Zwischenpuffer Hex String
;          ab [#600] Zwischenpuffer Resultname
;          ab [#700] Zwischenpuffer Diskreter Text
;          ab [#800] Zwischenpuffer Info Text
; F0       r
; F1       rtemp
;---------------------------------------------------------------
create_dynamically_results_from_data: AW AX
            gettmr      L6               ; trapmask=get_trap_mask()
            settmr      #$400.L          ; set_trap_mask(0x400)
            tabset      "MesswerteTab"   ; tabset("MesswerteTab")
            jt          %nio_table,#10   ; Tabelle nicht gefunden ?

            move        B0,#2            ; i = 2
            move        I4,#0.I          ; pos = 0
            slen        I3,<1>           ; datalen_daten = datalen(daten)

%0001:      pars        S1,B0            ; Puffer = Argument(i)
            jz          %9002            ; if (!exist(Argument) %9002

            strcmp      S1,"-"           ; Argument(i) = "-"
            jnz         %nio_arg7        ; Argument nicht gültig ?
            tabseek     <2>,S1           ; tabseek(argumentspalte,Argument(i))
            jt          %nio_table1,#10  ; Tabellenspalte nicht gefunden ?
            jz          %nio_arg2        ; Argument nicht gefunden ?

            tabget      S1,"INFO"        ; tabget(Puffer, "INFO");
            jt          %0002,#10        ; Spalte nicht gefunden ?
            strlen      I9,S1            ; strlen_einheit = strlen(EINHEIT)
            adds        I9,#1            ; '\0' noch dazu
            move        S1[#800],S1[#0]I9; Info nach hinten schieben
            jump        %0003

%0002:      clrt                         ; Trapregister löschen
            move        S1[#800],#'-'    ; wenn nicht gefunden dann "-"
            move        S1[#801],#0
            move        I9,#1

%0003:      tabget      S1,"EINHEIT"     ; tabget(Puffer, "EINHEIT");
            strlen      I6,S1            ; strlen_einheit = strlen(EINHEIT)
            adds        I6,#1            ; '\0' noch dazu
            move        S1[#500],S1[#0]I6; Einheit nach hinten schieben
            or          S1[#0],#$20      ; Puffer[0] = Puffer[0] | 0x20 --> Kleinbuchstabe
            or          S1[#1],#$20      ; Puffer[1] = Puffer[1] | 0x20 --> Kleinbuchstabe
            or          S1[#2],#$20      ; Puffer[2] = Puffer[2] | 0x20 --> Kleinbuchstabe
            strcmp      S1,"0/1"         ; Digitaler Wert
            jz          %3001            ; nein -> goto %3001
; Digitaler Wert
                                         ; Datentyp size ermitteln
            tabget      S1,"DATENTYP"    ; tabget(Puffer, "DATENTYP");
            move        L7,#0.L          ; temp = 0
            move        B1,#0            ; n = 0
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            move        I1,#0.I          ; size = 0

            comp        S1[B1],#'u'      ; Puffer[n] = 'u'nsigned
            jnz         %4002            ; nein -> goto %4002
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %4003

%4002:      comp        S1[B1],#'s'      ; Puffer[n] = 's'igned
            jnz         %4003            ; nein -> goto %4003
            move        B1,#7            ; n = 7
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %4003

%4003:      comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %4004            ; nein -> goto %4004
            move        I1,#1.I          ; size = 1
            move        L7,#0.L
            move        AC,<1>[I4]
            jump        %typ_ok4

%4004:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'ntel oder 'i'nteger
            jnz         %4007            ; nein -> goto %4007
            move        B1,#4            ; n = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[B1],#'l'      ; Puffer[n] = inte'l'
            jz          %nio_arg3        ; ja -> goto %nio_arg3
            move        I1,#2.I          ; size = 2
            move        L7,#0.L
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %4005            ; nein -> goto %4005
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            jump        %typ_ok4
%4005:      move        AC,<1>[I4,#1]
            move        AD,<1>[I4]
            jump        %typ_ok4

%4007:      comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            move        L7,#0.L
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %4008            ; nein -> goto %4008
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            move        AE,<1>[I4,#2]
            move        AF,<1>[I4,#3]
            jump        %typ_ok4
%4008:      move        AC,<1>[I4,#3]
            move        AD,<1>[I4,#2]
            move        AE,<1>[I4,#1]
            move        AF,<1>[I4]
;           jump        %typ_ok4

%typ_ok4:   tabget      S1,"RESULTNAME"
            ergd        S1,L7

            strlen      I5,S1            ; itemp = strlen(RESULTNAME)
            comp        I5,#63           ; itemp == 63
            jg          %nio_res         ; nein -> goto %nio_res
            subb        I5,#4            ; zurück auf ..._'WERT'
            comp        I5,#0            ; itemp == 0
            jl          %4101            ; nein -> goto %4101
            or          S1[I5],#$20      ; Puffer[itemp]   = Puffer[itemp]   | 0x20 --> Kleinbuchstabe
            comp        S1[I5],#'w'
            jnz         %4101            ; nein -> goto %4101
            or          S1[I5,#1],#$20   ; Puffer[itemp+1] = Puffer[itemp+1] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#1],#'e'
            jnz         %4101            ; nein -> goto %4101
            or          S1[I5,#2],#$20   ; Puffer[itemp+2] = Puffer[itemp+2] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#2],#'r'
            jnz         %4101            ; nein -> goto %4101
            or          S1[I5,#3],#$20   ; Puffer[itemp+3] = Puffer[itemp+3] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#3],#'t'
            jnz         %4101            ; nein -> goto %4101
            jump        %nio_res         ; nein -> goto %nio_res

%4101:      tabget      S1,"RESULTNAME"
            strlen      I5,S1            ; itemp = strlen(RESULTNAME)
            comp        I5,#58           ; itemp == 63-5
            jg          %nio_res         ; nein -> goto %nio_res
            move        S1[I5],#'_'
            move        S1[I5,#1],#'I'
            move        S1[I5,#2],#'N'
            move        S1[I5,#3],#'F'
            move        S1[I5,#4],#'O'
            move        S1[I5,#5],#0     ; Puffer[itemp] = ..."_INFO"
            ergs        S1,S1[#800]I9    ; RESULT_INFO = INFO

ergl "Wert",L7

            comp        L7,#0.L          ; temp = 0
            jz          %mk_pos          ; ja -> goto %mk_pos
            comp        L7,#1.L          ; temp = 1
            jz          %mk_pos          ; ja -> goto %mk_pos
            ergs        "JOB_MESSAGE","Warning: Digital value not valid"
            jump        %mk_pos          ; ja -> goto %mk_pos
;           jump        %nio_dig         ; nein -> goto %nio_dig
                                         ; fertig

%3001:      strcmp      S1,"0-n"         ; Diskreter Wert
            jz          %2001            ; nein -> goto %2001
; Diskreter Wert
                                         ; Datentyp size ermitteln
            tabget      S1,"DATENTYP"    ; tabget(Puffer, "DATENTYP");
            move        L7,#0.L          ; temp = 0
            move        B1,#0            ; n = 0
            move        BE,#0            ; datentyp = 0
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            move        I1,#0.I          ; size = 0
            comp        S1[B1],#'u'      ; Puffer[n] = 'u'nsigned
            jnz         %3002            ; nein -> goto %3002
            move        B1,#9            ; n = 9
            move        BE,#4            ; datentyp = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %3003

%3002:      comp        S1[B1],#'s'      ; Puffer[n] = 's'igned
            jnz         %3003            ; nein -> goto %3003
            move        B1,#7            ; n = 7
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %3003

%3003:      comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %3004            ; nein -> goto %3004
            move        I1,#1.I          ; size = 1
            move        L7,#0.L
            move        AC,<1>[I4]
            jump        %typ_ok3

%3004:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'ntel oder 'i'nteger
            jnz         %3007            ; nein -> goto %3007
            move        B1,#4            ; n = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[B1],#'l'      ; Puffer[n] = inte'l'
            jz          %nio_arg3        ; ja -> goto %nio_arg3
            move        I1,#2.I          ; size = 2
            adds        BE,#1.B          ; datentyp = datentyp + 1
            move        L7,#0.L
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %3005            ; nein -> goto %3005
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            jump        %typ_ok3
%3005:      move        AC,<1>[I4,#1]
            move        AD,<1>[I4]
            jump        %typ_ok3

%3007:      comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            adds        BE,#2.B          ; datentyp = datentyp + 2
            move        L7,#0.L
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %3008            ; nein -> goto %3008
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            move        AE,<1>[I4,#2]
            move        AF,<1>[I4,#3]
            jump        %typ_ok3
%3008:      move        AC,<1>[I4,#3]
            move        AD,<1>[I4,#2]
            move        AE,<1>[I4,#1]
            move        AF,<1>[I4]
;           jump        %typ_ok3

%typ_ok3:   tabget      S1,"RESULTNAME"
            ; Ergebnisse zuweisen

            comp        BE,#6            ; datentyp -> unsigned long
            jnz         %3101            ; nein -> goto %3101
            ergd        S1,L7
            jump        %3106

%3101:      comp        BE,#2            ; datentyp -> signed long
            jnz         %3102            ; nein -> goto %3102
            ergl        S1,L7
            jump        %3106

%3102:      comp        BE,#5            ; datentyp -> unsigned int
            jnz         %3103            ; nein -> goto %3103
            ergw        S1,IE
            jump        %3106

%3103:      comp        BE,#1            ; datentyp -> signed int
            jnz         %3104            ; nein -> goto %3104
            ergi        S1,IE
            jump        %3106

%3104:      comp        BE,#4            ; datentyp -> unsigned char
            jnz         %3105            ; nein -> goto %3105
            ergb        S1,AC
            jump        %3106

%3105:      ergc        S1,AC            ; datentyp -> signed char
;           jump        %3106

%3106:      strlen      I5,S1            ; itemp = strlen(RESULTNAME)
            comp        I5,#63           ; itemp == 63
            jg          %nio_res         ; nein -> goto %nio_res
            subb        I5,#4            ; zurück auf ..._'WERT'
            comp        I5,#0            ; itemp == 0
            jl          %nio_res         ; nein -> goto %nio_res
            or          S1[I5],#$20      ; Puffer[itemp]   = Puffer[itemp]   | 0x20 --> Kleinbuchstabe
            comp        S1[I5],#'w'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#1],#$20   ; Puffer[itemp+1] = Puffer[itemp+1] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#1],#'e'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#2],#$20   ; Puffer[itemp+2] = Puffer[itemp+2] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#2],#'r'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#3],#$20   ; Puffer[itemp+3] = Puffer[itemp+3] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#3],#'t'
            jnz         %nio_res         ; nein -> goto %nio_res

            move        S1[I5],#'E'
            move        S1[I5,#1],#'I'
            move        S1[I5,#2],#'N'
            move        S1[I5,#3],#'H'   ; Puffer[itemp] = ..._"EINH"
            ergs        S1,S1[#500]I6    ; RESULT_EINH = EINHEIT

            move        S1[I5],#'I'
            move        S1[I5,#1],#'N'
            move        S1[I5,#2],#'F'
            move        S1[I5,#3],#'O'   ; Puffer[itemp] = ..._"INFO"
            ergs        S1,S1[#800]I9    ; RESULT_INFO = INFO

            adds        I5,#5            ; wieder ans Ende + '\0' noch dazu
            move        S1[#600],S1[#0]I5; Resultname nach hinten schieben

            tabget      S1,"NAME"        ; tabget(Puffer, "Name");
            strcmp      S1,"-"           ; Puffer == "-"
            jnz         %mk_pos          ; Keine Tabelle fertig

            tabset      S1               ; tabset(Name)
            jt          %nio_table2,#10  ; Tabelle nicht gefunden ?
            tabseeku    "WERT",L7        ; tab_suche_unsigned("WERT")
;           jz          %nio_arg6        ; nicht gefunden ?
            tabget      S1,"TEXT"        ; tabget(Puffer, "TEXT");
            tabset      "MesswerteTab"   ; wieder zur Tabelle "MesswerteTab" zurück

            strlen      I8,S1            ; strlen_text = strlen(TEXT)
            adds        I8,#1            ; '\0' noch dazu
            move        S1[#700],S1[#0]I8; Text nach hinten schieben

            move        S1[#0],S1[#600]I5; Resultname wieder nach unten schieben
            subb        I5,#5            ; zurück auf ..._'WERT'
            move        S1[I5],#'T'
            move        S1[I5,#1],#'E'
            move        S1[I5,#2],#'X'
            move        S1[I5,#3],#'T'   ; Puffer[itemp] = ..._"TEXT"
            ergs        S1,S1[#700]I8    ; RESULT_TEXT = TEXT
            jump        %mk_pos          ; fertig

%2001:      strcmp      S1,"hex"         ; Hex String
            jz          %1001            ; nein -> goto %1001
; Hex String
                                         ; Datentyp size ermitteln
            tabget      S1,"DATENTYP"    ; tabget(Puffer, "DATENTYP");
            move        L7,#0.L          ; temp = 0
            move        B1,#0            ; n = 0
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            move        I1,#0.I          ; size = 0

            comp        S1[B1],#'u'      ; Puffer[n] = 'u'nsigned
            jnz         %2002            ; nein -> goto %2002
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %2003

%2002:      comp        S1[B1],#'s'      ; Puffer[n] = 's'igned
            jnz         %2003            ; nein -> goto %2003
            move        B1,#7            ; n = 7
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
;           jump        %2003

%2003:      comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %2004            ; nein -> goto %2004
            move        I1,#1.I          ; size = 1
            move        AC,<1>[I4]
            fix2hex     S1,AC
            move        S1[#600],S1[#2]#3; Hex String ohne 0x nach hinten schieben
            jump        %typ_ok2

%2004:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'ntel oder 'i'nteger
            jnz         %2007            ; nein -> goto %2007
            move        B1,#4            ; n = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[B1],#'l'      ; Puffer[n] = inte'l'
            jz          %nio_arg3        ; ja -> goto %nio_arg3
            move        I1,#2.I          ; size = 2
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %2005            ; nein -> goto %2005
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            jump        %2006
%2005:      move        AC,<1>[I4,#1]
            move        AD,<1>[I4]
%2006:      fix2hex     S1,IE
            move        S1[#600],S1[#2]#5; Hex String ohne 0x nach hinten schieben
            jump        %typ_ok2

%2007:      comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %2008            ; nein -> goto %2008
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            move        AE,<1>[I4,#2]
            move        AF,<1>[I4,#3]
            jump        %2009
%2008:      move        AC,<1>[I4,#3]
            move        AD,<1>[I4,#2]
            move        AE,<1>[I4,#1]
            move        AF,<1>[I4]
%2009:      fix2hex     S1,L7
            move        S1[#600],S1[#2]#9; Hex String ohne 0x nach hinten schieben
            jump        %typ_ok2

%typ_ok2:   tabget      S1,"RESULTNAME"
            ergs        S1,S1[#600]#9
            jump        %mk_einh        ; fertig

; Analogwerte
                                         ; Datentyp size ermitteln
%1001:      tabget      S1,"DATENTYP"    ; tabget(Puffer, "DATENTYP");
            move        L7,#0.L          ; temp = 0
            move        B1,#0            ; n = 0
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            move        I1,#0.I          ; size = 0

            comp        S1[B1],#'u'      ; Puffer[n] = 'u'nsigned
            jnz         %1009            ; nein -> goto %1009
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe

            comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %1002            ; nein -> goto %1002
            move        I1,#1.I          ; size = 1
            move        AC,<1>[I4]
            fix2flt     F0,L7            ; r=daten[pos]size
            jump        %typ_ok1

%1002:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'nteger
            jnz         %1005            ; nein -> goto %1005
            move        I1,#2.I          ; size = 2
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %1003            ; nein -> goto %1003
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            jump        %1004
%1003:      move        AC,<1>[I4,#1]
            move        AD,<1>[I4]
%1004:      fix2flt     F0,L7            ; r=daten[pos]size
            jump        %typ_ok1

%1005:      comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %1006            ; nein -> goto %1006
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            move        AE,<1>[I4,#2]
            move        AF,<1>[I4,#3]
            jump        %1007
%1006:      move        AC,<1>[I4,#3]
            move        AD,<1>[I4,#2]
            move        AE,<1>[I4,#1]
            move        AF,<1>[I4]
%1007:      fix2flt     F0,L7            ; r=daten[pos]size
            comp        L7,#0            ; temp == 0
            jge         %1008            ; ja -> goto %1008
            a2flt       F1,"4294967296"  ; rtemp = 0x100000000
            fadd        F0,F1            ; r = r + rtemp
%1008:      jump        %typ_ok1

%1009:      comp        S1[B1],#'s'      ; Puffer[n] = 's'igned
            jnz         %1010            ; nein -> goto %1010
            move        B1,#7            ; n = 7
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %1015

%1010:      comp        S1[B1],#'m'      ; Puffer[n] = 'm'otorola
            jnz         %1012            ; nein -> goto %1012
            move        B1,#9            ; n = 9
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe

            comp        S1[B1],#'f'      ; Puffer[n] = 'f'loat
            jnz         %1011            ; nein -> goto %1011
            move        I1,#4.I          ; size = 4
            move        S1[#400],<1>[I4]#4 ; Puffer[400] = daten[pos]
            swap        S1[#400]#4       ; Motorola-Format
            y42flt      F0,S1[#400]      ; r = Puffer[400]
            jump        %typ_ok1

%1011:      comp        S1[B1],#'d'      ; Puffer[n] = 'd'ouble
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#8.I          ; size = 8
            move        S1[#400],<1>[I4]#8 ; Puffer[400] = daten[pos]
            swap        S1[#400]#8       ; Motorola-Format
            y82flt      F0,S1[#400]      ; r = Puffer[400]
            jump        %typ_ok1

%1012:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'ntel oder 'i'nteger
            jnz         %1013            ; nein -> goto %1013
            move        B1,#4            ; n = 4
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[B1],#'l'      ; Puffer[n] = inte'l'
            jnz         %1018            ; nein -> goto %1018 (integer)
            move        B1,#6            ; n = 6
            or          S1[B1],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            jump        %1013

%1013:      comp        S1[B1],#'f'      ; Puffer[n] = 'f'loat
            jnz         %1014            ; nein -> goto %1014
            move        I1,#4.I          ; size = 4
            y42flt      F0,<1>[I4]       ; r = daten[pos]
            jump        %typ_ok1

%1014:      comp        S1[B1],#'d'      ; Puffer[n] = 'd'ouble
            jnz         %1015            ; nein -> goto %1015
            move        I1,#8.I          ; size = 8
            y82flt      F0,<1>[I4]       ; r = daten[pos]
            jump        %typ_ok1

%1015:      comp        S1[B1],#'c'      ; Puffer[n] = 'c'har
            jnz         %1017            ; nein -> goto %1017
            move        I1,#1.I          ; size = 1
            move        AC,<1>[I4]
            comp        L7,#$7F          ; temp == 127
            jle         %1016            ; nein -> goto %1016
            subb        L7,#$100         ; temp = temp - 256
%1016:      fix2flt     F0,L7            ; r=daten[pos]size
            jump        %typ_ok1

%1017:      comp        S1[B1],#'i'      ; Puffer[n] = 'i'nteger
            jnz         %1022            ; nein -> goto %1022
%1018:      move        I1,#2.I          ; size = 2

            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %1019            ; nein -> goto %1019
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            jump        %1020
%1019:      move        AC,<1>[I4,#1]
            move        AD,<1>[I4]
%1020:      comp        L7,#$7FFF        ; temp == 32767
            jle         %1021            ; nein -> goto %1021
            subb        L7,#$10000       ; temp = temp - 65536
%1021:      fix2flt     F0,L7            ; r=daten[pos]size
            jump        %typ_ok1

%1022:      comp        S1[B1],#'l'      ; Puffer[n] = 'l'ong
            jnz         %nio_arg3        ; nein -> goto %nio_arg3
            move        I1,#4.I          ; size = 4
            tabget      S1,"L/H"         ; tabget(Puffer, "L/H");
            or          S1[#0],#$20      ; Puffer[n] = Puffer[n] | 0x20 --> Kleinbuchstabe
            comp        S1[#0],#'l'      ; Puffer[n] = 'l'
            jnz         %1023            ; nein -> goto %1023
            move        AC,<1>[I4]
            move        AD,<1>[I4,#1]
            move        AE,<1>[I4,#2]
            move        AF,<1>[I4,#3]
            jump        %1024
%1023:      move        AC,<1>[I4,#3]
            move        AD,<1>[I4,#2]
            move        AE,<1>[I4,#1]
            move        AF,<1>[I4]
%1024:      fix2flt     F0,L7            ; r=daten[pos]size
            jump        %typ_ok1

%typ_ok1:   tabget      S1,"MUL"
            strcmp      S1,"-"           ; Puffer == "-"
            jnz         %1101            ; ja -> goto %1101
            a2flt       F1,S1            ; rtemp = ator(Puffer)
            fmul        F0,F1            ; r = r * rtemp

%1101:      tabget      S1,"DIV"
            strcmp      S1,"-"           ; Puffer == "-"
            jnz         %1102            ; ja -> goto %1102
            a2flt       F1,S1            ; rtemp = ator(Puffer)
            a2flt       F2,"0"           ; rtemp2 = 0
            fcomp       F1,F2            ; F1 = 0
            jz          %nio_div         ; ja -> goto %nio_div
            fdiv        F0,F1            ; r = r / rtemp

%1102:      tabget      S1,"ADD"
            strcmp      S1,"-"           ; Puffer == "-"
            jnz         %mk_real         ; ja -> goto %mk_real
            a2flt       F1,S1            ; rtemp = ator(Puffer)
            fadd        F0,F1            ; r = r + rtemp

%mk_real:   tabget      S1,"RESULTNAME"
            ergr        S1,F0

%mk_einh:   strlen      I5,S1            ; itemp = strlen(RESULTNAME)
            comp        I5,#63           ; itemp == 63
            jg          %nio_res         ; nein -> goto %nio_res
            subb        I5,#4            ; zurück auf ..._'WERT'
            comp        I5,#0            ; itemp == 0
            jl          %nio_res         ; nein -> goto %nio_res
            or          S1[I5],#$20      ; Puffer[itemp]   = Puffer[itemp]   | 0x20 --> Kleinbuchstabe
            comp        S1[I5],#'w'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#1],#$20   ; Puffer[itemp+1] = Puffer[itemp+1] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#1],#'e'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#2],#$20   ; Puffer[itemp+2] = Puffer[itemp+2] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#2],#'r'
            jnz         %nio_res         ; nein -> goto %nio_res
            or          S1[I5,#3],#$20   ; Puffer[itemp+3] = Puffer[itemp+3] | 0x20 --> Kleinbuchstabe
            comp        S1[I5,#3],#'t'
            jnz         %nio_res         ; nein -> goto %nio_res

            move        S1[I5],#'E'
            move        S1[I5,#1],#'I'
            move        S1[I5,#2],#'N'
            move        S1[I5,#3],#'H'   ; Puffer[itemp] = ..._"EINH"
            ergs        S1,S1[#500]I6    ; RESULT_EINH = EINHEIT

            move        S1[I5],#'I'
            move        S1[I5,#1],#'N'
            move        S1[I5,#2],#'F'
            move        S1[I5,#3],#'O'   ; Puffer[itemp] = ..._"INFO"
            ergs        S1,S1[#800]I9    ; RESULT_INFO = INFO

;           jump        %mk_pos          ; fertig

%mk_pos:    adds        I4,I1            ; pos = pos + size
            comp        I4,I3            ; pos == datalen_daten ?
            jg          %nio_arg4        ; Zu wenig Daten

            adds        B0,#1            ; i = i + 1
            comp        B0,#43           ; Maximal 1..43 Argumente
            jle         %0001            ; Wenn kleiner gleich 43

            pars        S1,B0            ; Puffer = Argument(i)
            jz          %9002            ; if (!exist(Argument) %9002
            jump        %nio_arg1        ; Zu viele Argumente

%9002:      comp        I4,I3            ; pos == datalen_daten ?
            jl          %nio_arg5        ; Zu viele Daten
            jump        %io              ; komplett fertig

%nio_dig:   ergs        "JOB_MESSAGE","Digital value not valid"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_res:   ergs        "JOB_MESSAGE","Resultname not valid"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_div:   ergs        "JOB_MESSAGE","Division by zero"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg1:  ergs        "JOB_MESSAGE","Too much arguments"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg2:  ergs        "JOB_MESSAGE","Argument not found"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg3:  ergs        "JOB_MESSAGE","Datatype not found"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg4:  ergs        "JOB_MESSAGE","Too less data"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg5:  ergs        "JOB_MESSAGE","Too much data"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg6:  ergs        "JOB_MESSAGE","Discrete value not found"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%nio_arg7:  ergs        "JOB_MESSAGE","Argument not valid"
            ergs        "JOB_STATUS","ERROR_ARGUMENT"
            jump        %endnio          ; Fehler !

%io:        push        #1.L             ; TRUE
            jump        %end

%nio_table: ergs        "JOB_MESSAGE","Table MesswerteTab not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%nio_table1:ergs        "JOB_MESSAGE","Table MesswerteTab column not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%nio_table2:ergs        "JOB_MESSAGE","Discrete value table not found"
            ergs        "JOB_STATUS","ERROR_TABLE"
            clrt                         ; Trapregister löschen
            jump        %endnio          ; Fehler !

%endnio:    push        #0.L             ; FALSE
;           jump        %end

%end:       settmr      L6               ; set_trap_mask(trapmask)
;end

;---------------------------------------------------------------
; is_unsigned_string(String)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx
;
; B0 (L0)  index
; B1 (L0)  maxlen
;---------------------------------------------------------------
is_unsigned_string: AX
            move        B0,#0            ; index = 0
            move        B1,#10           ; maxlen = 10
            comp        S1[B0],#0        ; Leerstring ?
            jz          %nio             ; ja -> goto %nio

            comp        S1[B0],#'+'
            jnz         %0001            ; nein -> goto %0001
            adds        B1,#1            ; maxlen++
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %nio             ; ja -> goto %nio
;           jump        %0001

%0001:      comp        S1[B0],#$30
            jl          %nio             ; < '0'
            comp        S1[B0],#$39
            jg          %nio             ; > '9'
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %io              ; ja -> goto %io
            comp        B0,B1            ; mehr als maxlen Stellen ?
            jge         %nio             ; ja -> goto %nio
            jump        %0001

%io:        push        #1.L             ; TRUE
            jump        %end

%nio:       push        #0.L             ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; is_signed_string(String)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx
;
; B0 (L0)  index
; B1 (L0)  maxlen
;---------------------------------------------------------------
is_signed_string: AX
            move        B0,#0            ; index = 0
            move        B1,#10           ; maxlen = 10
            comp        S1[B0],#0        ; Leerstring ?
            jz          %nio             ; ja -> goto %nio

            comp        S1[B0],#'-'
            jnz         %0001            ; nein -> goto %0001
            adds        B1,#1            ; maxlen++
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %nio             ; ja -> goto %nio
            jump        %0002

%0001:      comp        S1[B0],#'+'
            jnz         %0002            ; nein -> goto %0002
            adds        B1,#1            ; maxlen++
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %nio             ; ja -> goto %nio
;           jump        %0002

%0002:      comp        S1[B0],#$30
            jl          %nio             ; < '0'
            comp        S1[B0],#$39
            jg          %nio             ; > '9'
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %io              ; ja -> goto %io
            comp        B0,B1            ; mehr als maxlen Stellen ?
            jge         %nio             ; ja -> goto %nio
            jump        %0002

%io:        push        #1.L             ; TRUE
            jump        %end

%nio:       push        #0.L             ; FALSE
;           jump        %end

%end:
;end

;---------------------------------------------------------------
; is_hex_string(String)
;
; B0 B1 B2 B3  B4 B5 B6 B7  B8 B9 BA BB  BC BD BE BF  A0 A1 A2 A3  A4 A5 A6 A7  A8 A9 AA AB  AC AD AE AF
; -I0 - -I1 -  -I2 - -I3 -  -I4 - -I5 -  -I6 - -I7 -  -I8 - -I9 -  -IA - -IB -  -IC - -ID -  -IE - -IF -
; -   L0    -  -   L1    -  -   L2    -  -   L3    -  -   L4    -  -   L5    -  -   L6    -  -   L7    -
; xx xx
;
; B0 (L0)  index
; B1 (L0)  maxlen
;---------------------------------------------------------------
is_hex_string: AX
            move        B0,#0            ; index = 0
            move        B1,#10           ; maxlen = 10
            comp        S1[B0],#0        ; Leerstring ?
            jz          %nio             ; ja -> goto %nio

            comp        S1[B0],#'0'
            jnz         %nio             ; nein -> goto %nio
            adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %nio             ; ja -> goto %nio

            comp        S1[B0],#'x'
            jz          %0001            ; ja -> goto %0001
            comp        S1[B0],#'X'
            jz          %0001            ; ja -> goto %0001
            jump        %nio

%0001:      adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %nio             ; ja -> goto %nio
%0002:      comp        S1[B0],#$30
            jl          %nio             ; < '0'
            comp        S1[B0],#$39
            jg          %0003            ; > '9'
            jump        %0005

%0003:      comp        S1[B0],#$41
            jl          %nio             ; < 'A'
            comp        S1[B0],#$46
            jg          %0004            ; > 'F'
            jump        %0005

%0004:      comp        S1[B0],#$61
            jl          %nio             ; < 'a'
            comp        S1[B0],#$66
            jg          %nio             ; > 'f'
;           jump        %0005

%0005:      adds        B0,#1            ; index++
            comp        S1[B0],#0        ; Stringende ?
            jz          %io              ; ja -> goto %io
            comp        B0,B1            ; mehr als maxlen Stellen ?
            jge         %nio             ; ja -> goto %nio
            jump        %0002

%io:        push        #1.L             ; TRUE
            jump        %end

%nio:       push        #0.L             ; FALSE
;           jump        %end

%end:
;end
;eof
