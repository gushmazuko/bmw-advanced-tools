//**********************************************************************
//*
//* Nacharbeitssource für INPA
//*
//* Sourcedatei ICMV.IPS
//*
//**************************************************************************
//* History:
//* 30.03.2006 GA V0.01  Ersterstellung Grundumfang für UDS (ISO 14229)
//* 30.01.2007 GA V0.40  Ersterstellung Grundumfang ICMV ARS
//* 21.03.2007 SS V0.932 Ersterstellung Grundumfang ICMV
//* 26.03.2007 SS V0.940 Umstellung auf Diagnose DB Jobs
//* 27.03.2007 SS V0.945 Einbindung Inbetriebnahme
//* 29.03.2007 SS V0.946 Übergabe Diag Status als String in Rampenlogik
//* 02.04.2007 SS V0.947 Text für Rampenzeit in ms geändert
//* 03.04.2007 SS V0.948 Anpassung Bildschirm Rampenlogik
//* 04.04.2007 SS V0.949 nicht benötigte Variablen entfernt
//* 19.04.2007 SS V0.950 Änderung Rampenlogik, Rk Verbaukennung ohne
//*                      Funktion implementiert
//* 19.04.2007 SS V0.951 Erweiterung Rk Verbaukennung
//* 12.06.2007 SS V0.952 Anpassung Inbetriebnahme Ablauf siehe INB_L6.src
//*                      Verlegung des SG Reset unter Ansteuern statt Status
//* 13.06.2007 SS V0.953 Anpassung für den Fall, dass Job nicht vorhanden in
//*                      Inbetriebnahme
//* 19.06.2007 SS V0.955 Job für Radknoten implementiert
//*                      Result für Job Sensorabgleich implementiert
//* 20.06.2007 SS V0.956 Anpassungen in Inbetriebnahme Result
//*                      Implementierung Radknotenverbaukennung
//* 03.07.2007 SS V0.961 Darstellungsoptimierung
//* 06.07.2007 SS V0.962 Darstellungsoptimierung Radknotenverbaukennung
//* 18.07.2007 SS V0.964 ARS Eigendiagnose rudimentär implementiert
//* 01.08.2007 SS V1.000 Abgabestand I3.50
//* 03.08.2007 SS V1.020 Anpassungen für Rückwärtskompatibilität I3.15
//* 24.09.2007 SS V1.400 Erste Anpassungen an I4.00, Fehlerkorrektur I3.50
//* 26.09.2007 SS V1.410 Anpassungen im Inbetriebnahmeablauf nach Rücksprache
//*                      mit Funktionsentwicklung
//* 01.10.2007 SS V1.420 Job für Leerlaufdrehzahlanhebung integriert
//* 02.10.2007 SS V1.430 Inbetriebnahmeendekennung I-Stufenabhängig (6 oder 99)
//* 15.10.2007 SS V1.465 Abstimmung I4.00 mit A.Feine
//* 18.10.2007 SS V2.000 Abgabestand I4.00 ATS
//* 19.10.2007 SS V2.010 Einfügen ARS Daten Inbetriebnahme
//* 24.10.2007 SS V2.015 Anpassung für große Bildschirme (1280x1024)
//* 24.10.2007 SS V2.100 Anzeige Flexray Transceiver
//* 31.10.2007 SS V2.200 Ersteinbindung der Eigendiagnose als Ablauf
//* 05.11.2007 SS V2.210 Eigendiagnoseverfeinerung
//* 23.11.2007 SS V2.211 unbenutzte Teile entfernt
//*                      Änderung in Fehlerauswertung Abgleich Drucksensoren
//* 11.12.2007 SS V2.220 Ergänzung Schaltstellungsensor in Rampenlogik
//* 11.12.2007 SS V2.221 Anpassung an hohe Auflösung
//* 12.12.2007 SS V2.230 akt. Pumpendrehzahl und Motordrehzahl in LL-Anhebung
//* 14.12.2007 SS V2.231 Änderung in Fehlerauswertung Abgleich Drucksensoren
//* 16.01.2008 SS V2.300 Anpassung Daten Inbetriebnahme
//* 17.01.2008 SS V2.310 Neuer Job Predrive Daten
//**************************************************************************
#include "inpa.h"
#include "BMW_STD.H"

// Titel, Version, Verantwortung, Steuergerät
string titel  ="ICMV Vertikaldynamik Management F01"; // Titel Nacharbeitsprogramm
string version="2.310";                                 // Version Nacharbeitsprogramm
string origin ="BMW TI-432 Siegfried Helmich";          // Verantwortung Nacharbeitsprogramm
string sgbd   ="ICMV";                                  // Steuergerät
string gruppe ="G_ICMV";                                // Gruppendatei

string speicher_lesen_parameter="LAR;FLASH;UIFM;-ROMI;-ROMX;-RAMIS;-RAMIL;-RAMXX;-NVRAM";
// Moegliche Speicher-Parameter: "LAR;FLASH;UIFM;ROMI;ROMX;RAMIS;RAMIL;RAMXX;NVRAM";
// Bei Leerstring erfolgt kein Menüpunkt Speicher Lesen

// allgemeine globale Variable
string text_var;
real   zahlen_var;
int    ganz_zahl;
bool   logik_var;
string job_state;    // JOB_STATUS Variable
int    input_state;  // Eingabestatus
int input_state_VA;
int input_state_HA;
int    input_ok=0;   // Eingabe  mit OK beendet

int toggle_1;
int toggle_2;



// Ventile bestromen ANSTEUERN
real strom_sv_ventil;
real strom_rv_ventil;
real strom_va_ventil;
real strom_ha_ventil;

// Steuergeraete Reset wrid nur einmal ausgefuehrt
bool sg_reset_einmal = TRUE;
bool sv_ein_aus = FALSE;
bool rv_ein_aus = FALSE;
bool sd_ein_aus = FALSE;
bool ramp_mode_ein_aus = FALSE;
bool PropVA_ein_aus = FALSE;
bool PropHA_ein_aus = FALSE;

int strom_va_1 = 0;
int strom_ha_1 = 0;
int va_ramp_art = 0;
int ha_ramp_art = 0;
int rampenvorgabe = 0;

int va_ramp_zeit = 0;
int ha_ramp_zeit = 0;
int va_ramp_wert = 0;
int ha_ramp_wert = 0;

bool warnung_erfolgt = FALSE;

bool predrive_daten_info_einmal = FALSE;
bool predrive_daten_backup_choice = FALSE;

// start of :#include "BMW_STD.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BMW_STD.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.05.2000 rd V0.01 Ersterstellung
//* 23.06.2000 rd V0.02 Überarbeitung für E65 und E85
//* 04.07.2000 rd V0.03 Überarbeitung der Funktionen
//* 08.11.2000 rd V0.04 AIF Lesen Results überarbeitet
//* 01.03.2001 rd V0.05 m_status_flag neu hinzu
//* 02.03.2001 rd V0.06 m_steuern_flag neu hinzu
//* 18.05.2001 rd V0.07 AIF-Ausgabe verbessert
//* 25.04.2002 rd V0.08 Erweiterung HS_LESEN
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Erweiterung Ident für DS2
//* 19.11.2002 rd V1.02 FS_MODE erweitert um PCODEs
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//*            rd V2.00 Entfernung EldiAuftragLesen, EldiAuftragEingeben
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Hinweis im Hauptfenster, wenn Simulationsmodus aktiv ist.
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//**********************************************************************
string package="3.01";

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************

// Umrechnungsfaktoren deutsch / englisch
real   m_c    = 1.0;        // Grad Celsius -> Fahrenheit z = x * m_c + a_c
real   a_c    = 0.0;
real   m_km   = 1.0;     // km           -> miles      z = x * m_km
real   m_l    = 1.0;     // Liter        -> Gallon US  z = x * m_l

// für Info
string sgbd_ecu;
string sgbd_origin;
string sgbd_revision;
string sgbd_package;
string sgbd_sprache;
string sgbd_comment;
string gruppe_ecu;
string gruppe_origin;
string gruppe_revision;
string gruppe_comment;

// für Status-Menü
bool   m_status_flag=TRUE;
// True Status-Menü wird angezeigt

// für Steuern-Menü
bool   m_steuern_flag=TRUE;
// True Steuern-Menü wird angezeigt

// für FS_LESEN speichern
bool   fs_lesen_save_as_flag;

// für IS_LESEN speichern
bool   is_lesen_save_as_flag;

// für HS_LESEN speichern
bool   hs_lesen_save_as_flag;

// für FS_LESEN
bool   fs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LESEN
bool   is_lesen_flag;
// True wenn JOB vorhanden

// für HS_LESEN
bool   hs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LOESCHEN
bool   is_loeschen_flag;
// True wenn JOB vorhanden

// für HS_LOESCHEN
bool   hs_loeschen_flag;
// True wenn JOB vorhanden

// Handle für FS_LESEN
int    f_ort_nr_buffer   = 0;
int    f_ort_text_buffer = 0;

//  In INPA.INI wird festgelegt ob
//   nach FS- IS-, HS-Löschen automatisch wieder gelesen wird.
bool   deleteread_flag;

// Wenn Ediabas im Simulationsmode läuft, dies im Hauptfenster anzeigen
bool   simulation_flag;

// für Ident Screen, bzw. SVK Screen bei UDS (ISO 14229)
int ident_typ;
// 1= DS2
// 2= BMW Fast
// 3= UDS (ISO 14229)


// für SPEICHER_LESEN
bool   speicher_lesen_flag;
// True wenn JOB vorhanden
bool   speicher_lesen_lar_flag;
bool   speicher_lesen_uifm_flag;
bool   speicher_lesen_romi_flag;
bool   speicher_lesen_romx_flag;
bool   speicher_lesen_nvram_flag;
bool   speicher_lesen_ramis_flag;
bool   speicher_lesen_ramxx_flag;
bool   speicher_lesen_flash_flag;
bool   speicher_lesen_ramil_flag;

// für Speicher lesen Ausgabe
string speicher_lesen_text         = "";
string speicher_lesen_seg_adr_anz  = "";
string speicher_lesen_adresse      = "0x000000";
int    speicher_lesen_anzahl       = 64;

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern ScriptInit(); // befindet sich im Hauptprogramm

// start of :#include "BATTERIE.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BATTERIE.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 01.04.2004 rd V2.01 Im Fehlerfalle delay eingebaut
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* ShowBatteryIgnition
//*
//* Anzeige des Batterie- und Zündungs-Status
//*
//**********************************************************************
ShowBatteryIgnition()
{
  bool   fehlerflag;    // Fehler aufgetreten
  bool   fehlerflag2;   // Fehler aufgetreten
  bool   zuendung;      // Zündung ein/aus
  bool   batterie;      // Batterie ein/aus
  int    wert;          // allgemeine Variable

  ftextout("Batterie :", 0,5,1,0);
  ftextout("Zündung  :", 0,45,1,0);

  INPAapiJob("UTILITY","STATUS_UBATT","","");
  INP1apiResultInt(fehlerflag,wert,"STAT_UBATT",1);
  if ((fehlerflag!=TRUE) || (wert==0))
  {
    batterie=FALSE;
    zuendung=FALSE;
  }
  else
  {
    batterie=TRUE;
    INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
    INP1apiResultInt(fehlerflag2,wert,"STAT_ZUENDUNG",1);
    if ((fehlerflag2!=TRUE) || (wert==0))
      zuendung=FALSE;
    else
      zuendung=TRUE;
  }
  digitalout(batterie, 0,20,"","");
  if (batterie==TRUE)
    ftextout("ein  ", 0,25,1,0);
  else
  {
    if (fehlerflag==TRUE)
    {
      ftextout("aus  ", 0,25,1,0);
    }
    else
    {
      ftextout("---  ", 0,25,1,0);
    }
  }

  digitalout(zuendung, 0,62,"","");
  if (zuendung==TRUE)
    ftextout("ein  ", 0,67,1,0);
  else
  {
    if (fehlerflag2==TRUE)
    {
      ftextout("aus  ", 0,67,1,0);
    }
    else
    {
      ftextout("---  ", 0,67,1,0);
    }
  }

  if ((fehlerflag!=TRUE) || (fehlerflag2!=TRUE))
  {
    delay(2000);
  }
}
// -- EOF --
// end of :#include "BATTERIE.SRC"
// start of :#include "GRP_INFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GRP_INFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 EDIABAS.INI-Abfrage ob Simulationsmode aktiv ist
//* 18.10.2006 GA V3.01 Abfrage ob EDIABAS im Simulationsmodus läuft ist jetzt nicht mehr auf Pfad c:\windows\ediabas.ini beschränkt
//**********************************************************************

//**********************************************************************
//*
//* GruppenDateiInfo
//*
//* Versionsinformationen über Gruppendatei
//*
//**********************************************************************
import32 "C" lib "api32.DLL::__apiGetConfig" ApiGetConfig(in:long Handle,in: string Name,out: string Buffer, returns: int ReturnedValue);
GruppenDateiInfo( in: string grp,
                  inout: string grp_ecu, inout: string grp_origin,
                  inout: string grp_revision, inout: string grp_comment)
{
  string CurDir;
  string Temp;
  string Puffer;
  int    Size;
  long   PufferSize;
  int    ret_int;
  string BS;
  string CR;
  int    pos1;
  int    pos2;
  int    simulation;
  int    input;
  long   Handle;
  int    Returned;
  string ini_path= "??????????????????????";//Variable muß ausreichend lang vorbelegt sein!
  //                C:\ec-apps\ediabas\bin

  chr( 92, BS ); // '\'
  chr( 13, CR );

  // Pfad für EDIBAS.INI ermitteln
  // WERT 2 wurde durch Tests ermittelt
  Handle=2;
  ApiGetConfig(Handle,"EDIABASINIPATH",ini_path,Returned);
  //Abfrage, ob EDIABAS im Simulationsmodus betrieben wird. Hinweisfenster erfolgt im Hauptfenster s_main
  GetPrivateProfileInt("Configuration","Simulation",2,ini_path+BS+"ediabas.ini",simulation);
  if (simulation == 1) simulation_flag= TRUE;
  else simulation_flag= FALSE;

  Size=256;
  space(CurDir,Size);
  GetCurrentDirectory(256, CurDir, ret_int);
  SetCurrentDirectory("\EDIABAS\BIN", ret_int);

  Size=1024;
  space(Puffer,Size);
  inttolong(Size, PufferSize);
  XTRACT("\ediabas\ecu"+ BS + grp + ".grp", 1, Puffer, PufferSize, ret_int);

  grp_ecu="";
  instr(pos1, 0, Puffer, "ECU:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 4;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_ecu, Puffer, pos1, pos2 - pos1);
  }

  grp_origin="";
  instr(pos1, 0, Puffer, "ORIGIN:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 7;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_origin, Puffer, pos1, pos2 - pos1);
  }

  grp_revision="";
  instr(pos1, 0, Puffer, "REVISION:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 9;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
    midstr(grp_revision, Puffer, pos1, pos2 - pos1);
  }

  grp_comment="";
  pos1=0;
  pos2=0;
  while ((pos1 >= 0) && (pos2 >= 0))
  {
    instr(pos1, pos2, Puffer, "ECUCOMMENT:");
    if (pos1 >= 0)
    {
      pos1 = pos1 + 11;
      instr(pos2, pos1, Puffer, CR );
      if (pos2 > pos1)
      {
        midstr(Temp, Puffer, pos1, pos2 - pos1);
        grp_comment=grp_comment+Temp+",";
      }
    }
  }
  SetCurrentDirectory(CurDir, ret_int);
}
// -- EOF --
// end of :#include "GRP_INFO.SRC"
// start of :#include "SGBDINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SGBDINFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern SgbdInfo(in: string sg,
                inout: string sg_ecu, inout: string sg_origin,
                inout: string sg_revision, inout: string sg_package,
                inout: string sg_comment, inout: string sg_sprache);

//**********************************************************************
//*
//* SgbdInfo
//*
//* Versionsinformationen über SGBD
//*
//**********************************************************************
SgbdInfo( in: string sg,
          inout: string sg_ecu, inout: string sg_origin,
          inout: string sg_revision, inout: string sg_package,
          inout: string sg_comment, inout: string sg_sprache)
{
  INPAapiJob(sg,"INFO","","");
  INPAapiResultText(sg_ecu,"ECU",1,"");
  INPAapiResultText(sg_revision,"REVISION",1,"");
  INPAapiResultText(sg_package,"PACKAGE",1,"");
  INPAapiResultText(sg_origin,"ORIGIN",1,"");
  INPAapiResultText(sg_comment,"COMMENT",1,"");
  INPAapiResultText(sg_sprache,"SPRACHE",1,"");
}

// -- EOF --
// end of :#include "SGBDINFO.SRC"
// start of :#include "SGBDINPA.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SgbdInpa.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Gezielte Ausgabe, wenn Gruppendatei oder SGBD nicht existiert
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 18.10.2006 GA V3.01 Check bezüglich auf Gruppen-Simulationsdatei, sowie "Identification error" erweitert
//* 24.10.2006 GA V3.02 Überprüfung ob T_GRTB.PRG vorhanden eingebaut
//**********************************************************************

//**********************************************************************
//*
//* SgbdInpaCheck
//*
//* Überprüfung ob SGBD zu INPA passt
//*
//**********************************************************************
SgbdInpaCheck()
{
  string sgbd_version;             // für Versionskontrolle
  string inpa_version;             // für Versionskontrolle
  string inpa_sprache="deutsch"; // für Sprachvariante
  string variante="???";           // für Variantenkontrolle
  string err_text;                 // Fehlertext
  int    errorcode;                // Errorcode
  bool   fehlerflag;               // Fehlerflag
  string temp;
  string temp1;
  string temp2;
  int    i;
  int    k;
  int    kk;                       // für neue VersionsnummernKontrolle
  int    ii;
  int    a;
  int    aa;
  int    i1;
  int    i2;
  int    i3;                       // für neue VersionsnummernKontrolle
  string sgbd_String_Lang;
  string sgbd_von_inpa_version;
  string ver_temp;
  string ver_temp1;
  string ver_temp2;
  string ver_temp3="--";
  real   Version_SGBD;
  real   Version_INPA;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  int    ret_int;
  int    Size;
  int    filecheck;
  string hinweis_text;

  settitle(titel+" Version "+version);
  a=0;
  ii=0;
  i3=0;
  kk=0;
  aa=0;
  i=0;
  k=0;
  fehlerflag=FALSE;
  temp1="";
  temp2="";

  instr(i,k,","+gruppe+",",",");
  while ((i >= 0) && (fehlerflag == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppe+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppe+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(fehlerflag,variante,"VARIANTE",0,"");
      if (fehlerflag == TRUE) gruppe=temp;
      else
      {
        INP1apiErrorCode(errorcode);
        if (errorcode == 36)//Fehlende oder fehlerhafte Simulationsdatei
        {
           Size=256;
           space(CurDir,Size);
           GetCurrentDirectory(256, CurDir, ret_int);
           SetCurrentDirectory("\EDIABAS\SIM", ret_int);
           fileexist(temp+".SIM",filecheck);
           SetCurrentDirectory(CurDir, ret_int);
           if (filecheck == 0)
           {
             temp1= temp1+", "+temp+".SIM";//Fehlerhafte Simulationsdatei
           }
           else
           {
             temp2= temp2+", "+temp+".SIM";//Fehlende Simulationsdatei
           }
        }
      }
    }
  }

  instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
  instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
  if ((i == 0) || (k == 0))
       hinweis_text= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
  else hinweis_text= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an

  if (fehlerflag == FALSE)
  {
     //Fehlende oder fehlerhafte Gruppen-Simulationsdatei
     if (errorcode == 36)
     {
        //Fehlerhafte Simulationsdatei
        if (temp1 != "")
        {
          strlen(k,temp1);
          instr(i,k,temp1+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp1+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp1,temp1,1,k);//Kommata vor und hinter temp1 ausschneiden
          temp1= "Fehlerhafte Simulationsdatei: "+temp1+CRLF;
        }
        //Fehlende Simulationsdatei
        if (temp2 != "")
        {
          strlen(k,temp2);
          instr(i,k,temp2+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp2+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp2,temp2,1,k);//Kommata vor und hinter temp2 ausschneiden
          temp2= "Fehlende Simulationsdatei  : "+temp2+CRLF;
        }

        messagebox("Variantenkontrolle",
                   "Fehler!"+CRLF+
                   temp1+//Fehlerfafte Gruppen-Simulationsdateien
                   temp2+//Fehlende     -//-
                   "Das Programm wird abgebrochen!");
        exit();
     }

     //Gruppendatei vorhanden?
     Size=256;
     space(CurDir,Size);
     GetCurrentDirectory(256, CurDir, ret_int);
     SetCurrentDirectory("\EDIABAS\ECU", ret_int);
     fileexist(gruppe+".GRP",filecheck);
     SetCurrentDirectory(CurDir, ret_int);
     if (filecheck == 0)//Gruppendatei vorhanden, SGBD-, Kommunikationsfehler hier ausgeben
     {
       INP1apiErrorText(err_text);//Fehler beim Aufruf der VARIANTE?
       if (errorcode == 92)//92=SYS-0002: SG-Variantenbeschreibungsdatei (SGBD) nicht gefunden
       {
         //T_GRTB.PRG vorhanden?
         Size=256;
         space(CurDir,Size);
         GetCurrentDirectory(256, CurDir, ret_int);
         SetCurrentDirectory("\EDIABAS\ECU", ret_int);
         fileexist("T_GRTB.PRG",filecheck);
         SetCurrentDirectory(CurDir, ret_int);
         if (filecheck == 0)//T_GRTB.PRG ist vorhanden, somit fehlt die SGBD.
         {
           messagebox("Variantenkontrolle",
                      "Fehler!"+CRLF+
                      err_text+". "+CRLF+
                      " "+CRLF+
                      "Das Steuergerät läßt sich zwar über die Gruppendatei: "+gruppe+".GRP"+" ansprechen,"+CRLF+
                      "aber zur Diagnose fehlt eine entsprechende SGBD (*.PRG) im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                      " "+CRLF+
                      "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                      " "+CRLF+
                      "Das Programm wird abgebrochen!");
         }
         else//T_GRT.PRG fehlt
         {
           messagebox("Variantenkontrolle",
                     "Fehler!"+CRLF+
                     err_text+". "+CRLF+
                     " "+CRLF+
                     "Die Datei T_GRTB.PRG fehlt im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                     " "+CRLF+
                     "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                     " "+CRLF+
                     "Das Programm wird abgebrochen!");
         }
       }
       else if (errorcode == 102)//102= Identification error
       {
         instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
         instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
         if ((i == 0) || (k == 0))
              temp1= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
         else temp1= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                    hinweis_text+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
       else //alle anderen Fehler
       {
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    " "+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
     }
     else//Gruppendatei nicht vorhanden
     {
        messagebox("Variantenkontrolle",
        "Fehler! Gruppendatei : "+gruppe+".GRP "+CRLF+
        "existiert nicht im Verzeichnis ..\EDIABAS\ECU"+CRLF+
        " "+CRLF+
        "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
        " "+CRLF+
        "Das Programm wird abgebrochen!");
     }
     exit();
  }

  i1=0;
  i2=0;
  instr(i1,0,","+sgbd+",",","+variante+",");
  if (i1 < 0)
  {
    instr(i2,0,","+sgbd+",",","+variante+"/");
    if (i2 < 0)
    {
      messagebox("Variantenkontrolle",
                 "Gesuchtes Steuergerät: '"+sgbd+"' nicht gefunden. "+CRLF+
                 "Gefundenes Steuergerät: '"+variante+"'. "+CRLF+
                 " "+CRLF+
                 "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                 hinweis_text+CRLF+
                 " "+CRLF+
                 "Das Programm wird abgebrochen!");
      exit();
    }

    ver_temp3 = "--";
    instr(ii,i2,sgbd+",",",");
    if (ii >= 0)
    {
      midstr(ver_temp3,sgbd+",",i2,ii);
      instr(i3,0,ver_temp3,"/");
      if (i3 >= 0)
      {
        a = i2+i3+1;
        aa = ii-i2+i3-1;
        midstr(ver_temp3,sgbd+",",a,aa);
      }
    }
  }

  sgbd_String_Lang = sgbd;
  sgbd=variante;

//
// Info: Informatinon bei aufruf ohne BMW_STD.SRC
//
// ####################################################
// # //für Info                                       #
// #   string sgbd_ecu;                               #
// #   string sgbd_origin;                            #
// #   string sgbd_revision;                          #
// #   string sgbd_package;                           #
// #   string sgbd_sprache;                           #
// #   string sgbd_comment;                           #
// #   string gruppe_ecu;                             #
// #   string gruppe_origin;                          #
// #   string gruppe_revision;                        #
// #   string gruppe_comment;                         #
// #                                                  #
// #   #include "SgbdInfo.src"                        #
// ####################################################
//
//
  SgbdInfo(sgbd, sgbd_ecu, sgbd_origin, sgbd_revision, sgbd_package, sgbd_comment, sgbd_sprache);
// Bitte VARIABLEN als Globale variable aktivieren und Include (siehe Block //INFO)
//
//

  //Versionskontrolle Auf 3 stellen vor / hinter dem "."
  instr(i3,0,ver_temp3,"V");
  if(i3>=0)
  {
    instr(i2,0,ver_temp3,",");
    midstr(ver_temp3,ver_temp3,i3+1,i2-1);
    stringtoreal(ver_temp3,Version_INPA);
    realtostring(Version_INPA,"3.3",ver_temp3);
    midstr(sgbd_von_inpa_version,ver_temp3,0,2);
  }
  stringtoreal(version,Version_INPA);
  realtostring(Version_INPA,"3.3",version);
  midstr(inpa_version,version,0,2);

  stringtoreal(sgbd_revision,Version_SGBD);
  realtostring(Version_SGBD,"3.3",sgbd_revision);
  midstr(sgbd_version,sgbd_revision,0,2);

  temp=inpa_version;
  temp1=sgbd_version;

  if (ver_temp3 == "--")
  {
    // Vergleichen mit Versionsnummer INPA & SGBD
    if (inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!");
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }
  else
  {
    // Vergleichen mit Versionsnummer INPA(SGBD Vorwahl) & SGBD
    if (sgbd_von_inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!"+CRLF+CRLF+
                 "SGBD Version: "+ ver_temp3 +" (in INPA) "+CRLF+
                 "SGBD Version: "+ sgbd_revision +CRLF+
                 "INPA Version: "+ version);
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }

  if (inpa_sprache != sgbd_sprache)
  {
    messagebox("Sprachvariantenkontrolle",
               "Nicht zusammenpassende Sprachvariante. "+CRLF+
               "Fehlfunktion ist möglich!");
  }
}

// -- EOF --
// end of :#include "SGBDINPA.SRC"
// start of :#include "GRPCHECK.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GrpCheck.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//* 20.04.2007 GA V3.02 FS-, IS-, HS_LESEN werden in einzelnen Tempdateien in ..\EDIABAS\BIN abgelegt
//**********************************************************************

//**********************************************************************
//*
//* GroupCheck
//*
//* Überprüfung der Gruppen-Info
//*
//**********************************************************************
GroupCheck()
{
  string err_text;                 // Fehlertext
  bool   fehlerflag;               // Fehlerflag
  string temp;
  int    sgbd_saetze;              // für Funktionen-Suche in SGBD
  string job_name;                 // JOBNMAE in SGBD
  int    i;

  fehlerflag=FALSE;
  i=0;

  GruppenDateiInfo(gruppe, gruppe_ecu, gruppe_origin, gruppe_revision, gruppe_comment);

  // Vorbelegung der Flags
  fs_lesen_flag       = FALSE;
  is_lesen_flag       = FALSE;
  speicher_lesen_flag = FALSE;
  is_loeschen_flag    = FALSE;
  hs_loeschen_flag    = FALSE;

  INPAapiJob(sgbd,"_JOBS","","");

  INP1apiResultSets(fehlerflag, sgbd_saetze);
  if (fehlerflag == FALSE)
  {
    INP1apiErrorText(err_text);
    messagebox("Unerwarteter Fehler", // sollte nie kommen
                err_text+". "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }
  i = 1;
  while ( i <= sgbd_saetze)
  {
    INPAapiResultText(job_name,"JOBNAME",i,"");
    if (job_name == "FS_LESEN" )       fs_lesen_flag=TRUE;
    if (job_name == "IS_LESEN" )       is_lesen_flag=TRUE;
    if (job_name == "HS_LESEN" )       hs_lesen_flag=TRUE;
    if (job_name == "IS_LOESCHEN" )    is_loeschen_flag=TRUE;
    if (job_name == "HS_LOESCHEN" )    hs_loeschen_flag=TRUE;
    if (job_name == "SPEICHER_LESEN" ) speicher_lesen_flag=TRUE;

    if ((fs_lesen_flag == TRUE) &&
        (is_lesen_flag == TRUE) &&
        (hs_lesen_flag == TRUE) &&
        (is_loeschen_flag == TRUE) &&
        (hs_loeschen_flag == TRUE) &&
        (speicher_lesen_flag) == TRUE) i = sgbd_saetze;
    i = i + 1;
  }
  if (speicher_lesen_parameter == "")  speicher_lesen_flag = FALSE;

  if (speicher_lesen_flag == TRUE)
  {
    instr(i, 0, ";"+speicher_lesen_parameter+";", ";LAR;");
    if ( i == -1 ) speicher_lesen_lar_flag = FALSE; else speicher_lesen_lar_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";FLASH;");
    if ( i == -1 ) speicher_lesen_flash_flag = FALSE; else speicher_lesen_flash_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";UIFM;");
    if ( i == -1 ) speicher_lesen_uifm_flag = FALSE; else speicher_lesen_uifm_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMI;");
    if ( i == -1 ) speicher_lesen_romi_flag = FALSE; else speicher_lesen_romi_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIS;");
    if ( i == -1 ) speicher_lesen_ramis_flag = FALSE; else speicher_lesen_ramis_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIL;");
    if ( i == -1 ) speicher_lesen_ramil_flag = FALSE; else speicher_lesen_ramil_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";NVRAM;");
    if ( i == -1 ) speicher_lesen_nvram_flag = FALSE; else speicher_lesen_nvram_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMX;");
    if ( i == -1 ) speicher_lesen_romx_flag = FALSE; else speicher_lesen_romx_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMXX;");
    if ( i == -1 ) speicher_lesen_ramxx_flag = FALSE; else speicher_lesen_ramxx_flag = TRUE;
  }

  //IDENT-Typ ermitteln: DS2, BMW Fast oder UDS?
  INP1apiJob(sgbd,"IDENT","","");
  INP1apiResultText(fehlerflag,temp,"ID_DATUM_KW",1,"");//Hat nur DS2
  if ((fehlerflag == TRUE) && (temp != ""))
  {
    ident_typ= 1;//DS2
  }
  else//UDS, BMW Fast
  {
    INP1apiResultText(fehlerflag,temp,"ID_SGBD_INDEX",1,"");
    if ((fehlerflag == TRUE) && (temp != "")) ident_typ= 3; //Hat nur UDS (ISO 14229)
    else ident_typ= 2; //sonst BMW Fast
  }
}
// -- EOF --
// end of :#include "GRPCHECK.SRC"
// start of :#include "FS_LESEN.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen FS_LESEN.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 21.11.2000 rd V0.10 Umweltbedingungen als Zahl oder Text ( 0-n, Hex )
//* 02.03.2001 rd V0.11 Shadowspeicher umbenannt in Infospeicher
//* 25.04.2002 rd V1.00 Erweiterung HS_LESEN
//* 22.10.2002 rd V1.01 Erweiterung FS_LESEN
//*               V1.01 PCODE und PCODE7 Ausgabe neu
//*               V1.01 Fehlerbehandlung verbessert
//* 19.11.2002 iS V1.02 Fehlerbehandlung F_ORT_TEXT, F_UW_ANZ, F_PCODE
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Fehlerausgaben korrigiert und erweitert
//* 28.06.2006 GA V3.01 Bei UDS: Ausgabe "F_UW_DATUM_ZEIT" durch "F_UW_ZEIT" ersetzt, da Result entfällt
//* 19.10.2006 GA V3.02 Bei DS2: wurde nicht angezogen da if-Bedingung nicht korrekt gewesen ist.
//*            GA V3.02 Result: F_UW_ZEIT von Unterprg.: fs_protokoll_uwb in fs_protokoll_uwb_uds verschoben
//*            GA V3.02 Result: F_EREIGNIS_DTC: Text wurde inverse ausgegeben
//* 07.02.2007 GA V3.03 Result: F_EREIGNIS_DTC: Erklärender Text, was ein Ereinis DTC ist, war falsch
//**********************************************************************

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************
int    _FsMode        = 0x7FF; // alles ein
string _FsFileMode    = "w";
string _PreInfoFile   = "";
string _PostInfoFile  = "";
string _ApiFsJobName  = "FS_LESEN";

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern INPAapiFsMode_neu ( in: int FsMode, in: string FsFileMode,
                           in: string PreInfoFile, in: string PostInfoFile,
                           in: string ApiFsJobName);

extern INPAapiFsLesen_neu( in: string ecu, in: string FileName);

extern fs_protokoll_ort(in: int nr);
extern fs_protokoll_ort_uds(in: int nr);
extern fs_protokoll_PCode(in: int nr);
extern fs_protokoll_PCode7(in: int nr);
extern fs_protokoll_SAECode(in: int nr);
extern fs_protokoll_hfk(in: int nr);
extern fs_protokoll_hfk_uds(in: int nr);
extern fs_protokoll_art(in: int nr);
extern fs_protokoll_art_uds(in: int nr);
extern fs_protokoll_art_e(in: int nr);
extern fs_protokoll_uwb(in: int nr);
extern fs_protokoll_uwb_uds(in: int nr);
extern fs_protokoll_hex(in: int nr);
extern fs_protokoll_telantwort(in: int nr);

//**********************************************************************
//*
//* INPAapiFsMode_neu kompatibel mit INPAapiFsMode
//*
//**********************************************************************
INPAapiFsMode_neu(  in: int    FsMode,
                    in: string FsFileMode,
                    in: string PreInfoFile,
                    in: string PostInfoFile,
                    in: string ApiFsJobName)
{
  _FsMode       = FsMode;
  _FsFileMode   = FsFileMode;
  _PreInfoFile  = PreInfoFile;
  _PostInfoFile = PostInfoFile;
  _ApiFsJobName = ApiFsJobName;


  INPAapiFsMode(_FsMode, _FsFileMode, _PreInfoFile, _PostInfoFile, _ApiFsJobName);
  if (_ApiFsJobName=="") _ApiFsJobName="FS_LESEN";
}

//**********************************************************************
//*
//* INPAapiFsLesen_neu kompatibel mit INPAapiFsLesen
//*
//**********************************************************************
INPAapiFsLesen_neu( in: string ecu, in: string FileName)
{
  string _ecu;
  string _FileName;
  bool   rc;
  int    i;
  int    k;
  int    len;
  int    x1;
  long   xL;
  string temp1;
  string temp2;
  string temp3;
  string temp11;
  string temp12;
  string temp21;
  string temp22;
  int    F_VERSION;
  string JOB_STATUS;
  string JOB_MESSAGE;
  string VARIANTE;
  int    SETS;
  int    UW_SETS;
  string FS_CODE;
  string F_PCODE;
  string F_PCODE7;
  string F1_VERSION;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string errorcode_text;           // EDIABAS Fehlernummer als Text

  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  _ecu      = ecu;
  _FileName = FileName;


  //SGBD-Version auslesen
  sgbd_version= "???";
  INPAapiJob(_ecu,"INFO","","");
  INP1apiResultText(rc, sgbd_version, "REVISION", 1, "");

  INPAapiJob(_ecu, _ApiFsJobName,"","");
  INP1apiResultInt(rc, F_VERSION, "F_VERSION",1 );

  INP1apiErrorCode(errorcode);

//UDS:
  if ((rc == TRUE) && ( F_VERSION == 3 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort_uds(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="??????";
            StrArrayWrite(f_ort_text_buffer,i,temp1);

            INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
            if (rc == TRUE)
            {
              GetBinaryDataString (temp1,len);
              midstr(temp1,temp1,0,6);
            }
            else
            {
              temp1= "??????";
              filewrite("");
              filewrite("### Fehler beim Lesen des Results: F_HEX_CODE ###");
              filewrite("");
              INP1apiErrorCode(errorcode);
              if (errorcode != 0)
              {
                inttostring(errorcode, errorcode_text);
                INP1apiErrorText(error_text);
                error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
                ftextout(error_text ,2,0,0,0);
              }
            }
            StrArrayWrite(f_ort_nr_buffer,i,temp1);

            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort_uds(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_SAECode(1);//0x200 von BMW Fast für PCode genommen
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk_uds(1);
                k=1;

                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb_uds(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite("0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);

                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite("0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//BMW FAST:
  else if ((rc == TRUE) && ( F_VERSION == 2 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="????";

            StrArrayWrite(f_ort_text_buffer,i,temp1);
            INPAapiResultInt(x1, "F_ORT_NR", i);
            inttohexstring(x1, 4, temp1);
            StrArrayWrite(f_ort_nr_buffer,i,temp1);
            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_PCode(1);
                if ((_FsMode & 0x400) != 0) fs_protokoll_PCode7(1);
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk(1);
                k=1;
                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite( "0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                {
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                }
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);
                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite( "0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//DS2
  else if (errorcode == 134)//134=SYS-0014: Result nicht gefunden: 'F_VERSION'
  {
    INPAapiFsLesen( _ecu, _FileName);
  }
//Fehlerhafter Aufruf
  else
  {
    INPAapiCheckJobStatus("OKAY");//Damit der Bediener die Fehlermeldung bestätigen muß
    getdate(temp1);
    gettime(temp2);
    INP1apiErrorText(temp3);
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite( "");
    filewrite( "Datum    : "+temp1+" "+temp2);
    filewrite( "ECU      : "+_ecu);
    filewrite( "JobStatus: "+JOB_STATUS+"-->"+temp3) ;
    filewrite( "-------------------------------------------------------------------------------");
    fileclose();
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für DS2 und BMW Fast
//*
//**********************************************************************
fs_protokoll_ort(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  INP1apiResultInt(rc,x1, "F_ORT_NR", i);
  if (rc == TRUE)
  {
    inttohexstring(x1, 4, temp1);
  }
  else
  {
    temp1="????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für UDS (ISO 14229)
//*
//**********************************************************************
fs_protokoll_ort_uds(in: int nr)
{
  int    i;
  int    len;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");

  INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
  if (rc == TRUE)
  {
    if (_ApiFsJobName == "FS_LESEN")
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,0,6);
    }
    else//IS_LESEN
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,2,6);//Byte 0, Zeichen 0 und 1 sind das severity Byte!
    }

  }
  else
  {
    temp1= "??????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"??????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE
//*
//**********************************************************************
fs_protokoll_PCode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcodeText;
  string tempPcodeString;
  string tempPcodeHex;

  i=nr;
  INP1apiResultText(rc,tempPcodeString, "F_PCODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcodeText, "F_PCODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcodeHex);
        tempPcodeHex= "0x"+tempPcodeHex;
      }
      else
      {
        tempPcodeHex = "????";
      }
    }
    else
    {
      tempPcodeText = "????";
    }

    if (tempPcodeString == "??")
    {
      filewrite( "");
      filewrite( tempPcodeHex+"  "+tempPcodeText);
    }
    else
    {
      if (tempPcodeString != "--")
      {
        filewrite( "");
        filewrite( tempPcodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE7
//*
//**********************************************************************
fs_protokoll_PCode7(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcode7Text;
  string tempPcode7String;
  string tempPcode7Hex;

  i=nr;
  INP1apiResultText(rc,tempPcode7String, "F_PCODE7_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcode7Text, "F_PCODE7_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE7", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcode7Hex);
        tempPcode7Hex= "0x"+tempPcode7Hex;
      }
      else
      {
        tempPcode7Hex = "????";
      }
    }
    else
    {
      tempPcode7Text = "????";
    }

    if (tempPcode7String == "??")
    {
      filewrite( "");
      filewrite( tempPcode7Hex+"  "+tempPcode7Text);
    }
    else
    {
      if (tempPcode7String != "--")
      {
        filewrite( "");
        filewrite( tempPcode7Text);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe SAE Code für UDS
//*
//**********************************************************************
fs_protokoll_SAECode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempSAECodeText;
  string tempSAECodeString;
  string tempSAECodeHex;

  i=nr;
  INP1apiResultText(rc,tempSAECodeString, "F_SAE_CODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempSAECodeText, "F_SAE_CODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_SAE_CODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempSAECodeHex);
        tempSAECodeHex= "0x"+tempSAECodeHex;
      }
      else
      {
        tempSAECodeHex = "????";
      }
    }
    else
    {
      tempSAECodeText = "????";
    }

    if (tempSAECodeString == "??")
    {
      filewrite( "");
      filewrite( tempSAECodeHex+"    "+tempSAECodeText);
    }
    else
    {
      if (tempSAECodeString != "--")
      {
        filewrite( "");
        filewrite( tempSAECodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit
//*
//**********************************************************************
fs_protokoll_hfk(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;
  int f_hfk;
  int f_lz;

  i=nr;
  filewrite( "");

  INP1apiResultInt(rc,f_hfk,"F_HFK",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_hfk,temp1);
    if (f_hfk < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    filewrite( "Fehlerhäufigkeit: "+ temp1);
  }

  INP1apiResultInt(rc,f_lz,"F_LZ",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_lz,temp1);
    if (f_lz < 10) temp1= " "+temp1;//Formatierung der Nr des Logistikzählers, wenn sie kleiner 10 ist
    filewrite( "Logistikzähler  : "+ temp1);
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit für UDS
//*
//**********************************************************************
fs_protokoll_hfk_uds(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  //FS Überlauf
  INP1apiResultInt(rc,x1, "F_UEBERLAUF", i);
  if ((rc == TRUE) && (x1==1))
  {
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    if (_ApiFsJobName == "IS_LESEN")
      filewrite("++++++++++++++++++++++++ Infospeicher ist übergelaufen! +++++++++++++++++++++++");
    else
      filewrite("+++++++++++++++++++++++ Fehlerspeicher ist übergelaufen! ++++++++++++++++++++++");
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    filewrite( "");
  }

  //Fehlerhäufigkeit
  INP1apiResultInt(rc,x1, "F_HFK", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
   {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    }
  }
  filewrite( "Fehlerhäufigkeit: "+ temp1);

  //Heilungszähler
  INP1apiResultInt(rc,x1, "F_HLZ", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
    {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung des Heilungszählers, wenn er kleiner 10 ist
    }
  }
  filewrite( "Heilungszähler  : "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten
//*
//**********************************************************************
fs_protokoll_art(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_SYMPTOM_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe erweiterte Fehlerarten
//*
//**********************************************************************
fs_protokoll_art_e(in: int nr)
{
  int    i;
  int    k;
  int    F_ART_ANZ;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  INP1apiResultInt(rc,F_ART_ANZ, "F_ART_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_ART_ANZ > 0 )
    {
      k=0;
      while ( k < F_ART_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);
        INP1apiResultText(rc,temp1, "F_ART"+temp2+"_TEXT", i, "");
        if (rc == FALSE)  temp1 ="????";
        if (temp1 !="--") filewrite( "   "+ temp1);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten für UDS
//*
//**********************************************************************
fs_protokoll_art_uds(in: int nr)
{//Symptome entfallen bei UDS!
  int    i;
  int    x1;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  //Neu bei UDS:
  INP1apiResultInt(rc,x1, "F_EREIGNIS_DTC", i);
  if (rc == TRUE)
  {
    if (x1==0)
    {
      filewrite("   Dies ist kein Ereignis DTC. Das SG ist für den Fehlerspeicheintrag (DTC) verantwortlich.");
    }
    else if (x1==1)
    {
      filewrite("   Dies ein Ereignis DTC. Das SG ist somit nicht für den Fehlereintrag (DTC) verantwortlich.");
      filewrite("   Z.B. falsche oder fehlende Netzwerkinformationen.");
    }
    else
    {
      filewrite("   Fehler in SGBD! In Tabelle FOrtTexte, Spalte EREIGNIS_DTC muß 0 oder 1 stehen!");
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb(in: int nr)
{
  int    i;
  int    k;
  int    len;
  int    F_UW_ANZ;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  real   realval;
  int    pos;

  i=nr;
/*  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");
*/
  INP1apiResultText(rc,temp1, "F_UW_KM", i, "8L");
  if (rc == FALSE) temp1="    ????";
  if ((temp1 == "524280") && (ident_typ != 3)) temp1 = "-1";//Fehlerüberlauf für DS2 und BMW FAST, UDS liefert es von alleine

  temp2 =    "Kilometerstand                        ";
  filewrite( "   " + temp2 + temp1 + "     km");


  INP1apiResultInt(rc,F_UW_ANZ, "F_UW_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_UW_ANZ > 0 )
    {
      k=0;
      while ( k < F_UW_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);

        INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
        if (rc == TRUE)
        {
          AnsiUpper(temp3,temp3);
        }
        else
        {
          temp3 = "????";
        }
        if ((temp3 == "0-N") || (temp3 == "HEX"))
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-20T");
          if (rc == FALSE) temp1="????                ";
          if (temp1 !="--                  ") //"--" + 18 Zeichen

          {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "28T");
              if (rc == FALSE) temp3="????                        ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
          }
        }
        else
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-40T");
          if (rc == FALSE) temp1="????                                    ";
          if (temp1 !="--                                      ")
           {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "8.2R");
              if (rc == FALSE) temp3=" ????   ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
           }
         }
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb_uds(in: int nr)
{
  int    i;
 // int    k;
//  int    len;
//  int    F_UW_ANZ;
  bool   rc;
  string temp1;
//  string temp2;
//  string temp3;
//  real   realval;
//  int    pos;

  i=nr;
  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");

  fs_protokoll_uwb(i);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Hexcode
//*
//**********************************************************************
fs_protokoll_hex(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;

  chr(10,nl);
  i=nr;
  filewrite( "");
  INP1apiResultBinary(rc,"F_HEX_CODE", i);
  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????";
  }
  filewrite( "Fehlercode: "+temp2);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Telegrammantwort(en)
//* Wird nur bei Fehlerhaften FS_LESEN_DETAIL ausgegeben
//*
//**********************************************************************
fs_protokoll_telantwort(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  string temp4;
  string temp5;

  chr(10,nl);
  i=nr;
  filewrite( "");

  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_SNAPSHOT", i);
    else INP1apiResultBinary(rc,"_RESPONSE_2000", i);//IS_LESEN
  }
  else//1=DS2, 2=BMW Fast
  {
    INP1apiResultBinary(rc,"_TEL_ANTWORT", i);
  }


  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????--> Zur Analyse IFH-Trace benutzen!";
  }

  //2. Telegramm nur für UDS ausgeben
  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_EXTENDED_DATA", i);
    else INP1apiResultBinary(rc,"_RESPONSE_200X", i);//IS_LESEN

    if (rc == TRUE)
    {
      GetBinaryDataString (temp1, x1);
      x2 = 0;
      x3 = 0;
      temp4="";
      while ( x2 < x1 )
       {
         midstr(temp3, temp1, x2, 2);
         temp4 = temp4 + temp3;
         x2 = x2 + 2;
         x3 = x3 + 1;
         if ( x2 < x1 )
         {
           if ( x3 < 16 )//Leerzeichen zwischen den Bytes
           {
             if ( x3 == 8 )
               temp4 = temp4 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
             else temp4 = temp4 + " ";
           }
           else
           {
             x3 = 0;
             temp4 = temp4 + nl + "            ";
           }
         }
      }
    }
    else
    {
      temp4 = "????--> Zur Analyse IFH-Trace benutzen!";
    }

    filewrite("Telegramm-Antwort ab Service Identifier zur Analyse");
    if (_ApiFsJobName == "FS_LESEN")
    {
      filewrite("Data      : "+temp2);
      filewrite("Snapshot  : "+temp4);
    }
    else//IS_LESEN
    {
      filewrite("2000      : "+temp2);
      filewrite("200X      : "+temp4);
    }
  }
  else//DS2, BMW Fast
  {
  filewrite("Telegramm-");
  filewrite("Antwort   : "+temp2);
  }
}
// -- EOF --
// end of :#include "FS_LESEN.SRC"
// start of :#include "INITEXIT.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INITEXIT.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Scriptinit verlagert
//* 12.03.2003 iS V1.01 Anpassung SgbdInpaCheck()GroupCheck();
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//**********************************************************************

// **************************
// *** inpainit, inpaexit ***
// **************************
inpainit()
{
  bool   rc;
  string temp;
  int    i;

  INPAapiInit();
  chrinit();

  // Handle für FS_LESEN
  StrArrayCreate(rc,f_ort_nr_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_nr_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  StrArrayCreate(rc,f_ort_text_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_text_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  SgbdInpaCheck();
  GroupCheck();
  setmenu(m_main);
  setscreen(s_main,TRUE);

  //INPA.INI einlesen,
  //um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
  //hinter "SCRIPTS" muß DeleteRead stehen, um die Funktion freizuschalten
  ExtraScript("DeleteRead", deleteread_flag);

  //m FS,IS,HS zu speichern
  ExtraScript("SaveAs", fs_lesen_save_as_flag);
  is_lesen_save_as_flag=fs_lesen_save_as_flag;
  hs_lesen_save_as_flag=fs_lesen_save_as_flag;

  //INPA.INI-Einstellung, falls Funktionen gewünscht:
  //[EXTRA]
  //SCRIPTS               =  DeleteRead,SaveAs
  //Wichtig: Nach dem Komma kein Leerzeichen benutzen!

  ScriptInit();
}

inpaexit()
{
  INPAapiEnd();

  // Handle für FS_LESEN
  StrArrayDestroy(f_ort_nr_buffer);
  StrArrayDestroy(f_ort_text_buffer);
}

// -- EOF --
// end of :#include "INITEXIT.SRC"

// **************************
// *** Hauptmenü          ***
// **************************
MENU m_main()
{
  INIT  {
    setmenutitle("Hauptmenü");

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      setitem(2, "Ident", TRUE);
    }
    else
    {
      setitem(2, "SVK", TRUE);//ISO 14229
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setitem( 4 , "Fehler"  , TRUE);
    }

    if (m_status_flag == TRUE)
    {
      setitem( 5 , "Status"  , TRUE);
    }

    if (m_steuern_flag == TRUE)
    {
      setitem( 6 , "Steuern"  , TRUE);
    }

    if (speicher_lesen_flag == TRUE)
    {
      setitem( 7 , "Speicher"  , TRUE);
    }
  }
  ITEM( 1 ,"Info")  {
    userboxclose(1);
    setscreen(s_info,TRUE);
  }
  ITEM( 2 ,"Ident")  {
    userboxclose(1);
    if (ident_typ == 1)
      setscreen(s_ident_ds2,TRUE);
    else if (ident_typ == 2)
      setscreen(s_ident,TRUE);
    else setscreen(s_svk_lesen,TRUE);
  }
  ITEM( 3 ,"")  {
    userboxclose(1);
    setscreen(s_main,TRUE);
  }
  ITEM( 4 ,"")  {
    userboxclose(1);
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setscreen( s_fehler ,TRUE);
      setmenu(m_fehler);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 5 ,"")  {
    userboxclose(1);
    if (m_status_flag == TRUE)
    {
      setscreen(s_status,TRUE);
      setmenu(m_status);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 6 ,"")  {
    userboxclose(1);
    if (m_steuern_flag == TRUE)
    {
      setscreen(s_steuern,TRUE);
      setmenu(m_steuern);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(1);
    if (speicher_lesen_flag == TRUE)
    {
      setscreen(s_speicher,TRUE);
      setmenu(m_speicher);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Ende")  {
    exit();
  }
  ITEM( 11,  "KVP") {
    setscreen(s_info,TRUE);
    callwin( "kvp_edit "+titel+";"+version+";"+sgbd+": "+sgbd_ecu+";"+sgbd_revision);
  }
  ITEM( 12 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 14 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 15 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Fehlermenü         ***
// **************************
MENU m_fehler()
{
  int    ErrorCode;
  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  string DateiName="";
  int    aufrufIO;
  string JOB_STATUS;
  bool   fehlerflag;

  INIT {
    setmenutitle("Fehlerspeicher");
    if (fs_lesen_flag == TRUE)
    {
      setitem( 1 , "FS lesen"    , TRUE);
      setitem( 2 , "FS löschen"  , TRUE);
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 3 , "IS lesen"    , TRUE);
      if (is_loeschen_flag == TRUE)
           setitem( 4 , "IS löschen"  , TRUE);
      else setitem( 4 , ""  , FALSE);//Nicht alle SGs haben IS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 5 , "HS lesen"    , TRUE);
      if (hs_loeschen_flag == TRUE)
           setitem( 6 , "HS löschen"  , TRUE);
      else setitem( 6 , ""  , FALSE);//Nicht alle SGs haben HS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
  }
  ITEM( 1 ,"")  {
    userboxclose(0);
    viewclose();
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
      userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Fehlerspeicher lesen");
      setitem( 9 , "FS drucken"  , TRUE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
    }
  }
  ITEM( 2 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      INPAapiJob(sgbd,"FS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher wurde gelöscht!",1,3,0,0);

        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPTS = DeleteRead
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
             userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Fehlerspeicher lesen");
             setitem( 9 , "FS drucken"  , TRUE);
             if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 3 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Infospeicher lesen","");
      userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Infospeicher lesen");
      setitem( 8 , "IS drucken"  , TRUE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
    }
  }
  ITEM( 4 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"IS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Infospeicher lesen","");
             userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Infospeicher lesen");
             setitem( 8 , "IS drucken"  , TRUE);
             if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 5 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
      userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Historienspeicher lesen");
      setitem( 7 , "HS drucken"  , TRUE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
    }
  }
  ITEM( 6 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (hs_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"HS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
             userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Historienspeicher lesen");
             setitem( 7 , "HS drucken"  , TRUE);
             if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 7 ,"")  {
    if (hs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
    }
  }
  ITEM( 8 ,"")  {
    if (is_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 9 ,"")  {
    if (fs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(17 ,"")  {
    if ((hs_lesen_flag == TRUE) && (hs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Historienspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
      }
    }
  }
  ITEM(18 ,"")  {
    if ((is_lesen_flag == TRUE) && (is_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Infospeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(19 ,"")  {
    if ((fs_lesen_flag == TRUE) && (fs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Fehlerspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    viewclose();
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    viewclose();
    exit();
  }
}

// **************************
// *** Speichermenü       ***
// **************************
MENU m_speicher()
{
  int    input_ok=0;
  int    input_state;
  string text_var;

  INIT {
    setmenutitle("Speicher lesen");
    if (speicher_lesen_lar_flag==TRUE)    setitem( 1 , "LAR"  , TRUE);
    if (speicher_lesen_flash_flag==TRUE)  setitem( 2 , "FLASH", TRUE);
    if (speicher_lesen_uifm_flag==TRUE)   setitem( 3 , "UIFM" , TRUE);
    if (speicher_lesen_romi_flag==TRUE)   setitem( 4 , "ROMI" , TRUE);
    if (speicher_lesen_ramis_flag==TRUE)  setitem( 5 , "RAMIS", TRUE);
    if (speicher_lesen_ramil_flag==TRUE)  setitem( 6 , "RAMIL", TRUE);
    if (speicher_lesen_nvram_flag==TRUE)  setitem( 7 , "NVRAM", TRUE);
    if (speicher_lesen_romx_flag==TRUE)   setitem(14 , "ROMX" , TRUE);
    if (speicher_lesen_ramxx_flag==TRUE)  setitem(15 , "RAMXX", TRUE);
  }
  ITEM( 1 ,"")  {
    if (speicher_lesen_lar_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"LAR lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="LAR lesen";
        speicher_lesen_seg_adr_anz="LAR;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 2 ,"")  {
    if (speicher_lesen_flash_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"FLASH lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="FLASH lesen";
        speicher_lesen_seg_adr_anz="FLASH;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 3 ,"")  {
    if (speicher_lesen_uifm_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"UIFM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="UIFM lesen";
        speicher_lesen_seg_adr_anz="UIFM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 4 ,"")  {
    if (speicher_lesen_romi_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMI lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMI lesen";
        speicher_lesen_seg_adr_anz="ROMI;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 5 ,"")  {
    if (speicher_lesen_ramis_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIS lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIS lesen";
        speicher_lesen_seg_adr_anz="RAMIS;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 6 ,"")  {
    if (speicher_lesen_ramil_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIL lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIL lesen";
        speicher_lesen_seg_adr_anz="RAMIL;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 7 ,"")  {
    if (speicher_lesen_nvram_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"NVRAM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="NVRAM lesen";
        speicher_lesen_seg_adr_anz="NVRAM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 8 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 12 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 14 ,"")  {
    if (speicher_lesen_romx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMX lesen";
        speicher_lesen_seg_adr_anz="ROMX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 15 ,"")  {
    if (speicher_lesen_ramxx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMXX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMXX lesen";
        speicher_lesen_seg_adr_anz="RAMXX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 18 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Hauptscreen        ***
// **************************
SCREEN s_main()
{
  string text_var;

  userboxclose(0);
  ftextout("Hauptmenü",1,0,1,0);
  ftextout("",3,0,0,0);

  if (simulation_flag == TRUE)
  {
    userboxopen(1,14,30,5,48,"Hinweis","");
    userboxftextout(1,"INPA bzw. EDIABAS läuft im Simulationsmodus!",1,3,0,24);
    userboxsetcolor(1,0,4);
  }

  if (ident_typ != 3)
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
  }

  LINE("","")
  {
    if (ident_typ != 3)//Nur bei DS2 und BMW Fast vorhanden
    {
      ftextout("BMW Teilenummer",1,0,0,0);
      ftextout(":",1,19,0,0);
      INPAapiResultText(text_var,"ID_BMW_NR",1,"");
      ftextout(text_var,1,20,0,1);

      ftextout("Herstelldatum",1,43,0,0);
      ftextout(":",1,59,0,0);
      if (ident_typ == 1)//DS2
      {
        ftextout("KW / Jahr",1,68,0,0);
        ftextout("/",1,63,0,1);
        INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
        ftextout(text_var,1,60,0,1);
        INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
        ftextout(text_var,1,65,0,1);
      }
      else if (ident_typ == 2)//BMW FAST
      {
        INPAapiResultText(text_var,"ID_DATUM",1,"");
        ftextout(text_var,1,60,0,1);
      }
    }

    ftextout("< F1 >  Information"              , 4,5,0,1);

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      ftextout("< F2 >  Identifikation"           , 6,5,0,1);
    }
    else
    {
      ftextout("< F2 >  Steuergeräteverbaukennung"           , 6,5,0,1);//UDS (ISO 14229)
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
        ftextout("< F4 >  Fehlerspeicher"           ,10,5,0,1);

    if (m_status_flag == TRUE)
        ftextout("< F5 >  Status lesen"             ,12,5,0,1);

    if (m_steuern_flag == TRUE)
        ftextout("< F6 >  Ansteuern"                ,14,5,0,1);

    if (speicher_lesen_flag == TRUE)
        ftextout("< F7 >  Speicher lesen"           ,16,5,0,1);

    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F1 >  KVP-Editor"     , 4,45,0,1);
    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Infoscreen         ***
// **************************
SCREEN s_info ()
{
  int i;
  int slen;
  int pos;
  int pos2;
  int anzahl;
  string temp;

  ftextout("Information",1,0,1,0);
  ftextout("Nacharbeitsprogramm",4,0,0,0);             ftextout(":", 4,33,0,1); ftextout(titel,4,35,0,1);
  ftextout("Version",5,1,0,0);                         ftextout(":", 5,33,0,1); ftextout(version,5,35,0,1);
  ftextout("Package",6,1,0,0);                         ftextout(":", 6,33,0,1); ftextout(package,6,35,0,1);
  ftextout("Verantwortung",7,1,0,0);                   ftextout(":", 7,33,0,1); ftextout(origin,7,35,0,1);

  ftextout("Gruppendatei",10,0,0,0);                   ftextout(":",10,33,0,1); ftextout(gruppe,10,35,0,1);
  ftextout("Bezeichnung",11,1,0,0);                    ftextout(":",11,33,0,1); ftextout(gruppe_ecu,11,35,0,1);
  ftextout("Version",12,1,0,0);                        ftextout(":",12,33,0,1); ftextout(gruppe_revision,12,35,0,1);
  ftextout("Verantwortung",13,1,0,0);                  ftextout(":",13,33,0,1); ftextout(gruppe_origin,13,35,0,1);
  ftextout("Identifizierbare SGBD'en",14,1,0,0);

  strlen(slen, gruppe_comment);
  anzahl=44;
  pos=0;
  if ( slen <= anzahl )
  {
    ftextout(":",14,33,0,1); ftextout(gruppe_comment,14,35,0,1);
  }
  else
  {
    instr(pos2, anzahl, gruppe_comment, ",");
    if (pos2 > 0) anzahl=pos2+1;
    midstr(temp, gruppe_comment, pos, anzahl); ftextout(":",14,33,0,1); ftextout(temp,14,35,0,1);
    i=14;
    pos=pos+anzahl;
    while ( pos < slen )
    {
      i=i+1;
      anzahl=75;
      instr(pos2, pos + anzahl, gruppe_comment, ",");
      if (pos2 > 0) anzahl=pos2+1-pos;
      midstr(temp, gruppe_comment, pos, anzahl); ftextout(temp,i,1,0,1);
      pos=pos+anzahl;
      if ( i >= 18 )
      {
        if ( pos < slen ) ftextout(temp+" . . .",i,1,0,1);
        pos=slen;
      }
    }
  }

  ftextout("Steuergerätebeschreibungsdatei",21,0,0,0); ftextout(":",21,33,0,1); ftextout(sgbd,21,35,0,1);
  ftextout("Steuergerät",22,1,0,0);                    ftextout(":",22,33,0,1); ftextout(sgbd_ecu,22,35,0,1);
  ftextout("Version",23,1,0,0);                        ftextout(":",23,33,0,1); ftextout(sgbd_revision,23,35,0,1);
  ftextout("Package",24,1,0,0);                        ftextout(":",24,33,0,1); ftextout(sgbd_package,24,35,0,1);
  ftextout("Verantwortung",25,1,0,0);                  ftextout(":",25,33,0,1); ftextout(sgbd_origin,25,35,0,1);
  ftextout("Sprache",26,1,0,0);                        ftextout(":",26,33,0,1); ftextout(sgbd_sprache,26,35,0,1);
  if (sgbd_comment!="")
  {
    ftextout("Kommentar",27,1,0,0);
    ftextout(":",27,33,0,1);
    ftextout(sgbd_comment,27,35,0,1);
  }
}

// **************************
// *** Identscreen DS2    ***
// **************************
SCREEN s_ident_ds2()
{
  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"IDENT","","");
  INPAapiCheckJobStatus("OKAY");
  LINE("","")
  {
    ftextout("BMW Teilenummer",1,0,1,0);
    ftextout(":",1,33,1,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,35,1,1);

    ftextout("Hardwarenummer",4,0,1,0);
    ftextout(":",4,33,1,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,4,35,1,1);

    ftextout("Softwarenummer",7,0,1,0);
    ftextout(":",7,33,1,0);
    INPAapiResultText(text_var,"ID_SW_NR",1,"");
    ftextout(text_var,7,35,1,1);

    ftextout("Lieferant",10,0,1,0);
    ftextout(":",10,33,1,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,10,35,1,1);

    ftextout("Codier-Index",13,0,1,0);
    ftextout(":",13,33,1,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,13,35,1,1);

    ftextout("Diagnose-Index",16,0,1,0);
    ftextout(":",16,33,1,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,16,35,1,1);

    ftextout("Bus-Index",19,0,1,0);
    ftextout(":",19,33,1,0);
    INPAapiResultText(text_var,"ID_BUS_INDEX",1,"");
    ftextout(text_var,19,35,1,1);

    ftextout("Herstelldatum",22,0,1,0);
    ftextout(":",22,33,1,0);
    ftextout("KW / Jahr",22,55,1,0);
    ftextout("/",22,41,1,1);
    INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
    ftextout(text_var,22,35,1,1);
    INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
    ftextout(text_var,22,45,1,1);
  }
}

// ****************************
// *** Identscreen BMW Fast ***
// ****************************
SCREEN s_ident()
{
  string text_var;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext

  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,1);

  LINE("Identifikation","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");

    ftextout("BMW Teilenummer",1,0,0,0);
    ftextout(":",1,43,0,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,45,0,1);

    ftextout("Codier-Index",3,0,0,0);
    ftextout(":",3,43,0,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,3,45,0,1);

    ftextout("Varianten-Index",5,0,0,0);
    ftextout(":",5,43,0,0);
    INPAapiResultText(text_var,"ID_VAR_INDEX",1,"");
    ftextout(text_var,5,45,0,1);

    ftextout("Diagnose-Index",7,0,0,0);
    ftextout(":",7,43,0,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,7,45,0,1);

    ftextout("Hardwarenummer",9,0,0,0);
    ftextout(":",9,43,0,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,9,45,0,1);

    ftextout("Softwarenummer   Funktionssoftware",11,0,0,0);
    ftextout(":",11,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_FSV",1,"");
    ftextout(text_var,11,45,0,1);

    ftextout("Softwarenummer   Betriebssystem",13,0,0,0);
    ftextout(":",13,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_OSV",1,"");
    ftextout(text_var,13,45,0,1);

    ftextout("Softwarenummer   Nachrichtenkatalog",15,0,0,0);
    ftextout(":",15,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_MCV",1,"");
    ftextout(text_var,15,45,0,1);

    ftextout("Softwarenummer  (Reserve) Zur Zeit nicht benutzt",17,0,0,0);
    ftextout(":",17,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_RES",1,"");
    ftextout(text_var,17,45,0,1);

    ftextout("Herstelldatum",19,0,0,0);
    ftextout(":",19,43,0,0);
    INPAapiResultText(text_var,"ID_DATUM",1,"");
    ftextout(text_var,19,45,0,1);

    ftextout("Lieferant",21,0,0,0);
    ftextout(":",21,43,0,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,21,45,0,1);
  }
// *** AIF, Anwender-Information
// *** auf 2. Seite von IDENT

  LINE("Anwender-Information","")
  {
    INPAapiJob(sgbd,"AIF_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("",10,0,0,0);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Anwenderinfofeld (AIF_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: AIF_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      INPAapiResultInt(ganz_zahl,"AIF_ANZ_DATEN",1);
      if (ganz_zahl > 18)                // lange AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Datensatz Nr.",7,0,0,0);
        ftextout(":",7,43,0,0);
        INPAapiResultText(text_var,"AIF_SW_NR",1,"");
        ftextout(text_var,7,45,0,1);

        ftextout("Behörden Nr.",9,0,0,0);
        ftextout(":",9,43,0,0);
        INPAapiResultText(text_var,"AIF_BEHOERDEN_NR",1,"");
        ftextout(text_var,9,45,0,1);

        ftextout("Händler Nr.",11,0,0,0);
        ftextout(":",11,43,0,0);
        INPAapiResultText(text_var,"AIF_HAENDLER_NR",1,"");
        ftextout(text_var,11,45,0,1);

        ftextout("Tester Nr.",13,0,0,0);
        ftextout(":",13,43,0,0);
        INPAapiResultText(text_var,"AIF_SERIEN_NR",1,"");
        ftextout(text_var,13,45,0,1);

        ftextout("km-Stand",15,0,0,0);
        ftextout(":",15,43,0,0);
        INPAapiResultText(text_var,"AIF_KM",1,"");
        ftextout(text_var,15,45,0,1);

        ftextout("Programm-Stand",17,0,0,0);
        ftextout(":",17,43,0,0);
        INPAapiResultText(text_var,"AIF_PROG_NR",1,"");
        ftextout(text_var,17,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
      else                              //18 Byte -> kurze AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
    }
  }

LINE("CFG Lesen","")
  {
    INPAapiJob(sgbd,"C_FG_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("Codierdaten",0,0,0,1);
    ftextout("",10,0,0,0);// um auf einer neuen Seite darzustellen

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Fahrgestellnummer lesen (CFG_LESEN) vorhanden          " ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: C_FG_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Fahrgestell Nr.",3,0,0,0);
      ftextout(":",3,43,0,0);
      INPAapiResultText(text_var,"FG_NR",1,"");
      ftextout(text_var,3,45,0,1);
    }

    INPAapiJob(sgbd,"C_AEI_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Codierdatenänderungsindex (C_AEI_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Codierdatenänderungsindex",6,0,0,0);
      ftextout(":",6,43,0,0);
      INPAapiResultText(text_var,"COD_AE_INDEX",1,"");
      ftextout(text_var,6,45,0,1);
    }
  }
}

// ****************************************************************************
// *** Identinformationen werden über SVK_LESEN ermittelt                   ***
// *** SVK: SteuergeräeVerbauKennung Soft- und Hardware für UDS (ISO 14229) ***
// ****************************************************************************
SCREEN s_svk_lesen()
{
  string text_var;
  string text_var2;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  bool   eingabeWeiter;
  int    input_state;              // Eingabestatus
  int    input_ok=1;               // Eingabe  mit Nein beendet
  int    i;
  int    offset;
  int    einheiten_anz;
  int    pos;
  real   realval;
  real   realval2;
  long   longval;
  long   rest_long;
  long   multiplik_long;

  ftextout("Steuergeräteverbaukennung Soft- und Hardware",1,0,1,0);
  ftextout("",2,0,0,1);
  LINE("Hersteller Information","")
  {//HERSTELLINFO_LESEN ist kein Pflichtjob! (Stand: 03.2006)
    INPAapiJob(sgbd,"HERSTELLINFO_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Herstellerinformationen vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: HERSTELLINFO_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Herstelldatum",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"ID_DATUM",1,"");
      ftextout(text_var,1,45,0,1);

      ftextout("Lieferant",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
      ftextout(text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("Ident","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
/*    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Ident vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else */if (((fehlerflag == FALSE) /*&& (errorcode != 98)*/) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: IDENT",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Steuergeräte-Adresse",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultInt(ganz_zahl,"ID_SG_ADR",1);
      inttohexstring(ganz_zahl,4,text_var);
      //Führende Nullen ausblenden
      if (ganz_zahl <= 255) midstr(text_var,text_var,2,2);
      ftextout("0x"+text_var,1,45,0,1);

      ftextout("SGBD-Index",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultBinary("_RESPONSE",1);
      GetBinaryDataString (text_var,i);
      midstr(text_var,text_var,6,11);

      ftextout("0x"+text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("SVK","")
  {
    INPAapiJob(sgbd,"SVK_LESEN","","");
    //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
    sets=0;
    INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) || (sets <= 1))
    {
      ftextout("Fehler beim Lesen von Job: SVK_LESEN",1,0,0,0);
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
        ftextout(error_text ,2,0,0,0);
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        ftextout(error_text,2,0,0,0);
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
      ftextout("" ,3,0,0,0);
    }
    else
    {
      INPAapiResultText(text_var,"PROG_DATUM",sets,"");
      ftextout("Programm-Datum",0,0,0,0);
      ftextout(":",0,41,0,0);
      ftextout(text_var,0,45,0,1);

      INPAapiResultText(text_var,"PROG_KM",sets,"");
      if (text_var == "-1") text_var= "- - -";
      ftextout("Programm-km",1,0,0,0);
      ftextout(":",1,41,0,0);
      ftextout(text_var,1,45,0,1);

      INPAapiResultText(text_var,"ANZAHL_EINHEITEN",sets,"");
      INPAapiResultInt(einheiten_anz,"ANZAHL_EINHEITEN",sets);
      ftextout("Anzahl Prozeßklassen",2,0,0,0);
      ftextout(":",2,41,0,0);
      ftextout(text_var,2,45,0,1);

      ftextout("Prozeßklasse",5,2,0,1);
      ftextout("SGBM Identifier ",5,43,0,1);
      ftextout("Version",5,62,0,1);

      i=1;
      offset=0;
      while(i<=einheiten_anz)
      {
        inttostring(i,text_var2);
        INPAapiResultText(text_var,"PROZESSKLASSE_TEXT",i,"");
        ftextout(text_var2+") "+text_var,6+offset,0,0,0);

        //SGBM Identifier
        ftextout(":",6+offset,41,0,0);
        INPAapiResultText(text_var,"SGBM_IDENTIFIER",i,"");
        ftextout(text_var,6+offset,45,0,1);

        //Version
        INPAapiResultText(text_var,"VERSION",i,"");
        ftextout(text_var,6+offset,62,0,1);
        i=i+1;//um nächsten Set zu laden
        offset=offset+1;
      }
    }
  }
}

// **************************
// *** Speicherscreen     ***
// **************************
SCREEN s_speicher()
{
  ftextout("Speicher lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (speicher_lesen_lar_flag==TRUE)    ftextout("< F1 >  LAR lesen"               , 4,5,0,1);
    if (speicher_lesen_flash_flag==TRUE)  ftextout("< F2 >  FLASH lesen"             , 6,5,0,1);
    if (speicher_lesen_uifm_flag==TRUE)   ftextout("< F3 >  UIFM lesen"              , 8,5,0,1);
    if (speicher_lesen_romi_flag==TRUE)   ftextout("< F4 >  ROMI lesen"              ,10,5,0,1);
    if (speicher_lesen_ramis_flag==TRUE)  ftextout("< F5 >  RAMIS lesen"             ,12,5,0,1);
    if (speicher_lesen_ramil_flag==TRUE)  ftextout("< F6 >  RAMIL lesen"             ,14,5,0,1);
    if (speicher_lesen_nvram_flag==TRUE)  ftextout("< F7 >  NVRAM lesen"             ,16,5,0,1);
    if (speicher_lesen_romx_flag==TRUE)   ftextout("<Shift> + < F4 >  ROMX lesen"    ,10,45,0,1);
    if (speicher_lesen_ramxx_flag==TRUE)  ftextout("<Shift> + < F5 >  RAMXX lesen"   ,12,45,0,1);

    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Speicherscreen     ***
// *** Ausgabe            ***
// **************************
SCREEN s_speicher_ausgabe()
{
  string text_var;
  string job_state;

  ftextout(speicher_lesen_text,1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"SPEICHER_LESEN",speicher_lesen_seg_adr_anz,"");
  INPAapiResultText(job_state,"JOB_STATUS",1,"");
  LINE("","")
  {
    ftextout("Startadresse",1,0,0,0);
    ftextout(":",1,18,0,1);
    ftextout(speicher_lesen_adresse,1,20,0,1);
    ftextout("Anzahl",3,0,0,0);
    ftextout(":",3,18,0,1);
    inttostring(speicher_lesen_anzahl,text_var);
    ftextout(text_var,3,20,0,1);
    ftextout("Daten",5,0,0,0);
    ftextout(":",5,18,0,1);
    if(job_state != "OKAY")
      ftextout(job_state,5,20,0,1);
    else
    {
      INPAapiResultBinary("DATEN",1);
      hexdump(speicher_lesen_adresse,speicher_lesen_anzahl,5,20);
    }
  }
}

// **************************
// *** Fehlerscreen       ***
// **************************
SCREEN s_fehler()
{
  ftextout("Fehlerspeicher",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (fs_lesen_flag == TRUE)
    {
      ftextout("< F1 >  Fehlerspeicher lesen"      , 4,5,0,1);
      ftextout("< F2 >  Fehlerspeicher löschen"    , 6,5,0,1);
      ftextout("< F9 >  Fehlerspeicher drucken"    ,20,5,0,1);
      if (fs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F9 >  Fehlerspeicher speichern"   ,20,45,0,1);
    }

    if (is_lesen_flag == TRUE)
    {
      ftextout("< F3 >  Infospeicher lesen"        , 8,5,0,1);
      if (is_loeschen_flag == TRUE) ftextout("< F4 >  Infospeicher löschen"      ,10,5,0,1);
      ftextout("< F8 >  Infospeicher drucken"      ,18,5,0,1);
      if (is_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F8 >  Infospeicher speichern"     ,18,45,0,1);
    }

    if (hs_lesen_flag == TRUE)
    {
      ftextout("< F5 >  Historienspeicher lesen"   ,12,5,0,1);
      if (hs_loeschen_flag == TRUE) ftextout("< F6 >  Historienspeicher löschen" ,14,5,0,1);
      ftextout("< F7 >  Historienspeicher drucken" ,16,5,0,1);
      if (hs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F7 >  Historienspeicher speichern",16,45,0,1);
    }
    ftextout("< F10>  Zurück"                    ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"            ,22,45,0,1);
  }
}
// -- EOF --
// end of :#include "BMW_STD.SRC"

// Inbetriebnahmeablauf
// start of :#include "inb_l6.src"
//**********************************************************************
// diese Datei wird als 'include' File in 'ICMV.SRC' aufgerufen
//
//* 23.03.2007 ss V0.900 Ersterstellung auf Basis ARS_70
//* 12.06.2007 ss V0.901 Anpassung der Motordrehzahlanhebung
//* 13.06.2007 SS V0.953 Anpassung für den Fall, dass Job nicht vorhanden in
//*                      Inbetriebnahme
//* 20.06.2007 SS V0.956 Anpassungen in Inbetriebnahme Result
//* 01.08.2007 SS V1.000 Anpassungen in Inbetriebnahme Result Fortschritt
//*                      Abgabestand I3.50
//* 03.08.2007 SS V1.020 Anpassungen für Rückwärtskompatibilität I3.15
//* 24.09.2007 SS V1.400 Erste Anpassungen an I4.00, Korrektur I3.50
//* 26.09.2007 SS V1.410 Anpassungen im Inbetriebnahmeablauf nach Rücksprache
//*                      mit Funktionsentwicklung
//* 01.10.2007 SS V1.420 Job für Leerlaufdrehzahlanhebung integriert
//* 02.10.2007 SS V1.430 Inbetriebnahmeendekennung I-Stufenabhängig (6 oder 99)
//* 15.10.2007 SS V1.465 Abstimmung I4.00 mit A.Feine
//* 18.10.2007 SS V2.000 Abgabestand I4.00 ATS
//* 19.10.2007 SS V2.010 Einfügen ARS Daten Inbetriebnahme
//* 24.10.2007 SS V2.015 Anpassung für große Bildschirme (1280x1024)
//* 12.12.2007 SS V2.230 akt. Pumpendrehzahl und Motordrehzahl in LL-Anhebung
//* 16.01.2008 SS V2.300 Anpassung Daten Inbetriebnahme
//**********************************************************************
string fehler_inbetriebnahme = "";
string fehler_inbetriebnahme2 = "";
string warnung_inbetriebnahme = "";
string zusatzinfo_inbetriebnahme = "";
int suppress_infos = 0;

string z1,z4;
string leer_string = "";

string fehlertext_1;
string fehlertext_2;
string zusatzinfotext;

// *****************************************************
// ********      Fuer Statistikfile        *************
// *****************************************************

string FG_NR   = "";
string FZG_TYP = "XX11";
string statistik_daten;
string statistik_file = "D:\austausch\icmv_doku.dat";
string Uhrzeit = "hh:mm:ss";
string Datum = "dd.mm.yyyy";    

// *****************************************************

// Stringarrayvariablen
// Warnungen, Einzeltestergebnisse bei der Inbetriebnahme
int handleStringArr_Warnungen;
int handleStringArr_Einzeltests;
//
int    s1,s4;
int view_flag=0;

int farbe,hintergrund;
int state=0;
int sets;
int errorcode1;
int APIBUSY  = 0;
int APIREADY = 1;
int APIBREAK = 2;
int APIERROR = 3;

// Stringarrayvariablen
// konnte Stringarry erfolgreich angelegt werden
bool b_handleStringArr_Warnungen;
bool b_handleStringArr_Einzeltests;
//
bool zuendung_ein_test = FALSE;
bool fehlerspeicher_loeschen = FALSE;

bool werte_lernen = FALSE;

bool status_leerlauf = FALSE;
bool motordrehzahl_vorgeben = FALSE;
bool status_erhoehte_drehzahl = FALSE;
bool pruefung_ohne_drehzahlerhoehung = FALSE;
bool drehzahl_wurde_erhoeht = FALSE;
bool start_inbetriebnahme_okay = FALSE;
bool inbetriebnahme= FALSE;
bool status_motor_aus = FALSE;
bool sg_reset = FALSE;

bool ARS_TEST_OK = FALSE;
bool WEITER      = FALSE;
bool weitermachen_trotz_job_fehler = FALSE;
bool SG_ist_I315 = FALSE;

bool inbe_daten_info_einmal = FALSE;

//
// externe Deklaration von Funktionen
//
meldung_1(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,7,5,1,1);     // Ausgabe Text Ablaufschritte
}

meldung_2(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,10,5,1,1);     // Ausgabe Text Ablaufschritte
}
meldung_3(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,13,5,1,1);     // Ausgabe Text Ablaufschritte
}

meldung_4(in: string text)
{
  text = text+"  sec.    ";     // Platzhalter fuer Text
  ftextout(text,26,20,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}

meldung_5(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,16,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}

meldung_6(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,19,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}

meldung_7(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,22,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}


action_box_open(in: string text1, in: string text2, in: string text3)
{
   userboxopen(1,8,0,14,89,"Arbeitshinweis", "");
   userboxftextout(1,text1,1,3,2,2);
   userboxftextout(1,text2,4,3,2,2);
   userboxftextout(1,text3,7,3,2,2);

}

action_box_meldung(in: string text1, in: string text2)
{
   userboxopen(1,8,0,14,89,"Meldung", "");
   userboxsetcolor(1,0,9);
   userboxftextout(1,text1,1,18,2,0);
   userboxftextout(1,text2,4,18,2,0);
}


//                                                                    
//                                Fehler            Fehler2           Warnungen              Einzeltestergebnisse    Infos unterdrücken
action_box_meldung_inbetriebnahme(in: string text1, in: string text2, in: int hStrArrayWarn, in: int hStrArrayTests, in: int suppressinfos)
{
   int i = 0;
   int j = 0;
   int count;

   string text_action_box = "";

   userboxopen( 1, 1, 0, 32, 89, "Inbetriebnahme Meldungen", "" );
   userboxsetcolor( 1, 0, 9 );

   //userboxftextout( 1, "Fehler:", 1, 1, 1, 0 );
   userboxftextout( 1, text1, 1, 1, 1, 1 );
   userboxftextout( 1, text2, 3, 1, 1, 1 );

   if(suppressinfos == 0)
   {
     StrArrayGetElementCount( hStrArrayWarn, count );
     userboxftextout( 1, "Warnungen:", 7, 1, 1, 1 );
     while( i < count ) 
     {
       StrArrayRead( hStrArrayWarn, i, text_action_box );
       userboxftextout( 1, text_action_box, j + 7 , 1, 1, 0 );

       text_action_box = "";
       i = i + 1;
       j = j + 2;
     }

     i = 0;
     j = 0;
     StrArrayGetElementCount( hStrArrayTests, count );
     userboxftextout( 1, "Inbetriebnahme Einzeltestergebnisse:", 14, 1, 1, 1 );

     while( i < count ) 
     {
       StrArrayRead( hStrArrayTests, i, text_action_box );
       userboxftextout( 1, text_action_box, j + 14 , 1, 1, 0 );

       text_action_box = "";
       i = i + 1;
       j = j + 2;
     }
   }
}


message_box_open(in: string meldetext1,in: string meldetext2,in: string meldetext3)
{
   userboxopen(2,8,0,14,89,"Meldung", "");
   userboxsetcolor(2,1,12);
   userboxftextout(2,meldetext1,1,3,2,1);
   userboxftextout(2,meldetext2,4,3,2,1);
   userboxftextout(2,meldetext3,7,3,2,1);
}

action_box_close()
{
   userboxclose(1);
}

message_box_close()
{
   userboxclose(2);
}


delete_screen()
{
   action_box_close();
   message_box_close();
}

endebehandlung_inbe()
{

bool rc;              // return code vom Drucker
real drehzahl = 0;
string dh = "";
string sgbd_name = "";
string help_api_job0 = "";
string fg_nr = "";
string errorcode1_txt;
string errortext1;

int zustand=0;

    gettime(Uhrzeit);
    getdate(Datum);
    statistik_daten = Datum+","+Uhrzeit+","+FZG_TYP+","+fg_nr+","+fehlertext_1+","+fehlertext_2+","+zusatzinfotext+",";
    //fileopen(statistik_file,"a"); //für Tests aktivierbar
     
    if ( ARS_TEST_OK == TRUE )
    {
       fehlertext_1="";                         // Loeschen
       fehlertext_2="";                         // Loeschen
       statistik_daten = statistik_daten+"i.O";
    }
    else
    {
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "ARS Inbetriebnahme und Prüfung");
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_1);
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_2);
       PEMProtokollZeile (rc, "Fehlertext :" + zusatzinfotext);
       PEMProtokollZeile (rc, "");

       statistik_daten = statistik_daten+"n.i.O";
    }

   //filewrite(statistik_daten); //für Tests aktivierbar
   //fileclose(); //für Tests aktivierbar
   delay(500);
  
//  ***************************************************
//  ***     Motordrehzahl wieder zurücksetzen       ***
//  ***************************************************

    if(drehzahl_wurde_erhoeht == TRUE)
    {
      drehzahl_wurde_erhoeht = FALSE;
      INPAapiJob("G_MOTOR","INITIALISIERUNG","","");
      INP1apiErrorCode(errorcode1);
      if (errorcode1 != 0)
      {
        //Fehlertext erst holen, wenn auch ein Fehler anliegt.
        INP1apiErrorText(errortext1);
        inttostring( errorcode1, errorcode1_txt );
        infobox("Fehler","kein Motor gefunden: Errorcode "+errorcode1_txt+" "+errortext1);
        message_box_close();
      }
      else
      {
        INPAapiResultText(sgbd_name,"VARIANTE",0,"");         // Satz 0 ist richtig!
        
        //infobox(sgbd_name,"Motor gefunden");   // kann zu Testzwecken aktiviert werden
        
        help_api_job0 = "STOP_SYSTEMCHECK_LLERH";
        
        job_state = "";  
        INPAapiJob( sgbd_name, help_api_job0, dh, "" );
        INPAapiResultText(job_state,"JOB_STATUS",1,"");
        message_box_close();
        
        if (job_state == "OKAY")
        {
          message_box_open("Motordrehzahl zurücksetzen i.O.","","");
        }
        else  // *********** Jobstatus nicht OKAY   *************
        {
          message_box_open("Motordrehzahl zurücksetzen n.i.O.",help_api_job0,job_state);
        }
      }
    }
}

//
//       **********************************************************
//       ***               S c r e e n a u f b a u              ***
//       ***   Darstellung und Aktualisierung des Bildschirms   ***
//       **********************************************************
SCREEN s_inbetriebnahme()
{
  ftextout( "ARS Inbetriebnahme und Prüfung", 2, 5, 2, 5 );
  delay ( 500 );
}   
//       **************************
//       ***    Pruefscreen     ***
//       **************************
SCREEN s_pruefung()
{
   ftextout("ARS Dynamische Funktionsprüfung",2,5,2,5);
   setcolor(1, 8);   // gelb  mit schwarzer Schrift

}
//       ********************************
//       ***    LL-Anhebungscreen     ***
//       ********************************
SCREEN s_leerlauf_anhebung()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i400 = FALSE;
  string chk_jobstatus ="";
  int llsw_HV_version;
  int llsw_UV_version;
  real pump_uebersetzung;
  real motor_laeuft;
  real min_drehzahl;
  real max_drehzahl;

  ftextout("ARS Parameter Leerlaufdrehzahlanhebung",1,5,1,5);
  delay ( 500 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  //Wir gehen mal davon aus, die Version passt
  min_i400 = TRUE;
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
    min_i400 = FALSE;
  }
  else
  {
    INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);
    INPAapiResultInt( llsw_UV_version, "STAT_UV_WERT", 1);

    if( llsw_HV_version < 6)
    {
      ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
      min_i400 = FALSE;
    }
    else if(zahl_var < 1.410)
    {
      min_i400 = FALSE;
      ftextout( "(SGBD muss mindestens Version 1.410 sein)", 4, 0, 0 ,0 );
    }
  }

  LINE( "","" )
  {
    if(min_i400 == TRUE)
    {
      INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_DREHZAHLANHEBUNG", "" );
      INPAapiResultText( text_var, "STAT_MOTORDREHZAHL_INFO", 1,"");
      ftextout( text_var, 1, 2, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MOTORDREHZAHL_WERT", 1, "");
      stringtoreal( text_var, zahl_var );
      realtostring ( zahl_var, "5.0" , text_var );
      ftextout( text_var, 1, 35, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MOTORDREHZAHL_EINH", 1,"");
      ftextout( text_var, 1, 42, 0 ,0 );

      INPAapiResultText( text_var, "STAT_PUMPENDREHZAHL_INFO", 1,"");
      ftextout( text_var, 3, 2, 0 ,0 );
      INPAapiResultText( text_var, "STAT_PUMPENDREHZAHL_WERT", 1, "");
      stringtoreal( text_var, zahl_var );
      realtostring ( zahl_var, "5.0" , text_var );
      ftextout( text_var, 3, 35, 0 ,0 );
      INPAapiResultText( text_var, "STAT_PUMPENDREHZAHL_EINH", 1,"");
      ftextout( text_var, 3, 42, 0 ,0 );

      INPAapiResultText( text_var, "STAT_PUMPE_UEBERSETZUNG_INFO", 1,"");
      ftextout( text_var, 5, 2, 0 ,0 );
      INPAapiResultText( text_var, "STAT_PUMPE_UEBERSETZUNG_WERT", 1, "");
      stringtoreal( text_var, pump_uebersetzung );
      realtostring ( pump_uebersetzung, "3.2" , text_var );
      ftextout( text_var, 5, 35, 0 ,0 );

      INPAapiResultText( text_var, "STAT_MAX_TOL_MOTORDREHZAHL_INFO", 1,"");
      ftextout( text_var, 7, 2, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MAX_TOL_MOTORDREHZAHL_WERT", 1, "");
      stringtoreal( text_var, zahl_var );
      realtostring ( zahl_var, "5.0" , text_var );
      ftextout( text_var, 7, 35, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MAX_TOL_MOTORDREHZAHL_EINH", 1,"");
      ftextout( text_var, 7, 42, 0 ,0 );

      INPAapiResultText( text_var, "STAT_MAX_TOL_PUMPENDREHZAHL_INFO", 1,"");
      ftextout( text_var, 9, 2, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MAX_TOL_PUMPENDREHZAHL_WERT", 1, "");
      stringtoreal( text_var, zahl_var );
      realtostring ( zahl_var, "5.0" , text_var );
      ftextout( text_var, 9, 35, 0 ,0 );
      INPAapiResultText( text_var, "STAT_MAX_TOL_PUMPENDREHZAHL_EINH", 1,"");
      ftextout( text_var, 9, 42, 0 ,0 );
    }
  }
  LINE( "","" )
  {
    if(min_i400 == TRUE)
    {
      //aktuelle Motordrehzahl ausgeben
      ftextout( "aktuelle Motordrehzahl", 1, 2, 0 ,1 );
      INPAapiJob( sgbd ,"STATUS_LESEN", "ARG;STATUS_FR_DREHZAHL_ARS", "" );
      INPAapiResultAnalog(motor_laeuft,"STAT_DREHZAHL_MOTOR_WERT",1);

      min_drehzahl = 500;
      max_drehzahl = 1000;
      analogout ( motor_laeuft, 1, 35, 0, 1500, min_drehzahl, max_drehzahl, "4" );

      //aktuelle Pumpendrehzahl ausgeben
      ftextout( "aktuelle Pumpendrehzahl", 3, 2, 0 ,1 );
      min_drehzahl = min_drehzahl * pump_uebersetzung;
      max_drehzahl = max_drehzahl * pump_uebersetzung;
      zahl_var = motor_laeuft * pump_uebersetzung;
      analogout ( zahl_var, 3, 35, 0, 2500, min_drehzahl, max_drehzahl, "4" );
    }
  }
}
//       *****************************************
//       ***    Daten Inbetriebnahmescreen     ***
//       *****************************************
SCREEN s_inbe_daten_dyn_test_va()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i400 = FALSE;
  bool min_i450 = TRUE;
  string chk_jobstatus ="";
  int llsw_HV_version;
  int llsw_UV_version;

  ftextout("ARS Daten letzte Inbetriebnahme",1,5,1,5);
  delay ( 500 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  //Wir gehen mal davon aus, die Version passt
  min_i400 = TRUE;
  min_i450 = TRUE;
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
    min_i400 = FALSE;
  }
  else
  {
    INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);
    INPAapiResultInt( llsw_UV_version, "STAT_UV_WERT", 1);

    if( llsw_HV_version < 6)
    {
      ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
      min_i400 = FALSE;
    }
    else if(zahl_var < 1.410)
    {
      min_i400 = FALSE;
      ftextout( "(SGBD muss mindestens Version 1.410 sein)", 4, 0, 0 ,0 );
    }
    else if(zahl_var < 2.310)
    {
      min_i450 = FALSE;
    }
    else if ( llsw_HV_version == 6 && llsw_UV_version < 4 )
    {
      min_i450 = FALSE;
    }
  }

  LINE( "","" )
  {
    if(min_i400 == TRUE)
    {
      if(inbe_daten_info_einmal == TRUE)
      {
        inbe_daten_info_einmal = FALSE;
        INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_INBETRIEBNAHME", "" );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_RV_INFO", 1,"");
        ftextout( text_var, 1, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_RV_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 1, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_RV_EINH", 1,"");
        ftextout( text_var, 1, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_VA_INFO", 1,"");
        ftextout( text_var, 2, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 2, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_VA_EINH", 1,"");
        ftextout( text_var, 2, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_HA_INFO", 1,"");
        ftextout( text_var, 3, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 3, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PSTAU_HA_EINH", 1,"");
        ftextout( text_var, 3, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_U_INFO", 1,"");
        ftextout( text_var, 4, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_U_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 4, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_U_EINH", 1,"");
        ftextout( text_var, 4, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_B_INFO", 1,"");
        ftextout( text_var, 5, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_B_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 5, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_RV_B_EINH", 1,"");
        ftextout( text_var, 5, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_AKT_INFO", 1,"");
        ftextout( text_var, 6, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_AKT_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 6, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_AKT_EINH", 1,"");
        ftextout( text_var, 6, 62, 0 ,0 );

        if(min_i450 == TRUE)
        {
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_AKT_INFO", 1,"");
          ftextout( text_var, 7, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_AKT_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 7, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_AKT_EINH", 1,"");
          ftextout( text_var, 7, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_U_INFO", 1,"");
          ftextout( text_var, 8, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_U_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 8, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_U_EINH", 1,"");
          ftextout( text_var, 8, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_B_INFO", 1,"");
          ftextout( text_var, 9, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_B_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 9, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_RV_B_EINH", 1,"");
          ftextout( text_var, 9, 62, 0 ,0 );

        }
        else
        {
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_INFO", 1,"");
          ftextout( text_var, 7, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 7, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_LUFT_2SOLL_EINH", 1,"");
          ftextout( text_var, 7, 62, 0 ,0 );
        }
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_MAX_LUFT_2SOLL_INFO", 1,"");
        ftextout( text_var, 10, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_MAX_LUFT_2SOLL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 10, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_MAX_LUFT_2SOLL_EINH", 1,"");
        ftextout( text_var, 10, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_VA_INFO", 1,"");
        ftextout( text_var, 11, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 11, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_VA_EINH", 1,"");
        ftextout( text_var, 11, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_HA_INFO", 1,"");
        ftextout( text_var, 12, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 12, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PREACH_HA_EINH", 1,"");
        ftextout( text_var, 12, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_REACH_2TOL_INFO", 1,"");
        ftextout( text_var, 13, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_REACH_2TOL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 13, 70, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_REACH_2TOL_EINH", 1,"");
        ftextout( text_var, 13, 77, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MIN_INFO", 1,"");
        ftextout( text_var, 14, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MIN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 14, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MIN_EINH", 1,"");
        ftextout( text_var, 14, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MAX_INFO", 1,"");
        ftextout( text_var, 15, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MAX_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 15, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PTOL_VA_MAX_EINH", 1,"");
        ftextout( text_var, 15, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_ENDE_INFO", 1,"");
        ftextout( text_var, 16, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_ENDE_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 16, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_WZ_ENDE_EINH", 1,"");
        ftextout( text_var, 16, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_VA_INFO", 1,"");
        ftextout( text_var, 17, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 17, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_VA_EINH", 1,"");
        ftextout( text_var, 17, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_HA_INFO", 1,"");
        ftextout( text_var, 18, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 18, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PENDE_HA_EINH", 1,"");
        ftextout( text_var, 18, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PUMPE_EFF_INFO", 1,"");
        ftextout( text_var, 19, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PUMPE_EFF_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 19, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_VA_UW_PUMPE_EFF_EINH", 1,"");
        ftextout( text_var, 19, 62, 0 ,0 );

        if(min_i450 == TRUE)
        {
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_VA_ERR_STATUS_INFO", 1,"");
          ftextout( text_var, 21, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_VA_ERR_STATUS_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 21, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_VA_ERR_STATUS_EINH", 1,"");
          ftextout( text_var, 21, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_ID_INFO", 1,"");
          ftextout( text_var, 23, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 23, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_EINH", 1,"");
          ftextout( text_var, 23, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_INFO", 1,"");
          ftextout( text_var, 24, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 24, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_EINH", 1,"");
          ftextout( text_var, 24, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_INFO", 1,"");
          ftextout( text_var, 25, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 25, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_EINH", 1,"");
          ftextout( text_var, 25, 62, 0 ,0 );
        }
      }
    }
  }
}

SCREEN s_inbe_daten_dyn_test_ha()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i400 = FALSE;
  bool min_i450 = FALSE;
  string chk_jobstatus ="";
  int llsw_HV_version;
  int llsw_UV_version;

  ftextout("ARS Daten letzte Inbetriebnahme",1,5,1,5);
  delay ( 500 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  //Wir gehen mal davon aus, die Version passt
  min_i400 = TRUE;
  min_i450 = TRUE;
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
    min_i400 = FALSE;
  }
  else
  {
    INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);
    INPAapiResultInt( llsw_UV_version, "STAT_UV_WERT", 1);

    if( llsw_HV_version < 6)
    {
      ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
      min_i400 = FALSE;
    }
    else if(zahl_var < 1.410)
    {
      min_i400 = FALSE;
      ftextout( "(SGBD muss mindestens Version 1.410 sein)", 4, 0, 0 ,0 );
    }
    else if(zahl_var < 2.310)
    {
      min_i450 = FALSE;
    }
    else if ( llsw_UV_version < 4 )
    {
      min_i450 = FALSE;
    }
  }

  LINE( "","" )
  {
    if(min_i400 == TRUE)
    {
      if(inbe_daten_info_einmal == TRUE)
      {
        inbe_daten_info_einmal = FALSE;
        INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_INBETRIEBNAHME", "" );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_RV_INFO", 1,"");
        ftextout( text_var, 1, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_RV_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 1, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_RV_EINH", 1,"");
        ftextout( text_var, 1, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_VA_INFO", 1,"");
        ftextout( text_var, 2, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 2, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_VA_EINH", 1,"");
        ftextout( text_var, 2, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_HA_INFO", 1,"");
        ftextout( text_var, 3, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 3, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PSTAU_HA_EINH", 1,"");
        ftextout( text_var, 3, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_U_INFO", 1,"");
        ftextout( text_var, 4, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_U_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 4, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_U_EINH", 1,"");
        ftextout( text_var, 4, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_B_INFO", 1,"");
        ftextout( text_var, 5, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_B_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 5, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_RV_B_EINH", 1,"");
        ftextout( text_var, 5, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_AKT_INFO", 1,"");
        ftextout( text_var, 6, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_AKT_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 6, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_AKT_EINH", 1,"");
        ftextout( text_var, 6, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_U_INFO", 1,"");
        ftextout( text_var, 7, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_U_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 7, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_U_EINH", 1,"");
        ftextout( text_var, 7, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_B_INFO", 1,"");
        ftextout( text_var, 8, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_B_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 8, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_LUFTZYKLEN_RV_B_EINH", 1,"");
        ftextout( text_var, 8, 62, 0 ,0 );

        if(min_i450 == TRUE)
        {
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_AKT_INFO", 1,"");
          ftextout( text_var, 9, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_AKT_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 9, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_AKT_EINH", 1,"");
          ftextout( text_var, 9, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_U_INFO", 1,"");
          ftextout( text_var, 10, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_U_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 10, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_U_EINH", 1,"");
          ftextout( text_var, 10, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_B_INFO", 1,"");
          ftextout( text_var, 11, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_B_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 11, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_RV_B_EINH", 1,"");
          ftextout( text_var, 11, 62, 0 ,0 );

        }
        else
        {
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_INFO", 1,"");
          ftextout( text_var, 9, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 9, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_LUFT_2SOLL_EINH", 1,"");
          ftextout( text_var, 9, 62, 0 ,0 );
        }
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_MAX_LUFT_2SOLL_INFO", 1,"");
        ftextout( text_var, 12, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_MAX_LUFT_2SOLL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 12, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_MAX_LUFT_2SOLL_EINH", 1,"");
        ftextout( text_var, 12, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_VA_INFO", 1,"");
        ftextout( text_var, 13, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 13, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_VA_EINH", 1,"");
        ftextout( text_var, 13, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_HA_INFO", 1,"");
        ftextout( text_var, 14, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 14, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PREACH_HA_EINH", 1,"");
        ftextout( text_var, 14, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_REACH_2TOL_INFO", 1,"");
        ftextout( text_var, 15, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_REACH_2TOL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 15, 70, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_REACH_2TOL_EINH", 1,"");
        ftextout( text_var, 15, 77, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MIN_INFO", 1,"");
        ftextout( text_var, 16, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MIN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 16, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MIN_EINH", 1,"");
        ftextout( text_var, 16, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MAX_INFO", 1,"");
        ftextout( text_var, 17, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MAX_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 17, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PTOL_HA_MAX_EINH", 1,"");
        ftextout( text_var, 17, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_ENDE_INFO", 1,"");
        ftextout( text_var, 18, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_ENDE_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 18, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_WZ_ENDE_EINH", 1,"");
        ftextout( text_var, 18, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_VA_INFO", 1,"");
        ftextout( text_var, 19, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 19, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_VA_EINH", 1,"");
        ftextout( text_var, 19, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_HA_INFO", 1,"");
        ftextout( text_var, 20, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 20, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PENDE_HA_EINH", 1,"");
        ftextout( text_var, 20, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PUMPE_EFF_INFO", 1,"");
        ftextout( text_var, 21, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PUMPE_EFF_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 21, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_DYN_HA_UW_PUMPE_EFF_EINH", 1,"");
        ftextout( text_var, 21, 62, 0 ,0 );

        if(min_i450 == TRUE)
        {
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_HA_ERR_STATUS_INFO", 1,"");
          ftextout( text_var, 23, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_HA_ERR_STATUS_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 23, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_DYN_HA_ERR_STATUS_EINH", 1,"");
          ftextout( text_var, 23, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_ID_INFO", 1,"");
          ftextout( text_var, 24, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 24, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_EINH", 1,"");
          ftextout( text_var, 24, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_INFO", 1,"");
          ftextout( text_var, 25, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 25, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_EINH", 1,"");
          ftextout( text_var, 25, 62, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_INFO", 1,"");
          ftextout( text_var, 26, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 26, 55, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_EINH", 1,"");
          ftextout( text_var, 26, 62, 0 ,0 );
        }
      }
    }
  }
}

SCREEN s_inbe_daten_pi_test()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i400 = FALSE;
  bool min_i450 = FALSE;
  string chk_jobstatus ="";
  int llsw_HV_version;
  int llsw_UV_version;

  ftextout("ARS Daten letzte Inbetriebnahme",1,5,1,5);
  delay ( 500 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  //Wir gehen mal davon aus, die Version passt
  min_i400 = TRUE;
  min_i450 = TRUE;
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
    min_i400 = FALSE;
  }
  else
  {
    INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);
    INPAapiResultInt( llsw_UV_version, "STAT_UV_WERT", 1);

    if( llsw_HV_version < 6)
    {
      ftextout( "(erst in I4.00 vollständig implementiert. SG Software > 4.0.0)", 5, 0, 0 ,0 );
      min_i400 = FALSE;
    }
    else if(zahl_var < 1.410)
    {
      min_i400 = FALSE;
      ftextout( "(SGBD muss mindestens Version 1.410 sein)", 4, 0, 0 ,0 );
    }
    else if(zahl_var < 2.310)
    {
      min_i450 = FALSE;
    }
    else if ( llsw_HV_version == 6 && llsw_UV_version < 4 )
    {
      min_i450 = FALSE;
    }
  }

  LINE( "","" )
  {
    if(min_i400 == TRUE)
    {
      if(inbe_daten_info_einmal == TRUE)
      {
        inbe_daten_info_einmal = FALSE;
        INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_INBETRIEBNAHME", "" );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_VA_INFO", 1,"");
        ftextout( text_var, 1, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 1, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_VA_EINH", 1,"");
        ftextout( text_var, 1, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_VA_INFO", 1,"");
        ftextout( text_var, 2, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 2, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_VA_EINH", 1,"");
        ftextout( text_var, 2, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_VA_INFO", 1,"");
        ftextout( text_var, 3, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 3, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_VA_EINH", 1,"");
        ftextout( text_var, 3, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_VA_INFO", 1,"");
        ftextout( text_var, 4, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 4, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_VA_EINH", 1,"");
        ftextout( text_var, 4, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_VA_INFO", 1,"");
        ftextout( text_var, 5, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 5, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_VA_EINH", 1,"");
        ftextout( text_var, 5, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_VA_INFO", 1,"");
        ftextout( text_var, 6, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 6, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_VA_EINH", 1,"");
        ftextout( text_var, 6, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_HA_INFO", 1,"");
        ftextout( text_var, 8, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 8, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P1_HA_EINH", 1,"");
        ftextout( text_var, 8, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_HA_INFO", 1,"");
        ftextout( text_var, 9, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 9, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP1_HA_EINH", 1,"");
        ftextout( text_var, 9, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_HA_INFO", 1,"");
        ftextout( text_var, 10, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 10, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P2_HA_EINH", 1,"");
        ftextout( text_var, 10, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_HA_INFO", 1,"");
        ftextout( text_var, 11, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 11, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP2_HA_EINH", 1,"");
        ftextout( text_var, 11, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_HA_INFO", 1,"");
        ftextout( text_var, 12, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 12, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_HA_EINH", 1,"");
        ftextout( text_var, 12, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_HA_INFO", 1,"");
        ftextout( text_var, 13, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 13, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_HA_EINH", 1,"");
        ftextout( text_var, 13, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_SD_HA_INFO", 1,"");
        ftextout( text_var, 15, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_SD_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 15, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_P3_SD_HA_EINH", 1,"");
        ftextout( text_var, 15, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_SD_HA_INFO", 1,"");
        ftextout( text_var, 16, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_SD_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 16, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_PI_TEST_UW_DP3_SD_HA_EINH", 1,"");
        ftextout( text_var, 16, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MIN_INFO", 1,"");
        ftextout( text_var, 18, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MIN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 18, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MIN_EINH", 1,"");
        ftextout( text_var, 18, 67, 0 ,0 );

        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MAX_INFO", 1,"");
        ftextout( text_var, 19, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MAX_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 19, 60, 0 ,0 );
        INPAapiResultText( text_var, "STAT_INB_UW_NPUMPE_MAX_EINH", 1,"");
        ftextout( text_var, 19, 67, 0 ,0 );

        if(min_i450 == TRUE)
        {
          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_ERR_STATUS_INFO", 1,"");
          ftextout( text_var, 21, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_ERR_STATUS_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 21, 60, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_ERR_STATUS_EINH", 1,"");
          ftextout( text_var, 21, 67, 0 ,0 );

          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_SD_ERR_STATUS_INFO", 1,"");
          ftextout( text_var, 22, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_SD_ERR_STATUS_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 22, 60, 0 ,0 );
          INPAapiResultText( text_var, "STAT_FSP_INB_PI_TEST_SD_ERR_STATUS_EINH", 1,"");
          ftextout( text_var, 22, 67, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_ID_INFO", 1,"");
          ftextout( text_var, 24, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 24, 60, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_ID_EINH", 1,"");
          ftextout( text_var, 24, 67, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_INFO", 1,"");
          ftextout( text_var, 25, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 25, 60, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_MOTOR_EINH", 1,"");
          ftextout( text_var, 25, 67, 0 ,0 );

          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_INFO", 1,"");
          ftextout( text_var, 26, 2, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_WERT", 1, "");
          stringtoreal( text_var, zahl_var );
          realtostring ( zahl_var, "5.0" , text_var );
          ftextout( text_var, 26, 60, 0 ,0 );
          INPAapiResultText( text_var, "STAT_INB_UW_T_AUSSEN_EINH", 1,"");
          ftextout( text_var, 26, 67, 0 ,0 );
        }
      }
    }
  }
}
//       ****************************************************
//       ***             M e n ü a u f b a u              ***
//       ****************************************************
// ***********************************
// *** ueber Menuepkt ANSTEUERN F6 ***
// ***********************************
// wird ueber F2 aktiviert in ICMV.SRC
// 
MENU m_inbetriebnahme()
 {
  INIT 
  {
    setmenutitle( "Auswahlmenue Funktion");
  }

  ITEM( 1, "Info" )  
  {
    infobox("Information","Programm zur Inbetriebnahme des ARS-Systems");
  }
  
  ITEM( 2, "Start" )  
  {
    //Leerlaufknopf ausschalten
    setitem(4, "LL-Anhebung", FALSE);
    setitem(5, "letzte Daten", FALSE);

    //eventuelle Altlasten entfernen
    message_box_close();
    setcolor(1,0);

    setstatemachine( ARS_INBETRIEBNAHME );
  }
  
  ITEM( 3, "Stop" )  
  {
    setstatemachine( F10_ABBRUCH_INBE );
    //Leerlaufknopf einschalten
    setitem(4, "LL-Anhebung", TRUE);
    setitem(5, "letzte Daten", TRUE);
  }

  ITEM( 4, "LL-Anhebung" )
  {
     delete_screen();
     setcolor(1,0);
     setscreen(s_leerlauf_anhebung,TRUE);
     setmenu( m_leerlauf_anhebung );
  }
  
  ITEM( 5, "letzte Daten" )
  {
     inbe_daten_info_einmal = TRUE;
     delete_screen();
     setcolor(1,0);
     setscreen(s_inbe_daten_dyn_test_va,TRUE);
     setmenu( m_inbe_daten );
  }
  
  ITEM( 9, "Zurück" )
  {
     delete_screen();
     setcolor(1,0);
     setmenu (m_main);
     setscreen(s_steuern,TRUE);
     setmenu( m_steuern );
  }
  
  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
// ***********************************
// *** ueber Menuepkt ANSTEUERN F6 ***
// ***********************************
// wird ueber F4 aktiviert in ICMV.SRC
// 
MENU m_leerlauf_anhebung()
 {
  INIT 
  {
    setmenutitle( "Leerlaufdrehzahlanhebung");
  }

  ITEM( 9, "Zurück" )
  {
     setscreen(s_inbetriebnahme,TRUE);
     setmenu( m_inbetriebnahme );
  }
  
  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
// ***********************************
// *** ueber Menuepkt ANSTEUERN F6 ***
// ***********************************
// wird ueber F5 aktiviert in ICMV.SRC
// 
MENU m_inbe_daten()
 {
  INIT 
  {
    setmenutitle( "Daten der letzten Inbetriebnahme");
  }

  ITEM( 1, "Dyn. Test VA" )
  {
     inbe_daten_info_einmal = TRUE;
     setscreen(s_inbe_daten_dyn_test_va,TRUE);
     setmenu( m_inbe_daten );
  }
  ITEM( 2, "Dyn. Test HA" )
  {
     inbe_daten_info_einmal = TRUE;
     setscreen(s_inbe_daten_dyn_test_ha,TRUE);
     setmenu( m_inbe_daten );
  }
  ITEM( 3, "PI-KL Test" )
  {
     inbe_daten_info_einmal = TRUE;
     setscreen(s_inbe_daten_pi_test,TRUE);
     setmenu( m_inbe_daten );
  }
  ITEM( 9, "Zurück" )
  {
     setscreen(s_inbetriebnahme,TRUE);
     setmenu( m_inbetriebnahme );
  }
  
  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
//       ****************************************************
//       ****************************************************
//       ****************************************************
STATEMACHINE  F10_ABBRUCH_INBE()
{
  INIT
   {
     delete_screen();
     setcolor(1,4);
     message_box_open("Abbruch ARS Inbetriebnahme","","");
     ARS_TEST_OK = FALSE;
     fehlertext_1 = "Abbruchtaste F10 gedrueckt";  
     fehlertext_2 = "";
     endebehandlung_inbe();
   }
}

//   ************************************************************************
//   ***  S t a r t   S t a t e m a c h i n e   A b l a u f  G E S A M T  ***
//   ***                     Statemachine 1. Ebene                        ***
//   *************************************************************************


//
// Aufruf in MENU 'm_inbetriebnahme'
//
STATEMACHINE ARS_INBETRIEBNAHME()
{
  INIT
  {
    setstate ( ZUENDUNG );
  }

  // Schritt 1 - Abfrage, ob Zündung Ein 
  ZUENDUNG
  {
    // fehlerhafte Motordrehzahl verhindern
    meldung_1( "Zündung Ein?" );

    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( IST_MOTOR_AUS );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 2
  // definiertes Druckniveau an den Ventilen herstellen
  IST_MOTOR_AUS
  {
    callstatemachine( MOTOR_STATUS_AUS );

    // Motor ist aus
    // Motordrehzahl ist korrekt
    // d.h. KEINE fehlerhafte Motordrehzahl
    if ( status_motor_aus == TRUE )
    {
      setstate ( SG_NICHT_EINSCHLAFEN );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3
  // vermeidet das Einschlafen des SG's am Bus
  SG_NICHT_EINSCHLAFEN
  {
    meldung_1( "Zündung Ein?" );
    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( FEHLERSPEICHER_LOESCHEN_LESEN );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3b
  FEHLERSPEICHER_LOESCHEN_LESEN
  {
     meldung_2( "Fehlerspeicher löschen" );
     callstatemachine( FEHLERSPEICHER );

     if (fehlerspeicher_loeschen == TRUE)
      {
        setstate( OFFSET_WERTE_LERNEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  //////////////////////////////////////////////////////////////////////////////////
  //        Beginn Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 7
  OFFSET_WERTE_LERNEN
  {
     meldung_3( "Offsetwerte lernen" );
     callstatemachine( OFFSET_WERTE );

     if ( werte_lernen == TRUE )
      {
         setstate( STEUERGERAETE_RESET ); 
      }
     else
      {
         setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  //////////////////////////////////////////////////////////////////////////////////
  //        Ende Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 10
  STEUERGERAETE_RESET
  {
    meldung_7( "Steuergeräte Reset erfolgt" );

    callstatemachine( SG_RESET );
    if ( sg_reset == TRUE )
    {
      setstate( STATUS_ABFRAGE_MOTOR );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 12
  STATUS_ABFRAGE_MOTOR
  {
     callstatemachine( MOTOR_STATUS );

     if ( status_leerlauf == TRUE )
     {
       setstate( MOTORDREHZAHL_VORGEBEN );
     }
    else
     {
       setstate( PRUEFUNG_AUSWERTUNG );
     }
  }

  // Schritt 13
  MOTORDREHZAHL_VORGEBEN
  {
     callstatemachine( MOTORDREHZAHL );

     if ( status_erhoehte_drehzahl == TRUE )
      {
         setstate( PRUEFUNG_STARTEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 14
  PRUEFUNG_STARTEN
  {
     callstatemachine( STANDWANKEN_INBE );

     if ( start_inbetriebnahme_okay == TRUE )
      {
        setstate( ABFRAGE_PRUEFABLAUF );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 15
  ABFRAGE_PRUEFABLAUF
  {
     callstatemachine( STATUS_STANDWANKEN_INBE );

     setstate( PRUEFUNG_AUSWERTUNG );
  }

  
  PRUEFUNG_AUSWERTUNG
  {
     callstatemachine( AUSWERTUNG_INBE );

     setstate( ENDE_PRUEFUNG );
  }
      
  ENDE_PRUEFUNG
  {
     endebehandlung_inbe();      // Dokumentation und Fehlerausdruck
  }
}

// Ende Statemachine "ARS_Inbetriebnahme", 1. Ebene, Pruefablauf gesamt 

// **********************************************************************
// **********  Statemachines  ARS_Inbetriebnahme 2. Ebene  **************
// **********      Aufruf Job's und Auswertungen           **************
// **********************************************************************

STATEMACHINE MOTOR_STATUS_AUS()
{

  real motor_laeuft;
  // Ausschaltzeit 30 sec.
  int zaehler = 30;  
  string zaehler_txt = "";
  string fehler_drehzahl_motor_wert_z = "";
  int fehler_drehzahl_motor_wert ;

  int zaehler_fehler_motor_drehzahl = 0;

  INIT
  {
     setcolor(1,8);   // gelb mit schwarzer Schrift
     action_box_open("Motor MUSS AUS sein!","","");
     setstate( STATUS_MOTORDREHZAHL_NULL );
  }


  STATUS_MOTORDREHZAHL_NULL
  {
    job_state="";
    INPAapiJob( sgbd ,"STATUS_LESEN", "ARG;STATUS_FR_DREHZAHL_ARS", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");
    if (job_state != "OKAY")
    {
      //I3.15 Stand
      INPAapiJob(sgbd, "STATUS_LESEN", "ID;0x4102", "" );
      INPAapiResultText(job_state,"JOB_STATUS",1,"");
    }
    INPAapiResultAnalog(motor_laeuft,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout ( motor_laeuft, 24, 5, 0, 1500, 500, 1000, "4" );

    // Plausibilitaet der Motordrehzahl abpruefen
    // Ergebnis liegt nur als Zeichenkette vor

    INPAapiResultText( fehler_drehzahl_motor_wert_z, "STAT_FEHLER_DREHZAHL_MOTOR_WERT", 1, "");
    stringtoint( fehler_drehzahl_motor_wert_z, fehler_drehzahl_motor_wert );

    // Motordrehzahl ist korrekt
    // d.h. KEINE fehlerhafte Motordrehzahl
    if ( fehler_drehzahl_motor_wert == 1 )
    {
      // Motor ist AUS
      // keine Drehzahl, Wert '0' problematisch, daher 10 U/min
      if ( motor_laeuft < 10 ) 
      {
        status_motor_aus = TRUE;
        action_box_close();
        returnstatemachine();
      }
      // Motoer laeuft
      else
      {           
        if ( zaehler > 0 )    // wenn Motor nach 30 sec. nicht aus ist, dann Ende
        {
          zaehler = zaehler - 1;
          delay(1000);
          setstate( STATUS_MOTORDREHZAHL_NULL );
  
          inttostring( zaehler, zaehler_txt );
          ftextout( "verbleibende Ausschaltzeit", 26, 40, 1, 1 );     
          meldung_4( zaehler_txt );
  
        }
        else
        {
          status_motor_aus = FALSE;
          fehlertext_1 = "Motor wurde nicht abgeschaltet";
          fehlertext_2 = "";
          action_box_close();
          delay(5000);
          returnstatemachine();
        }
      }
    }
    // fehlerhafte Motordrehzahl
    else
    {
      // Wartezeit ob das Motordrehzahlsignal noch gueltig wird
      // maximale Wartezeit 20 sec
      // 20 sec = 20 * 1000 msec
      if ( zaehler_fehler_motor_drehzahl < 20 )
      {
        // 1000 msec warten
        // 1 sec warten
        delay( 1000 );
        zaehler_fehler_motor_drehzahl = zaehler_fehler_motor_drehzahl + 1;

        // Statemachine nochmal durchlaufen
        setstate ( STATUS_MOTORDREHZAHL_NULL ); 
      }
      // Wartezeit 20 sec ist abgelaufen
      else
      {
        status_motor_aus = FALSE;
        fehlertext_1 = "Motordrehzahlsignal war ungültig";
        fehlertext_2 = "";
        action_box_close();
        delay(1000);
        returnstatemachine();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE OFFSET_WERTE()  // Schritt 4, Sensorwerte lernen
{

    string error_job_state = "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR";

    INIT
    {

        job_state="";

        INPAapiJob(sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;STR", "" );
        INPAapiResultText(job_state,"JOB_STATUS",1,"");

        if (job_state == "OKAY")
         {
            werte_lernen = TRUE;
            digitalout(FALSE,13,62,"","i.O.");
            returnstatemachine();
         }
        else  // *********** Jobstatus nicht OKAY   *************
         {
            werte_lernen = FALSE;
            if (job_state == error_job_state)
             {
                fehlertext_1 = "Job Status STEUERN_START_OFFSET_WERTE nicht OKAY";
                fehlertext_2 = "Radgeschwind.(DSC), Offsetpegel oder Sensorwerte n.i.O.";
                returnstatemachine();
             }
            else
             { 
                fehlertext_1 = "Job Status STEUERN_START_OFFSET_WERTE nicht OKAY";
                fehlertext_2 = job_state;
                returnstatemachine();
             }
         }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE SG_RESET()
{
  INIT
  {
    INPAapiJob( sgbd, "STEUERGERAETE_RESET", "", "" );
    INPAapiResultText(job_state, "JOB_STATUS", 1, "");
    
    if (job_state == "OKAY")
    {
      sg_reset = TRUE;
      digitalout(FALSE,22,62,"","i.O.");

      // Programmablauf wird um 3sec verzoegert
      delay (3000);

      returnstatemachine();

    } 
    else   // *****  Jobstatus nicht OKAY ***********
    {
      sg_reset = FALSE;
      fehlertext_1 = "Steuergeräte RESET NICHT OKAY";
      fehlertext_2 = job_state;
      returnstatemachine();
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE FEHLERSPEICHER()
{

  INIT
  {
//        infobox("Fehlerspeicher","löschen");   // kann zu Testzwecken aktiviert werden
     
    INPAapiJob(sgbd,"FS_LOESCHEN","","");
    INPAapiResultText(job_state, "JOB_STATUS", 1, "");
          
    if (job_state == "OKAY")
    {
      fehlerspeicher_loeschen = TRUE;
      digitalout(FALSE,10,62,"","i.O.");
      returnstatemachine();
    } 
    else   // *****  Jobstatus nicht OKAY ***********
    {
      fehlerspeicher_loeschen = FALSE;
      fehlertext_1 = "Fehlerspeicher loeschen NICHT OKAY";
      fehlertext_2 = job_state;
      returnstatemachine();
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE MOTOR_STATUS()
{

  real motor_laeuft;
  int zaehler = 120;
  string zaehler_txt = "";
 
  INIT
  {
    setcolor(1,8);   // gelb mit schwarzer Schrift
    ftextout("ARS Inbetriebnahme und Prüfung", 2,5,2,5);
    action_box_open("Bitte den Motor starten!","","");
    setstate(STATUS_MOTORDREHZAHL);
  }

  STATUS_MOTORDREHZAHL
  {
    job_state="";
    INPAapiJob(sgbd, "STATUS_LESEN", "ARG;STATUS_FR_DREHZAHL_ARS", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state != "OKAY")
    {
      //I3.15 Stand
      INPAapiJob(sgbd, "STATUS_LESEN", "ID;0x4102", "" );
    }
    INPAapiResultAnalog(motor_laeuft,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout ( motor_laeuft, 26, 40, 0, 1500, 500, 1000, "4" );

    if ((motor_laeuft > 500) && (motor_laeuft < 1000))
    {
      status_leerlauf = TRUE;
      action_box_close();
      returnstatemachine();
    }
    else
    {
      if ( zaehler > 1 )    // wenn Motor nach 2 min. nicht laeuft, dann Ende
      {
        zaehler = zaehler - 1;
        inttostring( zaehler, zaehler_txt );
        ftextout ( "Wartezeit: ", 26, 5, 1 ,1 );
        ftextout ( "sec", 26, 27, 1 ,1 );
        meldung_4 ( zaehler_txt );
        delay(1000);
        setstate(STATUS_MOTORDREHZAHL);
      }
      else
      {
        status_leerlauf = FALSE;
        fehlertext_1 = "Motor laeuft nicht mit Leerlaufdrehzahl";
        fehlertext_2 = "";
        action_box_close();
        returnstatemachine();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE MOTORDREHZAHL()
{
  real drehzahl = 0;
  string dh = "";
  string sgbd_name = "";
  string help_api_job0 = "";
  string text_var = "";
  int zaehler = 0;
  int errorcode1;
  string errortext1;
  string errorcode1_txt;
    
  INIT
  {
    message_box_open("Automatische Drehzahlerhöhung","","Motordrehzahl wird erhöht");
  
    setstate(MOTORDREHZAHL_VORGEBEN);
  }
        
  MOTORDREHZAHL_VORGEBEN
  {        
    INPAapiJob("G_MOTOR","INITIALISIERUNG","","");
    INP1apiErrorCode(errorcode1);
    
    if (errorcode1 != 0)
    {
      //Fehlertext erst holen, wenn auch wirklich ein Fehler da ist.
      INP1apiErrorText(errortext1);
      inttostring( errorcode1, errorcode1_txt );
      infobox("Fehler","kein Motor gefunden: Errorcode "+errorcode1_txt+" "+errortext1);
      infobox("Warnung","Test wird ohne Drehzahlerhöhung fortgesetzt");
      //weitermachen ohne Motor
      pruefung_ohne_drehzahlerhoehung = TRUE;
      message_box_close();
      delay(500);
      setstate (MOTORDREHZAHL_ABFRAGEN);
    }
    else
    {
      INPAapiResultText(sgbd_name,"VARIANTE",0,"");          // Satz 0 ist richtig!
      //infobox("DME Steuergerät",sgbd_name);                 // kann zu Testzwecken aktiviert werden

      //  "MSD87"        für 6 Zylinder
      //  "MSD85L6"      für 8 Zylinder 
      //  "MSD87_R0"     für 12 Zylinder
      //  "D73N57A0"     für 6 Zylinder Diesel

      // ****************** alle Motoren gleichbehandeln ****************

      help_api_job0 = "START_SYSTEMCHECK_LLERH";            // Leerlaufdrehzahl erhöhen 
      //Solldrehzahl aus Steuergerät abfragen
      INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_DREHZAHLANHEBUNG", "" );
      INPAapiResultText(job_state,"JOB_STATUS",1,"");

      if (job_state == "OKAY")
      {
        INPAapiResultText( text_var, "STAT_MOTORDREHZAHL_WERT", 1, "");
        stringtoreal( text_var, drehzahl );
        //Plausibilität prüfen
        if(drehzahl > 1500 || drehzahl < 800)
        {
          realtostring ( drehzahl, "5.0", text_var );
          infobox("Fehler","Steuergerät meldet unzulässige Leerlaufdrehzahl: "+text_var+" 1/min");
          drehzahl = 800;
        }
      }
      else
      {
        drehzahl = 800;                               // Solldrehzahl 800 U/min
      }
      realtostring ( drehzahl, "3.0", dh );        
      //  ****************************************************************
      //  ***     Job aus Variablen zusammensetzen und abschicken      ***
      //  ****************************************************************

      job_state = "";  
      INPAapiJob( sgbd_name, help_api_job0, dh, "" );
      INP1apiErrorCode(errorcode1);
      
      if(errorcode1 == 0)
      {
        INPAapiResultText(job_state,"JOB_STATUS",1,"");
      }

      if (job_state == "OKAY")
      {
        drehzahl_wurde_erhoeht = TRUE;
        message_box_close();
        delay(500);
        setstate (MOTORDREHZAHL_ABFRAGEN);
      }
      else  // *********** Jobstatus nicht OKAY   *************
      {
        //Nachfrage, ob trotz Jobfehler weitergemacht werden soll
        inputdigital(weitermachen_trotz_job_fehler, help_api_job0,"Job schlug fehl! Trotzdem fortsetzen?","Nein","Ja");
        
        if(weitermachen_trotz_job_fehler == TRUE)
        {
          pruefung_ohne_drehzahlerhoehung = TRUE;
          message_box_close();
          delay(500);
          setstate (MOTORDREHZAHL_ABFRAGEN);
        }
        else
        {
          status_erhoehte_drehzahl = FALSE;
          fehlertext_1 = "Drehzahl vorgeben";
          fehlertext_2 = job_state;
          returnstatemachine();
        }
      }
    }
  }


  MOTORDREHZAHL_ABFRAGEN
  { 
    job_state = "";
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_FR_DREHZAHL_ARS", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state != "OKAY")
    {
      //I3.15 Stand
      INPAapiJob(sgbd, "STATUS_LESEN", "ID;0x4102", "" );
    }
    INPAapiResultAnalog(drehzahl,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout (drehzahl, 24, 5, 500, 2000, 700, 1000, "4" );

//    realtostring ( drehzahl, "4.0", dh );
//    infobox("aktuelle Motordrehzahl", dh);   // kann zu Testzwecken aktiviert werden

    if ((drehzahl > 700) && (drehzahl < 1000) || pruefung_ohne_drehzahlerhoehung == TRUE)     
    {
      status_erhoehte_drehzahl = TRUE;
      message_box_close();
  
      returnstatemachine();
    }
    else   // ***********   Motor hat Drehzahl noch nicht erreicht   *************
    {
      if (zaehler < 10)    // 10 sec warten 
      {
        zaehler = zaehler+1;
        delay (1000);
  
        setstate( MOTORDREHZAHL_ABFRAGEN);
      }
      else
      {
        status_erhoehte_drehzahl = FALSE;
        message_box_close();
        fehlertext_1 = "Erforderliche Drehzahl nicht erreicht";
        fehlertext_2 = "";
        returnstatemachine();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE STANDWANKEN_INBE()
{

  INIT
  {
    message_box_open("Achtung!","Dynamische Prüfung","Fahrzeug bewegt sich");
  
    setstate(PRUEFUNG_STARTEN);
  }

  PRUEFUNG_STARTEN
  {
    job_state="";

    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_INBETRIEBNAHME;STR", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state == "OKAY")
    {
      start_inbetriebnahme_okay = TRUE;
      returnstatemachine();
    }
    else  // *********** Jobstatus nicht OKAY   *************
    {
      start_inbetriebnahme_okay = FALSE;
      fehlertext_1 = "Start Inbetriebnahme";
      fehlertext_2 = job_state;
      message_box_close();
      returnstatemachine();
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE STATUS_STANDWANKEN_INBE()
{

  int zustand = 0;
  int fortschritt = 0;
  int laeuft = 0;
  int gesamt_ergebnis = 0;
  int zaehler = 0;
  int i = 1;
  int warn_drehzahl = 0;
  int warn_luft = 0;
  int int_var = 0;
 
  string zaehler_txt = "";
  string warn_drehzahl_txt = "";
  string warn_luft_txt = "";
  
  string gesamt_ergebnis_txt = "";
  string result_var = "";
  string text_var = "";
  string text_temp = "";
  int fortschritt_inbetriebnahme_ende = 0;
  string chk_jobstatus ="";
  int llsw_HV_version;

  INIT
  {
    setstate( STATUS_INBETRIEBNAHME );
  }


  STATUS_INBETRIEBNAHME
  {
    job_state = "";
    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_INBETRIEBNAHME;RRR", "" );
    INPAapiResultText( job_state, "JOB_STATUS", 1, "" );

    if ( job_state == "OKAY" )
    {
      delay( 100 );   // Verzoegerungszeit
      setstate ( STATUS_LESEN_BYTE_1 ); 
    }
    else  // *********** Jobstatus nicht OKAY  *************
    {
      if( job_state == "ERROR_ECU_RESPONSE_TOO_LESS_DATA" )
      {
        //SG ist wohl I3.15
        SG_ist_I315 = TRUE;
      }
      else
      {
        infobox( "unerwartetes Jobresult", job_state);
      }
      inbetriebnahme = FALSE;
      fehlertext_1 = "Status Inbetriebnahme abfragen";
      fehlertext_2 = job_state;
      message_box_close();
      delay( 1500 );

      returnstatemachine();
    }
  } 


  STATUS_LESEN_BYTE_1      // ****** Abfrage, ob Test noch laeuft ******
  {
    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_INBETRIEBNAHME;RRR", "" );

    INPAapiResultInt( fortschritt, "STAT_FORTSCHRITT_NR", 1 );   
    INPAapiResultText( text_var, "STAT_FORTSCHRITT_NR_TEXT", 1, "" );
    
    INPAapiResultInt( laeuft, "STAT_AKTIV_NR", 1 );   

    ftextout("Prüfschritt:",28,1,1,0);
    clearrect(28,30,2,53);
    ftextout(text_var,28,28,1,0);

    //sus Prüfung auf andere Variable: nicht Fortschritt sondern Aktiv
    if ( laeuft !=0 )             // größer 0 = Pruefung laeuft, 0 = Pruefung fertig
    {
      if ( zaehler < 60 )     // max. Zeit vorgeben, dann Abbruch (1 min)
      {
        zaehler = zaehler + 1;
        inttostring( zaehler, zaehler_txt );
        ftextout("Prüfzeit",26,40,1,1);     
        meldung_4(zaehler_txt);
        delay(1000);                     // 1 sec warten, dann wieder lesen 
        setstate(STATUS_LESEN_BYTE_1);
      }
      else
      {
        inbetriebnahme = FALSE;
        fehlertext_1 = "Zeitüberschreitung Dynamische Prüfung";
        fehlertext_2 = "";
        message_box_close();
        returnstatemachine();
      }
    }
    else
    {
      //Infos immer anzeigen, ausser Abbruch durch externe Ursachen (s.u.)
      suppress_infos = 0;
      //Texte löschen
      fehler_inbetriebnahme  ="";
      fehler_inbetriebnahme2 ="";
      //Lowlevel SW Version prüfen
      fortschritt_inbetriebnahme_ende = 6; //Endekennung für SW vor I4.00
      INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
        INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);

        if( llsw_HV_version >= 6)
        {
          fortschritt_inbetriebnahme_ende = 99; //Endekennung ab I4.00
        }
      }
      
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_INBETRIEBNAHME;RRR", "" );

      INPAapiResultInt(gesamt_ergebnis,"STAT_ERGEBNIS_NR",1);   // Gesamtergebnis auslesen
      
      if ( ( gesamt_ergebnis == 2 ) && ( fortschritt == fortschritt_inbetriebnahme_ende ))   // ohne Fehler durchgelaufen
      {
        INPAapiResultText( text_var, "STAT_ERGEBNIS_NR_TEXT", 1, "" );
        // fuer DEBUG Zwecke 
        //infobox ( "Inbetriebnahme IO", text_var );

        INPAapiResultInt(warn_drehzahl,"STAT_WARNUNG_DREHZAHL_NR",1);   // Warnung Drehzahl auslesen
        INPAapiResultInt(warn_luft,"STAT_WARNUNG_LUFT_NR",1);           // Warnung Luft auslesen
        
        // keine Warnungen
        if ( warn_drehzahl == 0 && warn_luft == 0 )
        {
          // keine Anzeige, da alles in Ordnung
        }
        // vorhandene Warnungen werden angezeigt ( z.B. Luft im VA System )
        else if ( warn_drehzahl != 0 || warn_luft != 0 )
        {
          //              bool Varible out            , int Variable out
          //              erzeugen erfolgreich        , HANDLE auf Array
          StrArrayCreate( b_handleStringArr_Warnungen, handleStringArr_Warnungen );

          // Speicherplatz erfolgreich reserviert ?
          if ( b_handleStringArr_Warnungen == FALSE )
          {
            infobox ( "b_handleStringArr_Warnungen", "FALSE" );
            exit();
          }

          StrArrayCreate( b_handleStringArr_Einzeltests, handleStringArr_Einzeltests );

          // Speicherplatz erfolgreich reserviert ?
          if ( b_handleStringArr_Einzeltests == FALSE )
          {
            infobox ( "b_handleStringArr_Einzeltests", "FALSE" );
            exit();
          }
          
          result_var =  "STAT_ERGEBNIS_NR_TEXT";

          INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
          fehlertext_1 = fehler_inbetriebnahme;
          fehlertext_2 = fehler_inbetriebnahme2;

          INPAapiResultText(warn_drehzahl_txt,"STAT_WARNUNG_DREHZAHL_NR_TEXT",1, "");
          INPAapiResultText(warn_luft_txt,"STAT_WARNUNG_LUFT_NR_TEXT",1, "");
          
          StrArrayWrite(handleStringArr_Warnungen, 1, warn_drehzahl_txt);
          StrArrayWrite(handleStringArr_Warnungen, 2, warn_luft_txt);
          
          
          INPAapiResultText(text_var,"STAT_DYNAMIKTEST_VA_NR_TEXT",1, "");
          StrArrayWrite(handleStringArr_Einzeltests, 1, "Dynamiktest Vorderachse:");
          StrArrayWrite(handleStringArr_Einzeltests, 2, text_var);
          INPAapiResultText(text_var,"STAT_DYNAMIKTEST_HA_NR_TEXT",1, "");
          StrArrayWrite(handleStringArr_Einzeltests, 3, "Dynamiktest Hinterachse:");
          StrArrayWrite(handleStringArr_Einzeltests, 4, text_var);
          INPAapiResultText(text_var,"STAT_PI_KENNLINIENTEST_NR_TEXT",1, "");
          StrArrayWrite(handleStringArr_Einzeltests, 5, "PI Kennlinientest:");
          StrArrayWrite(handleStringArr_Einzeltests, 6, text_var);
          INPAapiResultText(text_var,"STAT_SAUGDROSSELTEST_NR_TEXT",1, "");
          StrArrayWrite(handleStringArr_Einzeltests, 7, "Saugdrosseltest:");
          StrArrayWrite(handleStringArr_Einzeltests, 8, text_var);
          
          // 10 sec Anzeige auf dem Schirm
          callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );
          // StringArray wird gelöscht
          StrArrayDestroy (handleStringArr_Einzeltests);
          StrArrayDestroy (handleStringArr_Warnungen);
        }
        // fuer DEBUG Zwecke 
        //infobox("Inb Kurzmeldung","Inbetriebnahme TRUE");

        inbetriebnahme = TRUE;
        message_box_close();
        delay(1500);
        returnstatemachine();
      }
      // fehlerhafte Inbetriebnahme
      else
      {
        // fuer DEBUG Zwecke 
        //infobox("Inb Kurzmeldung","Inbetriebnahme FALSE");

        inbetriebnahme = FALSE;

        //              bool Varible out            , int Variable out
        //              erzeugen erfolgreich        , HANDLE auf Array
        StrArrayCreate( b_handleStringArr_Warnungen, handleStringArr_Warnungen );

        // Speicherplatz erfolgreich reserviert ?
        if ( b_handleStringArr_Warnungen == FALSE )
        {
          infobox ( "b_handleStringArr_Warnungen", "FALSE" );
          exit();
        }

        StrArrayCreate( b_handleStringArr_Einzeltests, handleStringArr_Einzeltests );
        // Speicherplatz erfolgreich reserviert ?
        if ( b_handleStringArr_Einzeltests == FALSE )
        {
          infobox ( "b_handleStringArr_Einzeltests", "FALSE" );
          exit();
        }
        
        //Prüfen auf Inbetriebnahmeabbruch
        INPAapiResultInt( int_var, "STAT_READYNESS_ERROR_DETAIL_NR", 1);

        if(int_var != 0)
        {
          //externer Abbruch ist gegeben, Abbruchgrund als Text ausgeben
          result_var =  "STAT_READYNESS_ERROR_DETAIL_NR_TEXT";
        }
        else
        {
          //Inbetriebnahme durchgelaufen, Ergebnis als Text ausgeben
          result_var =  "STAT_ERGEBNIS_NR_TEXT";
        }
        INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
        fehlertext_2 = fehler_inbetriebnahme2;
        
        //Prüfen Readyness Grund
        INPAapiResultInt( int_var, "STAT_READYNESS_NR" , 1);
        text_var = "";
        if(int_var != 0)
        {
          INPAapiResultText( text_var, "STAT_READYNESS_NR_TEXT" , 1, "");      
          fehler_inbetriebnahme2 = fehler_inbetriebnahme;
          fehler_inbetriebnahme = text_var+":";
          suppress_infos = 1;
        }
        fehlertext_1 = fehler_inbetriebnahme;
        fehlertext_2 = fehler_inbetriebnahme2;
        
        INPAapiResultText(warn_drehzahl_txt,"STAT_WARNUNG_DREHZAHL_NR_TEXT",1, "");
        INPAapiResultText(warn_luft_txt,"STAT_WARNUNG_LUFT_NR_TEXT",1, "");
        
        StrArrayWrite(handleStringArr_Warnungen, 1, warn_drehzahl_txt);
        StrArrayWrite(handleStringArr_Warnungen, 2, warn_luft_txt);
        
        
        INPAapiResultText(text_var,"STAT_DYNAMIKTEST_VA_NR_TEXT",1, "");
        StrArrayWrite(handleStringArr_Einzeltests, 1, "Dynamiktest Vorderachse:");
        StrArrayWrite(handleStringArr_Einzeltests, 2, text_var);
        INPAapiResultText(text_var,"STAT_DYNAMIKTEST_HA_NR_TEXT",1, "");
        StrArrayWrite(handleStringArr_Einzeltests, 3, "Dynamiktest Hinterachse:");
        StrArrayWrite(handleStringArr_Einzeltests, 4, text_var);
        INPAapiResultText(text_var,"STAT_PI_KENNLINIENTEST_NR_TEXT",1, "");
        StrArrayWrite(handleStringArr_Einzeltests, 5, "PI Kennlinientest:");
        StrArrayWrite(handleStringArr_Einzeltests, 6, text_var);
        INPAapiResultText(text_var,"STAT_SAUGDROSSELTEST_NR_TEXT",1, "");
        StrArrayWrite(handleStringArr_Einzeltests, 7, "Saugdrosseltest:");
        StrArrayWrite(handleStringArr_Einzeltests, 8, text_var);
        
        // 10 sec Anzeige auf dem Schirm
        callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );
        // StringArray wird gelöscht
        StrArrayDestroy (handleStringArr_Einzeltests);
        StrArrayDestroy (handleStringArr_Warnungen);

        message_box_close();
        returnstatemachine();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE WARNUNG_FEHLER_DARSTELLUNG()
{
  INIT
  {
    action_box_meldung_inbetriebnahme ( fehler_inbetriebnahme, fehler_inbetriebnahme2, handleStringArr_Warnungen, handleStringArr_Einzeltests, suppress_infos );
    // 10 sec. Anzeige auf dem Schirm
    delay ( 10000 );
    infobox("Hinweis","Detailansicht wird geschlossen!");
    action_box_close();
    returnstatemachine();
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE AUSWERTUNG_INBE()     // Schritt 13, Prüfablauf auswerten
{
   INIT
   {
      
      if (( zuendung_ein_test == TRUE ) && ( status_motor_aus == TRUE ) && 
          ( werte_lernen == TRUE ) &&
          ( sg_reset == TRUE ) && ( fehlerspeicher_loeschen == TRUE ) && ( status_leerlauf == TRUE ) &&
          ( status_erhoehte_drehzahl == TRUE ) && ( start_inbetriebnahme_okay == TRUE ) &&
          ( inbetriebnahme == TRUE ))
      {
         ARS_TEST_OK = TRUE;
         setcolor(1,10);      // Bildschirm grün
         message_box_open("Ende Prüfablauf","","Prüfung i.O.");
         delay(1500);
         returnstatemachine();
      }
      else  // *********** Pruefung nicht OKAY   *************
      {
          ARS_TEST_OK = FALSE;
          setcolor(1,4);       // Bildschirm rot

          //I3.15 Stand abfragen
          if (SG_ist_I315==TRUE)
          {
            message_box_open("Ende Prüfablauf","vermutlich I3.15 Stand","Fehlerspeicher überprüfen");
          }
          else
          {
            message_box_open("Ende Prüfablauf","","Prüfung n.i.O.");
          }
          delay(1500);
          returnstatemachine();
       }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

// Zuendung an/aus
STATEMACHINE STATUS_KL15()
{
  bool kl_15_ein = FALSE;
  // Ausschaltzeit 30 sec.
  int zaehler = 30;  
  string zaehler_txt = "";

  INIT
  {
//     setcolor( 1, 8 );   // gelb mit schwarzer Schrift
//     action_box_open( "Bitte Zündung einschalten" ,"" ,"" );
     setstate( STATUS_KLEMME15_AUS );
  }

  STATUS_KLEMME15_AUS
  {
    //sus klären ob das noch geht?
    //INPAapiJob( "UTILITY", "STATUS_ZUENDUNG", "", "" );
    //INPAapiResultDigital( kl_15_ein, "STAT_ZUENDUNG", 1 );
    kl_15_ein = TRUE; //sus erst mal immer true

    if ( kl_15_ein == TRUE )
    {
      zuendung_ein_test = TRUE;
      digitalout(FALSE,7,62,"","i.O.");
      action_box_close();
      //delay( 1500 );
      returnstatemachine();
    }
    else   // *****  Zuendung ist faelschlicherweise aus ***********
    {
      setcolor( 1, 8 );   // gelb mit schwarzer Schrift
      action_box_open( "Bitte Zündung einschalten" ,"" ,"" );

      if ( zaehler > 0 )    // wenn Zuendung nach 30 sec. nicht ein ist, dann Ende
      {
        zaehler = zaehler - 1;
        delay(1000);
        setstate( STATUS_KLEMME15_AUS );

        inttostring( zaehler, zaehler_txt );
        ftextout( "verbleibende Einschaltzeit", 26, 40, 1, 1 );     
        meldung_4( zaehler_txt );

      }
      else
      {
       zuendung_ein_test = FALSE;
       fehlertext_1 = "Zündung ist aus";
       fehlertext_2 = "";
       delay( 2000 );
       action_box_close();
       returnstatemachine();
      }
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
// end of :#include "inb_l6.src"
// start of :#include "eigdiag_l6.src"
//**********************************************************************
// diese Datei wird als 'include' File in 'ICMV.SRC' aufgerufen
//
//* 31.10.2007 SS V2.200 Ersteinbindung der Eigendiagnose als Ablauf
//* 05.11.2007 SS V2.210 Eigendiagnoseverfeinerung
//**********************************************************************
//globale Variablen werden mit Inbetriebnahme geteilt
//auch diverse Funktionen mit Inbetriebnahme geteilt
string fehler_eigendiagnose = "";
string fehler_eigendiagnose2 = "";
string warnung_eigendiagnose = "";
string zusatzinfo_eigendiagnose = "";

bool start_eigendiagnose_okay = FALSE;

bool eigendiagnose= FALSE;

//                                                                    
//                                Fehler            Fehler2           Warnungen              Einzeltestergebnisse    Infos unterdrücken
action_box_meldung_eigendiagnose(in: string text1, in: string text2, in: int hStrArrayWarn, in: int hStrArrayTests, in: int suppressinfos)
{
   int i = 0;
   int j = 0;
   int count;

   string text_action_box = "";

   userboxopen( 1, 1, 0, 32, 89, "Eigendiagnose Meldungen", "" );
   userboxsetcolor( 1, 0, 9 );

   userboxftextout( 1, text1, 1, 1, 1, 1 );
   userboxftextout( 1, text2, 3, 1, 1, 1 );

   if(suppressinfos == 0)
   {
     StrArrayGetElementCount( hStrArrayWarn, count );
     userboxftextout( 1, "Ergebnis:", 7, 1, 1, 1 );
     while( i < count ) 
     {
       StrArrayRead( hStrArrayWarn, i, text_action_box );
       userboxftextout( 1, text_action_box, j + 7 , 1, 1, 0 );

       text_action_box = "";
       i = i + 1;
       j = j + 2;
     }

     //i = 0;
     //j = 0;
     //StrArrayGetElementCount( hStrArrayTests, count );
     //userboxftextout( 1, "Eigendiagnose Einzeltestergebnisse:", 14, 1, 1, 1 );

     //while( i < count ) 
     //{
     //  StrArrayRead( hStrArrayTests, i, text_action_box );
     //  userboxftextout( 1, text_action_box, j + 14 , 1, 1, 0 );

     //  text_action_box = "";
     //  i = i + 1;
     //  j = j + 2;
     //}
   }
}

endebehandlung_eigdiag()
{

bool rc;              // return code vom Drucker
real drehzahl = 0;
string dh = "";
string sgbd_name = "";
string help_api_job0 = "";
string fg_nr = "";
string errorcode1_txt;
string errortext1;

int zustand=0;

    gettime(Uhrzeit);
    getdate(Datum);
    statistik_daten = Datum+","+Uhrzeit+","+FZG_TYP+","+fg_nr+","+fehlertext_1+","+fehlertext_2+","+zusatzinfotext+",";
    //fileopen(statistik_file,"a"); //für Tests aktivierbar
     
    if ( ARS_TEST_OK == TRUE )
    {
       fehlertext_1="";                         // Loeschen
       fehlertext_2="";                         // Loeschen
       statistik_daten = statistik_daten+"i.O";
    }
    else
    {
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "ARS Eigendiagnose");
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_1);
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_2);
       PEMProtokollZeile (rc, "Fehlertext :" + zusatzinfotext);
       PEMProtokollZeile (rc, "");

       statistik_daten = statistik_daten+"n.i.O";
    }

   //filewrite(statistik_daten); //für Tests aktivierbar
   //fileclose(); //für Tests aktivierbar
   delay(500);
  
//  ***************************************************
//  ***     Motordrehzahl wieder zurücksetzen       ***
//  ***************************************************

    if(drehzahl_wurde_erhoeht == TRUE)
    {
      drehzahl_wurde_erhoeht = FALSE;
      INPAapiJob("G_MOTOR","INITIALISIERUNG","","");
      INP1apiErrorCode(errorcode1);
      if (errorcode1 != 0)
      {
        //Fehlertext erst holen, wenn auch ein Fehler anliegt.
        INP1apiErrorText(errortext1);
        inttostring( errorcode1, errorcode1_txt );
        infobox("Fehler","kein Motor gefunden: Errorcode "+errorcode1_txt+" "+errortext1);
        message_box_close();
      }
      else
      {
        INPAapiResultText(sgbd_name,"VARIANTE",0,"");         // Satz 0 ist richtig!
        
        //infobox(sgbd_name,"Motor gefunden");   // kann zu Testzwecken aktiviert werden
        
        help_api_job0 = "STOP_SYSTEMCHECK_LLERH";
        
        job_state = "";  
        INPAapiJob( sgbd_name, help_api_job0, dh, "" );
        INPAapiResultText(job_state,"JOB_STATUS",1,"");
        message_box_close();
        
        if (job_state == "OKAY")
        {
          message_box_open("Motordrehzahl zurücksetzen i.O.","","");
        }
        else  // *********** Jobstatus nicht OKAY   *************
        {
          message_box_open("Motordrehzahl zurücksetzen n.i.O.",help_api_job0,job_state);
        }
      }
    }
}

//
//       **********************************************************
//       ***               S c r e e n a u f b a u              ***
//       ***   Darstellung und Aktualisierung des Bildschirms   ***
//       **********************************************************
SCREEN s_eigendiagnose()
{
  ftextout( "ARS Eigendiagnose", 2, 5, 2, 5 );
  delay ( 500 );
}   
//       ****************************************************
//       ***             M e n ü a u f b a u              ***
//       ****************************************************
// ***********************************
// *** ueber Menuepkt ANSTEUERN F6 ***
// ***********************************
// wird ueber F3 aktiviert in ICMV.SRC
// 
MENU m_eigendiagnose()
 {
  INIT 
  {
    setmenutitle( "Auswahlmenue Funktion");
  }

  ITEM( 1, "Info" )  
  {
    infobox("Information","Programm zur Eigendiagnose des ARS-Systems");
  }
  
  ITEM( 2, "Start" )  
  {
    //Leerlaufknopf ausschalten
    setitem(4, "LL-Anhebung", FALSE);
    setitem(5, "letzte Daten", FALSE);

    //eventuelle Altlasten entfernen
    message_box_close();
    setcolor(1,0);

    setstatemachine( ARS_EIGENDIAGNOSE );
  }
  
  ITEM( 3, "Stop" )  
  {
    setstatemachine( F10_ABBRUCH_EIGDIAG );
    //Leerlaufknopf einschalten
    setitem(4, "LL-Anhebung", TRUE);
  }

  ITEM( 4, "LL-Anhebung" )
  {
     delete_screen();
     setcolor(1,0);
     setscreen(s_leerlauf_anhebung,TRUE);
     setmenu( m_leerlauf_anhebung );
  }
  
  ITEM( 9, "Zurück" )
  {
     delete_screen();
     setcolor(1,0);
     setmenu (m_main);
     setscreen(s_steuern,TRUE);
     setmenu( m_steuern );
  }
  
  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
//       ****************************************************
//       ****************************************************
//       ****************************************************
STATEMACHINE  F10_ABBRUCH_EIGDIAG()
{
  INIT
   {
     delete_screen();
     setcolor(1,4);
     message_box_open("Abbruch ARS Eigendiagnose","","");
     ARS_TEST_OK = FALSE;
     fehlertext_1 = "Abbruchtaste F10 gedrueckt";  
     fehlertext_2 = "";
     endebehandlung_eigdiag();
   }
}

//   ************************************************************************
//   ***  S t a r t   S t a t e m a c h i n e   A b l a u f  G E S A M T  ***
//   ***                     Statemachine 1. Ebene                        ***
//   *************************************************************************


//
// Aufruf in MENU 'm_eigendiagnose'
//
STATEMACHINE ARS_EIGENDIAGNOSE()
{
  INIT
  {
    setstate ( ZUENDUNG );
  }

  // Schritt 1 - Abfrage, ob Zündung Ein 
  ZUENDUNG
  {
    // fehlerhafte Motordrehzahl verhindern
    meldung_1( "Zündung Ein?" );

    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( IST_MOTOR_AUS );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 2
  // definiertes Druckniveau an den Ventilen herstellen
  IST_MOTOR_AUS
  {
    callstatemachine( MOTOR_STATUS_AUS );

    // Motor ist aus
    // Motordrehzahl ist korrekt
    // d.h. KEINE fehlerhafte Motordrehzahl
    if ( status_motor_aus == TRUE )
    {
      setstate ( SG_NICHT_EINSCHLAFEN );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3
  // vermeidet das Einschlafen des SG's am Bus
  SG_NICHT_EINSCHLAFEN
  {
    meldung_1( "Zündung Ein?" );
    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( FEHLERSPEICHER_LOESCHEN_LESEN );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3b
  FEHLERSPEICHER_LOESCHEN_LESEN
  {
     meldung_2( "Fehlerspeicher löschen" );
     callstatemachine( FEHLERSPEICHER );

     if (fehlerspeicher_loeschen == TRUE)
      {
        setstate( OFFSET_WERTE_LERNEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  //////////////////////////////////////////////////////////////////////////////////
  //        Beginn Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 7
  OFFSET_WERTE_LERNEN
  {
     meldung_3( "Offsetwerte lernen" );
     callstatemachine( OFFSET_WERTE );

     if ( werte_lernen == TRUE )
      {
         setstate( STEUERGERAETE_RESET ); 
      }
     else
      {
         setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  //////////////////////////////////////////////////////////////////////////////////
  //        Ende Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 10
  STEUERGERAETE_RESET
  {
    meldung_7( "Steuergeräte Reset erfolgt" );

    callstatemachine( SG_RESET );
    if ( sg_reset == TRUE )
    {
      setstate( STATUS_ABFRAGE_MOTOR );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 12
  STATUS_ABFRAGE_MOTOR
  {
     callstatemachine( MOTOR_STATUS );

     if ( status_leerlauf == TRUE )
     {
       setstate( MOTORDREHZAHL_VORGEBEN );
     }
    else
     {
       setstate( PRUEFUNG_AUSWERTUNG );
     }
  }

  // Schritt 13
  MOTORDREHZAHL_VORGEBEN
  {
     callstatemachine( MOTORDREHZAHL );

     if ( status_erhoehte_drehzahl == TRUE )
      {
         setstate( PRUEFUNG_STARTEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 14
  PRUEFUNG_STARTEN
  {
     callstatemachine( STANDWANKEN_EIGDIAG );

     if ( start_eigendiagnose_okay == TRUE )
      {
        setstate( ABFRAGE_PRUEFABLAUF );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 15
  ABFRAGE_PRUEFABLAUF
  {
     callstatemachine( STATUS_STANDWANKEN_EIGDIAG );

     setstate( PRUEFUNG_AUSWERTUNG );
  }

  
  PRUEFUNG_AUSWERTUNG
  {
     callstatemachine( AUSWERTUNG_EIGDIAG );

     setstate( ENDE_PRUEFUNG );
  }
      
  ENDE_PRUEFUNG
  {
     endebehandlung_eigdiag();      // Dokumentation und Fehlerausdruck
  }
}

// Ende Statemachine "ARS_Eigendiagnose", 1. Ebene, Pruefablauf gesamt 

// **********************************************************************
// **********  Statemachines  ARS_Eigendiagnose 2. Ebene  **************
// **********      Aufruf Job's und Auswertungen           **************
// **********************************************************************

STATEMACHINE STANDWANKEN_EIGDIAG()
{

  INIT
  {
    message_box_open("Achtung!","Dynamische Prüfung","Fahrzeug bewegt sich");
  
    setstate(PRUEFUNG_STARTEN);
  }

  PRUEFUNG_STARTEN
  {
    job_state="";

    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_EIGENDIAGNOSE;STR", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state == "OKAY")
    {
      start_eigendiagnose_okay = TRUE;
      returnstatemachine();
    }
    else  // *********** Jobstatus nicht OKAY   *************
    {
      start_eigendiagnose_okay = FALSE;
      fehlertext_1 = "Start Eigendiagnose";
      fehlertext_2 = job_state;
      message_box_close();
      returnstatemachine();
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE STATUS_STANDWANKEN_EIGDIAG()
{

  int zustand = 0;
  int fortschritt = 0;
  int laeuft = 0;
  int gesamt_ergebnis = 0;
  int zaehler = 0;
  int i = 1;
  int warn_drehzahl = 0;
  int warn_luft = 0;
  int int_var = 0;
 
  string zaehler_txt = "";
  string warn_drehzahl_txt = "";
  string warn_luft_txt = "";
  
  string gesamt_ergebnis_txt = "";
  string result_var = "";
  string text_var = "";
  string text_temp = "";
  int fortschritt_eigendiagnose_ende = 0;
  string chk_jobstatus ="";
  int llsw_HV_version;

  INIT
  {
    setstate( STATUS_EIGENDIAGNOSE );
  }


  STATUS_EIGENDIAGNOSE
  {
    job_state = "";
    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_EIGENDIAGNOSE;RRR", "" );
    INPAapiResultText( job_state, "JOB_STATUS", 1, "" );

    if ( job_state == "OKAY" )
    {
      delay( 100 );   // Verzoegerungszeit
      setstate ( STATUS_LESEN_BYTE_1 ); 
    }
    else  // *********** Jobstatus nicht OKAY  *************
    {
      if( job_state == "ERROR_ECU_RESPONSE_TOO_LESS_DATA" )
      {
        //SG ist wohl I3.15
        SG_ist_I315 = TRUE;
      }
      else
      {
        infobox( "unerwartetes Jobresult", job_state);
      }
      eigendiagnose = FALSE;
      fehlertext_1 = "Status Eigendiagnose abfragen";
      fehlertext_2 = job_state;
      message_box_close();
      delay( 1500 );

      returnstatemachine();
    }
  } 


  STATUS_LESEN_BYTE_1      // ****** Abfrage, ob Test noch laeuft ******
  {
    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_EIGENDIAGNOSE;RRR", "" );

    INPAapiResultInt( fortschritt, "STAT_FORTSCHRITT_NR", 1 );   
    INPAapiResultText( text_var, "STAT_FORTSCHRITT_NR_TEXT", 1, "" );
    
    INPAapiResultInt( laeuft, "STAT_AKTIV_NR", 1 );   

    ftextout("Prüfschritt:",28,1,1,0);
    clearrect(28,30,2,53);
    ftextout(text_var,28,28,1,0);

    //sus Prüfung auf Aktiv
    if ( laeuft !=0 )             // größer 0 = Pruefung laeuft, 0 = Pruefung fertig
    {
      if ( zaehler < 240 )     // max. Zeit vorgeben, dann Abbruch (4 min)
      {
        zaehler = zaehler + 1;
        inttostring( zaehler, zaehler_txt );
        ftextout("Prüfzeit",26,40,1,1);     
        meldung_4(zaehler_txt);
        delay(1000);                     // 1 sec warten, dann wieder lesen 
        setstate(STATUS_LESEN_BYTE_1);
      }
      else
      {
        eigendiagnose = FALSE;
        fehlertext_1 = "Zeitüberschreitung Dynamische Prüfung";
        fehlertext_2 = "";
        message_box_close();
        returnstatemachine();
      }
    }
    else
    {
      //Infos immer anzeigen, ausser Abbruch durch externe Ursachen (s.u.)
      suppress_infos = 0;
      //Texte löschen
      fehler_eigendiagnose  ="";
      fehler_eigendiagnose2 ="";
      
      fortschritt_eigendiagnose_ende = 8;
      
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;ARS_EIGENDIAGNOSE;RRR", "" );

      INPAapiResultInt(gesamt_ergebnis,"STAT_ERGEBNIS_NR",1);   // Gesamtergebnis auslesen
      
      if ( ( gesamt_ergebnis == 2 ) && ( fortschritt == fortschritt_eigendiagnose_ende ))   // ohne Fehler durchgelaufen
      {
        INPAapiResultText( text_var, "STAT_ERGEBNIS_NR_TEXT", 1, "" );
        // fuer DEBUG Zwecke 
        //infobox ( "Eigendiagnose IO", text_var );

        eigendiagnose = TRUE;
        message_box_close();
        delay(1500);
        returnstatemachine();
      }
      // fehlerhafte Eigendiagnose
      else
      {
        // fuer DEBUG Zwecke 
        //infobox("EigDiag Kurzmeldung","Eigendiagnose FALSE");

        eigendiagnose = FALSE;

        //              bool Varible out            , int Variable out
        //              erzeugen erfolgreich        , HANDLE auf Array
        StrArrayCreate( b_handleStringArr_Warnungen, handleStringArr_Warnungen );

        // Speicherplatz erfolgreich reserviert ?
        if ( b_handleStringArr_Warnungen == FALSE )
        {
          infobox ( "b_handleStringArr_Warnungen", "FALSE" );
          exit();
        }

        StrArrayCreate( b_handleStringArr_Einzeltests, handleStringArr_Einzeltests );
        // Speicherplatz erfolgreich reserviert ?
        if ( b_handleStringArr_Einzeltests == FALSE )
        {
          infobox ( "b_handleStringArr_Einzeltests", "FALSE" );
          exit();
        }
        
        //Prüfen auf Eigendiagnoseabbruch
        INPAapiResultInt( int_var, "STAT_READYNESS_ERROR_DETAIL_NR", 1);

        if(int_var != 0)
        {
          //externer Abbruch ist gegeben, Abbruchgrund als Text ausgeben
          result_var =  "STAT_READYNESS_ERROR_DETAIL_NR_TEXT";
        }
        else
        {
          //Eigendiagnose durchgelaufen, Ergebnis als Text ausgeben
          result_var =  "STAT_FORTSCHRITT_NR_TEXT";
        }
        INPAapiResultText( fehler_eigendiagnose, result_var , 1, "");      
        fehlertext_2 = fehler_inbetriebnahme2;
        
        //Prüfen Readyness Grund
        INPAapiResultInt( int_var, "STAT_READYNESS_NR" , 1);
        text_var = "";
        if(int_var != 0)
        {
          INPAapiResultText( text_var, "STAT_READYNESS_NR_TEXT" , 1, "");      
          fehler_inbetriebnahme2 = fehler_inbetriebnahme;
          fehler_inbetriebnahme = text_var+":";
          suppress_infos = 1;
        }
        fehlertext_1 = fehler_inbetriebnahme;
        fehlertext_2 = fehler_inbetriebnahme2;
        
        INPAapiResultText( text_var, "STAT_FEHLER_ID_WERT", 1, "");
        StrArrayWrite(handleStringArr_Warnungen, 1, "0x"+text_var);

        // 10 sec Anzeige auf dem Schirm
        callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG_EIGDIAG );
        // StringArray wird gelöscht
        StrArrayDestroy (handleStringArr_Einzeltests);
        StrArrayDestroy (handleStringArr_Warnungen);

        message_box_close();
        returnstatemachine();
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE WARNUNG_FEHLER_DARSTELLUNG_EIGDIAG()
{
  INIT
  {
    action_box_meldung_eigendiagnose ( fehler_eigendiagnose, fehler_eigendiagnose2, handleStringArr_Warnungen, handleStringArr_Einzeltests, suppress_infos );
    // 10 sec. Anzeige auf dem Schirm
    delay ( 10000 );
    infobox("Hinweis","Detailansicht wird geschlossen!");
    action_box_close();
    returnstatemachine();
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE AUSWERTUNG_EIGDIAG()     // Schritt 13, Prüfablauf auswerten
{
   INIT
   {
      
      if (( zuendung_ein_test == TRUE ) && ( status_motor_aus == TRUE ) && 
          ( werte_lernen == TRUE ) &&
          ( sg_reset == TRUE ) && ( fehlerspeicher_loeschen == TRUE ) && ( status_leerlauf == TRUE ) &&
          ( status_erhoehte_drehzahl == TRUE ) && ( start_eigendiagnose_okay == TRUE ) &&
          ( eigendiagnose == TRUE ))
      {
         ARS_TEST_OK = TRUE;
         setcolor(1,10);      // Bildschirm grün
         message_box_open("Ende Prüfablauf","","Prüfung i.O.");
         delay(1500);
         returnstatemachine();
      }
      else  // *********** Pruefung nicht OKAY   *************
      {
          ARS_TEST_OK = FALSE;
          setcolor(1,4);       // Bildschirm rot

          //I3.15 Stand abfragen
          if (SG_ist_I315==TRUE)
          {
            message_box_open("Ende Prüfablauf","vermutlich I3.15 Stand","Fehlerspeicher überprüfen");
          }
          else
          {
            message_box_open("Ende Prüfablauf","","Prüfung n.i.O.");
          }
          delay(1500);
          returnstatemachine();
       }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
// end of :#include "eigdiag_l6.src"

// *****************************************************
// ********   Bildschirm-Manager-Funktionen*************
// *****************************************************

ScriptInit()
{}

// ****************************************************
// ***             M e n ue a u f b a u              ***
// ****************************************************
// **************************
// *** Statusmenue         ***
// **************************
// wird ueber F5 aktiviert 'Status lesen'
MENU m_status()
{
  INIT 
  {
    setmenutitle("Status lesen");
  }
  
  ITEM( 1 ,"FR Transc.")  
  {
    setscreen( s_fr_transceiver, TRUE);
    setmenu(  m_fr_transceiver ) ;
  }
  ITEM( 2 ,"Predrive")  
  {
    predrive_daten_info_einmal = TRUE;
    predrive_daten_backup_choice = FALSE;
    setscreen( s_predrive_daten, TRUE);
    setmenu(  m_predrive_daten ) ;
  }
  ITEM( 3 ,"Radknoten")  
  {
    setscreen( s_radknoten, TRUE);
    setmenu(  m_stati_radknoten ) ;
  }

  ITEM( 4 ,"Ventile")  
  {
    setscreen( s_ventile_status, TRUE );
    setmenu( m_ventile_status ) ;
  }

  ITEM( 5 ,"Sensorabgl.")  
  {
    setscreen( s_sensorabgleich, TRUE );
    setmenu( m_sensorabgleich_status ) ;
  }

  ITEM( 6 ,"Sensoren")  
  {
    setscreen( s_stati_sensor, TRUE);
    setmenu(  m_stati_sensor ) ;
  }

  ITEM( 7 ,"Versorgungen")  
  {
    setscreen( s_versorgungen, TRUE);
    setmenu(  m_stati_versorgungen ) ;
  }

  ITEM( 8 ,"Drucken")  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_main, TRUE );
    setmenu( m_main );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// **************************
// *** Steuernmenue       ***
// **************************
// wird ueber F6 aktiviert 'Ansteuern'
MENU m_steuern()
{
  INIT 
  {
    setmenutitle("Steuern");
  }
 
  ITEM( 1 ,"SG Reset")  
  {
    setscreen( s_sgreset, TRUE );
    setmenu( m_sgreset ) ;
  }

  ITEM( 2 ,"Inbetriebn.")  
  {
    // Implementierung des Screens und des Menues
    // siehe include File 'INB_L6.SRC'
    setscreen( s_inbetriebnahme,TRUE);
    setmenu( m_inbetriebnahme ) ;
  }

  ITEM( 3 ,"Eigendiag")  
  {
    // Implementierung des Screens und des Menues
    // siehe include File 'EIGDIAG_L6.SRC'
    setscreen( s_eigendiagnose, TRUE );
    setmenu( m_eigendiagnose ) ;
  }

  ITEM( 4 ,"RK Prüfung")  
  {
    setscreen( s_rk_verbau_steuern, TRUE );
    setmenu( m_rk_verbau_steuern ) ;
  }

  ITEM( 5 ,"Rampenlogik")  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    sd_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    setscreen( s_rampen_steuern, TRUE );
    setmenu( m_rampen_steuern ) ;
  }

  ITEM( 6 ,"Sensorabgl.")  
  {
    setscreen( s_sensorabgleich, TRUE );
    setmenu( m_sensorabgleich_steuern ) ;
  }

  ITEM( 8 ,"Drucken")  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_main, TRUE );
    setmenu( m_main );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }

}

// *****************************************************
// *********************************
// *** ueber Menuepkt status F5 ***
// *********************************
// *******************************
// *** Steuergeraete Reset     ***
// *******************************
// wird ueber F1 aktiviert 
MENU m_sgreset()
{
  INIT 
  {
    setmenutitle( "Steuergeraete Reset" );
  }

  ITEM( 1, "SG reset")  
  {
      sg_reset_einmal = TRUE;
      setscreen( s_sgreset, TRUE );
  }


  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** FR Transceiver          ***
// *******************************
// wird ueber F1 aktiviert 
MENU m_fr_transceiver()
{
  INIT 
  {
    setmenutitle( "Flexray Transceiver" );
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Predrive Daten          ***
// *******************************
// wird ueber F2 aktiviert 
MENU m_predrive_daten()
{
  INIT 
  {
    setmenutitle( "Predrive Daten" );
  }

  ITEM( 1, "Aktuell" )
  {
     predrive_daten_info_einmal = TRUE;
     predrive_daten_backup_choice = FALSE;
     setscreen(s_predrive_daten,TRUE);
     setmenu( m_predrive_daten );
  }
  ITEM( 2, "Backup" )
  {
     predrive_daten_info_einmal = TRUE;
     predrive_daten_backup_choice = TRUE;
     setscreen(s_predrive_daten,TRUE);
     setmenu( m_predrive_daten );
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Radknoten               ***
// *******************************
// wird ueber F3 aktiviert 
MENU m_stati_radknoten()
{
  INIT 
  {
    setmenutitle( "Radknoten" );
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Ventilemenue status     ***
// *******************************
// wird ueber F4 aktiviert 
MENU m_ventile_status()
{
  INIT 
  {
    setmenutitle("Ventile");
  }

  // Lesen
  ITEM( 1 ,"SV lesen")  
  {
    setscreen( s_sv_ventil, TRUE);
  }
  
  ITEM( 2 ,"RV lesen")  
  {
    setscreen( s_rv_ventil, TRUE);
  }

  ITEM( 3 ,"Prop VA lesen")  
  {
    setscreen( s_va_ventil, TRUE);
  }
  
  ITEM( 4 ,"Prop HA lesen")  
  {
    setscreen( s_ha_ventil, TRUE);
  }
  
  ITEM( 5 ,"SD lesen")  
  {
    setscreen( s_sd_ventil, TRUE);
  }
  
  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// ************************************
// *** Sensorabgleichmenue 'STATUS' ***
// ************************************
// wird ueber F5 aktiviert 
MENU m_sensorabgleich_status()
{
  INIT 
  {
    setmenutitle("Sensorabgleichwerte auslesen");
  }

  // Lesen
  ITEM( 1 ,"Offsets lesen")  
  {
    setscreen( s_sensorabgleich , TRUE);
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
// *******************************
// *** Stati Sensoren          ***
// *******************************
// wird ueber F6 aktiviert 
MENU m_stati_sensor()
{
  INIT 
  {
    setmenutitle( "Sensoren Status" );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *******************************
// *** Versorgungen            ***
// *******************************
// wird ueber F7 aktiviert 
MENU m_stati_versorgungen()
{
  INIT 
  {
    setmenutitle( "Versorgungen" );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Ventilemenue steuern    ***
// ***      Rampenlogik        ***
// *******************************
// wird ueber F3 aktiviert 
MENU m_rampen_steuern()
{
  int int_eingabe_tmp;
  int int_eingabe_tmp2;

  INIT 
  {
    setmenutitle( "Rampenlogik für Ventilansteuerung");
  }
  
  // Sicherheitsventil
  ITEM( 1, "SV EIN" )  
  {
    if(sv_ein_aus == FALSE)
    {
      sv_ein_aus = TRUE;
      setitem(1, "SV AUS", TRUE);
    }
    else
    {
      sv_ein_aus = FALSE;
      setitem(1, "SV EIN", TRUE);
    }
    
    setscreen( s_rampen_steuern, TRUE );
  }
  // Richtungsventil
  ITEM( 2, "RV EIN" )  
  {
    if(rv_ein_aus == FALSE)
    {
      rv_ein_aus = TRUE;
      setitem(2, "RV AUS", TRUE);
    }
    else
    {
      rv_ein_aus = FALSE;
      setitem(2, "RV EIN", TRUE);
    }
    
    setscreen( s_rampen_steuern, TRUE );
  }

  // Saugdrosselventil
  ITEM( 3, "SD EIN" )  
  {
    if(sd_ein_aus == FALSE)
    {
      sd_ein_aus = TRUE;
      setitem(3, "SD AUS", TRUE);
    }
    else
    {
      sd_ein_aus = FALSE;
      setitem(3, "SD EIN", TRUE);
    }
    
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 4, "Rampe EIN" )  
  {
    if(ramp_mode_ein_aus == FALSE)
    {
      ramp_mode_ein_aus = TRUE;
      setitem(4, "Rampe AUS", TRUE);
    }
    else
    {
      ramp_mode_ein_aus = FALSE;
      setitem(4, "Rampe EIN", TRUE);
    }
    
    setscreen( s_rampen_steuern, TRUE );
  }

  // Propventil Vorderachse (VA) bestromen
  ITEM( 5, "Ramp VA AUF" )  
  {
    // für einmaligen Aufruf der SGBD
    PropVA_ein_aus = TRUE;

    if(0 == va_ramp_zeit)
    {
        inputint( int_eingabe_tmp, "Proportionalventil VA", 
                  "Zeit ist Null, Neueingabe in ms", 0, 6000 );
        getinputstate( input_state_VA );
        if ( input_state_VA == 0 ) {   va_ramp_zeit  = int_eingabe_tmp; }
        userboxclose( 0 );
        viewclose();
    }

    if(va_ramp_art == 1)
    {
      va_ramp_art = 2;
      setitem(5, "Ramp VA AUF", TRUE);
    }
    else
    {
      va_ramp_art = 1;
      setitem(5, "Ramp VA AB", TRUE);
    }
    //int_eingabe_tmp = va_ramp_art;
    //inputint( int_eingabe_tmp, "Proportionalventil VA", 
    //         "Rampenrichtung (0 = Halt, 1 = Auf, 2 = Ab)", 0, 2 );
    //getinputstate( input_state_VA );
    //if ( input_state_VA == 0 ) {   va_ramp_art  = int_eingabe_tmp; }
    // Dialog schliessen
    //userboxclose( 0 );
    //viewclose();

    setscreen( s_rampen_steuern, TRUE );
  }

  // Propventil Hinterachse (HA)
  ITEM( 6, "Ramp HA AUF" )  
  {
    PropHA_ein_aus = TRUE;

    if(0 == ha_ramp_zeit)
    {
        inputint( int_eingabe_tmp, "Proportionalventil HA", 
                  "Zeit ist Null, Neueingabe in ms", 0, 6000 );
        getinputstate( input_state_VA );
        if ( input_state_VA == 0 ) {   ha_ramp_zeit  = int_eingabe_tmp; }
        userboxclose( 0 );
        viewclose();
    }

    if(ha_ramp_art == 1)
    {
      ha_ramp_art = 2;
      setitem(6, "Ramp HA AUF", TRUE);
    }
    else
    {
      ha_ramp_art = 1;
      setitem(6, "Ramp HA AB", TRUE);
    }

    //int_eingabe_tmp = ha_ramp_art;
    //inputint( int_eingabe_tmp, "Proportionalventil HA", 
    //         "Rampenrichtung (0 = Halt, 1 = Auf, 2 = Ab)", 0, 2 );
    //getinputstate( input_state_VA );
    //if ( input_state_VA == 0 ) {   ha_ramp_art  = int_eingabe_tmp; }
    // Dialog schliessen
    //userboxclose( 0 );
    //viewclose();

    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 7, "VA/HA AUF" )  
  {
    PropVA_ein_aus = TRUE;
    PropHA_ein_aus = TRUE;

    if(0 == va_ramp_zeit || 0 == ha_ramp_zeit)
    {
        inputint( int_eingabe_tmp, "Proportionalventil VA bzw. HA", 
                  "Zeit ist Null, Neueingabe in ms", 0, 6000 );
        getinputstate( input_state_VA );
        if ( input_state_VA == 0 ) 
        {
          va_ramp_zeit  = int_eingabe_tmp;
          ha_ramp_zeit  = int_eingabe_tmp;
        }
        userboxclose( 0 );
        viewclose();
    }

    if(va_ramp_art == 1)
    {
      va_ramp_art = 2;
      setitem(7, "VA/HA AUF", TRUE);
    }
    else
    {
      va_ramp_art = 1;
      setitem(7, "VA/HA AB", TRUE);
    }

    ha_ramp_art = 4;
    setitem(5, "VA mit HA", FALSE);
    setitem(6, "HA mit VA", FALSE);
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 8, "VA/HA AUS" )  
  {
    PropVA_ein_aus = FALSE;
    PropHA_ein_aus = FALSE;
    va_ramp_art = 0;
    ha_ramp_art = 0;
    setitem(5, "Ramp VA AUF", TRUE);
    setitem(6, "Ramp HA AUF", TRUE);
    setitem(7, "VA/HA AUF", TRUE);
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 11, "Vorgabe Strom" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(0 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Strom", 
                    "Steuerstrom in mA, Rampe wird automatisch deaktiviert!", 
                    "Proportionalventil VA", "Proportionalventil HA", 0, 3000, 0, 3000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 0;
              warnung_erfolgt = FALSE;
              ramp_mode_ein_aus = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 0;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Strom", 
                    "Steuerstrom in mA", "Proportionalventil VA", "Proportionalventil HA",
                    0, 3000, 0, 3000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 12, "Vorgabe Druck" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(1 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Druck", 
                    "Steuerdruck in 0.1 bar, Rampe wird automatisch deaktiviert!",
                    "Proportionalventil VA", "Proportionalventil HA", 0, 2500, 0, 2500);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 1;
              ramp_mode_ein_aus = FALSE;
              warnung_erfolgt = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 1;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Druck", 
                    "Steuerdruck in 0.1 bar", "Proportionalventil VA", "Proportionalventil HA",
                    0, 2500, 0, 2500);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 13, "Vorgabe PWM" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(2 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe PWM", 
                    "PWM in 0.1 %, Rampe wird automatisch deaktiviert!", 
                    "Proportionalventil VA", "Proportionalventil HA", 0, 1000, 0, 1000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 2;
              ramp_mode_ein_aus = FALSE;
              warnung_erfolgt = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 2;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe PWM", 
                    "PWM in 0.1 %", "Proportionalventil VA", "Proportionalventil HA",
                    0, 1000, 0, 1000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }
  
  ITEM( 14, "Rampenzeit" )  
  {
    int_eingabe_tmp = va_ramp_zeit;
    int_eingabe_tmp2 = ha_ramp_zeit;
    input2int( int_eingabe_tmp, int_eingabe_tmp2, "Vorgabe Rampenzeit",
                   "Rampenzeit in ms", "Proportionalventil VA", "Proportionalventil HA",
                   0, 6000, 0, 6000);

    getinputstate( input_state_VA );
    if ( input_state_VA == 0 )
    { // Eingabe uebernehmen
     va_ramp_zeit = int_eingabe_tmp;
     ha_ramp_zeit = int_eingabe_tmp2;
    }
    // Dialog schliessen
    userboxclose( 0 );
    viewclose();
    
    setscreen( s_rampen_steuern, TRUE );
  }
  // Shift F8
  ITEM( 18, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    sd_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    PropVA_ein_aus = FALSE;
    PropHA_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *************************************
// *** Sensorabgleichmenue 'STEUERN' ***
// *************************************
// wird ueber F6 aktiviert 
MENU m_sensorabgleich_steuern()
{
  INIT 
  {
    setmenutitle("Sensorabgleichwerte festlegen");
  }

  // Lesen
  ITEM( 1 ,"Offsets lesen")  
  {
    setscreen( s_sensorabgleich , TRUE);
  }


  // Lernen mit Grenzwertueberwachung
  ITEM( 3 ,"Offs. lernen")  
  {
    toggle_1 = 0;

    setscreen( s_nullpkt_lernen , TRUE);
    setmenu( m_nullpkt_lernen );
  }
 
  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurück" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ****************************************
// *** Nullpunkte der Sensoren lernen   ***
// *** mit Grenzwertueberwachung        ***
// ****************************************
MENU m_nullpkt_lernen()
{
  INIT 
  {
    setmenutitle("Nullpunkte der Drucksensoren lernen");
  }

  ITEM( 1 ,"lernen")  
  {
    toggle_1 = 1;
    
    setscreen( s_nullpkt_lernen , TRUE);
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }
  
  ITEM( 9 ,"Zurück")  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_sensorabgleich ,TRUE);
    setmenu( m_sensorabgleich_steuern );

    toggle_1 = 0;
  }

  ITEM( 10 ,"Ende")  
  {
    exit();
  }
}

MENU m_rk_verbau_steuern()
 {
  INIT 
  {
    setmenutitle( "Auswahlmenue Funktion");
  }

  ITEM( 1, "Info" )  
  {
    infobox("Information","Programm zur Prüfung des richtigen Radknotenverbaus");
  }
  
  ITEM( 2, "Start" )  
  {
    toggle_1 = 1;
  }
  
  ITEM( 3, "Stop" )  
  {
    toggle_2 = 1;
  }

  ITEM( 9, "Zurück" )
  {
     userboxclose(0);
     viewclose();
     setscreen(s_steuern,TRUE);
     setmenu( m_steuern );
     toggle_1 = 0;
     toggle_2 = 0;
  }
  
  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *****************************************************
// *****************************************************


// ****************************************************
// ***             S c r e e n a u f b a u          ***
// ****************************************************
// **************************
// *** Statusscreen       ***
// **************************
// wird ueber F5 aktiviert 'STATUS'
SCREEN s_status()
{
  // Initialisierung
  string text_var = "";
  int status_ars;
  real stat_alive;

  ftextout("Status lesen", 1, 0, 1, 0 );
  ftextout("",2,0,0,0);

   LINE("","")
   {
      // linke Seite des Bildschirms
      ftextout( "< F1 >  Flexray Transceiver Statuswort"      ,  3, 5, 0, 1 );
      ftextout( "< F2 >  Predrive Daten"                      ,  5, 5, 0, 1 );
      ftextout( "< F3 >  Radknoten"                           ,  7, 5, 0, 1 );
      ftextout( "< F4 >  Ventile"                             ,  9, 5, 0, 1 );
      ftextout( "< F5 >  Sensorabgleichwerte ( lesen )"       , 11, 5 ,0 ,1 );
      //
      ftextout( "< F6 >  Sensoren"                            , 13, 5, 0, 1 );
      ftextout( "< F7 >  Versorgungen"                        , 15, 5, 0, 1 );
      //
      ftextout( "< F8 >  Bildschirmdruck"                     , 19, 5, 0, 1 );
      ftextout( "< F9 >  Zurück"                              , 21, 5, 0, 1 );
      ftextout( "< F10 > Ende"                                , 23, 5, 0, 1 );
      //
      //
      // rechte Seite des Bildschirms
      //ftextout( "<Shift> + < F1 >  "                   , 3, 45, 0, 1 );
   }
}

// **************************
// *** Steuernscreen      ***
// **************************
// wurde ueber F6 aktiviert 'Ansteuern'
SCREEN s_steuern()
{
//  ftextout("ARS Inbetriebnahme und Pruefung", 2,5,2,5);
  // Initialisierung
  string text_var = "";
  int status_ars;
  real stat_alive;

  ftextout("Ansteuern",1,0,1,0);
  ftextout("",2,0,0,0);

   LINE("","")
   {
      ftextout( "< F1 >  SG Reset"                              ,  3, 5, 0, 1 );
      ftextout( "< F2 >  Inbetriebnahmeablauf ARS"              ,  5, 5, 0, 1 );
      ftextout( "< F3 >  Eigendiagnose ARS"                     ,  7, 5, 0, 1 );
      ftextout( "< F4 >  Radknoten Verbauprüfung"             ,  9, 5, 0, 1 );
      ftextout( "< F5 >  Rampenlogik für Ventilansteuerung" , 11, 5 ,0 ,1 );
      ftextout( "< F6 >  Sensorabgleichwerte ( lernen )"         , 13, 5 ,0 ,1 );
      //
      ftextout( "< F8 >  Bildschirmdruck"                        , 19, 5, 0, 1 );
      ftextout( "< F9 >  Zurück"                                 , 21, 5, 0, 1 );
      ftextout( "< F10 > Ende"                                   , 23, 5, 0, 1 );
   }
}


// *****************************
// *** Statusscreen Anzeigen ***
// *****************************
// ******************************
// *** Steuergeraete Reset    ***
// ******************************
// wird ueber F1 aktiviert 'SG reset'
SCREEN s_sgreset()
{
  int status_ars;
  real stat_alive;
  string text_var = "";
    
  ftextout( "Steuergeraete Reset durchfuehren", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0 ,0 );

  LINE( "","" )
  {
      if ( sg_reset_einmal == TRUE )
      {
        sg_reset_einmal = FALSE;
        INPAapiJob( sgbd, "STEUERGERAETE_RESET", "", "" );
        INPAapiCheckJobStatus( "OKAY" );
  
        ftextout( "Reset war erfolgreich", 1, 0, 1, 1 );
        ftextout( "", 3, 0, 0 ,0 );

        delay(2000);
      }
  }
}

// **********************************
// ***  Status FR Transceiver     ***
// **********************************
// wird ueber F1 aktiviert 'FR Transceiver'
SCREEN s_fr_transceiver()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool tja   = FALSE;
  bool elmos = FALSE;
  string chk_jobstatus = "";
  string arg_var = "";

  ftextout( "Flexray Transceiver Statuswort", 1, 0, 1, 0 );

  //Testen, welcher Transceiver verbaut ist
  arg_var = "ARG;STATUS_FR_TRANSCEIVER_E910_54";
  INPAapiJob( sgbd, "STATUS_LESEN", arg_var, "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  if(chk_jobstatus != "OKAY")
  {
    //okay, ein Elmos ist es nicht dann nach TJA schauen
    arg_var = "ARG;STATUS_FR_TRANSCEIVER_TJA1080";
    INPAapiJob( sgbd, "STATUS_LESEN", arg_var, "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus != "OKAY")
    {
      ftextout( "unbekannter Flexraytransceiver!", 5, 0, 0 ,0 );
    }
    else
    {
      ftextout( "Flexraytransceiver: TJA 1080", 5, 0, 0 ,0 );
      tja = TRUE;
    }
  }
  else
  {
    ftextout( "Flexraytransceiver: Elmos E910.54", 5, 0, 0 ,0 );
    elmos = TRUE;
  }


  LINE( "","" )
  {

    INPAapiJob( sgbd, "STATUS_LESEN", arg_var, "" );
    INPAapiCheckJobStatus( "OKAY" );
    if(tja == TRUE)
    {
      INPAapiResultText( text_var, "STAT_S0_WAKEUP_NR_INFO", 1,"");
      ftextout( text_var, 1, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S0_WAKEUP_NR", 1, "");
      ftextout( text_var+" :S0", 1, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S1_WAKEUP_SOURCE_NR_INFO", 1,"");
      ftextout( text_var, 2, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S1_WAKEUP_SOURCE_NR", 1, "");
      ftextout( text_var+" :S1", 2, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S2_NODE_CONFIG_NR_INFO", 1,"");
      ftextout( text_var, 3, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S2_NODE_CONFIG_NR", 1, "");
      ftextout( text_var+" :S2", 3, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S3_PWON_NR_INFO", 1,"");
      ftextout( text_var, 4, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S3_PWON_NR", 1, "");
      ftextout( text_var+" :S3", 4, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S4_BUS_ERROR_NR_INFO", 1,"");
      ftextout( text_var, 5, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S4_BUS_ERROR_NR", 1, "");
      ftextout( text_var+" :S4", 5, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S5_TEMP_HIGH_NR_INFO", 1,"");
      ftextout( text_var, 6, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S5_TEMP_HIGH_NR", 1, "");
      ftextout( text_var+" :S5", 6, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S6_TEMP_MEDIUM_NR_INFO", 1,"");
      ftextout( text_var, 7, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S6_TEMP_MEDIUM_NR", 1, "");
      ftextout( text_var+" :S6", 7, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S7_TXEN_BGE_CLAMPED_NR_INFO", 1,"");
      ftextout( text_var, 8, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S7_TXEN_BGE_CLAMPED_NR", 1, "");
      ftextout( text_var+" :S7", 8, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S8_UVVBAT_NR_INFO", 1,"");
      ftextout( text_var, 9, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S8_UVVBAT_NR", 1, "");
      ftextout( text_var+" :S8", 9, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S9_UVVCC_NR_INFO", 1,"");
      ftextout( text_var, 10, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S9_UVVCC_NR", 1, "");
      ftextout( text_var+" :S9", 10, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S10_UVVIO_NR_INFO", 1,"");
      ftextout( text_var, 11, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S10_UVVIO_NR", 1, "");
      ftextout( text_var+" :S10", 11, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S11_STAR_LOCKED_NR_INFO", 1,"");
      ftextout( text_var, 12, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S11_STAR_LOCKED_NR", 1, "");
      ftextout( text_var+" :S11", 12, 40, 0 ,0 );

      INPAapiResultText( text_var, "STAT_S12_TRXD_COLLISION_NR_INFO", 1,"");
      ftextout( text_var, 13, 1, 0 ,0 );
      INPAapiResultText( text_var, "STAT_S12_TRXD_COLLISION_NR", 1, "");
      ftextout( text_var+" :S12", 13, 40, 0 ,0 );
    }
  }
}

// **********************************
// ***  Status Predrive Daten     ***
// **********************************
// wird ueber F2 aktiviert 'Predrive Daten'
SCREEN s_predrive_daten()
{
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i450 = TRUE;
  string chk_jobstatus ="";
  int llsw_HV_version;
  int llsw_UV_version;

  if(predrive_daten_backup_choice == TRUE)
  {
    ftextout("ARS Daten Predrive Backup",1,5,1,5);
  }
  else
  {
    ftextout("ARS Daten Predrive Aktuell",1,5,1,5);
  }
  delay ( 500 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSION_LLSW", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  //Wir gehen mal davon aus, die Version passt
  min_i450 = TRUE;
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I4.50 vollständig implementiert. SG Software > 6.3.1)", 5, 0, 0 ,0 );
  }
  else
  {
    INPAapiResultInt( llsw_HV_version, "STAT_HV_WERT", 1);
    INPAapiResultInt( llsw_UV_version, "STAT_UV_WERT", 1);

    if( llsw_HV_version < 6)
    {
      ftextout( "(erst in I4.50 vollständig implementiert. SG Software > 6.3.1)", 5, 0, 0 ,0 );
      min_i450 = FALSE;
    }
    else if(zahl_var < 2.310)
    {
      min_i450 = FALSE;
    }
    else if ( llsw_HV_version == 6 && llsw_UV_version < 4 )
    {
      min_i450 = FALSE;
    }
  }

  LINE( "","" )
  {
    if(min_i450 == TRUE)
    {
      if(predrive_daten_info_einmal == TRUE)
      {
        predrive_daten_info_einmal = FALSE;
        if(predrive_daten_backup_choice == TRUE)
        {
          INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_PREDRIVE_BACKUP", "" );
        }
        else
        {
          INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DATEN_PREDRIVE_AKTUELL", "" );
        }

        INPAapiResultText( text_var, "STAT_PREDR_LAUFENDE_ID_INFO", 1,"");
        ftextout( text_var, 1, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_LAUFENDE_ID_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 1, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_LAUFENDE_ID_EINH", 1,"");
        ftextout( text_var, 1, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_ANZAHL_INFO", 1,"");
        ftextout( text_var, 2, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_ANZAHL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.0" , text_var );
        ftextout( text_var, 2, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_ANZAHL_EINH", 1,"");
        ftextout( text_var, 2, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_DURCHGELAUFEN_INFO", 1,"");
        ftextout( text_var, 3, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DURCHGELAUFEN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 3, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DURCHGELAUFEN_EINH", 1,"");
        ftextout( text_var, 3, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_AKTIV_INFO", 1,"");
        ftextout( text_var, 4, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_AKTIV_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 4, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_AKTIV_EINH", 1,"");
        ftextout( text_var, 4, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_TIEFTEMP_PHASE_INFO", 1,"");
        ftextout( text_var, 5, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_TIEFTEMP_PHASE_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 5, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_TIEFTEMP_PHASE_EINH", 1,"");
        ftextout( text_var, 5, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_P_UMLAUF_ZU_HOCH_INFO", 1,"");
        ftextout( text_var, 6, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_P_UMLAUF_ZU_HOCH_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.0" , text_var );
        ftextout( text_var, 6, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_P_UMLAUF_ZU_HOCH_EINH", 1,"");
        ftextout( text_var, 6, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_PVA_STAU_INFO", 1,"");
        ftextout( text_var, 7, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_PVA_STAU_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 7, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_PVA_STAU_EINH", 1,"");
        ftextout( text_var, 7, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_PHA_STAU_INFO", 1,"");
        ftextout( text_var, 8, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_PHA_STAU_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 8, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_PHA_STAU_EINH", 1,"");
        ftextout( text_var, 8, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_INFO", 1,"");
        ftextout( text_var, 9, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 9, 70, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_EINH", 1,"");
        ftextout( text_var, 9, 77, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_DPVA_REL_INFO", 1,"");
        ftextout( text_var, 10, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_REL_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 10, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_REL_EINH", 1,"");
        ftextout( text_var, 10, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_DPHA_INFO", 1,"");
        ftextout( text_var, 11, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPHA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 11, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPHA_EINH", 1,"");
        ftextout( text_var, 11, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_SDU2SDB_INFO", 1,"");
        ftextout( text_var, 12, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_SDU2SDB_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 12, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_DPVA_MIN_SDU2SDB_EINH", 1,"");
        ftextout( text_var, 12, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_UW_DPVA_REL_SDU2SDB_INFO", 1,"");
        ftextout( text_var, 13, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_UW_DPVA_REL_SDU2SDB_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "3.2" , text_var );
        ftextout( text_var, 13, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_UW_DPVA_REL_SDU2SDB_EINH", 1,"");
        ftextout( text_var, 13, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_WZ_TEST_SD_INFO", 1,"");
        ftextout( text_var, 14, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_WZ_TEST_SD_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 14, 70, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_WZ_TEST_SD_EINH", 1,"");
        ftextout( text_var, 14, 77, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_STROM_VA_INFO", 1,"");
        ftextout( text_var, 15, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_VA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.3" , text_var );
        ftextout( text_var, 15, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_VA_EINH", 1,"");
        ftextout( text_var, 15, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_STROM_HA_INFO", 1,"");
        ftextout( text_var, 16, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_HA_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.3" , text_var );
        ftextout( text_var, 16, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_HA_EINH", 1,"");
        ftextout( text_var, 16, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_STROM_FS_INFO", 1,"");
        ftextout( text_var, 17, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_FS_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.3" , text_var );
        ftextout( text_var, 17, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_FS_EINH", 1,"");
        ftextout( text_var, 17, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_STROM_SD_INFO", 1,"");
        ftextout( text_var, 18, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_SD_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "1.3" , text_var );
        ftextout( text_var, 18, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_STROM_SD_EINH", 1,"");
        ftextout( text_var, 18, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_WZ_STROMLOS_INFO", 1,"");
        ftextout( text_var, 19, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_WZ_STROMLOS_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 19, 70, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_WZ_STROMLOS_EINH", 1,"");
        ftextout( text_var, 19, 77, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_N_PUMPE_INFO", 1,"");
        ftextout( text_var, 20, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_N_PUMPE_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 20, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_N_PUMPE_EINH", 1,"");
        ftextout( text_var, 20, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_T_AUSSEN_INFO", 1,"");
        ftextout( text_var, 21, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_T_AUSSEN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 21, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_T_AUSSEN_EINH", 1,"");
        ftextout( text_var, 21, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_PREDR_T_MOTOR_INFO", 1,"");
        ftextout( text_var, 22, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_T_MOTOR_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 22, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_PREDR_T_MOTOR_EINH", 1,"");
        ftextout( text_var, 22, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_FSP_PREDR_ERR_INFO", 1,"");
        ftextout( text_var, 23, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_FSP_PREDR_ERR_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 23, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_FSP_PREDR_ERR_EINH", 1,"");
        ftextout( text_var, 23, 62, 0 ,0 );

        INPAapiResultText( text_var, "STAT_FSP_PREDR_WARN_INFO", 1,"");
        ftextout( text_var, 24, 2, 0 ,0 );
        INPAapiResultText( text_var, "STAT_FSP_PREDR_WARN_WERT", 1, "");
        stringtoreal( text_var, zahl_var );
        realtostring ( zahl_var, "5.0" , text_var );
        ftextout( text_var, 24, 55, 0 ,0 );
        INPAapiResultText( text_var, "STAT_FSP_PREDR_WARN_EINH", 1,"");
        ftextout( text_var, 24, 62, 0 ,0 );
      }
    }
  }
}

// ****************************
// ***  Stati Radknoten     ***
// ****************************
// wird ueber F3 aktiviert 'Radknoten'
SCREEN s_radknoten()
{
  real spannung_rk_links;
  real strom_rk_links;
  real spannung_rk_rechts;
  real strom_rk_rechts;
  real zahl_var;  
  int int_var;  
  string text_var = "";
  string sgbd_version = "";
  bool min_i350 = FALSE;
  string chk_jobstatus ="";

  ftextout( "Radknoten", 1, 0, 1, 0 );
  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  if(zahl_var > 0.952)
  {
    min_i350 = TRUE;
  }
  else
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SGBD Version >= 1.000)", 4, 0, 0 ,0 );
  }

  
  INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSORGUNG_RADKNOTEN", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SG Software > 3.5.0)", 5, 0, 0 ,0 );
    min_i350 = FALSE;
  }


  LINE( "","" )
  {

    if(min_i350 == TRUE)
    {
      INPAapiJob( sgbd, "STATUS_LESEN", "ARG;STATUS_VERSORGUNG_RADKNOTEN", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Versorgung Radknoten linke Seite", 1, 1, 0, 0 );
      INPAapiResultAnalog( spannung_rk_links, "STAT_VERSORGUNG_RK_LINKS_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( spannung_rk_links, 1, 30, 0, 20, 0, 20, "5.3" );
      // Einheit [Volt]
      INPAapiResultText( text_var, "STAT_VERSORGUNG_RK_LINKS_EINH", 1, "" );
      ftextout( text_var, 1, 65, 0, 0 );

      ftextout( "Stromaufnahme Radknoten linke Seite", 3, 1, 0, 0 );
      INPAapiResultAnalog( strom_rk_links, "STAT_ISTSTROM_RK_LINKS_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( strom_rk_links, 3, 30, 0, 10, 0, 10, "5.3" );
      // Einheit [Ampere]
      INPAapiResultText( text_var, "STAT_ISTSTROM_RK_LINKS_EINH", 1, "" );
      ftextout( text_var, 3, 65, 0, 0 );

      ftextout( "Fehler Radknoten linke Seite", 5, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RK_LINKS_FEHLER_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 5, 30, 0, 0 );

      // 'Fehlerzustaende' der Radknotenversorgung links
      INPAapiResultText( text_var, "STAT_RK_LINKS_FEHLER_NR_TEXT", 1, "" );
      clearrect(8,42,1,30);
      ftextout( text_var, 5, 40, 0, 0 );

      ftextout( "Status Radknoten linke Seite", 7, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RK_LINKS_STATUS_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 7, 30, 0, 0 );

      // 'Status' der Radknotenversorgung links
      INPAapiResultText( text_var, "STAT_RK_LINKS_STATUS_NR_TEXT", 1, "" );
      clearrect(10,42,1,30);
      ftextout( text_var, 7, 40, 0, 0 );



      ftextout( "Versorgung Radknoten rechte Seite", 11, 1, 0, 0 );
      INPAapiResultAnalog( spannung_rk_rechts, "STAT_VERSORGUNG_RK_RECHTS_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( spannung_rk_rechts, 11, 30, 0, 20, 0, 20, "5.3" );
      // Einheit [Volt]
      INPAapiResultText( text_var, "STAT_VERSORGUNG_RK_RECHTS_EINH", 1, "" );
      ftextout( text_var, 11, 65, 0, 0 );

      ftextout( "Stromaufnahme Radknoten rechte Seite", 13, 1, 0, 0 );
      INPAapiResultAnalog( strom_rk_rechts, "STAT_ISTSTROM_RK_RECHTS_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( strom_rk_rechts, 13, 30, 0, 10, 0, 10, "5.3" );
      // Einheit [Ampere]
      INPAapiResultText( text_var, "STAT_ISTSTROM_RK_RECHTS_EINH", 1, "" );
      ftextout( text_var, 13, 65, 0, 0 );

      ftextout( "Fehler Radknoten rechte Seite", 15, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RK_RECHTS_FEHLER_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 15, 30, 0, 0 );

      // 'Fehlerzustaende' der Radknotenversorgung rechts
      INPAapiResultText( text_var, "STAT_RK_RECHTS_FEHLER_NR_TEXT", 1, "" );
      clearrect(18,42,1,30);
      ftextout( text_var, 15, 40, 0, 0 );

      ftextout( "Status Radknoten rechte Seite", 17, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RK_RECHTS_STATUS_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 17, 30, 0, 0 );

      // 'Status' der Radknotenversorgung rechts
      INPAapiResultText( text_var, "STAT_RK_RECHTS_STATUS_NR_TEXT", 1, "" );
      clearrect(20,42,1,30);
      ftextout( text_var, 17, 40, 0, 0 );
    }
  }
}

// ******************************
// ***   Ventile Status       ***
// ******************************
SCREEN s_ventile_status()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "Ventile", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0, 0 );
  
  LINE( "","" )
  {
  
    ftextout( "< F1 >  Sicherheitsventil lesen"         ,3, 5, 0, 1 );
    ftextout( "< F2 >  Richtungsventil lesen"           ,5, 5, 0, 1 );
    ftextout( "< F3 >  Proportionalventil VA lesen"   ,7, 5, 0, 1 );
    ftextout( "< F4 >  Proportionalventil HA lesen"   ,9, 5, 0, 1 );
    ftextout( "< F5 >  Saugdrosselventil lesen"        ,11, 5, 0, 1 );
  
  }
}

// ******************************
// ***   SV Ventil            ***
// ******************************
SCREEN s_sv_ventil()
{
  real strom_sv_ventil;
  real stat_pwm_ventil;
  string text_var = "";
  int int_var;

  ftextout( "Sicherheitsventil", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
    INPAapiResultInt( int_var, "STAT_SICHERHEITSVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 30, 0, 0 );

    // 'Fehlerzustaende' des Sicherheitsventils
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );


    ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_ISTSTROM_SICHERHEITSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_SICHERHEITSVENTIL_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );

    ftextout( "Soll Strom Sicherheitsventil", 10, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_SOLLSTROM_SICHERHEITSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_SICHERHEITSVENTIL_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );

    ftextout( "Status PWM Sicherheitsventil", 13, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_SICHERHEITSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max          Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_SICHERHEITSVENTIL_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );
  }
}

// ******************************
// ***   RV Ventil            ***
// ******************************
SCREEN s_rv_ventil()
{
  real strom_rv_ventil;
  real stat_pwm_ventil;
  real stat_schaltstellung_RV;
  string text_var = "";
  int  int_var;

  ftextout( "Richtungsventil", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {

    //************************************************************
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
    INPAapiResultInt( int_var, "STAT_RICHTUNGSVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );


    ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_ISTSTROM_RICHTUNGSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_RICHTUNGSVENTIL_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Richtungsventil", 10, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_SOLLSTROM_RICHTUNGSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_RICHTUNGSVENTIL_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "Status PWM Richtungsventil", 13, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_RICHTUNGSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_RICHTUNGSVENTIL_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );

    //************************************************************
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTSTELLUNGSSENSOR", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Schaltstellung RV [ -1, 0, 1 ]
    ftextout( "Schaltstellung RV", 21, 5, 0, 0 );
    // Schaltstellung RV auslesen
    INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_SCHALTPOSITION_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "1" );
    //analogout( stat_schaltstellung_RV, 21, 30, -1.5, 1.5, -1, 1, "1" );

    // Einheit [Zustand]
    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_SW_EINH", 1, "" );
    ftextout( text_var, 21, 65, 0, 0 );
  }
}


// ******************************
// ***   VA Ventil            ***
// ******************************
SCREEN s_va_ventil()
{
  real stat_istdruck_ventil;
  real stat_pwm_ventil;
  real strom_va_ventil;
  string text_var = "";
  int  int_var;


  ftextout( "Proportionalventil VA", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE",  "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil VA", 5, 5, 0, 0 );
    INPAapiResultInt( int_var, "STAT_VENTIL_VA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_VA_NR_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );



    ftextout( "Steuerstrom Propventil VA", 7, 5, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_va_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Propventil VA", 10, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_va_ventil, "STAT_SOLLSTROM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_va_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_VA_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "PWM Propventil VA", 13, 5, 0, 0 );
    //
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_VA_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );

    //************************************************************


    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DRUCKSENSOREN", "" );
    INPAapiCheckJobStatus( "OKAY" );


    // Ist Druck VA
    ftextout( "Ist Druck VA", 16, 5, 0, 0 );
    //
    INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCKSENSOR_VA_SW_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_istdruck_ventil, 16, 30, -2, 250, -2, 250, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_SW_EINH", 1, "" );
    ftextout( text_var, 16, 65, 0, 0 );
  }
}

// ******************************
// ***   HA Ventil            ***
// ******************************
SCREEN s_ha_ventil()
{
  real stat_istdruck_ventil;
  real stat_pwm_ventil;
  real strom_ha_ventil;
  string text_var = "";
  int  int_var;

  ftextout( "Proportionalventil HA", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil HA", 5, 5, 0, 0 );
    INPAapiResultInt( int_var, "STAT_VENTIL_HA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_HA_NR_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );



    ftextout( "Steuerstrom Propventil HA", 7, 5, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_ha_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Propventil VA", 10, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_ha_ventil, "STAT_SOLLSTROM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_ha_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_HA_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "PWM Propventil HA", 13, 5, 0, 0 );
    //
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_HA_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );


    //************************************************************


    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DRUCKSENSOREN", "" );
    INPAapiCheckJobStatus( "OKAY" );


    // Ist Druck HA
    ftextout( "Ist Druck HA", 16, 5, 0, 0 );
    //
    INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCKSENSOR_HA_SW_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_istdruck_ventil, 16, 30, -2, 250, -2, 250, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_SW_EINH", 1, "" );
    ftextout( text_var, 16, 65, 0, 0 );
  }
}

// ******************************
// ***   SD Ventil            ***
// ******************************
SCREEN s_sd_ventil()
{
  real strom_sd_ventil;
  real stat_pwm_ventil;
  string text_var = "";
  int int_var;

  ftextout( "Saugdrosselventil", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Saugdrosselventil", 5, 5, 0, 0 );
    INPAapiResultInt( int_var, "STAT_SAUGDROSSELVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 30, 0, 0 );

    // 'Fehlerzustaende' des Sicherheitsventils
    INPAapiResultText( text_var, "STAT_SAUGDROSSELVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );


    ftextout( "Steuerstrom Saugdrosselventil", 7, 5, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_ISTSTROM_SAUGDROSSELVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_SAUGDROSSELVENTIL_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );

    ftextout( "Soll Strom Saugdrosselventil", 10, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_SOLLSTROM_SAUGDROSSELVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_SAUGDROSSELVENTIL_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );

    ftextout( "Status PWM Saugdrosselventil", 13, 5, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_SAUGDROSSELVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max          Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_SAUGDROSSELVENTIL_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );
  }
}

// ******************************
// ***    Sensorabgleich      ***
// ******************************
SCREEN s_sensorabgleich()
{
  real stat_offsetdruck_ventil;
  real stat_sensorpara;
  real tmpr = 0;
  int stat_steigung;
  string text_var = "";

  int sensor_nullpunkt = 0;
  int sensor_steigung = 0;
  int input_state_key_1 = 0;
  int int_var;
  real zahl_var = 0;

  string err_jobstatus = "";
  string chk_jobstatus = "";
  string sensor_nullpunkt_einh = "";
  string sensor_steigung_einh = "";
  string sgbd_version = "";
  string tmpn = "";
  string tmps = "";

  bool min_i350 = FALSE;

  ftextout( "Sensorabgleich", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  if(zahl_var > 0.952)
  {
    min_i350 = TRUE;
  }
  else
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SGBD Version >= 1.000)", 4, 0, 0 ,0 );
  }

  INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;RRR", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SG Software > 3.5.0)", 5, 0, 0 ,0 );
    min_i350 = FALSE;
  }


  LINE( "","" )
  {

    if(min_i350 == TRUE)
    {
      // gelernter Offset Wert lesen für Nullpunkt Druck VA
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;RRR", "" );
      INPAapiCheckJobStatus( "OKAY" );


      // Druck VA
      ftextout( "Arbeitsnullpunkt für Druck VA", 1, 1, 0, 0 );
      //
      INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_OFFSET_VA_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( stat_offsetdruck_ventil, 1, 37, 0, 2500, 0, 2500, "4.0" );

      // Einheit [mV]
      INPAapiResultText( text_var, "STAT_OFFSET_VA_EINH", 1, "" );
      ftextout( text_var, 1, 75, 0, 0 );

      ftextout( "Abgleichstatus Drucksensor VA", 3, 1, 0, 0 );
      // Ausgabe des Telegrammwertes
      INPAapiResultInt( int_var, "STAT_OFFSET_ERROR_VA_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 3, 37, 0, 0 );
    
      // Fehlertext für den Sensor
      INPAapiResultText( text_var, "STAT_OFFSET_ERROR_VA_NR_TEXT", 1, "" );
      clearrect(7,47,1,30);
      ftextout( text_var, 3, 45, 0, 0 );


      // gelernter Offset Wert lesen für Nullpunkt Druck HA
  
      // Druck HA
      ftextout( "Arbeitsnullpunkt für Druck HA", 5, 1, 0, 0 );
      //
      INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_OFFSET_HA_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( stat_offsetdruck_ventil, 5, 37, 0, 2500, 0, 2500, "4.0" );

      // Einheit [mV]
      INPAapiResultText( text_var, "STAT_OFFSET_HA_EINH", 1, "" );
      ftextout( text_var, 5, 75, 0, 0 );

      ftextout( "Abgleichstatus Drucksensor HA", 7, 1, 0, 0 );
      // Ausgabe des Telegrammwertes
      INPAapiResultInt( int_var, "STAT_OFFSET_ERROR_HA_NR", 1);
      inttohexstring(int_var, 4, text_var);
      ftextout( "0x"+text_var, 7, 37, 0, 0 );
    
      // Fehlertext für den Sensor
      INPAapiResultText( text_var, "STAT_OFFSET_ERROR_HA_NR_TEXT", 1, "" );
      clearrect(11,47,1,30);
      ftextout( text_var, 7, 45, 0, 0 );


      // Sensorparameter Druck VA (fest aus Datenblatt 650mV)
      ftextout( "Sensornullpunkt Druck VA", 15, 1, 0, 0 );
      stat_sensorpara = 650;
      analogout( stat_sensorpara, 15, 37, 0, 2500, 0, 2500, "4.0" );

      // Einheit [mV]
      text_var = "mV";
      ftextout( text_var, 15, 75, 0, 0 );

      ftextout( "Sensorsteigung Druck VA", 17, 1, 0, 0 );
      text_var = "19.25";
      ftextout( text_var, 17, 37, 0, 0 );

      // Einheit [mV/bar]
      text_var = "mV/bar";
      ftextout( text_var, 17, 42, 0, 0 );

      // Sensorparameter Druck HA lesen (fest aus Datenblat 650 mV)
      ftextout( "Sensornullpunkt Druck HA", 21, 1, 0, 0 );
      stat_sensorpara = 650;
      analogout( stat_sensorpara, 21, 37, 0, 2500, 0, 2500, "4.0" );

      // Einheit [mV]
      text_var = "mV";
      ftextout( text_var, 21, 75, 0, 0 );

      ftextout( "Sensorsteigung Druck HA", 23, 1, 0, 0 );
      text_var = "19.25";
      ftextout( text_var, 23, 37, 0, 0 );


      // Einheit [mV/bar]
      text_var = "mV/bar";
      ftextout( text_var, 23, 42, 0, 0 );
    }
  }
}

// ***************************
// *** Stati Sensoren ARS  ***
// ***************************
// wird ueber F6 aktiviert 'Sensoren'
SCREEN s_stati_sensor()
{
  int status_ars;
  real stat_alive;
  string text_var = "";
  real zahl_var;
  int  int_var;  

  // 5 Volt / 10bit --> 5 Volt /1024
  real EinBitVoltWert = 0.0048828125;
  real SensorWert_VA_roh;
  real SensorWert_VA;
  real SensorWert_HA_roh;
  real SensorWert_HA;

  real SensorWert_RV_roh;
  real SensorWert_RV;
  real SensorWert_QU_roh;
  real SensorWert_QU;


  ftextout( "Status Sensoren", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DRUCKSENSOREN", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Drucksensor VA", 1, 1, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultInt( int_var, "STAT_DRUCKSENSOR_VA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 1, 37, 0, 0 );
    
    // Fehlertext für den Sensor
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_NR_TEXT", 1, "" );
    clearrect(5,47,1,30);
    ftextout( text_var, 1, 45, 0, 0 );

    ftextout( "Status Drucksensor HA", 3, 1, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultInt( int_var, "STAT_DRUCKSENSOR_HA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 37, 0, 0 );
    
    // Fehlertext für den Sensor
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_NR_TEXT", 1, "" );
    clearrect(7,47,1,30);
    ftextout( text_var, 3, 45, 0, 0 );

    ////////////////////////////////////////////////////////////////////////////////

    // Ausgabe des Telegrammwertes
    // Druck VA
    ftextout( "Druck VA (Spg. Roh)", 9, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "3.3" , text_var );
    clearrect(13,39,1,30);
    ftextout( text_var, 9, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_SW_EINH", 1, "" );
    ftextout( text_var, 9, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 9, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_VA_HW_EINH", 1, "" );
    ftextout( text_var, 9, 71, 0, 0 );

    ////////////////////////////////////////////////////////////////////////////////

    // Ausgabe des Telegrammwertes
    // Druck HA
    ftextout( "Druck HA (Spg. Roh)", 11, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "3.3" , text_var );
    clearrect(15,39,1,30);
    ftextout( text_var, 11, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_SW_EINH", 1, "" );
    ftextout( text_var, 11, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 11, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCKSENSOR_HA_HW_EINH", 1, "" );
    ftextout( text_var, 11, 71, 0, 0 );
    ////////////////////////////////////////////////////////////////////////////////
    
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTSTELLUNGSSENSOR", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Schaltstellungssensor", 5, 1, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultInt( int_var, "STAT_SCHALTPOSITION_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 5, 37, 0, 0 );

    // Fehlertext für den Sensor
    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_NR_TEXT", 1, "" );
    clearrect(9,47,1,30);
    ftextout( text_var, 5, 45, 0, 0 );

    ////////////////////////////////////////////////////////////////////////////////

    // Schaltstellung RV
    ftextout( "Schaltstellung RV (Spg. Roh)", 13, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    clearrect(17,39,1,20);
    ftextout( text_var, 13, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_SW_EINH", 1, "" );
    ftextout( text_var, 13, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 13, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_HW_EINH", 1, "" );
    ftextout( text_var, 13, 71, 0, 0 );

    ////////////////////////////////////////////////////////////////////////////////
    
    // Oelstand

    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_OELSTANDSENSOR", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Oelstand (Spg. Roh)", 17, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_OELSTAND_SW_NR", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    ftextout( text_var, 17, 37, 0, 0 );
    
    INPAapiResultText( text_var, "STAT_OELSTAND_SW_NR_TEXT", 1, "" );
    clearrect(21,47,1,20);
    ftextout( text_var, 17, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_OELSTAND_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 17, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_OELSTAND_HW_EINH", 1, "" );
    ftextout( text_var, 17, 71, 0, 0 );
  }
}

// ****************************
// ***  Stati Versorgungen  ***
// ****************************
// wird ueber F7 aktiviert 'Versorgungen'
SCREEN s_versorgungen()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "Versorgungen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );
  
  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;SPANNUNG_KLEMME_30_WERT", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Versorgung Klemme 30 (Last)", 1, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_SPANNUNG_KLEMME_30_WERT", 1, "" );

    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 1 Nachkommastellen
    realtostring ( zahl_var, "2.1" , text_var );
    ftextout( text_var, 1, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_SPANNUNG_KLEMME_30_EINH", 1, "" );
    ftextout( text_var, 1, 50, 0, 0 );


    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;SPANNUNG_KLEMME_15N_WERT", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Versorgung Klemme 15N (Logik)", 3, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_SPANNUNG_KLEMME_15N_WERT", 1, "" );

    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 1 Nachkommastellen
    realtostring ( zahl_var, "2.1" , text_var );
    ftextout( text_var, 3, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_SPANNUNG_KLEMME_15N_EINH", 1, "" );
    ftextout( text_var, 3, 50, 0, 0 );


    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_VERSORGUNG_SENSOREN", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Versorgung Schaltstellungssensor", 5, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_SCHALTSENSOR_WERT", 1, "" );

    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 5, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_SCHALTSENSOR_EINH", 1, "" );
    ftextout( text_var, 5, 50, 0, 0 );



    ftextout( "Versorgung Drucksensor VA", 7, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_VA_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 7, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_VA_EINH", 1, "" );
    ftextout( text_var, 7, 50, 0, 0 );



    ftextout( "Versorgung Drucksensor HA", 9, 1, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_HA_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 9, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_HA_EINH", 1, "" );
    ftextout( text_var, 9, 50, 0, 0 );
  }
}


// ******************************
// ***   Ventile Steuern      ***
// ***    Rampenlogik         ***
// ******************************
// wird ueber F5 aktiviert 'Ansteuern'
SCREEN s_rampen_steuern()
{
  int status_ars;

  real stat_alive;
  real zahl_var;  
  real stat_istdruck_va;
  real stat_istdruck_ha;
  real mgl_restdruck;
  real mgl_reststrom;
  real eingabe_tmp;
  real r_min = 0;
  real r_max = 0;
  
  int int_eingabe_tmp;
  
  string text_var = "";
  string text_var2 = "";
  string chk_jobstatus = "";
  string job_parameter = "";
  string text_tmp = "";
  string text_va_druck_einh = "";
  string text_ha_druck_einh = "";

  int  int_var;

  ftextout( "Rampenlogik für Ventilansteuerung", 1, 0, 1, 0 );
  //ftextout( "", 2, 0, 1, 0 );
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Sicherheitsventil und Richtungsventil
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  LINE( "","" )
  {
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sicherheitsventil
    ftextout( "Sicherheitsventil bei Rampe", 1, 0, 0, 0 );
    digitalout( sv_ein_aus, 1, 30, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
    ftextout( "Status Sicherheitsventil", 3, 0, 0, 0 );
    INPAapiResultInt( int_var, "STAT_SICHERHEITSVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 23, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );
  
    ftextout( "Steuerstrom Sicherheitsventil", 4, 0, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_ISTSTROM_SICHERHEITSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 5, 0, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_SICHERHEITSVENTIL_EINH", 1, "" );
    ftextout( text_var, 5, 35, 0, 0 );
  
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Richtungsventil
    ftextout( "Richtungsventil bei Rampe", 1, 45, 0, 0 );
    //ftextout( "", 3, 0, 0, 0 );
    digitalout( rv_ein_aus, 1, 75, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Richtungsventil", 3, 45, 0, 0 );
    INPAapiResultInt( int_var, "STAT_RICHTUNGSVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
  
    ftextout( "Steuerstrom Richtungsventil", 4, 45, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_ISTSTROM_RICHTUNGSVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 5, 45, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_RICHTUNGSVENTIL_EINH", 1, "" );
    ftextout( text_var, 5, 80, 0, 0 );
  }
  //ende Line Sicherheitsventil und Richtungsventil

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Saugdrosselventil
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  LINE( "","" )
  {
    ftextout( "Saugdrosselventil bei Rampe", 1, 0, 0, 0 );
    digitalout( sd_ein_aus, 1, 30, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
    ftextout( "Status Saugdrosselventil", 3, 0, 0, 0 );
    INPAapiResultInt( int_var, "STAT_SAUGDROSSELVENTIL_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 23, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_SAUGDROSSELVENTIL_NR_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );
  
    ftextout( "Steuerstrom Saugdrosselventil", 4, 0, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_ISTSTROM_SAUGDROSSELVENTIL_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 5, 0, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_ISTSTROM_SAUGDROSSELVENTIL_EINH", 1, "" );
    ftextout( text_var, 5, 35, 0, 0 );

    
    // Schaltstellung RV
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_SCHALTSTELLUNGSSENSOR", "" );
    INPAapiCheckJobStatus( "OKAY" );
    ftextout( "Schaltstellung RV", 1, 45, 0, 0 );
    INPAapiResultText( text_var, "STAT_SCHALTPOSITION_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    clearrect(11,62,1,5);
    ftextout( text_var, 1, 60, 0, 0 );
    
    
    // Text Rampe an
    if (   (sv_ein_aus == TRUE) || (rv_ein_aus == TRUE)  || (sd_ein_aus == TRUE)
         ||(PropVA_ein_aus == TRUE) || (PropHA_ein_aus == TRUE))
    {
      if( FALSE == ramp_mode_ein_aus )
      {
         ftextout( "Rampe aktivieren durch <F4>", 3, 45, 0, 1 );
         // Ansteuerung durch Rampenlogik Job spaeter
      }
      else
      {
         ftextout( "Rampenansteuerung aktiv!           ", 3, 45, 0, 1 );
      }
    }
    else
    {
      if( FALSE == ramp_mode_ein_aus )
      {
         //Text löschen
         ftextout( "                                       ", 3, 45, 0, 1 );
      }
      else
      {
         ftextout( "Rampenansteuerung aktiv!           ", 3, 45, 0, 1 );
      }
    }
  }
  //ende Line Saugdrosselventil

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Propventil VA UND
  // Propventil HA
  LINE( "","" )
  {
    // vorab alle notwendigen Grenzen berechnen:
    //
    // Roter Bereich VA abhaengig vom Istdruck HA
    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_DRUCKSENSOREN", "" );
    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultAnalog( stat_istdruck_ha, "STAT_DRUCKSENSOR_HA_SW_WERT", 1 );
    INPAapiResultAnalog( stat_istdruck_va, "STAT_DRUCKSENSOR_VA_SW_WERT", 1 );
    INPAapiResultText( text_va_druck_einh, "STAT_DRUCKSENSOR_VA_SW_EINH", 1, "" );
    INPAapiResultText( text_ha_druck_einh, "STAT_DRUCKSENSOR_HA_SW_EINH", 1, "" );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    mgl_restdruck = 180;
    mgl_reststrom = 0.453 + (0.0069375 * (180 - stat_istdruck_ha));
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil VA 
    ftextout( "Proportionalventil VA bei Rampe", 1, 0, 0, 0 );
    digitalout( PropVA_ein_aus, 1, 30, "Ein", "Aus" );
    ftextout( "Status Propventil VA", 3, 0, 0, 0 );
    INPAapiResultInt( int_var, "STAT_VENTIL_VA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 23, 0, 0 );
    
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_VA_NR_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );

    ftextout("Rampenzeit", 4, 0,0,0);
    inttoreal(va_ramp_zeit, eingabe_tmp);
    eingabe_tmp= eingabe_tmp/1000;
    realtostring( eingabe_tmp, "3.2",text_var );
    strcat(text_var2, text_var, " s");
    ftextout( text_var2, 4, 23,0,0);
    if(0 == va_ramp_art) { ftextout( "Stop            ", 4, 30,0,0); }
    else if(1 == va_ramp_art) { ftextout("Aufwärts   ", 4, 30,0,0); }
    else if(2 == va_ramp_art) { ftextout("Abwärts    ", 4, 30,0,0); }
    else { ftextout("Ungültig    ", 4, 30,0,0); }

    if(0 == rampenvorgabe) 
    {    // Vorgabe ueber Strom
         ftextout( "Rampenobergrenze (Strom)", 5, 0, 0, 0);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/1000;
         realtostring( eingabe_tmp, "3.3",text_var );
         ftextout( text_var, 5, 23,0,0);
         ftextout( "Ampere", 5,30,0,0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_va_ventil, 6, 0, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
         ftextout( text_var, 6, 35, 0, 0 );

         // Ist Druck VA
         ftextout( "Ist Druck VA", 8, 0, 0, 0 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_va, 9, 0, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_va_druck_einh, 9, 35, 0, 0 );
    }
    else if(1 == rampenvorgabe)
    {    // Vorgabe ueber Druck
         ftextout( "Rampenobergrenze (Druck)", 5, 0, 0, 0);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/10;
         realtostring( eingabe_tmp, "3.1",text_var );
         ftextout( text_var, 5, 23,0,0);
         ftextout( "[bar]", 5,30,0,0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_va, 6, 0, -2, 250, -2, mgl_restdruck, "3.3" );
         // Einheit [bar]
         ftextout( text_va_druck_einh, 6, 35, 0, 0 );
    }
    else if(2 == rampenvorgabe)
    {    // Vorgabe ueber PWM
         ftextout( "Rampenobergrenze (PWM)", 5, 0, 0, 0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,0,2,30);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp = eingabe_tmp/10;
         analogout( eingabe_tmp, 6, 0, 0, 100, 0, 100, "3.3" );
         // Einheit [%]
         ftextout( "[%]", 6, 35, 0, 0 );
    }

    if(0 != rampenvorgabe) 
    {    // für Druck und PWM:
         INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE", "" );
         INPAapiCheckJobStatus( "OKAY" );
         // Stromwert auslesen
         ftextout( "Steuerstrom Propventil VA", 8, 0, 0, 0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_va_ventil, 9, 0, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
         ftextout( text_var,9, 35, 0, 0 );
    }
    if(2 == rampenvorgabe)
    {    // nur bei PWM:
         // Ist Druck VA
         ftextout( "Ist Druck VA", 11, 0, 0, 0 );
         //                         Zl, Sp, min  max    Format
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (29,0,2,30);
         analogout( stat_istdruck_va, 12, 0, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_va_druck_einh, 12, 35, 0, 0 );
    }

    ///////////////////////////////////////////////////////////////////////////

    // Taste 'EIN' wurde gedrueckt
    if ( PropVA_ein_aus == TRUE )
    {
      if (TRUE == ramp_mode_ein_aus)
      {
        inttoreal(va_ramp_wert, eingabe_tmp);
        if((0 == rampenvorgabe) && (eingabe_tmp > (mgl_reststrom*1000)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if((1 == rampenvorgabe) && (eingabe_tmp > (mgl_restdruck*10)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if(2 == rampenvorgabe)
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Keine Ueberpruefung der Grenzwerte bei Vorgabe PWM");
              warnung_erfolgt = TRUE;
           }
        }
      }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    // konstante Werte für Hinterachsgrenzen
    mgl_restdruck = 180 - (stat_istdruck_va - stat_istdruck_ha);
    mgl_reststrom = 0.453 + (0.0069375 * mgl_restdruck );

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil HA mit Fehlerpruefung

    ftextout( "Proportionalventil HA bei Rampe", 1, 45, 0, 0 );
    digitalout( PropHA_ein_aus, 1, 75, "Ein", "Aus" );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil HA", 3, 45, 0, 0 );
    INPAapiResultInt( int_var, "STAT_VENTIL_HA_NR", 1);
    inttohexstring(int_var, 4, text_var);
    ftextout( "0x"+text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_HA_NR_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
    ftextout("Rampenzeit", 4, 45,0,0);
    inttoreal(ha_ramp_zeit, eingabe_tmp);
    eingabe_tmp= eingabe_tmp/1000;
    realtostring( eingabe_tmp, "3.2",text_var );
    strcat(text_var2, text_var, " s");
    ftextout( text_var2, 4, 68,0,0);
    if(0 == ha_ramp_art) { ftextout( "Stop            ", 4, 75,0,0); }
    else if(1 == ha_ramp_art) { ftextout("Aufwärts   ", 4, 75,0,0); }
    else if(2 == ha_ramp_art) { ftextout("Abwärts    ", 4, 75,0,0); }
    else if(4 == ha_ramp_art) { ftextout("siehe VA ", 4, 75,0,0); }
    else { ftextout("Ungueltig    ", 4, 75,0,0); }

    ftextout( "Rampenwert Propventil HA:", 5, 45, 0, 0);
    
    if(0 == rampenvorgabe) 
    {    // Vorgabe ueber Strom
         ftextout( "Rampenobergrenze (Strom)", 5, 45, 0, 0);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/1000;
         realtostring( eingabe_tmp, "3.3",text_var );
         ftextout( text_var, 5, 68,0,0);
         ftextout( "Ampere", 5,75,0,0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_ha_ventil, 6, 45, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
         ftextout( text_var, 6, 80, 0, 0 );

         // Ist Druck VA
         ftextout( "Ist Druck HA", 8, 45, 0, 0 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_ha, 9, 45, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_ha_druck_einh, 9, 80, 0, 0 );
    }
    else if(1 == rampenvorgabe)
    {    // Vorgabe ueber Druck
         ftextout( "Rampenobergrenze (Druck)", 5, 45, 0, 0);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/10;
         realtostring( eingabe_tmp, "3.1",text_var );
         ftextout( text_var, 5, 68,0,0);
         ftextout( "[bar]", 5,75,0,0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_ha, 6, 45, -2, 250, -2, mgl_restdruck, "3.3" );
         // Einheit [bar]
         ftextout( text_ha_druck_einh, 6, 80, 0, 0 );
    }
    else if(2 == rampenvorgabe)
    {    // Vorgabe ueber PWM
         ftextout( "Rampenobergrenze (PWM)", 5, 45, 0, 0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,45,2,30);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp = eingabe_tmp/10;
         analogout( eingabe_tmp, 6, 45, 0, 100, 0, 100, "3.3" );
         // Einheit [%]
         ftextout( "[%]", 6, 80, 0, 0 );
    }

    if(0 != rampenvorgabe) 
    {    // für Druck und PWM:
         INPAapiJob( sgbd, "STATUS_LESEN", "ARG;ARS_PROPORTIONALVENTILE", "" );
         INPAapiCheckJobStatus( "OKAY" );
         // Stromwert auslesen
         ftextout( "Steuerstrom Propventil HA", 8, 45, 0, 0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_ha_ventil, 9, 45, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
         ftextout( text_var,9, 80, 0, 0 );
    }
    if(2 == rampenvorgabe)
    {    // nur bei PWM:
         // Ist Druck HA
         ftextout( "Ist Druck HA", 11, 45, 0, 0 );
         //                         Zl, Sp, min  max    Format
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (29,45,2,30);
         analogout( stat_istdruck_ha, 12, 45, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_ha_druck_einh, 12, 80, 0, 0 );
    }

    ///////////////////////////////////////////////////////////////////////////

    // Taste 'EIN' wurde gedrueckt
    if ( PropHA_ein_aus == TRUE )
    {
      if (TRUE == ramp_mode_ein_aus)
      {
        inttoreal(ha_ramp_wert, eingabe_tmp);
        if((0 == rampenvorgabe) && (eingabe_tmp > (mgl_reststrom*1000)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if((1 == rampenvorgabe) && (eingabe_tmp > (mgl_restdruck*10)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if(2 == rampenvorgabe)
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Keine Ueberpruefung der Grenzwerte bei Vorgabe PWM");
              warnung_erfolgt = TRUE;
           }
        }
      }
    }

//      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 14, 45, 0, 0 );

    // Eigentlichen Diagnoseaufruf starten
    if(TRUE == ramp_mode_ein_aus)
    {
       // Parameter1: Diag Ramp Ctrl Status
       int_eingabe_tmp = 0;
       if(0==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  1; } // HA Halt
       if(1==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  4; } // HA Auf
       if(2==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  2; } // HA Ab
       if(0==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  8; } // VA Halt
       if(1==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 32; } // VA Auf
       if(2==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 16; } // VA Ab
       if(4==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 64; } // HA zusammen mit VA
       inttostring(int_eingabe_tmp, text_tmp);
       strcat(job_parameter, text_tmp, ";");
       // Parameter2,3: Diag Ramp Time VA, HA
       inttostring(va_ramp_zeit, text_tmp);
       if(PropVA_ein_aus == FALSE)
       {
         strcat(job_parameter, job_parameter, "0");
       }
       else
       {
         strcat(job_parameter, job_parameter, text_tmp);
       }
       strcat(job_parameter, job_parameter, ";");
       inttostring(ha_ramp_zeit, text_tmp);
       if(PropHA_ein_aus == FALSE)
       {
         strcat(job_parameter, job_parameter, "0");
       }
       else
       {
         strcat(job_parameter, job_parameter, text_tmp);
       }
       strcat(job_parameter, job_parameter, ";");
       // Parameter4,5: Diag Ramp Value VA, HA
       inttostring(va_ramp_wert, text_tmp);
       if(PropVA_ein_aus == FALSE)
       {
         strcat(job_parameter, job_parameter, "0");
       }
       else
       {
         strcat(job_parameter, job_parameter, text_tmp);
       }
       strcat(job_parameter, job_parameter, ";");
       inttostring(ha_ramp_wert, text_tmp);
       if(PropHA_ein_aus == FALSE)
       {
         strcat(job_parameter, job_parameter, "0");
       }
       else
       {
         strcat(job_parameter, job_parameter, text_tmp);
       }
       strcat(job_parameter, job_parameter, ";");
       // Parameter6: Diag Ramp RV FS SD Status
       int_eingabe_tmp = 0;
       if(TRUE == sv_ein_aus) {  int_eingabe_tmp = int_eingabe_tmp +   4; } // FS ein
       if(TRUE == rv_ein_aus) {  int_eingabe_tmp = int_eingabe_tmp +  16; } // RV ein
       if(TRUE == sd_ein_aus) {  int_eingabe_tmp = int_eingabe_tmp + 256; } // SD ein
       inttostring(int_eingabe_tmp, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);
       // Jobargumente zusammenbauen
       strcat(job_parameter,  "ARG;STEUERN_DIAG_PARAMETER;", job_parameter);

       INPAapiJob( sgbd, "STEUERN", job_parameter, "OKAY" );
       // Momentan kein Errorhandling
       // Parameter: Status Wort
       //int_eingabe_tmp = 8;  // Rampenmode aktiv
       //if(0==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 32; } // Strom
       //if(1==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 16; } // Druck
       //if(2==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 64; } // PWM
       if(0==rampenvorgabe) {  job_parameter = "Rampe_Strom"; } // Strom
       if(1==rampenvorgabe) {  job_parameter = "Rampe_Druck"; } // Druck
       if(2==rampenvorgabe) {  job_parameter = "Rampe_PWM"; } // PWM

       //inttostring(int_eingabe_tmp, job_parameter);

       // Jobargumente zusammenbauen
       strcat(job_parameter,  "ARG;STEUERN_DIAGSTAT_SETZEN;", job_parameter);
       INPAapiJob( sgbd, "STEUERN", job_parameter, "OKAY" );
    }
  }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Ende 'Line' Rampenlogik
}


// ***************************************
// ***  Nullpunkte der Sensoren lernen ***
// ***  mit Grenzwertueberwachung      ***
// ***  Anfangsbildschirm              ***
// ***************************************
SCREEN s_nullpkt_mitGrenz_lernen()
{

  ftextout( "MIT GRENZWERTÜBERWACHUNG"                  ,1, 1, 0, 1 );
  ftextout( "< F1 >  Arbeitsnullpunkte Drucksensoren (VA/HA) lernen"        ,3, 5, 0, 1 );
}

// ***************************************
// ***  Nullpunkte der Sensoren lernen ***
// ***  mit Grenzwertueberwachung      ***
// ***************************************
SCREEN s_nullpkt_lernen()
{
  real stat_offsetdruck_ventil;
  string chk_jobstatus = "";
  string sgbd_version = "";
  real zahl_var = 0;
  bool min_i350 = FALSE;
    
  ftextout( "MIT GRENZWERTÜBERWACHUNG"                                        ,1, 1, 0, 1 );
  ftextout( "< F1 >  Arbeitsnullpunkte Drucksensoren (VA/HA) lernen"   ,3, 5, 0, 1 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  if(zahl_var > 0.952)
  {
    min_i350 = TRUE;
  }
  else
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SGBD Version >= 1.000)", 4, 0, 0 ,0 );
  }

  INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;RRR", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SG Software > 3.5.0)", 5, 0, 0 ,0 );
    min_i350 = FALSE;
  }


  if ( toggle_1 == 1 )
  {
    INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;STR", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

    if ( chk_jobstatus == "OKAY" )
    {
      infobox ( "Drucksensorabgleich", "Abgleich durchgeführt!" );
      userboxclose( 0 );
      viewclose();

      if(min_i350 == TRUE)
      {
        // gelernter Offset Wert lesen für Nullpunkt Druck VA
        INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;STEUERN_START_OFFSET_WERTE;RRR", "" );
        INPAapiCheckJobStatus( "OKAY" );
  
        // Druck VA
        ftextout( "Arbeitsnullpunkt für Druck VA", 10, 1, 0, 0 );
        //
        INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_OFFSET_VA_WERT", 1 );
        //                         Zl, Sp, min  max    Format
        analogout( stat_offsetdruck_ventil, 10, 37, 0, 2500, 0, 2500, "4.0" );
  
        // Einheit [mV]
        INPAapiResultText( text_var, "STAT_OFFSET_VA_EINH", 1, "" );
        ftextout( text_var, 10, 75, 0, 0 );

        // gelernter Offset Wert lesen für Nullpunkt Druck HA
        // Druck HA
        ftextout( "Arbeitsnullpunkt für Druck HA", 12, 1, 0, 0 );
        //
        INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_OFFSET_HA_WERT", 1 );
        //                         Zl, Sp, min  max    Format
        analogout( stat_offsetdruck_ventil, 12, 37, 0, 2500, 0, 2500, "4.0" );
  
        // Einheit [mV]
        //INPAapiResultText( text_var, "STAT_OFFSET_HA_EINH", 1, "" );
        ftextout( text_var, 12, 75, 0, 0 );
      }
      toggle_1 = 0;
    }
    else if ( chk_jobstatus == "ERROR_ECU_VEHICLE_SPEED_TOO_HIGH" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen ==> FZGgeschw. gleich NULL" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else if ( chk_jobstatus == "ERROR_ECU_RPM_TOO_HIGH" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Motor muss aus sein ==> Motordrehzahl gleich NULL" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else if ( chk_jobstatus == "ERROR_ECU_VOLTAGE_TOO_LOW" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Sensorspannung zu niedrig" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else if ( chk_jobstatus == "ERROR_ECU_VOLTAGE_TOO_HIGH" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Sensorspannung zu hoch" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else if ( chk_jobstatus == "ERROR_ECU_GENERAL_PROGRAMMING_FAILURE" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Daten nicht abgespeichert ==> Eepromfehler" );
      userboxclose( 0 );
      viewclose();
    }
    else
    {
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
      userboxclose( 0 );
      viewclose();
    }
    toggle_1 = 0;
  }
}

// ******************************
// ***   RK Verbauprüfung     ***
// ******************************
SCREEN s_rk_verbau_steuern()
{
  string text_var = "";
  int int_var;
  real zahl_var = 0;
  string err_jobstatus = "";
  string chk_jobstatus = "";
  string sgbd_version = "";
  bool min_i350 = FALSE;


  ftextout( "Radknotenverbauprüfung", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  //Version abfragen
  INPAapiJob(sgbd,"info","","");
  INPAapiResultText( sgbd_version, "REVISION", 1, "" );
  stringtoreal( sgbd_version, zahl_var );
  
  if(zahl_var > 0.952)
  {
    min_i350 = TRUE;
  }
  else
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SGBD Version >= 1.000)", 4, 0, 0 ,0 );
  }

  INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;RRR", "" );
  INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
  if(chk_jobstatus != "OKAY")
  {
    ftextout( "(erst in I3.50 vollständig implementiert. SG Software > 3.5.0)", 5, 0, 0 ,0 );
    min_i350 = FALSE;
  }

  LINE( "","" )
  {

    if(min_i350 == TRUE)
    {
      // gelernter Offset Wert lesen für Nullpunkt Druck VA
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;RRR", "" );
      INPAapiCheckJobStatus( "OKAY" );

      // Prüfung Status
      ftextout( "Prüfung", 1, 1, 1, 0 );
      INPAapiResultText( text_var, "STAT_PRUEFUNG_LAEUFT_NR_TEXT", 1, "" );
      clearrect(5,19,2,30);
      ftextout( text_var, 1, 15, 1, 0 );
      
      // Prüfung Hinten Rechts
      ftextout( "Prüfung Radknoten HR", 7, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RESULT_HR_NR", 1);
      inttohexstring(int_var, 1, text_var);
      ftextout( "(0x"+text_var+")", 7, 20, 0, 0 );

      INPAapiResultText( text_var, "STAT_RESULT_HR_NR_TEXT", 1, "" );
      clearrect(11,27,1,60);
      ftextout( text_var, 7, 25, 0, 0 );
      

      // Prüfung Vorne Rechts
      ftextout( "Prüfung Radknoten VR", 9, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RESULT_VR_NR", 1);
      inttohexstring(int_var, 1, text_var);
      ftextout( "(0x"+text_var+")", 9, 20, 0, 0 );

      INPAapiResultText( text_var, "STAT_RESULT_VR_NR_TEXT", 1, "" );
      clearrect(13,27,1,60);
      ftextout( text_var, 9, 25, 0, 0 );
      

      // Prüfung Hinten Links
      ftextout( "Prüfung Radknoten HL", 11, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RESULT_HL_NR", 1);
      inttohexstring(int_var, 1, text_var);
      ftextout( "(0x"+text_var+")", 11, 20, 0, 0 );

      INPAapiResultText( text_var, "STAT_RESULT_HL_NR_TEXT", 1, "" );
      clearrect(15,27,1,60);
      ftextout( text_var, 11, 25, 0, 0 );
      

      // Prüfung Vorne Links
      ftextout( "Prüfung Radknoten VL", 13, 1, 0, 0 );
      INPAapiResultInt( int_var, "STAT_RESULT_VL_NR", 1);
      inttohexstring(int_var, 1, text_var);
      ftextout( "(0x"+text_var+")", 13, 20, 0, 0 );

      INPAapiResultText( text_var, "STAT_RESULT_VL_NR_TEXT", 1, "" );
      clearrect(17,27,1,60);
      ftextout( text_var, 13, 25, 0, 0 );
      


    }

    if ( toggle_1 == 1 )
    {
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;STR", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

      if ( chk_jobstatus == "OKAY" )
      {
      }
      else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT" )
      {
        // nachsehen, ob Prüfung schon läuft
        INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;RRR", "" );
        INPAapiCheckJobStatus( "OKAY" );

        INPAapiResultInt( int_var, "STAT_PRUEFUNG_LAEUFT_NR", 1);
        
        // Prüfung läuft, erneuter Start nicht möglich
        if(int_var == 0x01)
        {
          infobox ( "Prüfung läuft", "Nochmaliger Start nicht möglich!" );
          userboxclose( 0 );
          viewclose();
          setscreen( s_rk_verbau_steuern, TRUE );
        }
      }
      toggle_1 = 0;
    }

    if ( toggle_2 == 1 )
    {
      INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;STPR", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

      if ( chk_jobstatus == "OKAY" )
      {
      }
      else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT" )
      {
        // nachsehen, ob Prüfung nicht läuft
        INPAapiJob( sgbd, "STEUERN_ROUTINE", "ARG;VDC_VERBAUKENNUNG;RRR", "" );
        INPAapiCheckJobStatus( "OKAY" );

        INPAapiResultInt( int_var, "STAT_PRUEFUNG_LAEUFT_NR", 1);
        
        // Prüfung läuft nicht, erneuter Stopp nicht möglich
        if(int_var == 0x00)
        {
          infobox ( "Prüfung läuft nicht", "Nochmaliger Stopp nicht möglich!" );
          userboxclose( 0 );
          viewclose();
          setscreen( s_rk_verbau_steuern, TRUE );
        }
      }
      toggle_2 = 0;
    }
  }
}



// -- EOF --
