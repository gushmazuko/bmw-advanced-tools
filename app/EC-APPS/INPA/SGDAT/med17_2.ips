//**********************************************************************
//*
//* Nacharbeitssource für INPA
//*
//* Sourcedatei MED17_2.SRC
//*
//**********************************************************************
//* History         :
//* 06.12.2004 jm V0.01 Ersterstellung Grundumfang
//* 23.08.2005 as V0.11 Statusjobs Analog/Digital integriert
//* 30.08.2005 as V0.20 Adaptionen löschen eingefügt
//* 13.03.2006 as V.061 Geberradadaption sowie STATUS_ADD auskommentiert (kommen wieder rein, sobald verfügbar)
//* 21.04.2006 au V2.00 Steuernjobs E_LUEFTER, EKP, EML, MIL, DMTLP, DMTLH, DMTLV, DK im Menü "Ansteuern" eingefügt
//*                     Systemchecks DMTL, TEV, GRUNDADAP, IGR sowie STATUS_LMM_MASSE auskommentiert (kommen wieder rein, sobald verfügbar)
//* 11.05.2006 asc V4.00 Analogwerte 1-3 werden jetzt aus MESSWERTBLOCK ausgelesen
//* 26.05.2006 asc V4.01 MSA Jobs eingefügt
//* 02.06.2006 asc V4.02 Delay bei MSA_Stat
//* 29.06.2006 asc V4.03 Lambda regulation values changed, systemchecks DMTL,IGR and Grundadaption integrated, air mass values adapted and jobs for 2 stage fan inserted
//* 03.07.2006 asc V7.00 STATUS_FGR raus, Bugfix Lambda regulation values
//* 13.07.2006 asc V7.01 Randbedingungen bei msa_lern werden nicht mehr geprüft
//* 21.07.2006 asc V7.02 TEV Check aktiviert; Expertenmenü Fehlerort hinzu
//* 29.08.2006 asc V7.10 diverse Stellgliedansteuerungen hinzugefügt
//* 30.08.2006 asc V7.11 Bugfix MSA; MSA DEAK AV hinzugefügt; Bitbeschreibung wie E8x-07-03-I4.50
//* 06.10.2006 au  V11.00 SGBD MED17_2N hinzugefügt
//* 12.10.2006 asc V11.01 englische Texte korrigiert
//* 03.11.2006 asc V11.02 Überlauf bei Verarbeitung von long-Variablen behoben;Toleranzbereich bei msa_lern angepasst
//* 08.11.2006 asc V11.03 Anpassung der Bitbeschreibung (wie E8x-07-03-I4.50)
//* 01.12.2006 asc V11.10 MSA Bitzuordnung aktualisiert, Anzeige gruppiert
//* 26.01.2007 asc V11.11 Bugfix bei DEAK_AV
//* 31.01.2007 asc V11.12 PM-IBS Jobs hinzu
//* 07.03.2007 asc V11.13 Status Readiness hinzu
//* 06.02.2008 ib  V12.00 Implementiert: F3: Inpa-Wechsel, Shift+F2: Sensoren Ident, Shift+F9: Drucken Sensor Ident, F7: FeTraFla, F8: Funktionen, Anzeige: Aktueller INPA-Scriptname, (benötigt Package 4.0!)
//* 17.03.2008 ib         F2: SVK Lesen: SERIENNUMMER_LESEN dazu, Shift+F6: STEUERGERAETE RESET (benötigt Package 4.01!)
//* 14.05.2008 ib  V12.01 Anpassen Zylinderreihenfolge an logische Reihenfolge
//* 26.06.2008 ib  V12.10 Anpassen Systemcheck DMTL
//* 20.08.2008 ib  V12.20 Hinzufügen neuer Messwerte
//* 20.08.2008 ib  V12.21 weitere Englischtexte
//**********************************************************************
#include "inpa.h"
#include "BMW_STD.H"

// Titel, Version, Verantwortung, Steuergerät
string titel  ="MED17_2";                                               // Titel Nacharbeitsprogramm
string version="12.21";                                                  // Version Nacharbeitsprogramm
string origin ="BMW TI-431 Unverdorben";                                       // Verantwortung Nacharbeitsprogramm
string sgbd   ="MED17_2,MED17_2N";                                      // Steuergerät
string gruppe ="D_MOTOR";                                              // Gruppendatei

string inpa   ="MED17_2";                                              // INPA-Scriptname ohne Endung "IPO" muß eingetragen werden. Notwendig für INPA-Rücksprung vom letzt aufgerufenem INPA-Script
                                                                        // Optional können Sie "MENU m_scriptwechsel()" und "SCREEN s_scriptwechsel()" befüllen.

string speicher_lesen_parameter="LAR;FLASH;UIFM;-ROMI;-ROMX;-RAMIS;-RAMIL;-RAMXX;-NVRAM";
// Mögliche Speicher-Parameter: "LAR;FLASH;UIFM;ROMI;ROMX;RAMIS;RAMIL;RAMXX;NVRAM";
// Bei Leerstring erfolgt kein Menüpunkt Speicher Lesen

// allgemeine globale Variable
string text_var;
real   zahlen_var;
int    ganz_zahl;
bool   logik_var;
string job_state;    // JOB_STATUS Variable
int    input_state;  // Eingabestatus
int    input_ok=0;   // Eingabe  mit OK beendet
int 	 ll_wert=700;			// Eingestellter Wert für Leerlauf
int    taste;
string blank="                                                                                                                                                                                                                           ";


bool msa_deak_var; // Status der MSA; TRUE: MSA deaktiviert!
bool randbed;
int i = 0;
long   longval;
long vergleich_var = 1;
long stelle;
string fort_hex="";
int timeout=20;
int tast=50;

// start of :#include "BMW_STD.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BMW_STD.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.05.2000 rd V0.01 Ersterstellung
//* 23.06.2000 rd V0.02 Überarbeitung für E65 und E85
//* 04.07.2000 rd V0.03 Überarbeitung der Funktionen
//* 08.11.2000 rd V0.04 AIF Lesen Results überarbeitet
//* 01.03.2001 rd V0.05 m_status_flag neu hinzu
//* 02.03.2001 rd V0.06 m_steuern_flag neu hinzu
//* 18.05.2001 rd V0.07 AIF-Ausgabe verbessert
//* 25.04.2002 rd V0.08 Erweiterung HS_LESEN
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Erweiterung Ident für DS2
//* 19.11.2002 rd V1.02 FS_MODE erweitert um PCODEs
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//*            rd V2.00 Entfernung EldiAuftragLesen, EldiAuftragEingeben
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Hinweis im Hauptfenster, wenn Simulationsmodus aktiv ist.
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//*            GA V3.01 FS-, IS_ und HS_LESEN werden jetzt in eigenen Dateien abgelegt. Immer unter ..\INPA\BIN auch wenn *.IPO direkt gestartet wird.
//* 28.01.2008 GA V4.00 Hauptmenü um F3 erweitert: Scriptwechsel, F7: FeTraWe, FeTraFla, F8: Funktionen, F12: Sensoren (ab F01)
//* 17.02.2008 GA V4.00 F1: Info: Angabe des Inpascriptdateinamens, alle Dateinamen werden mit Endungen ausgegeben.
//* 14.03.2008 GA V4.01 Automatische Inpascriptnamen und Pfad zu SGDAT ermitteln -> neu INPAINFO, hier scriptwechsel_flag auf "TRUE" geändert.
//*            GA V4.01 SERIENNUMMER_LESEN unter F2: SVK dazu, STEUERGERAETE_RESET unter Shift+F6 dazu
//* 03.04.2008 GA V4.02 Sonderlösung für DSC_01 um SG in Fertigungsmodus zu setzen : zuvor muß DIAGNOSE_MODE mit Parameter: ECUEXTDIAG gesendet werden.
//*            GA V4.02 m_main(): Ident-Aufruf in Line..If() gezogen, da nach SG_RESET Ident nicht immer aufgerufen wurde.
//* 04.04.2008 GA V4.03 Für EA: entwicklungsscript_flag, sgbd_name_motor, motor_master_flag dazu, Simulationsfenster wird oben angezeigt, um alle Funktionen lesen zu können.
//* 04.04.2008 GA V4.03 "Aktuelles INPA" in s_svk_lesen nachgezogen, SENSORID.SRC: SENSOR_BMW_NR wurde nicht ausgegeben, Steuergerätinformation dazu
//* 04.04.2008 GA V4.03 airbag_is_loeschen_hinweis_flag dazu
//**********************************************************************
string package="4.03";

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************

// Umrechnungsfaktoren deutsch / englisch
real   m_c    = 1.0;        // Grad Celsius -> Fahrenheit z = x * m_c + a_c
real   a_c    = 0.0;
real   m_km   = 1.0;     // km           -> miles      z = x * m_km
real   m_l    = 1.0;     // Liter        -> Gallon US  z = x * m_l

// für Info
string sgbd_ecu;
string sgbd_origin;
string sgbd_revision;
string sgbd_package;
string sgbd_sprache;
string sgbd_comment;
string gruppe_ecu;
string gruppe_origin;
string gruppe_revision;
string gruppe_comment;

// für Status-Menü
bool   m_status_flag=TRUE;
// True Status-Menü wird angezeigt

// für Steuern-Menü
bool   m_steuern_flag=TRUE;
// True Steuern-Menü wird angezeigt

// für FS_LESEN speichern
bool   fs_lesen_save_as_flag;

// für IS_LESEN speichern
bool   is_lesen_save_as_flag;

// für HS_LESEN speichern
bool   hs_lesen_save_as_flag;

// für FS_LESEN
bool   fs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LESEN
bool   is_lesen_flag;
// True wenn JOB vorhanden

// für HS_LESEN
bool   hs_lesen_flag;
// True wenn JOB vorhanden

// für SENSOR_IDENT_LESEN
bool   sensoren_ident_lesen_save_as_flag;

// für IS_LOESCHEN
bool   is_loeschen_flag;
// True wenn JOB vorhanden

// für HS_LOESCHEN
bool   hs_loeschen_flag;
// True wenn JOB vorhanden

// Handle für FS_LESEN
int    f_ort_nr_buffer   = 0;
int    f_ort_text_buffer = 0;

//  In INPA.INI wird festgelegt ob
//   nach FS- IS-, HS-Löschen automatisch wieder gelesen wird.
bool   deleteread_flag;

// für Scriptwechsel
bool   scriptwechsel_flag      = TRUE; //F2: Standardmäßig nicht immer möglich, muß im Script aktiviert werden.
                                       //    Als Rücksprung dienen fest definierte oder zumindest das letzt aufgerufene.
string ipo_pfad;                       //Pfad zur INPA-Script *.IPO
string inpa_ermittelt;                 //INPA-Name über GetCommandLine ermtittelt, stimmt aber nur beim Erststart von INPA.
string letztes_inpa;                   //    Zuletzt aufgerufenes INPA-Script
string letzte_gruppe;
string scriptwechsel_error     = "error reading inpa.ini";

bool   entwicklungsscript_flag = FALSE;//Sonderflag z.B. für EA, es werden nur Entwicklungsumfänge bei TRUE freigeschaltet.
                                       //EA: Dieses Flag NICHT im INPA-Script aufnehmen. EA muß es in seinen Includes auf TRUE stellen!
string sgbd_name_motor         = "";   //Sonderfall: Bei 12 Zylindermotoren ab F01 müssen beide SGs gleichzeitig den Fehlerspeicher bzw. Infospeicher löschen.
                                       //            Diese variable muß im INPA-Script (ScriptInit()) gesetzt werden.
                                       //            Im INPA-Mastersteuergerät z.B.: sgbd_name_motor= "MSD87_L0"
                                       //            Im INPA-Slavesteuergerät z.B.: sgbd_name_motor= "MSD87_R0"
bool   motor_master_flag       = TRUE; //Um bei Fehlern im INPA-Master- und -Slave-Script das jeweils das andere SG richtig zu benennen.
                                       //    Im Master: motor_master_flag=TRUE, im Slave: motor_master_flag= FALSE angeben.

bool   airbag_is_loeschen_hinweis_flag = FALSE; //Sonderflag für Airbag: Hinweis bringen, wenn Jobstatus 0x33. IS kann nur einmal gelöscht werden!
bool   set_sg_information_flag = FALSE;//Shift+F3: Standardmäßig nicht immer möglich, muß im Script aktiviert werden.
                                       //          Im Script können Steuergeräte spezifische Information angezeigt werden, die im Umgamg mit dem SG notwendig/hilfreich sind.
string sg_information_titel    = "";   //          Titel des Steuergerätes, z.B.: Motor, Getriebe, ACSM etc.

bool   fetrafla_flag;                  //F7: Wird automatisch gesetzt, wenn der Job vorhanden ist. Ist ab F01 auslesbar.
bool   fetrawe_flag;                   //    Bis F01 auslesbar.
bool   set_extendedSession_flag= FALSE;//    DSC: Um  Fertigungsmodus einzuschalten, muß zuvor der DIAGNOSE_MODE mit Parameter: ECUEXTDIAG gesendet werden. In INPA auf TRUE setzen, falls benötigt.
bool   set_normalmodus_flag    = TRUE; //    Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
bool   set_fertigungsmodus_flag= TRUE; //    Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
bool   set_transportmodus_flag = TRUE; //    Darf laut VS nicht bei I-Bus Steuergeräten gesetzt werden! Muß im INPA-Script deaktiviert werden.

bool   funktionen_flag;                //F8: Steuergeräte übergreifende Stati oder Steuerfunktionen
bool   sensoren_ident_lesen_flag;      //Shift+F2: Wird automatisch gesetzt, wenn der Job SENSOREN_IDENT_LESEN existiert. Ab F01.
bool   steuergeraete_reset_flag= FALSE;         //Shift+F6: Wird automatisch gesetzt, wenn der Job SENSOREN_IDENT_LESEN existiert. Ab F01.
bool   steuergeraete_reset_warnung_flag = TRUE; //   Nicht alle Steuergeräte verursachen bei einem Reset Fehlerspeichereinträge in anderen SGs. (Bsp.: EMA_LI/RE)

// Wenn Ediabas im Simulationsmode läuft, dies im Hauptfenster anzeigen.
bool   simulation_flag;

// für Ident Screen, bzw. SVK Screen bei UDS (ISO 14229)
int    ident_typ;
// 1= DS2
// 2= BMW Fast
// 3= UDS (ISO 14229)


// für SPEICHER_LESEN
bool   speicher_lesen_flag;
// True wenn JOB vorhanden
bool   speicher_lesen_lar_flag;
bool   speicher_lesen_uifm_flag;
bool   speicher_lesen_romi_flag;
bool   speicher_lesen_romx_flag;
bool   speicher_lesen_nvram_flag;
bool   speicher_lesen_ramis_flag;
bool   speicher_lesen_ramxx_flag;
bool   speicher_lesen_flash_flag;
bool   speicher_lesen_ramil_flag;

// für Speicher lesen Ausgabe
string speicher_lesen_text         = "";
string speicher_lesen_seg_adr_anz  = "";
string speicher_lesen_adresse      = "0x000000";
int    speicher_lesen_anzahl       = 64;

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern ScriptInit(); // befindet sich im Hauptprogramm
extern sensoren_ident_lesen(in: string FileName);

// start of :#include "BATTERIE.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BATTERIE.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 01.04.2004 rd V2.01 Im Fehlerfalle delay eingebaut
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* ShowBatteryIgnition
//*
//* Anzeige des Batterie- und Zündungs-Status
//*
//**********************************************************************
ShowBatteryIgnition()
{
  bool   fehlerflag;    // Fehler aufgetreten
  bool   fehlerflag2;   // Fehler aufgetreten
  bool   zuendung;      // Zündung ein/aus
  bool   batterie;      // Batterie ein/aus
  int    wert;          // allgemeine Variable

  ftextout("Batterie :", 0,5,1,0);
  ftextout("Zündung  :", 0,45,1,0);

  INPAapiJob("UTILITY","STATUS_UBATT","","");
  INP1apiResultInt(fehlerflag,wert,"STAT_UBATT",1);
  if ((fehlerflag!=TRUE) || (wert==0))
  {
    batterie=FALSE;
    zuendung=FALSE;
  }
  else
  {
    batterie=TRUE;
    INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
    INP1apiResultInt(fehlerflag2,wert,"STAT_ZUENDUNG",1);
    if ((fehlerflag2!=TRUE) || (wert==0))
      zuendung=FALSE;
    else
      zuendung=TRUE;
  }
  digitalout(batterie, 0,20,"","");
  if (batterie==TRUE)
    ftextout("ein  ", 0,25,1,0);
  else
  {
    if (fehlerflag==TRUE)
    {
      ftextout("aus  ", 0,25,1,0);
    }
    else
    {
      ftextout("---  ", 0,25,1,0);
    }
  }

  digitalout(zuendung, 0,62,"","");
  if (zuendung==TRUE)
    ftextout("ein  ", 0,67,1,0);
  else
  {
    if (fehlerflag2==TRUE)
    {
      ftextout("aus  ", 0,67,1,0);
    }
    else
    {
      ftextout("---  ", 0,67,1,0);
    }
  }

  if ((fehlerflag!=TRUE) || (fehlerflag2!=TRUE))
  {
    delay(2000);
  }
}
// -- EOF --
// end of :#include "BATTERIE.SRC"
// start of :#include "INPAINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INPAINFO.SRC
//*
//* Extrahiert: Pfadangabe zu SGDAT und der INPA-Scriptname ohne Endung in globale Variablen
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 15.03.2008 GA V4.00 Ersterstellung
//**********************************************************************
//***********************
//* InpaInfos_ermitteln *
//***********************
InpaInfos_ermitteln()
{
  string CurDir;                   //Aktuelle Pfadangabe
  int    ret_int;
  string temp;
  int    anzahl;                   //Anzahl Zeichen die zu kopieren sind
  int    pos;
  int    von;
  int    i=0;
  int    k=0;
  int    len;
  int    lenInpa;
  string sucheHKomma;
  string sucheBackslash;

  chr( 34, sucheHKomma ); // '"'
  GetCommandLine(temp);
  trimstr(temp);//Bei Standardaufruf steht am Ende ein Leezeichen.
  //mögliche Fälle:
  //temp= sucheHKomma+"C:\INPA\BIN\INPALOAD.exe"+sucheHKomma+" C:\INPA\SGDAT\CID_01.IPO";
  //temp= sucheHKomma+"C:\INPA\BIN\INPALOAD.exe"+sucheHKomma+" "+sucheHKomma+"C:\INPA\SGDAT\CID_01.IPO"+sucheHKomma;
  //temp= "C:\INPA\BIN\INPALOAD.exe C:\INPA\SGDAT\CID_01.IPO";
  //Bsp. 1 temp: '"C:\INPA\BIN\INPALOAD.exe" C:\INPA\SGDAT\CID_01.IPO'
  //Bsp. 2 temp: '"C:\INPA\BIN\INPALOAD.exe" "C:\INPA\SGDAT\CID_01.IPO"'
  //                           suche nach '" '
  instr(pos,0,temp,sucheHKomma+" ");
  strlen(len,temp);

  if (pos == -1) //'" ' nicht im String enthalten, tritt im Standardfall auf (Start über INPALOAD.EXE, Auswahl....)
  {
     anzahl= len-18; //BIN\INPALOAD.EXE" abziehen
     midstr(ipo_pfad,temp,1,anzahl);
     ipo_pfad= ipo_pfad+"SGDAT";
  }
  else//'" ' gefunden
  {
    midstr(CurDir,temp,pos+2,len-pos);     //alles nach '...LOAD.exe" ' kopieren
    strlen(len,CurDir);
    instr(pos,0,CurDir,sucheHKomma);

    if (pos == -1)                         //(Bsp. 1) '"' nicht in der Pfadangabe von SGDAT enthalten
    {
      midstr(CurDir,CurDir,0,len-pos);     //Pfad kopieren
    }
    else                                   //(Bsp. 2) '"' in Pfadangabe enthalten
    {
      pos= pos+1;
      anzahl= len-pos-1;
      midstr(CurDir,CurDir,pos,anzahl);    //nach Pfad ohne '"' kopieren
    }
    strlen(len,CurDir);

    chr( 92, sucheBackslash ); // '\'
    i= 0;
    k= 0;
    while (k != -1)
    {
      instr(k,i,CurDir,sucheBackslash);
      if (k != -1)
       anzahl= k;
      i= i+1;
    }

    //Pfad bis SGDAT
    midstr(ipo_pfad,CurDir,0,anzahl);//Pfad z.B.: C:\INPA\SGDAT

    //INPA-Scriptname ohne Endung #.IPO'
    von= anzahl+1;
    strlen(lenInpa, ipo_pfad);
    anzahl= len-von-4;                           //ohne Endung: '.IPO'
    midstr(inpa_ermittelt,CurDir,von,anzahl);    //Inpa-Script z.B.: CID_01, ist aber obsolete, da Windows nur bei Erstart das richtige Script angibt.

    //Nur für Analysezwecke in INPA.INI ablegen.
    WritePrivateProfileString("EXTRA","PfadzuIPO",ipo_pfad,"..\cfgdat\inpa.ini",logik_var);//logik_var == FALSE, wenn Fehler
  }
}
// -- EOF --
// end of :#include "INPAINFO.SRC"
// start of :#include "GRP_INFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GRP_INFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 EDIABAS.INI-Abfrage ob Simulationsmode aktiv ist
//* 18.10.2006 GA V3.01 Abfrage ob EDIABAS im Simulationsmodus läuft ist jetzt nicht mehr auf Pfad c:\windows\ediabas.ini beschränkt
//**********************************************************************

//**********************************************************************
//*
//* GruppenDateiInfo
//*
//* Versionsinformationen über Gruppendatei
//*
//**********************************************************************
import32 "C" lib "api32.DLL::__apiGetConfig" ApiGetConfig(in:long Handle,in: string Name,out: string Buffer, returns: int ReturnedValue);
GruppenDateiInfo( in: string grp,
                  inout: string grp_ecu, inout: string grp_origin,
                  inout: string grp_revision, inout: string grp_comment)
{
  string CurDir;
  string Temp;
  string Puffer;
  int    Size;
  long   PufferSize;
  int    ret_int;
  string BS;
  string CR;
  int    pos1;
  int    pos2;
  int    simulation;
  int    input;
  long   Handle;
  int    Returned;
  string ini_path= "??????????????????????";//Variable muß ausreichend lang vorbelegt sein!
  //                C:\ec-apps\ediabas\bin

  chr( 92, BS ); // '\'
  chr( 13, CR );

  // Pfad für EDIBAS.INI ermitteln
  // WERT 2 wurde durch Tests ermittelt
  Handle=2;
  ApiGetConfig(Handle,"EDIABASINIPATH",ini_path,Returned);
  //Abfrage, ob EDIABAS im Simulationsmodus betrieben wird. Hinweisfenster erfolgt im Hauptfenster s_main
  GetPrivateProfileInt("Configuration","Simulation",2,ini_path+BS+"ediabas.ini",simulation);
  if (simulation == 1) simulation_flag= TRUE;
  else simulation_flag= FALSE;

  Size=256;
  space(CurDir,Size);
  GetCurrentDirectory(256, CurDir, ret_int);
  SetCurrentDirectory("\EDIABAS\BIN", ret_int);

  Size=1024;
  space(Puffer,Size);
  inttolong(Size, PufferSize);
  XTRACT("\ediabas\ecu"+ BS + grp + ".grp", 1, Puffer, PufferSize, ret_int);

  grp_ecu="";
  instr(pos1, 0, Puffer, "ECU:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 4;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_ecu, Puffer, pos1, pos2 - pos1);
  }

  grp_origin="";
  instr(pos1, 0, Puffer, "ORIGIN:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 7;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_origin, Puffer, pos1, pos2 - pos1);
  }

  grp_revision="";
  instr(pos1, 0, Puffer, "REVISION:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 9;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
    midstr(grp_revision, Puffer, pos1, pos2 - pos1);
  }

  grp_comment="";
  pos1=0;
  pos2=0;
  while ((pos1 >= 0) && (pos2 >= 0))
  {
    instr(pos1, pos2, Puffer, "ECUCOMMENT:");
    if (pos1 >= 0)
    {
      pos1 = pos1 + 11;
      instr(pos2, pos1, Puffer, CR );
      if (pos2 > pos1)
      {
        midstr(Temp, Puffer, pos1, pos2 - pos1);
        grp_comment=grp_comment+Temp+",";
      }
    }
  }
  SetCurrentDirectory(CurDir, ret_int);
}
// -- EOF --
// end of :#include "GRP_INFO.SRC"
// start of :#include "SGBDINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SGBDINFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern SgbdInfo(in: string sg,
                inout: string sg_ecu, inout: string sg_origin,
                inout: string sg_revision, inout: string sg_package,
                inout: string sg_comment, inout: string sg_sprache);

//**********************************************************************
//*
//* SgbdInfo
//*
//* Versionsinformationen über SGBD
//*
//**********************************************************************
SgbdInfo( in: string sg,
          inout: string sg_ecu, inout: string sg_origin,
          inout: string sg_revision, inout: string sg_package,
          inout: string sg_comment, inout: string sg_sprache)
{
  INPAapiJob(sg,"INFO","","");
  INPAapiResultText(sg_ecu,"ECU",1,"");
  INPAapiResultText(sg_revision,"REVISION",1,"");
  INPAapiResultText(sg_package,"PACKAGE",1,"");
  INPAapiResultText(sg_origin,"ORIGIN",1,"");
  INPAapiResultText(sg_comment,"COMMENT",1,"");
  INPAapiResultText(sg_sprache,"SPRACHE",1,"");
}

// -- EOF --
// end of :#include "SGBDINFO.SRC"
// start of :#include "SGBDINPA.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SgbdInpa.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Gezielte Ausgabe, wenn Gruppendatei oder SGBD nicht existiert
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 18.10.2006 GA V3.01 Check bezüglich auf Gruppen-Simulationsdatei, sowie "Identification error" erweitert
//* 24.10.2006 GA V3.02 Überprüfung ob T_GRTB.PRG vorhanden eingebaut
//* 17.02.2007 GA V4.00 Gruppendateiüberprüfung von d bzw. D auf d_ bzw. D_ erweitert
//**********************************************************************

//**********************************************************************
//*
//* SgbdInpaCheck
//*
//* Überprüfung ob SGBD zu INPA passt
//*
//**********************************************************************
SgbdInpaCheck()
{
  string sgbd_version;             // für Versionskontrolle
  string inpa_version;             // für Versionskontrolle
  string inpa_sprache="deutsch"; // für Sprachvariante
  string variante="???";           // für Variantenkontrolle
  string err_text;                 // Fehlertext
  int    errorcode;                // Errorcode
  bool   fehlerflag;               // Fehlerflag
  string temp;
  string temp1;
  string temp2;
  int    i;
  int    k;
  int    kk;                       // für neue VersionsnummernKontrolle
  int    ii;
  int    a;
  int    aa;
  int    i1;
  int    i2;
  int    i3;                       // für neue VersionsnummernKontrolle
  string sgbd_String_Lang;
  string sgbd_von_inpa_version;
  string ver_temp;
  string ver_temp1;
  string ver_temp2;
  string ver_temp3="--";
  real   Version_SGBD;
  real   Version_INPA;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  int    ret_int;
  int    Size;
  int    filecheck;
  string hinweis_text;

  settitle(titel+" Version "+version);
  a=0;
  ii=0;
  i3=0;
  kk=0;
  aa=0;
  i=0;
  k=0;
  fehlerflag=FALSE;
  temp1="";
  temp2="";

  instr(i,k,","+gruppe+",",",");
  while ((i >= 0) && (fehlerflag == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppe+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppe+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(fehlerflag,variante,"VARIANTE",0,"");
      if (fehlerflag == TRUE) gruppe=temp;
      else
      {
        INP1apiErrorCode(errorcode);
        if (errorcode == 36)//Fehlende oder fehlerhafte Simulationsdatei
        {
           Size=256;
           space(CurDir,Size);
           GetCurrentDirectory(256, CurDir, ret_int);
           SetCurrentDirectory("\EDIABAS\SIM", ret_int);
           fileexist(temp+".SIM",filecheck);
           SetCurrentDirectory(CurDir, ret_int);
           if (filecheck == 0)
           {
             temp1= temp1+", "+temp+".SIM";//Fehlerhafte Simulationsdatei
           }
           else
           {
             temp2= temp2+", "+temp+".SIM";//Fehlende Simulationsdatei
           }
        }
      }
    }
  }

  instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
  instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
  if ((i == 0) || (k == 0))
       hinweis_text= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
  else hinweis_text= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an

  if (fehlerflag == FALSE)
  {
     //Fehlende oder fehlerhafte Gruppen-Simulationsdatei
     if (errorcode == 36)
     {
        //Fehlerhafte Simulationsdatei
        if (temp1 != "")
        {
          strlen(k,temp1);
          instr(i,k,temp1+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp1+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp1,temp1,1,k);//Kommata vor und hinter temp1 ausschneiden
          temp1= "Fehlerhafte Simulationsdatei: "+temp1+CRLF;
        }
        //Fehlende Simulationsdatei
        if (temp2 != "")
        {
          strlen(k,temp2);
          instr(i,k,temp2+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp2+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp2,temp2,1,k);//Kommata vor und hinter temp2 ausschneiden
          temp2= "Fehlende Simulationsdatei  : "+temp2+CRLF;
        }

        messagebox("Variantenkontrolle",
                   "Fehler!"+CRLF+
                   temp1+//Fehlerfafte Gruppen-Simulationsdateien
                   temp2+//Fehlende     -//-
                   "Das Programm wird abgebrochen!");
        exit();
     }

     //Gruppendatei vorhanden?
     Size=256;
     space(CurDir,Size);
     GetCurrentDirectory(256, CurDir, ret_int);
     SetCurrentDirectory("\EDIABAS\ECU", ret_int);
     fileexist(gruppe+".GRP",filecheck);
     SetCurrentDirectory(CurDir, ret_int);
     if (filecheck == 0)//Gruppendatei vorhanden, SGBD-, Kommunikationsfehler hier ausgeben
     {
       INP1apiErrorText(err_text);//Fehler beim Aufruf der VARIANTE?
       if (errorcode == 92)//92=SYS-0002: SG-Variantenbeschreibungsdatei (SGBD) nicht gefunden
       {
         //T_GRTB.PRG vorhanden?
         Size=256;
         space(CurDir,Size);
         GetCurrentDirectory(256, CurDir, ret_int);
         SetCurrentDirectory("\EDIABAS\ECU", ret_int);
         fileexist("T_GRTB.PRG",filecheck);
         SetCurrentDirectory(CurDir, ret_int);
         if (filecheck == 0)//T_GRTB.PRG ist vorhanden, somit fehlt die SGBD.
         {
           messagebox("Variantenkontrolle",
                      "Fehler!"+CRLF+
                      err_text+". "+CRLF+
                      " "+CRLF+
                      "Das Steuergerät läßt sich zwar über die Gruppendatei: "+gruppe+".GRP"+" ansprechen,"+CRLF+
                      "aber zur Diagnose fehlt eine entsprechende SGBD (*.PRG) im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                      " "+CRLF+
                      "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                      " "+CRLF+
                      "Das Programm wird abgebrochen!");
         }
         else//T_GRTB.PRG fehlt
         {
           messagebox("Variantenkontrolle",
                     "Fehler!"+CRLF+
                     err_text+". "+CRLF+
                     " "+CRLF+
                     "Die Datei T_GRTB.PRG fehlt im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                     " "+CRLF+
                     "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                     " "+CRLF+
                     "Das Programm wird abgebrochen!");
         }
       }
       else if (errorcode == 102)//102= Identification error
       {
         instr(i,0,gruppe,"d_");//erstes Zeichen ein 'd'?
         instr(k,0,gruppe,"D_");//erstes Zeichen ein 'D'?
         if ((i == 0) || (k == 0))
              temp1= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
         else temp1= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                    hinweis_text+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
       else //alle anderen Fehler
       {
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    " "+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
     }
     else//Gruppendatei nicht vorhanden
     {
        messagebox("Variantenkontrolle",
        "Fehler! Gruppendatei : "+gruppe+".GRP "+CRLF+
        "existiert nicht im Verzeichnis ..\EDIABAS\ECU"+CRLF+
        " "+CRLF+
        "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
        " "+CRLF+
        "Das Programm wird abgebrochen!");
     }
     exit();
  }

  i1=0;
  i2=0;
  instr(i1,0,","+sgbd+",",","+variante+",");
  if (i1 < 0)
  {
    instr(i2,0,","+sgbd+",",","+variante+"/");
    if (i2 < 0)
    {
      messagebox("Variantenkontrolle",
                 "Gesuchtes Steuergerät: '"+sgbd+"' nicht gefunden. "+CRLF+
                 "Gefundenes Steuergerät: '"+variante+"'. "+CRLF+
                 " "+CRLF+
                 "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                 hinweis_text+CRLF+
                 " "+CRLF+
                 "Das Programm wird abgebrochen!");
      exit();
    }

    ver_temp3 = "--";
    instr(ii,i2,sgbd+",",",");
    if (ii >= 0)
    {
      midstr(ver_temp3,sgbd+",",i2,ii);
      instr(i3,0,ver_temp3,"/");
      if (i3 >= 0)
      {
        a = i2+i3+1;
        aa = ii-i2+i3-1;
        midstr(ver_temp3,sgbd+",",a,aa);
      }
    }
  }

  sgbd_String_Lang = sgbd;
  sgbd=variante;

//
// Info: Informatinon bei aufruf ohne BMW_STD.SRC
//
// ####################################################
// # //für Info                                       #
// #   string sgbd_ecu;                               #
// #   string sgbd_origin;                            #
// #   string sgbd_revision;                          #
// #   string sgbd_package;                           #
// #   string sgbd_sprache;                           #
// #   string sgbd_comment;                           #
// #   string gruppe_ecu;                             #
// #   string gruppe_origin;                          #
// #   string gruppe_revision;                        #
// #   string gruppe_comment;                         #
// #                                                  #
// #   #include "SgbdInfo.src"                        #
// ####################################################
//
//
  SgbdInfo(sgbd, sgbd_ecu, sgbd_origin, sgbd_revision, sgbd_package, sgbd_comment, sgbd_sprache);
// Bitte VARIABLEN als Globale variable aktivieren und Include (siehe Block //INFO)
//
//

  //Versionskontrolle Auf 3 stellen vor / hinter dem "."
  instr(i3,0,ver_temp3,"V");
  if(i3>=0)
  {
    instr(i2,0,ver_temp3,",");
    midstr(ver_temp3,ver_temp3,i3+1,i2-1);
    stringtoreal(ver_temp3,Version_INPA);
    realtostring(Version_INPA,"3.3",ver_temp3);
    midstr(sgbd_von_inpa_version,ver_temp3,0,2);
  }
  stringtoreal(version,Version_INPA);
  realtostring(Version_INPA,"3.3",version);
  midstr(inpa_version,version,0,2);

  stringtoreal(sgbd_revision,Version_SGBD);
  realtostring(Version_SGBD,"3.3",sgbd_revision);
  midstr(sgbd_version,sgbd_revision,0,2);

  temp=inpa_version;
  temp1=sgbd_version;

  if (ver_temp3 == "--")
  {
    // Vergleichen mit Versionsnummer INPA & SGBD
    if (inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!");
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }
  else
  {
    // Vergleichen mit Versionsnummer INPA(SGBD Vorwahl) & SGBD
    if (sgbd_von_inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!"+CRLF+CRLF+
                 "SGBD Version: "+ ver_temp3 +" (in INPA) "+CRLF+
                 "SGBD Version: "+ sgbd_revision +CRLF+
                 "INPA Version: "+ version);
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }

  if (inpa_sprache != sgbd_sprache)
  {
    messagebox("Sprachvariantenkontrolle",
               "Nicht zusammenpassende Sprachvariante. "+CRLF+
               "Fehlfunktion ist möglich!");
  }
}

// -- EOF --
// end of :#include "SGBDINPA.SRC"
// start of :#include "GRPCHECK.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GrpCheck.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//* 20.04.2007 GA V3.02 FS-, IS-, HS_LESEN werden in einzelnen Tempdateien in ..\EDIABAS\BIN abgelegt
//* 28.01.2008 GA V4.00 Hauptmenü um Sensoren Ident und FeTraFla erweitert. Hier wird das Flag gesetzt.
//* 13.03.2008 GA V4.01 'if (inpa != "") scriptwechsel_flag= TRUE;' entfernt
//*            GA V4.01 Hauptmenü um STEUERGERAETE_RESET erweitert
//**********************************************************************

//**********************************************************************
//*
//* GroupCheck
//*
//* Überprüfung der Gruppen-Info
//*
//**********************************************************************
GroupCheck()
{
  string err_text;                 // Fehlertext
  bool   fehlerflag;               // Fehlerflag
  string temp;
  int    sgbd_saetze;              // für Funktionen-Suche in SGBD
  string job_name;                 // JOBNMAE in SGBD
  int    i;
  int    pos1;
  int    pos2;

  fehlerflag=FALSE;
  i=0;

  GruppenDateiInfo(gruppe, gruppe_ecu, gruppe_origin, gruppe_revision, gruppe_comment);

  // Vorbelegung der Flags
  fs_lesen_flag             = FALSE;
  is_lesen_flag             = FALSE;
  speicher_lesen_flag       = FALSE;
  is_loeschen_flag          = FALSE;
  hs_loeschen_flag          = FALSE;
  fetrafla_flag             = FALSE;
  sensoren_ident_lesen_flag = FALSE;
  steuergeraete_reset_flag  = FALSE;

  INPAapiJob(sgbd,"_JOBS","","");

  INP1apiResultSets(fehlerflag, sgbd_saetze);
  if (fehlerflag == FALSE)
  {
    INP1apiErrorText(err_text);
    messagebox("Unerwarteter Fehler", // sollte nie kommen
                err_text+". "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }
  i = 1;
  while ( i <= sgbd_saetze)
  {
    INPAapiResultText(job_name,"JOBNAME",i,"");
    if (job_name == "FS_LESEN" )               fs_lesen_flag             = TRUE;
    if (job_name == "IS_LESEN" )               is_lesen_flag             = TRUE;
    if (job_name == "HS_LESEN" )               hs_lesen_flag             = TRUE;
    if (job_name == "IS_LOESCHEN" )            is_loeschen_flag          = TRUE;
    if (job_name == "HS_LOESCHEN" )            hs_loeschen_flag          = TRUE;
    if (job_name == "SPEICHER_LESEN" )         speicher_lesen_flag       = TRUE;
    if (job_name == "STATUS_ENERGIESPARMODE" ){fetrafla_flag             = TRUE;
       instr(pos1,0,gruppe,"d_");
       instr(pos2,0,gruppe,"D_");
       if ((pos1 != -1) || (pos2 != -1))
            fetrawe_flag= TRUE;  //Bis F01
       else fetrawe_flag= FALSE; //Ab F01 (Gruppendatei: G_...)
    }
    if (job_name == "SENSOREN_IDENT_LESEN" )   sensoren_ident_lesen_flag = TRUE;
    if (job_name == "STEUERGERAETE_RESET" )    steuergeraete_reset_flag  = TRUE;

    if ((fs_lesen_flag             == TRUE) &&
        (is_lesen_flag             == TRUE) &&
        (hs_lesen_flag             == TRUE) &&
        (is_loeschen_flag          == TRUE) &&
        (hs_loeschen_flag          == TRUE) &&
        (speicher_lesen_flag       == TRUE) &&
        (fetrafla_flag             == TRUE) &&
        (sensoren_ident_lesen_flag == TRUE) &&
        (steuergeraete_reset_flag  == TRUE)) i = sgbd_saetze;
    i = i + 1;
  }

  if (speicher_lesen_parameter == "")  speicher_lesen_flag = FALSE;   //Hauptmenü F7-Taste: Speicher lesen wird angezeigt.
  if (speicher_lesen_flag == TRUE)
  {
    instr(i, 0, ";"+speicher_lesen_parameter+";", ";LAR;");
    if ( i == -1 ) speicher_lesen_lar_flag = FALSE; else speicher_lesen_lar_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";FLASH;");
    if ( i == -1 ) speicher_lesen_flash_flag = FALSE; else speicher_lesen_flash_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";UIFM;");
    if ( i == -1 ) speicher_lesen_uifm_flag = FALSE; else speicher_lesen_uifm_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMI;");
    if ( i == -1 ) speicher_lesen_romi_flag = FALSE; else speicher_lesen_romi_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIS;");
    if ( i == -1 ) speicher_lesen_ramis_flag = FALSE; else speicher_lesen_ramis_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIL;");
    if ( i == -1 ) speicher_lesen_ramil_flag = FALSE; else speicher_lesen_ramil_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";NVRAM;");
    if ( i == -1 ) speicher_lesen_nvram_flag = FALSE; else speicher_lesen_nvram_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMX;");
    if ( i == -1 ) speicher_lesen_romx_flag = FALSE; else speicher_lesen_romx_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMXX;");
    if ( i == -1 ) speicher_lesen_ramxx_flag = FALSE; else speicher_lesen_ramxx_flag = TRUE;
  }

  //IDENT-Typ ermitteln: DS2, BMW Fast oder UDS?
  INP1apiJob(sgbd,"IDENT","","");
  INP1apiResultText(fehlerflag,temp,"ID_DATUM_KW",1,"");//Hat nur DS2
  if ((fehlerflag == TRUE) && (temp != ""))
  {
    ident_typ= 1;//DS2
  }
  else//UDS, BMW Fast
  {
    INP1apiResultText(fehlerflag,temp,"ID_SGBD_INDEX",1,"");
    if ((fehlerflag == TRUE) && (temp != "")) ident_typ= 3; //Hat nur UDS (ISO 14229)
    else ident_typ= 2; //sonst BMW Fast
  }
}
// -- EOF --
// end of :#include "GRPCHECK.SRC"
// start of :#include "SWECHSEL.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SWECHSEL.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.02.2008 GA V4.00 Ersterstellung
//* 14.03.2008 GA V4.01 INPA-Datei-Überprüfung: Pfad für *.IPO ist variable
//**********************************************************************
//**********************
//* scriptwechsel_init *
//**********************
scriptwechsel_init()
{
  int    m;
  int    len;
  string ausgelesen;

  setmenutitle("INPA-Nacharbeitsprogramm-Wechsel");
  GetPrivateProfileString("EXTRA","SCRIPTWECHSEL",scriptwechsel_error,ausgelesen,80,"..\cfgdat\inpa.ini",ganz_zahl);

  //String-Array zerlegen in:
  //Inpascript,Gruppendatei
  instr(m,0,ausgelesen,",");                //Position für "," feststellen
  strlen(len,ausgelesen);                   //Stringlänge feststellen

  if (m!=-1)                                //-1: gesuchtes Zeichen nicht gefunden
  {
    midstr(letztes_inpa,ausgelesen,0,m);
    midstr(letzte_gruppe,ausgelesen,m+1,len);
  }
  else//Falls etwas schief geht, wird das aktuelle Script wieder aufgerufen.
  {
    letztes_inpa = inpa;
    letzte_gruppe= gruppe;
  }

  if ((ganz_zahl > 0) && (letztes_inpa != scriptwechsel_error))
       setitem( 1,"Rücksprung",TRUE);
  else setitem( 1,"Rücksprung",FALSE);
  //0: kein Eintrag vorhanden
}


//**********************
//* scriptwechsel_item *
//**********************
scriptwechsel_item(in: string inpa_script, in: string gruppendatei)
{
  string JOB_STATUS;
  bool   aufruf_io=FALSE;
  bool   script_vorhanden;
  bool   gruppe_vorhanden;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string variante;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  string SgdatDir;
  int    ret_int;
  int    Size;
  int    filecheck;
  string temp;
  int    i=0;
  int    k=0;
  string Backslash;


  //Hinweis bei mehreren Gruppendateien:
  //Es wird auch eine fehlende Gruppendatei ausgegeben, auch wenn diese nicht für
  //den aktullen Motor zuständig ist.
  userboxopen(2,11,0,9,91,"Nacharbeitsprogramm-Wechsel", "");
  userboxsetcolor(2,1,2);// 2=hellgrau
  userboxftextout(2,"Nacharbeitsprogramm: "+inpa_script+".IPO wird aufgerufen.",2,2,0,16);
  userboxftextout(2,"Bitte warten!",4,2,0,16);
  //Prüfen ob SG antwortet, da man sonst wieder in der Baureihen-Auswahl landet.


  //INPA-Script vorhanden?-------------------------------------------------------------------
  //Muß hier oben geprüft werden! Wenn Gruppenaufruf i.O. kann immer noch das Script fehlen.
  //Pfad muß hier auf SGDAT gesetzt werden! Verknüpfungen auf dem Desktop haben aber den Pfad auf \BIN!
  //Der Pfad wurde zuvor durch INPAINFO.SRC ermittelt.
  chr( 92, Backslash ); // '\'
  fileexist(ipo_pfad+Backslash+inpa_script+".IPO",filecheck);
  if (filecheck == 0)
    script_vorhanden= TRUE;
  else
  {
    script_vorhanden= FALSE;
    userboxclear(2);
    userboxopen(2,11,0,9,91,"Fehlermeldung", "");
    userboxsetcolor(2,1,4);// 4=leuchtend rot
    messagebox("Fehlermeldung: INPA-Nacharbeitsprogramm-Wechsel",
               "Es kann nicht zum Nacharbeitsprogramm: "+inpa_script+" gewechselt werden."+CRLF+CRLF+
               "Grund:"+CRLF+
               "- Datei "+inpa_script+".IPO existiert nicht im Verzeichnis "+ipo_pfad+CRLF+
               "- Nur für INPA-Verantwortlichen ("+origin+") : Wurde der INPA-Name zu dem gewechselt werden soll,"+CRLF+
               "  im Script ("+inpa+".SRC) korrekt angegeben?");
    userboxclose(2);
  }


  //Test über Gruppendatei(en), wenn i.O. erfolgt Wechsel. Bei fehlenden Dateien werden angezeigt.
  instr(i,k,","+gruppendatei+",",",");
  while ((i >= 0) && (aufruf_io == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppendatei+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppendatei+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(aufruf_io,variante,"VARIANTE",0,"");

      //Alles i.O., somit Script wechseln
      if (aufruf_io == TRUE && script_vorhanden == TRUE)
      {
        if ((ganz_zahl > 0) || (letztes_inpa != scriptwechsel_error)) setitem( 1,"Rücks.",TRUE);
        WritePrivateProfileString("EXTRA","SCRIPTWECHSEL",inpa+","+gruppe,"..\cfgdat\inpa.ini",logik_var);//logik_var == FALSE, wenn Fehler
        if (ipo_pfad == "") //Standardafall, Script wurde übre INPAOAD.EXE, Auswahl...
             scriptchange(inpa_script);
        else scriptchange(ipo_pfad+Backslash+inpa_script);//Script wurde über eine Verknüpfung gestartet.
      }
      else//Aufruf n.i.O., somit weitere Prüfungen
      {
        //Existiert die angegebene Gruppendatei?---------------------------------------------------
        Size=256;
        space(CurDir,Size);
        GetCurrentDirectory(256, CurDir, ret_int);
        SetCurrentDirectory("\EDIABAS\ECU", ret_int);
        fileexist(temp+".GRP",filecheck);
        SetCurrentDirectory(CurDir, ret_int);
        if (filecheck == 0) //Gruppendatei existiert, also Fehler auslesen und ausgeben
        {
          gruppe_vorhanden= TRUE;
          INP1apiErrorCode(errorcode);
          if (errorcode != 0) INP1apiErrorText(error_text);
          else error_text= JOB_STATUS;
          //Fehlerausgabe erfolgt am Ende.
        }
        else//Fehler beim Aufruf über Gruppendatei
        {
          gruppe_vorhanden= FALSE;
          userboxclear(2);
          userboxopen(2,12,0,7,91,"Fehlermeldung", "");
          userboxsetcolor(2,1,4);// 4=leuchtend rot
          messagebox("Fehlermeldung: INPA Nacharbeitsprogramm-Wechsel",
                     "Es kann nicht zum Nacharbeitsprogramm: "+inpa_script+" gewechselt werden."+CRLF+
                     "Grund: Gruppendatei "+temp+".GRP existiert nicht im Verzeichnis ...\EDIABAS\ECU");
          userboxclose(2);
        }
      }
    }
  }

  //Gruppe vorhanden, aber es meldet sich kein SG
  if ((aufruf_io == FALSE) && (gruppe_vorhanden == TRUE))
        //Fehler beim Aufruf über Gruppendatei
        {
          userboxclear(2);
          userboxopen(2,12,0,7,91,"Fehlermeldung", "");
          userboxsetcolor(2,1,4);// 4=leuchtend rot
          messagebox("Hinweis: INPA Nacharbeitsprogramm-Wechsel",
                     "Es kann nicht zum Nacharbeitsprogramm: "+inpa_script+" gewechselt werden."+CRLF+
                     "Grund: Aufruf über Gruppendatei(en) "+gruppendatei+" ist fehlgeschlagen"+CRLF+
                     "Grund: "+error_text);
        }

  userboxclose(2);
}
// -- EOF --
// end of :#include "SWECHSEL.SRC"
// start of :#include "FS_LESEN.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen FS_LESEN.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 21.11.2000 rd V0.10 Umweltbedingungen als Zahl oder Text ( 0-n, Hex )
//* 02.03.2001 rd V0.11 Shadowspeicher umbenannt in Infospeicher
//* 25.04.2002 rd V1.00 Erweiterung HS_LESEN
//* 22.10.2002 rd V1.01 Erweiterung FS_LESEN
//*               V1.01 PCODE und PCODE7 Ausgabe neu
//*               V1.01 Fehlerbehandlung verbessert
//* 19.11.2002 iS V1.02 Fehlerbehandlung F_ORT_TEXT, F_UW_ANZ, F_PCODE
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Fehlerausgaben korrigiert und erweitert
//* 28.06.2006 GA V3.01 Bei UDS: Ausgabe "F_UW_DATUM_ZEIT" durch "F_UW_ZEIT" ersetzt, da Result entfällt
//* 19.10.2006 GA V3.02 Bei DS2: wurde nicht angezogen da if-Bedingung nicht korrekt gewesen ist.
//*            GA V3.02 Result: F_UW_ZEIT von Unterprg.: fs_protokoll_uwb in fs_protokoll_uwb_uds verschoben
//*            GA V3.02 Result: F_EREIGNIS_DTC: Text wurde inverse ausgegeben
//* 07.02.2007 GA V3.03 Result: F_EREIGNIS_DTC: Erklärender Text, was ein Ereinis DTC ist, war falsch
//**********************************************************************

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************
int    _FsMode        = 0x7FF; // alles ein
string _FsFileMode    = "w";
string _PreInfoFile   = "";
string _PostInfoFile  = "";
string _ApiFsJobName  = "FS_LESEN";

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern INPAapiFsMode_neu ( in: int FsMode, in: string FsFileMode,
                           in: string PreInfoFile, in: string PostInfoFile,
                           in: string ApiFsJobName);

extern INPAapiFsLesen_neu( in: string ecu, in: string FileName);

extern fs_protokoll_ort(in: int nr);
extern fs_protokoll_ort_uds(in: int nr);
extern fs_protokoll_PCode(in: int nr);
extern fs_protokoll_PCode7(in: int nr);
extern fs_protokoll_SAECode(in: int nr);
extern fs_protokoll_hfk(in: int nr);
extern fs_protokoll_hfk_uds(in: int nr);
extern fs_protokoll_art(in: int nr);
extern fs_protokoll_art_uds(in: int nr);
extern fs_protokoll_art_e(in: int nr);
extern fs_protokoll_uwb(in: int nr);
extern fs_protokoll_uwb_uds(in: int nr);
extern fs_protokoll_hex(in: int nr);
extern fs_protokoll_telantwort(in: int nr);

//**********************************************************************
//*
//* INPAapiFsMode_neu kompatibel mit INPAapiFsMode
//*
//**********************************************************************
INPAapiFsMode_neu(  in: int    FsMode,
                    in: string FsFileMode,
                    in: string PreInfoFile,
                    in: string PostInfoFile,
                    in: string ApiFsJobName)
{
  _FsMode       = FsMode;
  _FsFileMode   = FsFileMode;
  _PreInfoFile  = PreInfoFile;
  _PostInfoFile = PostInfoFile;
  _ApiFsJobName = ApiFsJobName;


  INPAapiFsMode(_FsMode, _FsFileMode, _PreInfoFile, _PostInfoFile, _ApiFsJobName);
  if (_ApiFsJobName=="") _ApiFsJobName="FS_LESEN";
}

//**********************************************************************
//*
//* INPAapiFsLesen_neu kompatibel mit INPAapiFsLesen
//*
//**********************************************************************
INPAapiFsLesen_neu( in: string ecu, in: string FileName)
{
  string _ecu;
  string _FileName;
  bool   rc;
  int    i;
  int    k;
  int    len;
  int    x1;
  long   xL;
  string temp1;
  string temp2;
  string temp3;
  string temp11;
  string temp12;
  string temp21;
  string temp22;
  int    F_VERSION;
  string JOB_STATUS;
  string JOB_MESSAGE;
  string VARIANTE;
  int    SETS;
  int    UW_SETS;
  string FS_CODE;
  string F_PCODE;
  string F_PCODE7;
  string F1_VERSION;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string errorcode_text;           // EDIABAS Fehlernummer als Text

  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  _ecu      = ecu;
  _FileName = FileName;


  //SGBD-Version auslesen
  sgbd_version= "???";
  INPAapiJob(_ecu,"INFO","","");
  INP1apiResultText(rc, sgbd_version, "REVISION", 1, "");

  INPAapiJob(_ecu, _ApiFsJobName,"","");
  INP1apiResultInt(rc, F_VERSION, "F_VERSION",1 );

  INP1apiErrorCode(errorcode);

//UDS:
  if ((rc == TRUE) && ( F_VERSION == 3 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort_uds(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="??????";
            StrArrayWrite(f_ort_text_buffer,i,temp1);

            INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
            if (rc == TRUE)
            {
              GetBinaryDataString (temp1,len);
              midstr(temp1,temp1,0,6);
            }
            else
            {
              temp1= "??????";
              filewrite("");
              filewrite("### Fehler beim Lesen des Results: F_HEX_CODE ###");
              filewrite("");
              INP1apiErrorCode(errorcode);
              if (errorcode != 0)
              {
                inttostring(errorcode, errorcode_text);
                INP1apiErrorText(error_text);
                error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
                ftextout(error_text ,2,0,0,0);
              }
            }
            StrArrayWrite(f_ort_nr_buffer,i,temp1);

            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort_uds(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_SAECode(1);//0x200 von BMW Fast für PCode genommen
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk_uds(1);
                k=1;

                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb_uds(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite("0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);

                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite("0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//BMW FAST:
  else if ((rc == TRUE) && ( F_VERSION == 2 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="????";

            StrArrayWrite(f_ort_text_buffer,i,temp1);
            INPAapiResultInt(x1, "F_ORT_NR", i);
            inttohexstring(x1, 4, temp1);
            StrArrayWrite(f_ort_nr_buffer,i,temp1);
            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_PCode(1);
                if ((_FsMode & 0x400) != 0) fs_protokoll_PCode7(1);
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk(1);
                k=1;
                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite( "0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                {
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                }
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);
                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite( "0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//DS2
  else if (errorcode == 134)//134=SYS-0014: Result nicht gefunden: 'F_VERSION'
  {
    INPAapiFsLesen( _ecu, _FileName);
  }
//Fehlerhafter Aufruf
  else
  {
    INPAapiCheckJobStatus("OKAY");//Damit der Bediener die Fehlermeldung bestätigen muß
    getdate(temp1);
    gettime(temp2);
    INP1apiErrorText(temp3);
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite( "");
    filewrite( "Datum    : "+temp1+" "+temp2);
    filewrite( "ECU      : "+_ecu);
    filewrite( "JobStatus: "+JOB_STATUS+"-->"+temp3) ;
    filewrite( "-------------------------------------------------------------------------------");
    fileclose();
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für DS2 und BMW Fast
//*
//**********************************************************************
fs_protokoll_ort(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  INP1apiResultInt(rc,x1, "F_ORT_NR", i);
  if (rc == TRUE)
  {
    inttohexstring(x1, 4, temp1);
  }
  else
  {
    temp1="????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für UDS (ISO 14229)
//*
//**********************************************************************
fs_protokoll_ort_uds(in: int nr)
{
  int    i;
  int    len;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");

  INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
  if (rc == TRUE)
  {
    if (_ApiFsJobName == "FS_LESEN")
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,0,6);
    }
    else//IS_LESEN
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,2,6);//Byte 0, Zeichen 0 und 1 sind das severity Byte!
    }

  }
  else
  {
    temp1= "??????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"??????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE
//*
//**********************************************************************
fs_protokoll_PCode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcodeText;
  string tempPcodeString;
  string tempPcodeHex;

  i=nr;
  INP1apiResultText(rc,tempPcodeString, "F_PCODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcodeText, "F_PCODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcodeHex);
        tempPcodeHex= "0x"+tempPcodeHex;
      }
      else
      {
        tempPcodeHex = "????";
      }
    }
    else
    {
      tempPcodeText = "????";
    }

    if (tempPcodeString == "??")
    {
      filewrite( "");
      filewrite( tempPcodeHex+"  "+tempPcodeText);
    }
    else
    {
      if (tempPcodeString != "--")
      {
        filewrite( "");
        filewrite( tempPcodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE7
//*
//**********************************************************************
fs_protokoll_PCode7(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcode7Text;
  string tempPcode7String;
  string tempPcode7Hex;

  i=nr;
  INP1apiResultText(rc,tempPcode7String, "F_PCODE7_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcode7Text, "F_PCODE7_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE7", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcode7Hex);
        tempPcode7Hex= "0x"+tempPcode7Hex;
      }
      else
      {
        tempPcode7Hex = "????";
      }
    }
    else
    {
      tempPcode7Text = "????";
    }

    if (tempPcode7String == "??")
    {
      filewrite( "");
      filewrite( tempPcode7Hex+"  "+tempPcode7Text);
    }
    else
    {
      if (tempPcode7String != "--")
      {
        filewrite( "");
        filewrite( tempPcode7Text);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe SAE Code für UDS
//*
//**********************************************************************
fs_protokoll_SAECode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempSAECodeText;
  string tempSAECodeString;
  string tempSAECodeHex;

  i=nr;
  INP1apiResultText(rc,tempSAECodeString, "F_SAE_CODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempSAECodeText, "F_SAE_CODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_SAE_CODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempSAECodeHex);
        tempSAECodeHex= "0x"+tempSAECodeHex;
      }
      else
      {
        tempSAECodeHex = "????";
      }
    }
    else
    {
      tempSAECodeText = "????";
    }

    if (tempSAECodeString == "??")
    {
      filewrite( "");
      filewrite( tempSAECodeHex+"    "+tempSAECodeText);
    }
    else
    {
      if (tempSAECodeString != "--")
      {
        filewrite( "");
        filewrite( tempSAECodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit
//*
//**********************************************************************
fs_protokoll_hfk(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;
  int f_hfk;
  int f_lz;

  i=nr;
  filewrite( "");

  INP1apiResultInt(rc,f_hfk,"F_HFK",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_hfk,temp1);
    if (f_hfk < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    filewrite( "Fehlerhäufigkeit: "+ temp1);
  }

  INP1apiResultInt(rc,f_lz,"F_LZ",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_lz,temp1);
    if (f_lz < 10) temp1= " "+temp1;//Formatierung der Nr des Logistikzählers, wenn sie kleiner 10 ist
    filewrite( "Logistikzähler  : "+ temp1);
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit für UDS
//*
//**********************************************************************
fs_protokoll_hfk_uds(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  //FS Überlauf
  INP1apiResultInt(rc,x1, "F_UEBERLAUF", i);
  if ((rc == TRUE) && (x1==1))
  {
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    if (_ApiFsJobName == "IS_LESEN")
      filewrite("++++++++++++++++++++++++ Infospeicher ist übergelaufen! +++++++++++++++++++++++");
    else
      filewrite("+++++++++++++++++++++++ Fehlerspeicher ist übergelaufen! ++++++++++++++++++++++");
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    filewrite( "");
  }

  //Fehlerhäufigkeit
  INP1apiResultInt(rc,x1, "F_HFK", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
   {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    }
  }
  filewrite( "Fehlerhäufigkeit: "+ temp1);

  //Heilungszähler
  INP1apiResultInt(rc,x1, "F_HLZ", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
    {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung des Heilungszählers, wenn er kleiner 10 ist
    }
  }
  filewrite( "Heilungszähler  : "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten
//*
//**********************************************************************
fs_protokoll_art(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_SYMPTOM_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe erweiterte Fehlerarten
//*
//**********************************************************************
fs_protokoll_art_e(in: int nr)
{
  int    i;
  int    k;
  int    F_ART_ANZ;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  INP1apiResultInt(rc,F_ART_ANZ, "F_ART_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_ART_ANZ > 0 )
    {
      k=0;
      while ( k < F_ART_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);
        INP1apiResultText(rc,temp1, "F_ART"+temp2+"_TEXT", i, "");
        if (rc == FALSE)  temp1 ="????";
        if (temp1 !="--") filewrite( "   "+ temp1);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten für UDS
//*
//**********************************************************************
fs_protokoll_art_uds(in: int nr)
{//Symptome entfallen bei UDS!
  int    i;
  int    x1;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  //Neu bei UDS:
  INP1apiResultInt(rc,x1, "F_EREIGNIS_DTC", i);
  if (rc == TRUE)
  {
    if (x1==0)
    {
      filewrite("   Dies ist kein Ereignis DTC. Das SG ist für den Fehlerspeicheintrag (DTC) verantwortlich.");
    }
    else if (x1==1)
    {
      filewrite("   Dies ein Ereignis DTC. Das SG ist somit nicht für den Fehlereintrag (DTC) verantwortlich.");
      filewrite("   Z.B. falsche oder fehlende Netzwerkinformationen.");
    }
    else
    {
      filewrite("   Fehler in SGBD! In Tabelle FOrtTexte, Spalte EREIGNIS_DTC muß 0 oder 1 stehen!");
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb(in: int nr)
{
  int    i;
  int    k;
  int    len;
  int    F_UW_ANZ;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  real   realval;
  int    pos;

  i=nr;
/*  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");
*/
  INP1apiResultText(rc,temp1, "F_UW_KM", i, "8L");
  if (rc == FALSE) temp1="    ????";
  if ((temp1 == "524280") && (ident_typ != 3)) temp1 = "-1";//Fehlerüberlauf für DS2 und BMW FAST, UDS liefert es von alleine

  temp2 =    "Kilometerstand                        ";
  filewrite( "   " + temp2 + temp1 + "     km");


  INP1apiResultInt(rc,F_UW_ANZ, "F_UW_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_UW_ANZ > 0 )
    {
      k=0;
      while ( k < F_UW_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);

        INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
        if (rc == TRUE)
        {
          AnsiUpper(temp3,temp3);
        }
        else
        {
          temp3 = "????";
        }
        if ((temp3 == "0-N") || (temp3 == "HEX"))
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-20T");
          if (rc == FALSE) temp1="????                ";
          if (temp1 !="--                  ") //"--" + 18 Zeichen

          {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "28T");
              if (rc == FALSE) temp3="????                        ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
          }
        }
        else
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-40T");
          if (rc == FALSE) temp1="????                                    ";
          if (temp1 !="--                                      ")
           {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "8.2R");
              if (rc == FALSE) temp3=" ????   ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
           }
         }
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb_uds(in: int nr)
{
  int    i;
 // int    k;
//  int    len;
//  int    F_UW_ANZ;
  bool   rc;
  string temp1;
//  string temp2;
//  string temp3;
//  real   realval;
//  int    pos;

  i=nr;
  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");

  fs_protokoll_uwb(i);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Hexcode
//*
//**********************************************************************
fs_protokoll_hex(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;

  chr(10,nl);
  i=nr;
  filewrite( "");
  INP1apiResultBinary(rc,"F_HEX_CODE", i);
  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????";
  }
  filewrite( "Fehlercode: "+temp2);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Telegrammantwort(en)
//* Wird nur bei Fehlerhaften FS_LESEN_DETAIL ausgegeben
//*
//**********************************************************************
fs_protokoll_telantwort(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  string temp4;
  string temp5;

  chr(10,nl);
  i=nr;
  filewrite( "");

  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_SNAPSHOT", i);
    else INP1apiResultBinary(rc,"_RESPONSE_2000", i);//IS_LESEN
  }
  else//1=DS2, 2=BMW Fast
  {
    INP1apiResultBinary(rc,"_TEL_ANTWORT", i);
  }


  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????--> Zur Analyse IFH-Trace benutzen!";
  }

  //2. Telegramm nur für UDS ausgeben
  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_EXTENDED_DATA", i);
    else INP1apiResultBinary(rc,"_RESPONSE_200X", i);//IS_LESEN

    if (rc == TRUE)
    {
      GetBinaryDataString (temp1, x1);
      x2 = 0;
      x3 = 0;
      temp4="";
      while ( x2 < x1 )
       {
         midstr(temp3, temp1, x2, 2);
         temp4 = temp4 + temp3;
         x2 = x2 + 2;
         x3 = x3 + 1;
         if ( x2 < x1 )
         {
           if ( x3 < 16 )//Leerzeichen zwischen den Bytes
           {
             if ( x3 == 8 )
               temp4 = temp4 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
             else temp4 = temp4 + " ";
           }
           else
           {
             x3 = 0;
             temp4 = temp4 + nl + "            ";
           }
         }
      }
    }
    else
    {
      temp4 = "????--> Zur Analyse IFH-Trace benutzen!";
    }

    filewrite("Telegramm-Antwort ab Service Identifier zur Analyse");
    if (_ApiFsJobName == "FS_LESEN")
    {
      filewrite("Data      : "+temp2);
      filewrite("Snapshot  : "+temp4);
    }
    else//IS_LESEN
    {
      filewrite("2000      : "+temp2);
      filewrite("200X      : "+temp4);
    }
  }
  else//DS2, BMW Fast
  {
  filewrite("Telegramm-");
  filewrite("Antwort   : "+temp2);
  }
}
// -- EOF --
// end of :#include "FS_LESEN.SRC"
// start of :#include "SENSORID.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SENSORID.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.02.2008 GA V4.00 Ersterstellung
//* 21.04.2008 GA V4.03 SENSOR_BMW_NR wurde nicht ausgegeben
//**********************************************************************
//***************************
//* textFormartiertAusgeben *
//***************************
textFormartiertAusgeben(in: int pos, in: string bezeichnerIn, out: string bezeichnerOut, in: string fuellzeichen, in: string letztesZeichen)
{
    //Formatierung:
    //String mit Bezeichner und "fuellzeichen" erstellen, so daß "letztesZeichen" immer an gleicher Stelle beginnt.
    int    i;
    string text_leer= "";
    int    len;                                    // Länge eines Strings

    strlen(len,bezeichnerIn);
    if (len >= pos)
         len= 1;                                   // falls die Position <= Textlänge, dann letztes Zeichen unmittelbar ausgeben
    else len= pos-len;

    i=1;
    while(i<len)
      {
       i= i+1;
       strcat(text_leer,text_leer,fuellzeichen);
      }
    bezeichnerOut = bezeichnerIn+text_leer+letztesZeichen;
}


//**********************
//* Sensor Ident lesen *
//**********************
sensoren_ident_lesen(in: string FileName)
{
  string text_var;
  string text_var2;
  string text_var3;
  string text_leerzeichen ="                               "; //Vor Bezeichner ausgeben
  int    pos=25;                   // Position für "_ " Ausgabe
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    anzahl;                   // Sensoren
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  int    i;
  int    temp;
  string temp1;
  string temp2;
  string JOB_STATUS;
  string _ecu;
  string VARIANTE;
  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  getdate(temp1);
  gettime(temp2);
  //SGBD-Version auslesen
  INPAapiJob(sgbd,"INFO","","");
  INP1apiResultText(fehlerflag, sgbd_version, "REVISION", 1, "");
  INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
  INP1apiResultText(fehlerflag, sgbd_version, "REVISION", 1, "");
  if (fehlerflag == FALSE)   sgbd_version= "???";

  fileopen(FileName,"w");
  filewrite( "           S E N S O R E N   I D E N T   L E S E N");
  filewrite( "           ---------------------------------------");
  filewrite("");
  filewrite("Datum    : "+temp1+" "+temp2);


  INPAapiJob(sgbd,"SENSOREN_IDENT_LESEN","","");
  //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
  sets=0;
  INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) && (sets <= 1))
    {
      filewrite("Fehler beim Lesen von Job: SENSOREN_IDENT_LESEN");
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr. "+errorcode_text+": "+ error_text;

        filewrite("JobStatus: "+error_text);
        filewrite("Variante : "+VARIANTE+".PRG");
        filewrite("Version  : "+sgbd_version);
        filewrite( "-------------------------------------------------------------------------------");
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        filewrite("JobStatus: "+error_text);
        filewrite("Variante : "+VARIANTE+".PRG");
        filewrite("Version  : "+sgbd_version);
        filewrite( "-------------------------------------------------------------------------------");
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
    }
    else
    {
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", sets, "");
      filewrite("JobStatus: "+JOB_STATUS);
      filewrite("Variante : "+VARIANTE+".PRG");
      filewrite("Version  : "+sgbd_version);
      filewrite( "-------------------------------------------------------------------------------");
      anzahl= sets-1;
      inttostring(anzahl, text_var);
      textFormartiertAusgeben(56, "Anzahl Sensoren", text_var2, " ", ": ");
      filewrite(text_var2+text_var);
      filewrite("   ---Sensor---");

      if ((fehlerflag == TRUE) && (sets == 1))//Es liegen keine Daten vor, Antwort besteht nur aus Jobstatus.
      {
         filewrite("");
         filewrite("");
         filewrite("Keine Sensordaten vorhanden!");
      }
      else //Es liegt mindestens ein Satz mit Daten vor
      {
        i=1;
        while(i<=anzahl)
        {
          inttostring(i,text_var2);
          INPAapiResultText(text_var,"SENSOR_VERBAUORT",i,"");
          filewrite(text_var2+") " +text_var);//Sensor durchnummerieren und dann Bezeichnung ausgeben (Ort)
          //Verbauort Nr.
          INP1apiResultText(fehlerflag,text_var, "SENSOR_VERBAUORT_NR", i, "");
          if ((fehlerflag != TRUE) && (text_var == ""))
          {
             text_var = "--";
             text_var2= "--";
          }
          else
          {//Hexwerte abholen:
            INPAapiResultBinary("_RESPONSE_2",i);
            GetBinaryDataString (text_var2,temp);
            midstr(text_var2,text_var2,6,4);
            text_var= text_var+"/0x"+text_var2;//dezimal/hexadezimal ausgeben
          }
          textFormartiertAusgeben(pos, "Verbauort Nummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //BMW-Nr.
          INPAapiResultText(text_var,"SENSOR_BMW_NR",i,"");
          textFormartiertAusgeben(pos, "BMW-Nummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Teilenummer
          INP1apiResultText(fehlerflag,text_var, "SENSOR_PART_NR", i, "");
          if ((fehlerflag != TRUE) && (text_var == ""))
          {
             text_var= "--";
          }
          textFormartiertAusgeben(pos, "Teilenummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Hersteller
          INPAapiResultText(text_var3,"SENSOR_HERSTELLER_NR",i,"");
          INPAapiResultInt(temp,"SENSOR_HERSTELLER_NR",i);
          inttohexstring(temp, 2, text_var);
          text_var3= text_var+"/0x"+text_var3;
          INPAapiResultText(text_var,"SENSOR_HERSTELLER_TEXT",i,"");
          textFormartiertAusgeben(pos, "Hersteller", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var3+": "+text_var);

          //Funktionsnummer
          INPAapiResultText(text_var,"SENSOR_FUNKTIONS_NR",i,"");
          textFormartiertAusgeben(pos, "Funktionsnummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Varianten
          INPAapiResultText(text_var,"SENSOR_VARIANTEN_NR",i,"");
          textFormartiertAusgeben(pos, "Varianten", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Produktionsdatum
          INPAapiResultText(text_var,"SENSOR_PROD_DATUM",i,"");
          textFormartiertAusgeben(pos, "Produktionsdatum", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Seriennummer
          INPAapiResultText(text_var,"SENSOR_SERIEN_NR",i,"");
          textFormartiertAusgeben(pos, "Seriennummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Software Release Nummer
          INPAapiResultText(text_var,"SENSOR_SW_RELEASE_NR",i,"");
          textFormartiertAusgeben(pos, "Software Release Nummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);

          //Hardware Release Nummer
          INPAapiResultText(text_var,"SENSOR_HW_RELEASE_NR",i,"");
          textFormartiertAusgeben(pos, "Hardware Release Nummer", text_var2, " ", ": ");
          filewrite(text_leerzeichen+text_var2+text_var);
          filewrite("");

          i=i+1;//um nächstes Set zu laden
         }
       }
    }

    filewrite("");
    filewrite("#########################################################################################");
    filewrite("Dieser Inhalt wird temporär in folgender Textdatei abgelegt  ..\inpa\bin\na_sensor_id.tmp");
    filewrite("#########################################################################################");
    fileclose();
}
// -- EOF --
// end of :#include "SENSORID.SRC"
// start of :#include "INITEXIT.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INITEXIT.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Scriptinit verlagert
//* 12.03.2003 iS V1.01 Anpassung SgbdInpaCheck()GroupCheck();
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 15.03.2008 GA V4.01 InpaInfos_ermitteln() dazu
//**********************************************************************

// **************************
// *** inpainit, inpaexit ***
// **************************
inpainit()
{
  bool   rc;
  string temp;
  int    i;

  INPAapiInit();
  chrinit();

  // Handle für FS_LESEN
  StrArrayCreate(rc,f_ort_nr_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_nr_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  StrArrayCreate(rc,f_ort_text_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_text_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }


  InpaInfos_ermitteln();                           //INPA-Scriptname und Pfad zu SGDAT ermitteln
  SgbdInpaCheck();
  GroupCheck();
  setmenu(m_main);
  setscreen(s_main,TRUE);

  //INPA.INI einlesen,
  //um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
  //hinter "SCRIPTS" muß DeleteRead stehen, um die Funktion freizuschalten
  ExtraScript("DeleteRead", deleteread_flag);

  //m FS,IS,HS zu speichern
  ExtraScript("SaveAs", fs_lesen_save_as_flag);
  is_lesen_save_as_flag=fs_lesen_save_as_flag;
  hs_lesen_save_as_flag=fs_lesen_save_as_flag;

  //INPA.INI-Einstellung, falls Funktionen gewünscht:
  //[EXTRA]
  //SCRIPTS               =  DeleteRead,SaveAs
  //Wichtig: Nach dem Komma kein Leerzeichen benutzen!

  ScriptInit();
}

inpaexit()
{
  INPAapiEnd();

  // Handle für FS_LESEN
  StrArrayDestroy(f_ort_nr_buffer);
  StrArrayDestroy(f_ort_text_buffer);
}

// -- EOF --
// end of :#include "INITEXIT.SRC"


// **************************
// *** Hauptmenü          ***
// **************************
MENU m_main()
{
  string pfad="..\bin";
  string BS;//Backslash \
  string DateiName;
  string DateiName_Sensor_ID="na_sensor_id.tmp";

  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  bool   steuergeraet_reseten;
  bool   fehlerflag;
  string JOB_STATUS;

  INIT  {
    chr( 92, BS ); // '\'

    //Pfad vor Dateinamen einfügen (..INPA\BIN\)
    DateiName_Sensor_ID= pfad+BS+DateiName_Sensor_ID;


    setmenutitle("Hauptmenü");

    if ((ident_typ == 1) || (ident_typ == 2)) //DS2 oder BMW FAST
    {
      setitem(2, "Ident", TRUE);
    }
    else
    {
      setitem(2, "SVK", TRUE);//ISO 14229
    }
    if (scriptwechsel_flag == TRUE)
    {
        setitem( 3, "INPA  <->", TRUE);
    }
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setitem( 4 , "Fehler"  , TRUE);
    }

    if (m_status_flag == TRUE)
    {
      setitem( 5 , "Status"  , TRUE);
    }

    if (m_steuern_flag == TRUE)
    {
      setitem( 6 , "Steuern"  , TRUE);
    }

    if (speicher_lesen_flag == TRUE)
    {
      setitem( 7 , "Speicher"  , TRUE);
    }
    else if (fetrafla_flag == TRUE)
    {
      if (fetrawe_flag == TRUE)
           setitem( 7 , "FeTraWe", TRUE);
      else setitem( 7 , "FeTraFla", TRUE);
    }
    else
    {
      setscreen( s_main ,TRUE);
    }

    if (funktionen_flag == TRUE)
    {
      setitem( 8 , "Funktionen", TRUE);
      setitem(18 ,"",FALSE);
    }
    else
    {
      setitem( 8 , "Auswahl", TRUE);
      setitem(18 , "Gesamt",TRUE);
    }

    if (sensoren_ident_lesen_flag == TRUE)
    {
      setitem(12, "Sensoren", TRUE);
    }
    else
    {
      setscreen( s_main ,TRUE);
    }

    if (set_sg_information_flag == TRUE)
    {
      setitem(13, "Information", TRUE);
    }
    else
    {
      setscreen( s_main ,TRUE);
    }

    if (steuergeraete_reset_flag == TRUE)
    {
      setitem(16, "Reset", TRUE);
    }
    else
    {
      setscreen( s_main ,TRUE);
    }

    if (sensoren_ident_lesen_flag == TRUE) setitem(19 , "S. Speichern", FALSE);
  }
  ITEM( 1 ,"Info")  {
    userboxclose(1);
    viewclose();
    setscreen(s_info,TRUE);
  }
  ITEM( 2 ,"Ident")  {
    userboxclose(1);
    viewclose();
    if (ident_typ == 1)
      setscreen(s_ident_ds2,TRUE);
    else if (ident_typ == 2)
      setscreen(s_ident,TRUE);
    else setscreen(s_svk_lesen,TRUE);
  }
  ITEM( 3 ,"")  {
    userboxclose(1);
    viewclose();
    if (scriptwechsel_flag == TRUE)
    {
       setscreen(s_scriptwechsel, TRUE);
       setmenu(m_scriptwechsel);
    }
    else
      setscreen(s_main,TRUE);
  }
  ITEM( 4 ,"")  {
    userboxclose(1);
    viewclose();
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setscreen( s_fehler ,TRUE);
      setmenu(m_fehler);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 5 ,"")  {
    userboxclose(1);
    viewclose();
    if (m_status_flag == TRUE)
    {
      setscreen(s_status,TRUE);
      setmenu(m_status);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 6 ,"")  {
    userboxclose(1);
    viewclose();
    if (m_steuern_flag == TRUE)
    {
      setscreen(s_steuern,TRUE);
      setmenu(m_steuern);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(1);
    viewclose();
    if (speicher_lesen_flag == TRUE)
    {
      setscreen(s_speicher,TRUE);
      setmenu(m_speicher);
    }
    else if (fetrafla_flag == TRUE)
    {
      setscreen( s_fetrawefla ,TRUE);
      setmenu( m_fetrawefla);
    }
    else  setscreen( s_main ,TRUE);
  }
  ITEM( 8 ,"")  {
    viewclose();
    if (funktionen_flag == TRUE)
    {
      userboxclose(1);
      setscreen( s_funktionen ,TRUE);
      setmenu( m_funktionen);
    }
    else
    {
      start();
      select(TRUE);
    }
  }
  ITEM(18 ,"")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Ende")  {
    exit();
  }
  ITEM( 11,  "KVP") {
    viewclose();
    setscreen(s_info,TRUE);
    callwin( "kvp_edit "+titel+";"+version+";"+sgbd+": "+sgbd_ecu+";"+sgbd_revision);
  }
  ITEM( 12 ,"")  {
    viewclose();
    if (sensoren_ident_lesen_flag == TRUE)
    {
      sensoren_ident_lesen(DateiName_Sensor_ID);
      viewopen(DateiName_Sensor_ID,"Sensoren");
      setitem(19 , "S. Speichern", TRUE);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 13 ,"")  {
    viewclose();
    userboxclose(1);
    setscreen( s_sg_information ,TRUE);
    setmenu( m_sg_information);
  }
  ITEM( 14 ,"")  {
    viewclose();
    setscreen( s_main ,TRUE);
  }
  ITEM( 15 ,"")  {
    viewclose();
    setscreen( s_main ,TRUE);
  }

  ITEM( 16 ,"")  {
    viewclose();
    if (steuergeraete_reset_flag == TRUE)
    {
      if (steuergeraete_reset_warnung_flag == TRUE)
      {
         userboxopen(0,0,0,16,91,"Steuergeräte Reset   Warnung", "");
         userboxsetcolor(0,1,4);// 4=leuchtend rot
         userboxftextout(0, "Der Vorgang kann zu Fehlerspeichereinträgen in anderen Steuergeräten führen!", 1, 0, 0, 16);
      }
      else
      {
         userboxopen(0,0,0,16,91,"Steuergeräte Reset   Hinweis", "");
         userboxsetcolor(0,1,2);// 2=hellgrau
         userboxftextout(0, "Der Vorgang führt zu KEINEN Fehlerspeichereinträgen in anderen Steuergeräten.", 1, 0, 0, 16);
      }

      inputdigital(steuergeraet_reseten,"Steuergerät reseten?",
                                         "Auswahl über Cursortasten","Steuergerät wird resetet",
                                         "Vorgang abbrechen");
      getinputstate(input_state);
      userboxclear(0);
      if ((input_state==input_ok) && (!steuergeraet_reseten))
      {

         INPAapiJob(sgbd,"STEUERGERAETE_RESET","","");
         INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
         if (JOB_STATUS != "OKAY")
         {
           userboxopen(0,8,35,5,50,"Steuergeräte Reset   Fehlermeldung","");
           userboxftextout(0,"Das Steuergerät konnte nicht resetet werden!",1,3,1,16);
           userboxsetcolor(0,1,4);
           INPAapiCheckJobStatus("OKAY");
         }
         else
         {
           userboxopen(0,8,35,5,50,"Steuergeräte Reset","");
           userboxftextout(0,"Das Steuergerät wird resetet.",1,3,1,16);
           userboxsetcolor(0,1,10);
           delay(3000);
         }
         userboxclose(0);
      }
      else
         setscreen( s_main ,TRUE);
    }
  }
  ITEM( 17 ,"")  {
    viewclose();
    setscreen( s_main ,TRUE);
  }
  ITEM( 19 ,"")  {
  userboxclose(1);
  viewclose();
  input2text(SpeichernKommentar1,SpeichernKommentar2,
  "Kommentar",
  "Geben Sie den zu speichernden Kommentar ein",
  "","");
  getinputstate(input_state);
  if (input_state==input_ok)
  {
    space(SpeicherUnterDateiName,256);
    strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

    GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
    SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
    SetCurrentDirectory(CurrentDirectory,ReturnedValue);
    if (SpeicherUnterDateiNameLaenge > 0)
    {
      DateiLesenPuffer="";
      fileopen(DateiName_Sensor_ID,"r");
      fileread(DateiLesenZeile, DateiLesenEOF );
      while (DateiLesenEOF == FALSE)
      {
        DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
        fileread(DateiLesenZeile, DateiLesenEOF );
        if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
      }
      fileclose();

      DateiName=SpeicherUnterDateiName;
      fileopen(DateiName,"w");
      if (SpeichernKommentar1 + SpeichernKommentar2 != "")
      {
        filewrite( "           K O M M E N T A R");
        filewrite( "           -----------------");
        filewrite( "");
        if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
        if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
        filewrite( "-------------------------------------------------------------");
        filewrite("");
      }
      filewrite(DateiLesenPuffer);
      fileclose();

      viewclose();
      viewopen(DateiName,"Sensoren Ident: "+DateiName);
    }
  }
  viewclose();
  setitem(19 , "S. Speichern", FALSE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Fehlermenü         ***
// **************************
MENU m_fehler()
{
  int    ErrorCode;
  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  int    filecheck;
  string pfad="..\bin";
  string BS;//Backslash \
  string DateiName;
  string DateiName_FS_LESEN="na_fs.tmp";
  string DateiName_IS_LESEN="na_is.tmp";
  string DateiName_HS_LESEN="na_hs.tmp";
  string JOB_STATUS;
  bool   fehlerflag;

  INIT {
    chr( 92, BS ); // '\'

    //Pfad vor Dateinamen einfügen (..INPA\BIN\)
    DateiName_FS_LESEN= pfad+BS+DateiName_FS_LESEN;
    DateiName_IS_LESEN= pfad+BS+DateiName_IS_LESEN;
    DateiName_HS_LESEN= pfad+BS+DateiName_HS_LESEN;

    setmenutitle("Fehlerspeicher");
    if (fs_lesen_flag == TRUE)
    {
      setitem( 1 , "FS lesen"    , TRUE);
      setitem( 2 , "FS löschen"  , TRUE);
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 3 , "IS lesen"    , TRUE);
      if (is_loeschen_flag == TRUE)
           setitem( 4 , "IS löschen"  , TRUE);
      else setitem( 4 , ""  , FALSE);//Nicht alle SGs haben IS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 5 , "HS lesen"    , TRUE);
      if (hs_loeschen_flag == TRUE)
           setitem( 6 , "HS löschen"  , TRUE);
      else setitem( 6 , ""  , FALSE);//Nicht alle SGs haben HS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
  }
  ITEM( 1 ,"")  {
    userboxclose(0);
    viewclose();
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
      userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,DateiName_FS_LESEN);
      userboxclose(0);
      viewopen(DateiName_FS_LESEN,"Fehlerspeicher lesen");
      setitem( 9 , "FS drucken"  , TRUE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
    }
  }
  ITEM( 2 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      INPAapiJob(sgbd,"FS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
          userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
          if (sgbd_name_motor != "")
          {
              userboxftextout(0,"Der Fehlerspeicher konnte im ",1,3,0,0);
              if (motor_master_flag == TRUE)
              {
                  userboxftextout(0,"Master-Steuergerät",2,3,0,0);
              }
              else
              {
                  userboxftextout(0,"Slave-Steuergerät",2,3,0,0);
              }
              userboxftextout(0,"nicht gelöscht werden!",3,3,0,0);
          }
          else//Standardfall
          {
              userboxftextout(0,"Der Fehlerspeicher konnte nicht gelöscht werden!",1,3,0,0);
          }
          userboxsetcolor(0,1,4);
          INPAapiCheckJobStatus("OKAY");
      }
      else
      {
          //Wenn i.O.: Sonderfall 12 Zylinder Motor (ab F01): Master- und Slavesteuergerät löschen!
          //INPA-Script vorhanden?
          if (sgbd_name_motor != "")
          {
              fileexist(ipo_pfad+BS+sgbd_name_motor+".IPO",filecheck);
              if (filecheck != 0)
              {
                  userboxclear(2);
                  userboxopen(2,11,0,9,91,"Fehlermeldung", "");
                  userboxsetcolor(2,1,4);// 4=leuchtend rot
                  messagebox("Fehlermeldung: Fehlerspeicher löschen",
                             "Der Fehlerspeicher von : "+sgbd_name_motor+" kann nicht gelöscht werden."+CRLF+CRLF+
                             "Grund:"+CRLF+
                             "- Datei "+sgbd_name_motor+".IPO existiert nicht im Verzeichnis "+ipo_pfad+CRLF+
                             "- Nur für INPA-Verantwortlichen ("+origin+") :" +CRLF+
                             "  Wurde der INPA-Name "+ "im Script ("+inpa+".SRC) korrekt angegeben?");
                  userboxclose(2);
              }

              INPAapiJob(sgbd_name_motor,"FS_LOESCHEN","","");
              INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
            if (JOB_STATUS != "OKAY")
            {
                userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
                userboxftextout(0,"Der Fehlerspeicher konnte im ",1,3,0,0);
                if (motor_master_flag == TRUE)
                {
                    userboxftextout(0,"Slave-Steuergerät",2,3,0,0);
                }
                else
                {
                    userboxftextout(0,"Master-Steuergerät",2,3,0,0);
                }
                userboxftextout(0,"nicht gelöscht werden!",3,3,0,0);
                userboxsetcolor(0,1,4);
                INPAapiCheckJobStatus("OKAY");
            }
          }

          if ((sgbd_name_motor != "") && (JOB_STATUS == "OKAY"))//Sonderfall: Slavesteuergerät vorhanden, aber Fehler beim Löschen.
          {
              userboxclear(0);
              userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
              userboxftextout(0,"Der Fehlerspeicher wurde im Master und Slave gelöscht!",1,3,0,0);
          }
          else if (sgbd_name_motor == "")//Standardfall
          {
              userboxclear(0);
              userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
              userboxftextout(0,"Der Fehlerspeicher wurde gelöscht!",1,3,0,0);
          }

          if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPTS = DeleteRead  oder SCRIPT = *
          {
              delay(2000);
              userboxclose(0);
              userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
              userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
              INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
              INPAapiFsLesen_neu(sgbd,DateiName_FS_LESEN);
              userboxclose(0);
              viewopen(DateiName_FS_LESEN,"Fehlerspeicher lesen");
              setitem( 9 , "FS drucken"  , TRUE);
              if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
          }
      }
    }
  }
  ITEM( 3 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Infospeicher lesen","");
      userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,DateiName_IS_LESEN);
      userboxclose(0);
      viewopen(DateiName_IS_LESEN,"Infospeicher lesen");
      setitem( 8 , "IS drucken"  , TRUE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
    }
  }
  ITEM( 4 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"IS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
          userboxopen(0,8,35,5,50,"Infospeicher löschen","");
          if (sgbd_name_motor != "")
          {
              userboxftextout(0,"Der Infospeicher konnte im ",1,3,0,0);
              if (motor_master_flag == TRUE)
              {
                  userboxftextout(0,"Master-Steuergerät",2,3,0,0);
              }
              else
              {
                  userboxftextout(0,"Slave-Steuergerät",2,3,0,0);
              }
              userboxftextout(0,"nicht gelöscht werden!",3,3,0,0);
          }
          else//Standardfall
          {
             userboxftextout(0,"Der Infospeicher konnte nicht gelöscht werden!",1,3,0,0);
             if (airbag_is_loeschen_hinweis_flag == TRUE)
             {
                 INP1apiErrorCode(ErrorCode);
                 if (ErrorCode == 0)//Airbag: 0x33: ERROR_ECU_SECURITY_ACCESS_DENIED
                 {
                     INP1apiResultText(fehlerflag,JOB_STATUS,"JOB_STATUS",1,"");
                     if (JOB_STATUS == "ERROR_ECU_SECURITY_ACCESS_DENIED")
                     {
                         userboxftextout(0,"---Er wird nach einmaligen Löschen verriegelt!---",3,3,0,0);
                         userboxftextout(0,"      (Ringspeicher für die Entwicklung.)",4,3,0,0);
                     }
                 }
             }
          }
          userboxsetcolor(0,1,4);
          INPAapiCheckJobStatus("OKAY");
      }
      else
      {
          //Wenn i.O:: Sonderfall 12 Zylinder Motor (ab F01): Master- und Slavesteuergerät löschen!
          //INPA-Script vorhanden?
          if (sgbd_name_motor != "")
          {
              fileexist(ipo_pfad+BS+sgbd_name_motor+".IPO",filecheck);
              if (filecheck != 0)
              {
                  userboxclear(2);
                  userboxopen(2,11,0,9,91,"Fehlermeldung", "");
                  userboxsetcolor(2,1,4);// 4=leuchtend rot
                  messagebox("Fehlermeldung: Infospeicher löschen",
                             "Der Infospeicher von : "+sgbd_name_motor+" kann nicht gelöscht werden."+CRLF+CRLF+
                             "Grund:"+CRLF+
                             "- Datei "+sgbd_name_motor+".IPO existiert nicht im Verzeichnis "+ipo_pfad+CRLF+
                             "- Nur für INPA-Verantwortlichen ("+origin+") :" +CRLF+
                             "  Wurde der INPA-Name "+ "im Script ("+inpa+".SRC) korrekt angegeben?");
                  userboxclose(2);
              }
          }

          if (sgbd_name_motor != "")
          {
              INPAapiJob(sgbd_name_motor,"IS_LOESCHEN","","");
              INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
              if (JOB_STATUS != "OKAY")
              {
                  userboxopen(0,8,35,5,50,"Infospeicher löschen","");
                  userboxftextout(0,"Der Infospeicher konnte im ",1,3,0,0);
                  if (motor_master_flag == TRUE)
                  {
                      userboxftextout(0,"Slave-Steuergerät",2,3,0,0);
                  }
                  else
                  {
                      userboxftextout(0,"Master-Steuergerät",2,3,0,0);
                  }
                  userboxftextout(0,"nicht gelöscht werden!",3,3,0,0);
                  userboxsetcolor(0,1,4);
                  INPAapiCheckJobStatus("OKAY");
              }
          }

          if ((sgbd_name_motor != "") && (JOB_STATUS == "OKAY"))//Sonderfall: Slavesteuergerät vorhanden, aber Fehler beim Löschen.
          {
              userboxclear(0);
              userboxopen(0,8,35,5,50,"Infospeicher löschen","");
              userboxftextout(0,"Der Infospeicher wurde im Master und Slave gelöscht!",1,3,0,0);
          }
          else if (sgbd_name_motor == "")//Standardfall
          {
              userboxclear(0);
              userboxopen(0,8,35,5,50,"Infospeicher löschen","");
              userboxftextout(0,"Der Infospeicher wurde gelöscht!",1,3,0,0);
          }

          if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread  oder SCRIPT = *
          {
              delay(2000);
              userboxclose(0);
              userboxopen(0,8,35,5,50,"Infospeicher lesen","");
              userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
              INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
              INPAapiFsLesen_neu(sgbd,DateiName_IS_LESEN);
              userboxclose(0);
              viewopen(DateiName_IS_LESEN,"Infospeicher lesen");
              setitem( 8 , "IS drucken"  , TRUE);
              if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
          }
      }
    }
  }
  ITEM( 5 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
      userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,DateiName_HS_LESEN);
      userboxclose(0);
      viewopen(DateiName_HS_LESEN,"Historienspeicher lesen");
      setitem( 7 , "HS drucken"  , TRUE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
    }
  }
  ITEM( 6 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (hs_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"HS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
             userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,DateiName_HS_LESEN);
             userboxclose(0);
             viewopen(DateiName_HS_LESEN,"Historienspeicher lesen");
             setitem( 7 , "HS drucken"  , TRUE);
             if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 7 ,"")  {
    if (hs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName_HS_LESEN, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
    }
  }
  ITEM( 8 ,"")  {
    if (is_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName_IS_LESEN, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 9 ,"")  {
    if (fs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName_FS_LESEN, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(17 ,"")  {
    if ((hs_lesen_flag == TRUE) && (hs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen(DateiName_HS_LESEN,"r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Historienspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
      }
    }
  }
  ITEM(18 ,"")  {
    if ((is_lesen_flag == TRUE) && (is_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen(DateiName_IS_LESEN,"r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Infospeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(19 ,"")  {
    if ((fs_lesen_flag == TRUE) && (fs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen(DateiName_FS_LESEN,"r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Fehlerspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    viewclose();
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    viewclose();
    exit();
  }
}

// **************************
// *** Speichermenü       ***
// **************************
MENU m_speicher()
{
  int    input_ok=0;
  int    input_state;
  string text_var;

  INIT {
    setmenutitle("Speicher lesen");
    if (speicher_lesen_lar_flag==TRUE)    setitem( 1 , "LAR"  , TRUE);
    if (speicher_lesen_flash_flag==TRUE)  setitem( 2 , "FLASH", TRUE);
    if (speicher_lesen_uifm_flag==TRUE)   setitem( 3 , "UIFM" , TRUE);
    if (speicher_lesen_romi_flag==TRUE)   setitem( 4 , "ROMI" , TRUE);
    if (speicher_lesen_ramis_flag==TRUE)  setitem( 5 , "RAMIS", TRUE);
    if (speicher_lesen_ramil_flag==TRUE)  setitem( 6 , "RAMIL", TRUE);
    if (speicher_lesen_nvram_flag==TRUE)  setitem( 7 , "NVRAM", TRUE);
    if (speicher_lesen_romx_flag==TRUE)   setitem(14 , "ROMX" , TRUE);
    if (speicher_lesen_ramxx_flag==TRUE)  setitem(15 , "RAMXX", TRUE);
  }
  ITEM( 1 ,"")  {
    if (speicher_lesen_lar_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"LAR lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="LAR lesen";
        speicher_lesen_seg_adr_anz="LAR;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 2 ,"")  {
    if (speicher_lesen_flash_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"FLASH lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="FLASH lesen";
        speicher_lesen_seg_adr_anz="FLASH;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 3 ,"")  {
    if (speicher_lesen_uifm_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"UIFM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="UIFM lesen";
        speicher_lesen_seg_adr_anz="UIFM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 4 ,"")  {
    if (speicher_lesen_romi_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMI lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMI lesen";
        speicher_lesen_seg_adr_anz="ROMI;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 5 ,"")  {
    if (speicher_lesen_ramis_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIS lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIS lesen";
        speicher_lesen_seg_adr_anz="RAMIS;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 6 ,"")  {
    if (speicher_lesen_ramil_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIL lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIL lesen";
        speicher_lesen_seg_adr_anz="RAMIL;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 7 ,"")  {
    if (speicher_lesen_nvram_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"NVRAM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="NVRAM lesen";
        speicher_lesen_seg_adr_anz="NVRAM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 8 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 12 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 14 ,"")  {
    if (speicher_lesen_romx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMX lesen";
        speicher_lesen_seg_adr_anz="ROMX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 15 ,"")  {
    if (speicher_lesen_ramxx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMXX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMXX lesen";
        speicher_lesen_seg_adr_anz="RAMXX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 18 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}


// **************************
// *** Steuernmenü        ***
// **************************
MENU m_fetrawefla()
{
  bool energiesparmode_setzen;
  INIT {
    setmenutitle("Steuern");
   if (set_normalmodus_flag == FALSE)//Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
           setitem( 1 ,"", FALSE);
     else  setitem( 1 ,"Normal", TRUE);

   if (set_fertigungsmodus_flag == FALSE)//Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
           setitem( 2 ,"", FALSE);
     else  setitem( 2 ,"Fertigung", TRUE);

    if (set_transportmodus_flag == FALSE)//Darf nicht bei I-Bus Steuergeräten benutzt werden. VS-Vorgabe, dazu gibt es auch eine Liste.
           setitem( 3 ,"", FALSE);
     else  setitem( 3 ,"Transport", TRUE);
  }
  ITEM( 1 ,"")  {
    if (fetrawe_flag == TRUE)//FeTraWe
    {
        inputdigital(energiesparmode_setzen,"Normalmodus setzen?",
                                            "Auswahl über Cursortasten","Normalmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
          {
           INPAapiJob(sgbd,"energiesparmode","0;0;0","");//FeTraWe
          }
    }
    else //FeTraFla
    {
        inputdigital(energiesparmode_setzen,"Normalmodus setzen?",
                                            "Auswahl über Cursortasten","Normalmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
          {
           INPAapiJob(sgbd,"energiesparmode","0","");    //FeTraFla
          }
    }
    INPAapiCheckJobStatus("OKAY");
  }
  ITEM( 2 ,"")  {
    if (fetrawe_flag == TRUE)//FeTraWe
    {
        inputdigital(energiesparmode_setzen,"Fertigungsmodus setzen?",
                                            "Auswahl über Cursortasten","Fertigungsmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
          {
           INPAapiJob(sgbd,"energiesparmode","0;1;0","");//FeTraWe
          }
    }
    else //FeTraFla
    {
        inputdigital(energiesparmode_setzen,"Fertigungsmodus setzen?",
                                            "Auswahl über Cursortasten","Fertigungsmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
        {
           if (set_extendedSession_flag == TRUE)
           {
              INPAapiJob(sgbd,"diagnose_mode","ECUEXTDIAG","");
              INPAapiCheckJobStatus("OKAY");
           }
           INPAapiJob(sgbd,"energiesparmode","1","");    //FeTraFla
        }
    }
    INPAapiCheckJobStatus("OKAY");
  }
  ITEM( 3 ,"")  {
    if (fetrawe_flag == TRUE)//FeTraWe
    {
        inputdigital(energiesparmode_setzen,"Transportmodus setzen?",
                                            "Auswahl über Cursortasten","Transportmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
        {
           INPAapiJob(sgbd,"energiesparmode","0;0;1","");//FeTraWe
        }
    }
    else //FeTraFla
    {
        inputdigital(energiesparmode_setzen,"Fertigungsmodus setzen?",
                                            "Auswahl über Cursortasten","Transportmodus wird gesetzt.",
                                            "Vorgang abbrechen");
        getinputstate(input_state);
        if ((input_state==input_ok) && (!energiesparmode_setzen))
        {
           INPAapiJob(sgbd,"energiesparmode","2","");    //FeTraFla
        }
    }
    INPAapiCheckJobStatus("OKAY");
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}


// **************************
// *** Hauptscreen        ***
// **************************
SCREEN s_main()
{
  int    i;
  bool   fehlerflag;
  string text_var;
  string temp;
  int    errorcode;
  string errorcode_text;
  string error_text;
  string job_status;

  userboxclose(0);
  ftextout("Hauptmenü",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);

  if (simulation_flag == TRUE)
  {
    userboxopen(1,2,31,5,48,"Hinweis","");
    userboxftextout(1,"INPA bzw. EDIABAS läuft im Simulationsmodus!",1,3,0,24);
    userboxsetcolor(1,0,4);
  }

  LINE("","")
  {
    if (ident_typ != 3)//Nur bei DS2 und BMW Fast vorhanden
    {
      INPAapiJob(sgbd,"IDENT","","");
      INPAapiCheckJobStatus("OKAY");

      ftextout("BMW Teilenummer",1,0,0,0);
      ftextout(":",1,19,0,0);
      INPAapiResultText(text_var,"ID_BMW_NR",1,"");
      ftextout(text_var,1,20,0,1);

      ftextout("Herstelldatum",1,43,0,0);
      ftextout(":",1,59,0,0);
      if (ident_typ == 1)//DS2
      {
        ftextout("KW / Jahr",1,68,0,0);
        ftextout("/",1,63,0,1);
        INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
        ftextout(text_var,1,60,0,1);
        INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
        ftextout(text_var,1,65,0,1);
      }
      else if (ident_typ == 2)//BMW FAST
      {
        INPAapiResultText(text_var,"ID_DATUM",1,"");
        ftextout(text_var,1,60,0,1);
      }
    }

    ftextout("< F1 >  Information"              , 4,5,0,1);

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      ftextout("< F2 >  Identifikation"           , 6,5,0,1);
    }
    else
    {
      ftextout("< F2 >  Steuergeräteverbaukennung"           , 6,5,0,1);//UDS (ISO 14229)
    }

    if (scriptwechsel_flag == TRUE)
        ftextout("< F3 >  INPA-Wechsel"       , 8,5,0,1);

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
        ftextout("< F4 >  Fehlerspeicher"           ,10,5,0,1);

    if (m_status_flag == TRUE)
        ftextout("< F5 >  Status lesen"             ,12,5,0,1);

    if (m_steuern_flag == TRUE)
        ftextout("< F6 >  Ansteuern"                ,14,5,0,1);

    error_text="                                                                   ";
    if (speicher_lesen_flag == TRUE)
        ftextout("< F7 >  Speicher lesen"           ,16,5,0,1);
    else if (fetrawe_flag == TRUE)//--FeTraWe
    {
        ftextout("< F7>  FeTraWe"                    ,16,5,0,1);//Bis F01

        INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
        //hier nicht!:    INPAapiCheckJobStatus("OKAY");
        INP1apiResultInt(fehlerflag,ganz_zahl,"STAT_MODE",1);
        if (fehlerflag == TRUE)
        {
          if (ganz_zahl == 0) text_var= "Normalmodus";                   //Normalmodus
          else
          if (ganz_zahl == 1) text_var= "Fertigungsmodus";               //Fertigungsmodus
          else
          if (ganz_zahl == 2) text_var= "Transportmodus";                //Transportmodus
          else
          if (ganz_zahl == 3) text_var= "Werkstattmodus";                //Werkstattmodus
          else
          {
             inttostring(ganz_zahl, temp);
             text_var= "Wert: "+temp+" ist nicht definiert";
          }
        }
        else
        {
          INP1apiErrorCode(errorcode);
          if (errorcode != 0)
          {
            inttostring(errorcode, errorcode_text);
            INP1apiErrorText(error_text);
            temp= "Ediabas-Fehlermeldung Nr. "+errorcode_text+": ";
            text_var="Job-Status: "+temp;
            //Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
          }
          else
          {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
             INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
             temp= "Job-Status-Fehlermeldung: "+job_status;
             text_var="Job-Status: "+temp;
          }
        }
      ftextout("Aktuell: "+text_var                    ,16,20,0,0);
      ftextout(error_text                              ,17,25,0,0);

    }
    else if (fetrafla_flag == TRUE)//--FeTraFla
    {
        ftextout("< F7>  FeTraFla"                    ,16,5,0,1);//Ab F01
        INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
        //hier nicht!:    INPAapiCheckJobStatus("OKAY");
        INP1apiResultInt(fehlerflag,ganz_zahl,"STAT_ENERGIESPARMODE_WERT",1);
        if (fehlerflag == TRUE)
        {
          if (ganz_zahl == 0) text_var= "Normalmodus";                   //Normalmodus
          else
          if (ganz_zahl == 1) text_var= "Fertigungsmodus";               //F01 eigentlich: Produktionsmodus
          else
          if (ganz_zahl == 2) text_var= "Transportmodus";                //Transportmodus
          else
          if (ganz_zahl == 3) text_var= "Flashmodus";                    //Werkstattmodus
          else
          {
             inttostring(ganz_zahl, temp);
             text_var= "Wert: "+temp+" ist nicht definiert";
          }
        }
        else
        {
          INP1apiErrorCode(errorcode);
          if (errorcode != 0)
          {
            inttostring(errorcode, errorcode_text);
            INP1apiErrorText(error_text);
            temp= "Ediabas-Fehlermeldung Nr. "+errorcode_text+": ";
            text_var="Job-Status: "+temp;
            //Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
          }
          else
          {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
             INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
             temp= "Job-Status-Fehlermeldung: "+job_status;
             text_var="Job-Status: "+temp;
          }
        }
      ftextout("Aktuell: "+text_var+"                                        ",16,20,0,0);
      ftextout(error_text                              ,17,25,0,0);
    }
    if (funktionen_flag == TRUE)
    {
       ftextout("< F8 >  Funktionen"                ,18,5,0,1);
    }
    else
    {
       ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
       ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
       ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    }
    ftextout("< F10>  Ende"                     ,22,5,0,1);
    ftextout("<Shift> + < F1 >  KVP-Editor"     , 4,45,0,1);
    if (sensoren_ident_lesen_flag == TRUE)
       ftextout("<Shift> + < F2>  Sensoren Ident lesen"      , 6,45,0,1);
    if (set_sg_information_flag == TRUE)
       ftextout("<Shift> + < F3>  Steuergeräte-Information"  , 8,45,0,1);
    if (steuergeraete_reset_flag == TRUE)
       ftextout("<Shift> + < F6>  Steuergeräte Reset"        ,14,45,0,1);
    if (sensoren_ident_lesen_flag == TRUE)
       ftextout("<Shift> + < F9>  Sensoren Ident speichern"  ,20,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Infoscreen         ***
// **************************
SCREEN s_info ()
{
  int i;
  int slen;
  int pos;
  int pos2;
  int anzahl;
  string temp;

  ftextout("Information",1,0,1,0);
  ftextout("Nacharbeitsprogrammdatei",4,0,0,0);        ftextout(":", 4,33,0,1); ftextout(inpa+".IPO",4,35,0,1);
  ftextout("Bezeichnung",5,1,0,0);                     ftextout(":", 5,33,0,1); ftextout(titel,5,35,0,1);
  ftextout("Version",6,1,0,0);                         ftextout(":", 6,33,0,1); ftextout(version,6,35,0,1);
  ftextout("Package",7,1,0,0);                         ftextout(":", 7,33,0,1); ftextout(package,7,35,0,1);
  ftextout("Verantwortung",8,1,0,0);                   ftextout(":", 8,33,0,1); ftextout(origin,8,35,0,1);

  ftextout("Gruppendatei",10,0,0,0);                   ftextout(":",10,33,0,1); ftextout(gruppe+".GRP",10,35,0,1);
  ftextout("Bezeichnung",11,1,0,0);                    ftextout(":",11,33,0,1); ftextout(gruppe_ecu,11,35,0,1);
  ftextout("Version",12,1,0,0);                        ftextout(":",12,33,0,1); ftextout(gruppe_revision,12,35,0,1);
  ftextout("Verantwortung",13,1,0,0);                  ftextout(":",13,33,0,1); ftextout(gruppe_origin,13,35,0,1);
  ftextout("Identifizierbare SGBD'en",14,1,0,0);

  strlen(slen, gruppe_comment);
  anzahl=44;
  pos=0;
  if ( slen <= anzahl )
  {
    ftextout(":",14,33,0,1); ftextout(gruppe_comment,14,35,0,1);
  }
  else
  {
    instr(pos2, anzahl, gruppe_comment, ",");
    if (pos2 > 0) anzahl=pos2+1;
    midstr(temp, gruppe_comment, pos, anzahl); ftextout(":",14,33,0,1); ftextout(temp,14,35,0,1);
    i=14;
    pos=pos+anzahl;
    while ( pos < slen )
    {
      i=i+1;
      anzahl=75;
      instr(pos2, pos + anzahl, gruppe_comment, ",");
      if (pos2 > 0) anzahl=pos2+1-pos;
      midstr(temp, gruppe_comment, pos, anzahl); ftextout(temp,i,1,0,1);
      pos=pos+anzahl;
      if ( i >= 18 )
      {
        if ( pos < slen ) ftextout(temp+" . . .",i,1,0,1);
        pos=slen;
      }
    }
  }

  ftextout("Steuergerätebeschreibungsdatei",21,0,0,0); ftextout(":",21,33,0,1); ftextout(sgbd+".PRG",21,35,0,1);
  ftextout("Steuergerät",22,1,0,0);                    ftextout(":",22,33,0,1); ftextout(sgbd_ecu,22,35,0,1);
  ftextout("Version",23,1,0,0);                        ftextout(":",23,33,0,1); ftextout(sgbd_revision,23,35,0,1);
  ftextout("Package",24,1,0,0);                        ftextout(":",24,33,0,1); ftextout(sgbd_package,24,35,0,1);
  ftextout("Verantwortung",25,1,0,0);                  ftextout(":",25,33,0,1); ftextout(sgbd_origin,25,35,0,1);
  ftextout("Sprache",26,1,0,0);                        ftextout(":",26,33,0,1); ftextout(sgbd_sprache,26,35,0,1);
  if (sgbd_comment!="")
  {
    ftextout("Kommentar",27,1,0,0);
    ftextout(":",27,33,0,1);
    ftextout(sgbd_comment,27,35,0,1);
  }
}

// **************************
// *** Identscreen DS2    ***
// **************************
SCREEN s_ident_ds2()
{
  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"IDENT","","");
  INPAapiCheckJobStatus("OKAY");
  LINE("","")
  {
    ftextout("BMW Teilenummer",1,0,1,0);
    ftextout(":",1,33,1,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,35,1,1);

    ftextout("Hardwarenummer",4,0,1,0);
    ftextout(":",4,33,1,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,4,35,1,1);

    ftextout("Softwarenummer",7,0,1,0);
    ftextout(":",7,33,1,0);
    INPAapiResultText(text_var,"ID_SW_NR",1,"");
    ftextout(text_var,7,35,1,1);

    ftextout("Lieferant",10,0,1,0);
    ftextout(":",10,33,1,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,10,35,1,1);

    ftextout("Codier-Index",13,0,1,0);
    ftextout(":",13,33,1,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,13,35,1,1);

    ftextout("Diagnose-Index",16,0,1,0);
    ftextout(":",16,33,1,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,16,35,1,1);

    ftextout("Bus-Index",19,0,1,0);
    ftextout(":",19,33,1,0);
    INPAapiResultText(text_var,"ID_BUS_INDEX",1,"");
    ftextout(text_var,19,35,1,1);

    ftextout("Herstelldatum",22,0,1,0);
    ftextout(":",22,33,1,0);
    ftextout("KW / Jahr",22,55,1,0);
    ftextout("/",22,41,1,1);
    INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
    ftextout(text_var,22,35,1,1);
    INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
    ftextout(text_var,22,45,1,1);
  }
}

// ****************************
// *** Identscreen BMW Fast ***
// ****************************
SCREEN s_ident()
{
  string text_var;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext

  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,1);

  LINE("Identifikation","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");

    ftextout("BMW Teilenummer",1,0,0,0);
    ftextout(":",1,43,0,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,45,0,1);

    ftextout("Codier-Index",3,0,0,0);
    ftextout(":",3,43,0,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,3,45,0,1);

    ftextout("Varianten-Index",5,0,0,0);
    ftextout(":",5,43,0,0);
    INPAapiResultText(text_var,"ID_VAR_INDEX",1,"");
    ftextout(text_var,5,45,0,1);

    ftextout("Diagnose-Index",7,0,0,0);
    ftextout(":",7,43,0,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,7,45,0,1);

    ftextout("Hardwarenummer",9,0,0,0);
    ftextout(":",9,43,0,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,9,45,0,1);

    ftextout("Softwarenummer   Funktionssoftware",11,0,0,0);
    ftextout(":",11,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_FSV",1,"");
    ftextout(text_var,11,45,0,1);

    ftextout("Softwarenummer   Betriebssystem",13,0,0,0);
    ftextout(":",13,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_OSV",1,"");
    ftextout(text_var,13,45,0,1);

    ftextout("Softwarenummer   Nachrichtenkatalog",15,0,0,0);
    ftextout(":",15,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_MCV",1,"");
    ftextout(text_var,15,45,0,1);

    ftextout("Softwarenummer  (Reserve) Zur Zeit nicht benutzt",17,0,0,0);
    ftextout(":",17,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_RES",1,"");
    ftextout(text_var,17,45,0,1);

    ftextout("Herstelldatum",19,0,0,0);
    ftextout(":",19,43,0,0);
    INPAapiResultText(text_var,"ID_DATUM",1,"");
    ftextout(text_var,19,45,0,1);

    ftextout("Lieferant",21,0,0,0);
    ftextout(":",21,43,0,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,21,45,0,1);
  }
// *** AIF, Anwender-Information
// *** auf 2. Seite von IDENT

  LINE("Anwender-Information","")
  {
    INPAapiJob(sgbd,"AIF_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("",10,0,0,0);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Anwenderinfofeld (AIF_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: AIF_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      INPAapiResultInt(ganz_zahl,"AIF_ANZ_DATEN",1);
      if (ganz_zahl > 18)                // lange AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Datensatz Nr.",7,0,0,0);
        ftextout(":",7,43,0,0);
        INPAapiResultText(text_var,"AIF_SW_NR",1,"");
        ftextout(text_var,7,45,0,1);

        ftextout("Behörden Nr.",9,0,0,0);
        ftextout(":",9,43,0,0);
        INPAapiResultText(text_var,"AIF_BEHOERDEN_NR",1,"");
        ftextout(text_var,9,45,0,1);

        ftextout("Händler Nr.",11,0,0,0);
        ftextout(":",11,43,0,0);
        INPAapiResultText(text_var,"AIF_HAENDLER_NR",1,"");
        ftextout(text_var,11,45,0,1);

        ftextout("Tester Nr.",13,0,0,0);
        ftextout(":",13,43,0,0);
        INPAapiResultText(text_var,"AIF_SERIEN_NR",1,"");
        ftextout(text_var,13,45,0,1);

        ftextout("km-Stand",15,0,0,0);
        ftextout(":",15,43,0,0);
        INPAapiResultText(text_var,"AIF_KM",1,"");
        ftextout(text_var,15,45,0,1);

        ftextout("Programm-Stand",17,0,0,0);
        ftextout(":",17,43,0,0);
        INPAapiResultText(text_var,"AIF_PROG_NR",1,"");
        ftextout(text_var,17,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
      else                              //18 Byte -> kurze AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
    }
  }

  LINE("CFG Lesen","")
  {
    INPAapiJob(sgbd,"C_FG_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("Codierdaten",0,0,0,1);
    ftextout("",10,0,0,0);// um auf einer neuen Seite darzustellen

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Fahrgestellnummer lesen (CFG_LESEN) vorhanden          " ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: C_FG_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Fahrgestell Nr.",3,0,0,0);
      ftextout(":",3,43,0,0);
      INPAapiResultText(text_var,"FG_NR",1,"");
      ftextout(text_var,3,45,0,1);
    }

    INPAapiJob(sgbd,"C_AEI_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Codierdatenänderungsindex (C_AEI_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Codierdatenänderungsindex",6,0,0,0);
      ftextout(":",6,43,0,0);
      INPAapiResultText(text_var,"COD_AE_INDEX",1,"");
      ftextout(text_var,6,45,0,1);
    }
  }
}

// ****************************************************************************
// *** Identinformationen werden über SVK_LESEN ermittelt                   ***
// *** SVK: SteuergeräeVerbauKennung Soft- und Hardware für UDS (ISO 14229) ***
// ****************************************************************************
SCREEN s_svk_lesen()
{
  string text_var;
  string text_var2;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  bool   eingabeWeiter;
  int    input_state;              // Eingabestatus
  int    input_ok=1;               // Eingabe  mit Nein beendet
  int    i;
  int    offset;
  int    einheiten_anz;
  int    pos;
  real   realval;
  real   realval2;
  long   longval;
  long   rest_long;
  long   multiplik_long;

  ftextout("Steuergeräteverbaukennung Soft- und Hardware",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("Hersteller Information","")
  {//HERSTELLINFO_LESEN ist kein Pflichtjob! (Stand: 03.2006)
    INPAapiJob(sgbd,"HERSTELLINFO_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Herstellerinformationen vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: HERSTELLINFO_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
//      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Herstelldatum",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"ID_DATUM",1,"");
      ftextout(text_var,1,45,0,1);

      ftextout("Lieferant",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
      ftextout(text_var,2,45,0,1);
//      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
//      ftextout("",4,0,0,0);
    }
  }

  LINE("Seriennummer","")
  {//SERIENNUMMER_LESEN ist ein Pflichtjob!
    INPAapiJob(sgbd,"SERIENNUMMER_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Seriennummer vorhanden" ,1,0,0,0);
//      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: SERIENNUMMER_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
//      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Seriennummer",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"SERIENNUMMER",1,"");
      ftextout(text_var,1,45,0,1);
    }
  }

  LINE("Ident","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if (((fehlerflag == FALSE) /*&& (errorcode != 98)*/) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: IDENT",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Steuergeräte-Adresse",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultInt(ganz_zahl,"ID_SG_ADR",1);
      inttohexstring(ganz_zahl,4,text_var);
      //Führende Nullen ausblenden
      if (ganz_zahl <= 255) midstr(text_var,text_var,2,2);
      ftextout("0x"+text_var,1,45,0,1);

      ftextout("SGBD-Index",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultBinary("_RESPONSE",1);
      GetBinaryDataString (text_var,i);
      midstr(text_var,text_var,6,11);

      ftextout("0x"+text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("SVK","")
  {
    INPAapiJob(sgbd,"SVK_LESEN","","");
    //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
    sets=0;
    INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) || (sets <= 1))
    {
      ftextout("Fehler beim Lesen von Job: SVK_LESEN",1,0,0,0);
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
        ftextout(error_text ,2,0,0,0);
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        ftextout(error_text,2,0,0,0);
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
      ftextout("" ,3,0,0,0);
    }
    else
    {
      INPAapiResultText(text_var,"PROG_DATUM",sets,"");
      ftextout("Programm-Datum",0,0,0,0);
      ftextout(":",0,41,0,0);
      ftextout(text_var,0,45,0,1);

      INPAapiResultText(text_var,"PROG_KM",sets,"");
      if (text_var == "-1") text_var= "- - -";
      ftextout("Programm-km",1,0,0,0);
      ftextout(":",1,41,0,0);
      ftextout(text_var,1,45,0,1);

      INPAapiResultText(text_var,"ANZAHL_EINHEITEN",sets,"");
      INPAapiResultInt(einheiten_anz,"ANZAHL_EINHEITEN",sets);
      ftextout("Anzahl Prozeßklassen",2,0,0,0);
      ftextout(":",2,41,0,0);
      ftextout(text_var,2,45,0,1);

      ftextout("Prozeßklasse",5,2,0,1);
      ftextout("SGBM Identifier ",5,43,0,1);
      ftextout("Version",5,62,0,1);

      i=1;
      offset=0;
      while(i<=einheiten_anz)
      {
        inttostring(i,text_var2);
        INPAapiResultText(text_var,"PROZESSKLASSE_TEXT",i,"");
        ftextout(text_var2+") "+text_var,6+offset,0,0,0);

        //SGBM Identifier
        ftextout(":",6+offset,41,0,0);
        INPAapiResultText(text_var,"SGBM_IDENTIFIER",i,"");
        ftextout(text_var,6+offset,45,0,1);

        //Version
        INPAapiResultText(text_var,"VERSION",i,"");
        ftextout(text_var,6+offset,62,0,1);
        i=i+1;//um nächsten Set zu laden
        offset=offset+1;
      }
    }
  }
}

// **************************
// *** Speicherscreen     ***
// **************************
SCREEN s_speicher()
{
  ftextout("Speicher lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (speicher_lesen_lar_flag==TRUE)    ftextout("< F1 >  LAR lesen"               , 4,5,0,1);
    if (speicher_lesen_flash_flag==TRUE)  ftextout("< F2 >  FLASH lesen"             , 6,5,0,1);
    if (speicher_lesen_uifm_flag==TRUE)   ftextout("< F3 >  UIFM lesen"              , 8,5,0,1);
    if (speicher_lesen_romi_flag==TRUE)   ftextout("< F4 >  ROMI lesen"              ,10,5,0,1);
    if (speicher_lesen_ramis_flag==TRUE)  ftextout("< F5 >  RAMIS lesen"             ,12,5,0,1);
    if (speicher_lesen_ramil_flag==TRUE)  ftextout("< F6 >  RAMIL lesen"             ,14,5,0,1);
    if (speicher_lesen_nvram_flag==TRUE)  ftextout("< F7 >  NVRAM lesen"             ,16,5,0,1);
    if (speicher_lesen_romx_flag==TRUE)   ftextout("<Shift> + < F4 >  ROMX lesen"    ,10,45,0,1);
    if (speicher_lesen_ramxx_flag==TRUE)  ftextout("<Shift> + < F5 >  RAMXX lesen"   ,12,45,0,1);

    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Speicherscreen     ***
// *** Ausgabe            ***
// **************************
SCREEN s_speicher_ausgabe()
{
  string text_var;
  string job_state;

  ftextout(speicher_lesen_text,1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"SPEICHER_LESEN",speicher_lesen_seg_adr_anz,"");
  INPAapiResultText(job_state,"JOB_STATUS",1,"");
  LINE("","")
  {
    ftextout("Startadresse",1,0,0,0);
    ftextout(":",1,18,0,1);
    ftextout(speicher_lesen_adresse,1,20,0,1);
    ftextout("Anzahl",3,0,0,0);
    ftextout(":",3,18,0,1);
    inttostring(speicher_lesen_anzahl,text_var);
    ftextout(text_var,3,20,0,1);
    ftextout("Daten",5,0,0,0);
    ftextout(":",5,18,0,1);
    if(job_state != "OKAY")
      ftextout(job_state,5,20,0,1);
    else
    {
      INPAapiResultBinary("DATEN",1);
      hexdump(speicher_lesen_adresse,speicher_lesen_anzahl,5,20);
    }
  }
}

// **************************
// *** Fehlerscreen       ***
// **************************
SCREEN s_fehler()
{
  ftextout("Fehlerspeicher",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("","")
  {
    if (fs_lesen_flag == TRUE)
    {
      ftextout("< F1 >  Fehlerspeicher lesen"      , 4,5,0,1);
      ftextout("< F2 >  Fehlerspeicher löschen"    , 6,5,0,1);
      ftextout("< F9 >  Fehlerspeicher drucken"    ,20,5,0,1);
      if (fs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F9 >  Fehlerspeicher speichern"   ,20,45,0,1);
    }

    if (is_lesen_flag == TRUE)
    {
      ftextout("< F3 >  Infospeicher lesen"        , 8,5,0,1);
      if (is_loeschen_flag == TRUE) ftextout("< F4 >  Infospeicher löschen"      ,10,5,0,1);
      ftextout("< F8 >  Infospeicher drucken"      ,18,5,0,1);
      if (is_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F8 >  Infospeicher speichern"     ,18,45,0,1);
    }

    if (hs_lesen_flag == TRUE)
    {
      ftextout("< F5 >  Historienspeicher lesen"   ,12,5,0,1);
      if (hs_loeschen_flag == TRUE) ftextout("< F6 >  Historienspeicher löschen" ,14,5,0,1);
      ftextout("< F7 >  Historienspeicher drucken" ,16,5,0,1);
      if (hs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F7 >  Historienspeicher speichern",16,45,0,1);
    }
    ftextout("< F10>  Zurück"                    ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"            ,22,45,0,1);
  }
}


// ****************************
// *** FeTraFlascreen       ***
// ****************************
SCREEN s_fetrawefla()
{
  if (fetrawe_flag == TRUE)
  {
    ftextout("FeTraWe",1,0,1,0);
    ftextout("Fertigungs-, Transport- und Werkstattmodus",2,15,0,0);
  }
  else
  {
    ftextout("FeTraFla",1,0,1,0);
    ftextout("Fertigungs-, Transport- und Flashmodus",2,15,0,0);
  }

  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  if (fetrawe_flag == TRUE)//Bis F01
  {
    INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
    INPAapiCheckJobStatus("OKAY");
    //Es gibt Result "NORMALMODE" daher:
    INPAapiResultInt(ganz_zahl,"STAT_MODE",1);
    if (ganz_zahl == 0) logik_var= 1;
    else logik_var= 0;
    digitalout(logik_var, 9,30,"aktiv           ","nicht aktiv");//Normalmodus

    if (ganz_zahl == 1) logik_var= 1;
    else logik_var= 0;
    digitalout(logik_var,12,30,"aktiv           ","nicht aktiv");//Fertigungsmodus

    if (ganz_zahl == 2) logik_var= 1;
    else logik_var= 0;
    digitalout(logik_var,15,30,"aktiv           ","nicht aktiv");//Transportmodus

    if (ganz_zahl == 3) logik_var= 1;
    else logik_var= 0;
    digitalout(logik_var,18,30,"aktiv           ","nicht aktiv");//Werkstattmodus

    ftextout("< F1 >"                            , 9, 5,0,1);
    ftextout("Normalmodus"                     , 9,12,0,1);
    ftextout("< F2 >"                            ,12, 5,0,1);
    ftextout("Fertigungsmodus"                 ,12,12,0,1);
    if (set_transportmodus_flag)//Darf nicht bei I-Bus Steuergeräten benutzt werden. VS-Vorgabe, dazu gibt es auch eine Liste.
      ftextout("< F3 >"                            ,15, 5,0,1);
    ftextout("Transportmodus"                  ,15,12,0,1);
    ftextout("Werkstattmodus"                  ,18,12,0,1);

    ftextout("< F9 >  Bildschirmdruck"     	,25, 5,0,1);
    ftextout("< F10>  Zurück"              	,27, 5,0,1);
    ftextout("<Shift> + < F10>  Exit"      	,27,45,0,1);
  }
  else //Ab F01:
  {
    INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
    INPAapiCheckJobStatus("OKAY");
    //Es gibt kein Result "NORMALMODE" daher:
    INPAapiResultInt(ganz_zahl,"STAT_ENERGIESPARMODE_WERT",1);
    if (ganz_zahl == 0) logik_var= 1;
    else logik_var= 0;
    digitalout(logik_var, 9,30,"aktiv           ","nicht aktiv");
    INPAapiResultDigital(logik_var,"STAT_PRODUKTIONSMODE_EIN",1);          //Fertigungsmodus/Produktionsmodus
    digitalout(logik_var,12,30,"aktiv           ","nicht aktiv");      //Damit der Anwender nicht irritiert wird, wird auch
    INPAapiResultDigital(logik_var,"STAT_TRANSPORTMODE_EIN",1);            //ab F01 die Bezeichnung Fertigungsmodus statt Produktionsmodus
    digitalout(logik_var,15,30,"aktiv           ","nicht aktiv");      //beibehalten. FeTraFla
    INPAapiResultDigital(logik_var,"STAT_FLASHMODE_EIN",1);                //             Fertigung!!!
    digitalout(logik_var,18,30,"aktiv           ","nicht aktiv");


    if (set_normalmodus_flag == TRUE)    //Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
    {
      ftextout("< F1 >"                            , 9, 5,0,1);
    }
    ftextout("Normalmodus"                     , 9,12,0,1);


    if (set_fertigungsmodus_flag == TRUE)//Im INPA-Script deaktivierbar, falls bei einem SG dieser Modus gesetzt werden soll.
    {
      ftextout("< F2 >"                            ,12, 5,0,1);
    }
    ftextout("Fertigungsmodus"                 ,12,12,0,1);

    if (set_transportmodus_flag == TRUE)//Darf nicht bei I-Bus Steuergeräten benutzt werden. VS-Vorgabe, dazu gibt es auch eine Liste.
    {
      ftextout("< F3 >"                            ,15, 5,0,1);
    }
    ftextout("Transportmodus"                  ,15,12,0,1);
    ftextout("Flashmodus"                      ,18,12,0,1);

    ftextout("< F9 >  Bildschirmdruck"     	,25, 5,0,1);
    ftextout("< F10>  Zurück"              	,27, 5,0,1);
    ftextout("<Shift> + < F10>  Exit"      	,27,45,0,1);
  }
}
// -- EOF --
// end of :#include "BMW_STD.SRC"

// ****************************************************
// ***             Initialisierungsfunktion         ***
// ****************************************************
ScriptInit()
{
//Hier anpassen:                      F7 im Hauptmenü, falls FeTraFla vorhanden (Job "ENERGIESPARMODE"):
  set_extendedSession_flag= FALSE; //                  Sonderfall UDS-SGs z.B. DSC: vor Setzen des Fertigungsmodus muß DIAGNOSE_MODE mit Parameter ECUEXTDIAG gesendet werden.
  set_normalmodus_flag    = TRUE;  //                  FALSE: Der Normalmodus kann nicht gesetzt werden.    (Nur Statusanzeige möglich)
  set_fertigungsmodus_flag= TRUE;  //                  FALSE: DerFertigungsmodus kann nicht gesetzt werden. (Nur Statusanzeige möglich)
  set_transportmodus_flag = TRUE;  //                  FALSE: Der Transportmodus kann nicht gesetzt werden. (Nur Statusanzeige möglich)

  funktionen_flag         = FALSE; // F8 im Hauptmenü: Steuergeräte übergreifende Status und/oder Steuerfunktionen
                                   //                       Wird die Variable auf TRUE gesetzt, müssen Sie "MENU m_funktionen()" und "SCREEN s_funktionen()" befüllen.
  set_sg_information_flag = FALSE; //Shift+F3 im Hautpmenü: Steuergeräte Information. FALSE/TRUE: (de)aktivierbar. (Nützliche SG-Informationen für die Nacharbeit eintragen.)
                                   //                       Wird die Variable auf TRUE gesetzt, müssen Sie "MENU m_sg_information()" und "SCREEN s_sg_information()" befüllen.
  steuergeraete_reset_flag= FALSE;  //Shift+F6 im Hauptmenü: Steuergeräte Reset. FALSE/TRUE: (de)aktivierbar
  steuergeraete_reset_warnung_flag = TRUE; //               TRUE: Warnung wird angezeigt, das der Reset zu Fehlerspeichereinträgen in anderen SGs führen kann.
                                           //               FALSE: Hinweis wird angezeigt, das der Reset zu KEINEN Fehlerspeichereinträgen in anderen SGs führt.



//Hier anpassen: korrigieren, löschen >>>
  if (sgbd=="MED17_2") titel = "MED17_2";
//<<<<


  settitle(titel+" Version "+version);
}

// ****************************************************************************
// ***                         U S E R - Funktionen                         ***
// ****************************************************************************
//********************************************
//**  Ausgabe von Texten                 *****
//********************************************

ergebnisAusgabeTxt(in:string text1, in:string ResultText, in:int Zeile, in:int Spalte,
                    in:int OffsetY1, in:int OffsetX1)
{
  int ergSatz;
  string s_temp="";

  textout(text1,Zeile,Spalte);
  ergSatz=1;
  INPAapiResultText(s_temp,ResultText,ergSatz,"");
  textout(s_temp,Zeile+OffsetY1,Spalte+OffsetX1);
}

//neu
//*******************************************
//**   Ausgabe Int-Werte                *****
//*******************************************

ergebnisAusgabeInt(in:string text1, in:string ResultText, in:int Zeile, in:int Spalte,
                   in:int OffsetY1, in:int OffsetX1)
{
  int ergSatz;
  int i_temp;
  string s_temp,s;

  textout(text1,Zeile,Spalte);
  ergSatz=1;
  INPAapiResultInt(i_temp,ResultText,ergSatz);
  inttostring(i_temp,s_temp);
  textout(s_temp,Zeile+OffsetY1,Spalte+OffsetX1);
}


//neu
//*******************************************
//**   Ausgabe Analog-Werte             *****
//*******************************************

ergebnisAusgabeAnalog(in:string text1, in:string ResultText, in:string format, in:int Zeile, in:int Spalte,
                      in:int OffsetY1, in:int OffsetX1)
{
  int ergSatz;
  real r_temp;
  string s_temp;

  textout(text1,Zeile,Spalte);

  ergSatz=1;

  INPAapiResultAnalog(r_temp,ResultText,ergSatz);
  realtostring(r_temp, format, s_temp);
  textout(s_temp,Zeile+OffsetY1,Spalte+OffsetX1);
}

//** Ausgabe eines Ergebnisses als Analogwert des 1. Satzes mit Job-Status-Ueberpruefung

ergebnisAnalogAusgabe(in: string ergebnis,in: int y,in: int x,
                      in: real min,in: real max,in: real minGueltig,in: real maxGueltig,in: string format)
  {
  real r_temp;
  INPAapiResultAnalog(r_temp,ergebnis,1);
  analogout(r_temp,y,x,min,max,minGueltig,maxGueltig,format);
  }


// Ausgabe eines Ergebnisses als Digitalwert des 1. Satzes mit Job-Status-Ueberpruefung
ergebnisDigitalAusgabe(in: string ergebnis,in: int y,in: int x,in: string trueText,in: string falseText) {
    bool tmpBool;

    INPAapiResultDigital(tmpBool,ergebnis,1);
    digitalout(tmpBool,y,x,trueText,falseText);
}

//** Neuen Sollwert berechnen
//** Job-Status-Ueberpruefung, Grenzen werden ebenfalls abgefangen
llerh(in: int wohin)
{
  int i_help;
  int temp_ll;
  string s1;
  real r_help;
  real r1;

  i_help = ll_wert + wohin;
  if (i_help >= 1200) i_help = 1200;
  if (i_help <= 300) i_help = 0;
  inttostring(i_help,s1);
  INPAapiJob(sgbd,"STOP_SYSTEMCHECK_LLERH","","");
  INPAapiJob(sgbd,"START_SYSTEMCHECK_LLERH",s1,"");
  INPAapiResultText(s1,"JOB_STATUS",1,"");
  if (s1 != "OKAY")	{ messagebox("START_SYSTEMCHECK_LLERH",s1); stop(); }
  ll_wert = i_help;
}

//*************************************
//***   Adaptionen löschen        *****
//*************************************
adaption_loesch(in:int was)
{
  string s1;


  if (was == 1)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","1;0","");
    text_var = "LL-Regelung";
  }
  if (was == 2)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","2;0","");
    text_var = "Klopfregelung";
  }
  if (was == 4)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","4;0","");
    text_var = "Lambdaregelungsfaktor vor KAT";
  }
  if (was == 8)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","8;0","");
    text_var = "Lambdaregelungsfaktor hinter KAT";
  }
  if (was == 16)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","16;0","");
    text_var = "Massenströme zum Saugrohr";
  }
  if (was == 32)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","32;0","");
    text_var = "Höhenadaption fho_w";
  }
  if (was == 64)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","64;0","");
    text_var = "Fuel -Off/-On";
  }
  if (was == 128)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","128;0","");
    text_var = "Lambdaalterung";
  }
  if (was == 256)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","0;1","");
    text_var = "Dynamikvorhalt";
  }
  if (was == 512)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","0;2","");
    text_var = "Bereichserkennung Benzin im Öl";
  }
  if (was == 4096)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","0;16","");
    text_var = "Batterietausch";
  }
  if (was == 16384)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","0;64","");
    text_var = "Hinterachsübersetzung";
  }
  if (was == 32768)
  {
    INPAapiJob(sgbd,"ADAPTIONEN_LOESCHEN","0;128","");
    text_var = "Vanos";
  }

  INPAapiResultText( s1, "JOB_STATUS", 1, "" );
  if ( s1 != "OKAY" ) { messagebox( "ADAPTON_SELEKTIV_LOESCHEN", s1 ); stop(); }
  else {
    s1 = text_var+" erfolgreich gelöscht!";
    textout( s1, 23, 5 );
    delay(2000);
    textout( blank, 23, 0 );
  }
  stop();
}

INPAapiResultLong(out: long returnlong, in: string inparesult,in: int set_val)
{

	real   realval;
	real   realval2;
	long   rest_long;
	long   multiplik_long;
	long   longval;
	long   l_fac=0;

	// Abholen einer LONG Variablen als REAL und Umwandlung in LONG
	INPAapiResultAnalog( realval,inparesult,set_val); //realval=987344.0
	while(realval>2147418112)                       // def. 2147418112 = 65535 * 32767 als Offset um Überlauf zu vermeiden
        {
                realval=realval-2147418112;
                l_fac=l_fac+1;
        }

	realval2= realval/65535;                       //15.0659 (real)
      realtostring(realval2,"12.0",text_var);         //15 (string)
      stringtoint(text_var,ganz_zahl);               //15 (integer)
      inttolong(ganz_zahl,multiplik_long);           //15 (long) Multiplikator

      longval= 65535*multiplik_long;                 //983025= 65535*15 (long)
      longtoreal(longval,realval2);                  //983025 (real)
      realval2= realval-realval2;                    //4319.0= 987344.0-983025.0

      realtoint(realval2, ganz_zahl);                //4319 (integer)
      inttolong(ganz_zahl,rest_long);                //4319 (long) Rest
      longval= (65535*multiplik_long)+rest_long;
      returnlong = (l_fac * 2147418112) + longval;   //Offset wieder aufaddieren
}


exp(out: real ergebnis, in: real basis, in: int exponent) //allgemeine Exponentialfunktion
{
	int i=1;
	real produkt;


        if (exponent == -1) ergebnis = 0; // Um fehlerhafte Eingabe abzufangen
	if (exponent == 0) ergebnis = 1;
	else
	{
		produkt = basis;
		while (i < exponent)
		{
			produkt = produkt * basis;
			i=i+1;
		}
	   ergebnis = produkt;

	}
}

zeigebit(in: int pos1,in: long bitfolge,in: int zeile,in: int spalte) //Bitweise Ausgabe der LONG Variablen
{
	long vergleich_var = 1;
	int i = 0;
	while(i < pos1)
	{

	   i = i+1;
	   vergleich_var= vergleich_var * 2;
	}
	stelle = bitfolge & vergleich_var;
	if(stelle == 0)
	   textout("0",zeile,spalte);
	else
	   textout("1",zeile,spalte);
}

// ****************************************************
// ***             M e n ü a u f b a u              ***
// ****************************************************
// *************************
// *** Scriptwechselmenü ***-----------------------------------------------------------------------F3-Taste-Hauptmenü
// *************************
MENU m_scriptwechsel()
{
//Zwingend:
  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>nicht verändern!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  INIT {
    scriptwechsel_init();
  }
  ITEM( 1 ,"")  {
    scriptwechsel_item(letztes_inpa,letzte_gruppe);
  }
  //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<nicht verändern!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//OPTIONAL:

  ITEM( 2 ,"CAS")  {                      //<-- Funktionstastenbeschriftung eintragen.
    scriptwechsel_item("CAS3","D_CAS3"); //<-- INPA-Scriptnamen, Gruppendatei(en) eintragen auf das umgeschaltet werden soll.
                                             //                      Gruppendateiname(n) aus dem umzuschaltendem INPA-Script übernehmen.
  }
/*
  ITEM( 3 ,"??????")  {
    scriptwechsel_item("??????","D_??????");
  }
  ITEM( 4 ,"???")  {
    scriptwechsel_item("??????","D_??????");
  }
  //.... 5, 6......17,
  ITEM( 18 ,"???")  {
    scriptwechsel_item("??????","D_??????");
  }
*/
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// ******************
// *** Statusmenü ***------------------------------------------------------------------------------F5-Taste-Hauptmenü
// ******************
MENU m_status()
{
  INIT {
    setmenutitle("Status lesen");
  }
  ITEM( 1 ,"Analog1")  {
    setscreen( s_status_analog1 ,TRUE);
  }
  ITEM( 2 ,"Analog2")  {
    setscreen( s_status_analog2 ,TRUE);
  }
  ITEM( 3 ,"Analog3")  {
    setscreen( s_status_analog3 ,TRUE);
  }
  ITEM( 4 ,"Digital1")  {
    setscreen( s_status_digital1 ,TRUE);
  }
  ITEM( 5 ,"Digital2")  {
    setscreen( s_status_digital2 ,TRUE);
  }
  ITEM(  6,"PM - IBS")        {
    setscreen(s_main_pm,TRUE);
    setmenu(m_main_pm);
    }

  ITEM( 7 ,"Systemcheck")  {
    setscreen( s_systemcheck ,TRUE);
    setmenu( m_systemcheck );
  }
  ITEM( 8 ,"Readiness")  {
    setscreen( s_readiness,TRUE);

  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// ***  Systemcheckmenü   ***
// **************************

MENU m_systemcheck()
{
	INIT	{
		setmenutitle("Systemcheck");
	}
	ITEM(1 ,"TEV") {
		setscreen( s_systemcheck_tev , TRUE);
		setmenu( m_systemcheck_tev );
	}
	ITEM(2 ,"LL") {
		setscreen( s_systemcheck_llerh, TRUE );
		setmenu( m_systemcheck_llerh );
	}

	ITEM(3 ,"DMTL") {
		setscreen( s_systemcheck_dmtl , TRUE);
		setmenu( m_systemcheck_dmtl );
	}

	ITEM(4 ,"GrundAdap") {
		setscreen( s_systemcheck_grund, TRUE );
		setmenu( m_systemcheck_grund );
	}
	ITEM(5 ,"IGR") {
		setscreen( s_systemcheck_igr, TRUE );
		setmenu( m_systemcheck_igr );
	}

	ITEM(6 ,"LSVK") {
	     setscreen( s_systemcheck_lsvk, TRUE );
	     setmenu( m_systemcheck_lsvk );
	}
	ITEM(7 ,"LSHK") {
	     setscreen( s_systemcheck_lshk, TRUE );
	     setmenu( m_systemcheck_lshk );
	}
	ITEM(8,"IBS")   {
	        blankscreen();
	        setscreen(s_systemtest_ibs,TRUE);
	        setmenu(m_systemtest_ibs);
	        }

	ITEM(10,"Zurück") {
		setscreen( s_main, TRUE );
		setmenu( m_main );
	}


	ITEM(20,"ENDE") {
		userboxclose(0);
		viewclose();
		exit();
	}
}

// **********************************
// ***  Menü für Systemcheck TEV  ***
// **********************************

MENU m_systemcheck_tev()
{
  INIT {
  	setmenutitle("TEV");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_TEV_FUNC","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK TEV",text_var); stop(); }
    else  setscreen(s_systemcheck_tev,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_TEV_FUNC","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_TEV Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_tev,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}


// *********************************
// *** Menü für LL-Erhöhung      ***
// *********************************
MENU m_systemcheck_llerh()
{
  int ll_help;

  INIT
  {
    setmenutitle("Leerlauferhöhung");
    taste = 0;
  }

  ITEM(1,"+10")
  {
    llerh(10);
    setscreen(s_systemcheck_llerh,TRUE);
    taste = 1;
  }
  ITEM(2,"-10")
  {
    llerh(-10);
    setscreen(s_systemcheck_llerh,TRUE);
    taste = 1;
  }
  ITEM(3,"+100")
  {
    llerh(100);
    setscreen(s_systemcheck_llerh,TRUE);
    taste = 1;
  }
  ITEM(4,"-100")
  {
    llerh(-100);
    setscreen(s_systemcheck_llerh,TRUE);
    taste = 1;
  }
  ITEM(6,"Eingabe")
  {
    input_state = 2;
    while (input_state != 0)
    {
      ll_help = ll_wert;
      inputint(ll_help,"Vorgabe LL-Sollwert","Drehzahl in den Grenzen von 130 < N < 1200",0,1999);
      getinputstate(input_state);
    }
    if (input_state == 0)
    {
      ll_help = ll_help - ll_wert;
      llerh(ll_help);
      blankscreen();
      setscreen(s_systemcheck_llerh,TRUE);
      taste = 1;
    }
  }
  ITEM(9,"STOP")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_LLERH","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_LLERH Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_llerh,TRUE);

  }
  ITEM(10,"Zurück") {blankscreen(); setscreen(s_systemcheck,TRUE); setmenu(m_systemcheck);}
  ITEM(20,"ENDE")   {userboxclose(0); viewclose(); exit();}
}

// **********************************
// ***  Menü für Systemcheck DMTL ***
// **********************************

MENU m_systemcheck_dmtl()
{
  INIT {
  	setmenutitle("DMTL");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_DMTL","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK DMTL",text_var); stop(); }
    else  setscreen(s_systemcheck_dmtl,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_DMTL","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_DMTL Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_dmtl,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// **********************************
// ***   Menü für Grundadaption   ***
// **********************************

MENU m_systemcheck_grund()
{
  INIT {
  	setmenutitle("Grundadaption");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_GRUNDADAPT","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK GRUNDADAPT",text_var); stop(); }
    else  setscreen(s_systemcheck_grund,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_GRUNDADAPT","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_GRUNDADAPT Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_grund,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// ********************************************
// *** Menü Systemdiagnose Ruhestrommessung ***
// ********************************************
MENU m_systemtest_ibs()
{
  string s1, s2, max_i, msb, mz, timo;
  bool b1;
  real r1;
  int i1, i2, l1, p1, t1, status;

  INIT
  {
    setmenutitle("Systemdiagnose Ruhestrommessung");
  }
  ITEM(1,"START")
  {
    userboxclose(0);
    viewclose();
    max_i = "0.08";
    msb = "0.05";
    mz = "0.05";
    timo = "30.0";
    s1 = max_i + ";" + msb + ";" + mz + ";" + timo;
    inputtext(s1, "Parametereingabe Ruhestrommessung","Trennzeichen beachten (Dezimaltrennzeichen = Punkt, Prametertrennzeichen = Semikolon) z.B.");
    getinputstate(input_state);                       // 0 = OK 1 = Abbruch
    if (input_state != 1)
    {
      i1 = 0;
      i2 = 0;
      strlen(l1,s1);
      while (i1 <= l1)
      {
        midstr(s2,s1,i1,1);
        if (s2 == ";")
        {
          i2 = i2 + 1;
          if(i2 == 3)
          {
            p1 = i1 + 1;
            i1 = l1;
          }
        }
        i1 = i1 + 1;
      }
      i1 = l1 - p1;
      midstr(timo,s1,p1,i1);
      stringtoint(timo,t1);
      INPAapiJob(sgbd,"STEUERN_RUHESTROMMESSUNG",s1,"");
      INPAapiResultText(s1,"JOB_STATUS",1,"");
      if (s1 == "OKAY")
      {
        INP1apiJob("UTILITY","STATUS_ZUENDUNG","","");
        INPAapiResultText(s1,"JOB_STATUS",1,"");
        if (s1 != "OKAY")
        {
          messagebox("STATUS_DIGITAL_1",s1);
          stop();
        }
        else
        {
          while(i1 != 0)
          {
            messagebox("Status Ruhestrommessung","Ruhestrommessung läuft! Klemme 15 umgehend deaktivieren!");
            INP1apiJob("UTILITY","STATUS_ZUENDUNG","","");
            INPAapiResultInt(i1,"STAT_ZUENDUNG",1);
          }
          INPAapiJob(sgbd,"SLEEP_MODE_FUNKTIONAL","ALL","");
          while(t1 > 0)
          {
            ftextout("Systemtest Ruhestrommessung",1,0,1,0);

            textout(" < F1  > Start Systemtest Ruhestrommessung",3,5);
            textout(" < F10 > Zurück",5,5);
            textout("< Shift > + < F10 > INPA beenden", 5,45);
            textout("===  Status Ruhestrommessung ===",8,5);
            status = 5;
            inttostring(status,s1);
            textout(blank,10,5);
            textout(s1,10,5);
            s1 = "Funktion laeuft";
            textout(blank,12,5);
            textout(s1,12,5);
            textout("===  Status Diagnosezeit ===",14,5);
            inttostring(t1,s1);
            s1 = "Verbleibende Diagnosezeit: " + s1 + " s";
            textout(blank,16,5);
            textout(s1,16,5);
            textout("Klemme 15",21,5);
            b1 = 0;
            digitalout(b1,22, 5," JA     "," NEIN ");
            text(25,5,"Ruhestrom");
            r1 = 0;
            analogout(r1,26, 5, 0.0, 0.300, 0.0, 0.08,"5.3");
            text(26,41,"A");
            delay(1000);
            t1 = t1 - 1;
            ftextout("Parametereingabe Ruhestrommessung",22,45,0,1);
            textout("1. Parameter = Maximale Ruhestromschwelle",23,45);
            textout("2. Parameter = Messtartbedingung",24,45);
            textout("3. Parameter = Dauer Mittelwertmessung",25,45);
            textout("4. Parameter = Timeoutzeit",26,45);
          }
          messagebox("Status Ruhestrommessung","Klemme 15 aktivieren!");
          delay(1500);
          INP1apiJob("UTILITY","STATUS_ZUENDUNG","","");
          INPAapiResultText(s1,"JOB_STATUS",1,"");
          if (s1 != "OKAY")
          {
            messagebox("STATUS_ZUENDUNG",s1);
            stop();
          }
          setscreen(s_systemtest_ibs,TRUE);
        }
      }
      else
      {
        messagebox("STEUERN_RUHESTROMMESSUNG",s1);
        stop();
      }
    }
    else
    {
      messagebox("Status Ruhestrommessung","Ruhestrommessung erneut starten!");
    }
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// **********************************
// ***   Menü für Systemtest IGR  ***
// **********************************

MENU m_systemcheck_igr()
{
  INIT {
  	setmenutitle("IGR");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_IGR","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK IGR",text_var); stop(); }
    else  setscreen(s_systemcheck_igr,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_IGR","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_IGR Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_igr,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// ***********************************
// ***   Menü für Systemtest LSVK  ***
// ***********************************

MENU m_systemcheck_lsvk()
{
  INIT {
        setmenutitle("LSVK");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_LSVK","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK LSVK",text_var); stop(); }
    else  setscreen(s_systemcheck_lsvk,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_lsvk","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_LSVK Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_lsvk,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// ***********************************
// ***   Menü für Systemtest LSHK  ***
// ***********************************

MENU m_systemcheck_lshk()
{
  INIT {
        setmenutitle("LSHK");
  }

  ITEM(1,"Start")
  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"START_SYSTEMCHECK_LSHK","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") { messagebox("START SYSTEMCHECK LSHK",text_var); stop(); }
    else  setscreen(s_systemcheck_lshk,TRUE);
  }
  ITEM(2,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_lshk","","");
    INPAapiResultText(text_var,"JOB_STATUS",1,"");
    if (text_var != "OKAY") {messagebox("STOP_LSHK Systemtest",text_var); stop();}
    else  setscreen(s_systemcheck_lshk,TRUE);
  }
  ITEM(10,"Zurück")
  {
    userboxclose(0);
    viewclose();
    blankscreen();
    setscreen(s_systemcheck,TRUE);
    setmenu(m_systemcheck);
  }
  ITEM(20,"ENDE")   { userboxclose(0); viewclose(); exit();}
}

// *******************
// *** Steuernmenü ***-----------------------------------------------------------------------------F6-Taste-Hauptmenü
// *******************
MENU m_steuern()
{
  INIT {
    setmenutitle("Steuern");
  }
  ITEM( 1 ,"Adap lösch.") {
  	setscreen(s_adap_loe,TRUE);
  	setmenu(m_adap_loe);
 }
   ITEM( 2,"Stell1") {
  	 setscreen(s_steuern1,TRUE);
  	 setmenu(m_steuern1);
  }
  ITEM( 3,"Stell2") {
  	 setscreen(s_steuern2,TRUE);
  	 setmenu(m_steuern2);
  }
  ITEM( 8 ,"MSA")  {
        setscreen( s_msa,TRUE);
        setmenu( m_msa);
    }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"FOrt")  {
    setscreen( s_fort ,TRUE);
    setmenu( m_fort );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

MENU m_steuern1()
{
  INIT {
    setmenutitle("Steuern 1");
  }
  ITEM( 1 ,"TEV") {
  	setscreen(s_tev,TRUE);
  	setmenu(m_tev);

  }
  ITEM( 2 ,"E_Luef") {
  	setscreen(s_e_luefter,TRUE);

  }
  ITEM( 3 ,"DMTL") {
   	setscreen(s_dmtl,TRUE);

  }
  ITEM( 4 ,"MIL") {
   	setscreen(s_mil,TRUE);

  }
  ITEM( 5 ,"Drosselkl.") {
   	setscreen(s_dk,TRUE);

  }
  ITEM( 6 ,"EKP") {
   	setscreen(s_ekp,TRUE);

}
  ITEM( 7 ,"EML") {
   	setscreen(s_eml,TRUE);

}
  ITEM( 8 ,"MSV") {
   	setscreen(s_msv,TRUE);
   	setmenu(m_msv);

}




  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );
  }



  ITEM( 20 ,"Exit")  {
    exit();
  }
}

MENU m_steuern2()
{
  INIT {
    setmenutitle("Steuern 2");
  }
  ITEM( 1 ,"LSHVK") {
  	setscreen(s_lshvk,TRUE);
  	setmenu(m_lshvk);

  }
  ITEM( 11 ,"LSHHK") {
  	setscreen(s_lshhk,TRUE);
	setmenu(m_lshhk);
  }
  ITEM( 2 ,"WAPUT") {
   	setscreen(s_waput,TRUE);
	  	setmenu(m_waput);
  }
  ITEM( 3 ,"KFK") {
   	setscreen(s_kfk,TRUE);
	  	setmenu(m_kfk);
  }
  ITEM( 4 ,"VANOS ein") {
   	setscreen(s_vanos_ein,TRUE);
   	setmenu(m_vanos_ein);

  }
  ITEM( 5 ,"ULV") {
   	setscreen(s_ulv,TRUE);
   	setmenu(m_ulv);

}
  ITEM( 6 ,"WGV") {
   	setscreen(s_wgv,TRUE);
   	setmenu(m_wgv);

}
  ITEM( 7 ,"KGEH") {
   	setscreen(s_kgeh,TRUE);
   	setmenu(m_kgeh);

}


  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );
  }



  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// *******************************
// *** Menü Adaptionen löschen ***
// *******************************
MENU m_adap_loe()
{
	INIT {
		setmenutitle("Adaptionen löschen");
	}
	ITEM( 1 ,"LL-Reg") { adaption_loesch(1); }
	ITEM( 2 ,"Klopf") { adaption_loesch(2); }
	ITEM( 3 ,"L-Sonde v.KAT") { adaption_loesch(4); }
	ITEM( 4 ,"L-Sonde n.KAT") { adaption_loesch(8); }
	ITEM( 5 ,"Massenstr.") { adaption_loesch(16); }
	ITEM( 6 ,"Höhenad") { adaption_loesch(32); }
	ITEM( 7 ,"Fuell") { adaption_loesch(64); }
	ITEM( 8 ,"L-Sond.Alt") { adaption_loesch(128); }
	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")  {
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );
   }
   ITEM( 11 ,"Dynamik") { adaption_loesch(256); }
   ITEM( 12 ,"Benz i.Öl") { adaption_loesch(512); }
   ITEM( 13 ,"Batteriet") { adaption_loesch(4096); }
   ITEM( 14 ,"HiAchse") { adaption_loesch(16384); }
   ITEM( 15 ,"Vanos") { adaption_loesch(32768); }
   ITEM( 20 ,"Exit")  {
    exit();
  }
}

// *******************************
// *** Menü E-Luefter ansteuern***
// *******************************
MENU m_e_luefter()
{
	INIT {
		setmenutitle("E-Luefter ansteuern");
	}
	ITEM( 1 ,"E-Luef. St1")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_e_luefter,TRUE);
        	userboxopen(0,1,20,1,50,"Steuern","    E-Lüfter Stufe 1 ein");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_E_LUEFTER",";55;15","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(15000);
	        userboxclose(0);
    	}

   ITEM( 2 ,"E-Luef. St2")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_e_luefter,TRUE);
        	userboxopen(0,1,20,1,50,"Steuern","    E-Lüfter Stufe 2 ein");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_E_LUEFTER",";100;15","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(15000);
	        userboxclose(0);
    	}


	ITEM( 3 ,"E-Luef. aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_e_luefter,TRUE);
        	userboxopen(0,1,20,1,50,"Steuern","    E-Lüfter aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_E_LUEFTER","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(1000);
	        userboxclose(0);
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_tev()
{
	string tmp;
	INIT {
		setmenutitle("TEV ansteuern");
	}
	ITEM( 1 ,"50%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    TEV 50% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_TEV",";50;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 2 ,"90%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    TEV 90% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_TEV",";90;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 4,"...%")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(tast,"Vorgabe Tastverhältnis","Prozentwert von 0-100",0,100);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    TEV "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_TEV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    TEV "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_TEV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    TEV beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_TEV","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_msv()
{
	string tmp;
	INIT {
		setmenutitle("MSV ansteuern");
	}
	ITEM( 1 ,"5 MPa")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    MSV 5MPa "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_MSV","5;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}



   ITEM( 4,"...MPa")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(tast,"Vorgabe Solldruck","Wert von 5-8MPa",5,8);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    MSV "+tmp+"MPa "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_MSV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    MSV "+tmp+"MPa "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_MSV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    MSV beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_MSV","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


// ********************************
// ***    Menü DMTL ansteuern   ***
// ********************************
MENU m_dmtl()
{
	INIT {
		setmenutitle("DMTL ansteuern");
	}
	ITEM( 1 ,"DMTL Pumpe")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_pump,TRUE);
        	setmenu( m_dmtl_pump);
    	}
	ITEM( 2 ,"DMTL Heiz.")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_heat,TRUE);
        	setmenu( m_dmtl_heat);

	}
	ITEM( 3 ,"DMTL Ventil")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_valve,TRUE);
        	setmenu( m_dmtl_valve);
	}

	ITEM( 9 ,"Druck")
	{
    		printscreen();
    	}
   	ITEM( 10 ,"Zurück")
	{
	    setscreen( s_steuern1 ,TRUE);
	    setmenu( m_steuern1 );
	}

	ITEM( 20 ,"Exit")
	{
	    exit();
	}
}


// ********************************
// *** Menü DMTL Pumpe ansteuern***
// ********************************
MENU m_dmtl_pump()
{
	INIT {
		setmenutitle("DMTL Pumpe ansteuern");
	}
	ITEM( 1 ,"Pumpe ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_pump,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Pumpe an");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_DMTLP","3","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(3000);
	        userboxclose(0);
    	}
	ITEM( 2 ,"Pumpe aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_pump,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Pumpe aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_DMTLP","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(800);
	        userboxclose(0);
	}


	ITEM( 9 ,"Druck")
	{
    		printscreen();
    	}
   	ITEM( 10 ,"Zurück")
	{
	    setscreen( s_dmtl,TRUE);
	    setmenu( m_dmtl );
	}

	ITEM( 20 ,"Exit")
	{
	    exit();
	}
}
//???? Ventil und Heizung noch genauer spezifizieren!!!Jobs inkorrekt

// ***********************************
// *** Menü DMTL Heizung ansteuern ***
// ***********************************
MENU m_dmtl_heat()
{
	INIT {
		setmenutitle("DMTL Heizung ansteuern");
	}
	ITEM( 1 ,"Heizung ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_heat,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Heizung an");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_DMTLH","3","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(3000);
	        userboxclose(0);
    	}
	ITEM( 2 ,"Heizung aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_heat,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Heizung aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_DMTLH","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(800);
	        userboxclose(0);
	}


	ITEM( 9 ,"Druck")
	{
    		printscreen();
    	}
   	ITEM( 10 ,"Zurück")
	{
	    setscreen( s_dmtl,TRUE);
	    setmenu( m_dmtl );
	}

	ITEM( 20 ,"Exit")
	{
	    exit();
	}
}



// ***********************************
// *** Menü DMTL Ventil ansteuern  ***
// ***********************************
MENU m_dmtl_valve()
{
	INIT {
		setmenutitle("DMTL Ventil ansteuern");
	}
	ITEM( 1 ,"Ventil ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_valve,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Ventil an");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_DMTLV","3","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(3000);
	        userboxclose(0);
    	}
	ITEM( 2 ,"Ventil aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dmtl_heat,TRUE);
        	userboxopen(0,1,20,1,50,"DMTL","Ventil aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_DMTLV","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(800);
	        userboxclose(0);
	}


	ITEM( 9 ,"Druck")
	{
    		printscreen();
    	}
   	ITEM( 10 ,"Zurück")
	{
	    setscreen( s_dmtl,TRUE);
	    setmenu( m_dmtl );
	}

	ITEM( 20 ,"Exit")
	{
	    exit();
	}
}


// ********************************
// *** Menü MIL ansteuern***
// ********************************
MENU m_mil()
{
	INIT {
		setmenutitle("MIL ansteuern");
	}
	ITEM( 1 ,"MIL an")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_mil,TRUE);
        	userboxopen(0,1,20,1,50,"MIL","    ansteuern");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_MIL","2","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(2000);
	        userboxclose(0);
    	}

	ITEM( 2 ,"MIL aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_mil,TRUE);
        	userboxopen(0,1,20,1,50,"MIL","    aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_MIL","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(1000);
	        userboxclose(0);
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


// ************************************
// *** Menü Drosselklappe ansteuern ***
// ************************************
MENU m_dk()
{
	INIT {
		setmenutitle("Drosselklappe ansteuern");
	}
	ITEM( 1 ,"Ansteuerung DK an")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dk,TRUE);
        	userboxopen(0,1,20,1,50,"Drosselklappe","    ansteuern");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_DK",";100;3","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(3000);
	        userboxclose(0);
    	}

	ITEM( 2 ,"Ansteuerung DK aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_dk,TRUE);
        	userboxopen(0,1,20,1,50,"Ansteuerung Drosselklappe","aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_DK","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(1000);
	        userboxclose(0);
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

// **************************
// *** Menü EKP ansteuern ***
// **************************
MENU m_ekp()
{
	INIT {
		setmenutitle("EKP ansteuern");
	}
	ITEM( 1 ,"EKP an")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_ekp,TRUE);
        	userboxopen(0,1,20,1,50,"EKP","    ansteuern");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_EKP","3","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(3000);
	        userboxclose(0);
    	}

	ITEM( 2 ,"EKP aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_ekp,TRUE);
        	userboxopen(0,1,20,1,50,"EKP","aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_EKP","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(1000);
	        userboxclose(0);
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

// **************************
// *** Menü EML ansteuern ***
// **************************
MENU m_eml()
{
	INIT {
		setmenutitle("EML ansteuern");
	}
	ITEM( 1 ,"EML an")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_eml,TRUE);
        	userboxopen(0,1,20,1,50,"EML","    ansteuern");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_EML","2","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(2000);
	        userboxclose(0);
    	}
	ITEM( 2 ,"EML aus")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen
        	setscreen( s_eml,TRUE);
        	userboxopen(0,1,20,1,50,"EML","aus");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_EML","","");
	        INPAapiCheckJobStatus("OKAY");

	        delay(1000);
	        userboxclose(0);
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern1 ,TRUE);
    setmenu( m_steuern1 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_lshvk()
{
	string tmp;
	INIT {
		setmenutitle("LSHVK ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    LSHVK "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_LSHVK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    LSHVK "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_LSHVK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    LSHVK beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_LSHVK","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

MENU m_lshhk()
{
	string tmp;
	INIT {
		setmenutitle("LSHHK ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    LSHHK "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_LSHHK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    LSHHK "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_LSHHK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    LSHHK beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_LSHHK","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_waput()
{
	string tmp;
	INIT {
		setmenutitle("WAPUT ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Wasserpumpe Turbolader "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WAPUT",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    Wasserpumpe Turbolader "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WAPUT",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    Wasserpumpe Turbolader beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_WAPUT","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

MENU m_kfk()
{
	string tmp;
	INIT {
		setmenutitle("KFK ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Kennfeldthermostat "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_KFK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    Kennfeldthermostat "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_KFK",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    Kennfeldthermostat beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_KFK","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_vanos_ein()
{
	string tmp;
	INIT {
		setmenutitle("VANOS  ansteuern");
	}
	ITEM( 1 ,"50%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    VANOS 50% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_VANOS_EINLASS",";50;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 2 ,"90%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    VANOS 90% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_VANOS_EINLASS",";90;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 4,"...%")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(tast,"Vorgabe Tastverhältnis","Prozentwert von 0-100",0,100);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    VANOS "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_VANOS_EINLASS",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    VANOS "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_VANOS_EINLASS",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    VANOS beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_VANOS_EINLASS","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_ulv()
{
	string tmp;
	INIT {
		setmenutitle("ULV ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Umluftventil "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ULV",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    Umluftventil "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ULV",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    Umluftventil beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_ULV","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

MENU m_wgv()
{
	string tmp;
	INIT {
		setmenutitle("Wastegate Ventil  ansteuern");
	}
	ITEM( 1 ,"50%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Wastegate Ventil 50% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WGV",";50;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 2 ,"90%")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Wastegate Ventil 90% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WGV",";90;"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 4,"...%")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(tast,"Vorgabe Tastverhältnis","Prozentwert von 0-100",0,100);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    Wastegate Ventil "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WGV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);
      inttostring(tast,tmp);
        	userboxopen(0,1,20,1,50,"Steuern","    Wastegate Ventil "+tmp+"% "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_WGV",";"+tmp+";"+text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    Wastegate Ventil beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_WGV","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}


MENU m_kgeh()
{
	string tmp;
	INIT {
		setmenutitle("KGEH ansteuern");
	}
	ITEM( 1 ,"ein")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	inttostring(timeout,text_var);
        	userboxopen(0,1,20,1,50,"Steuern","    Kurbelgeh.Entl. "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_KGEH",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    	}

   ITEM( 5,"Dauer")
   {
   	userboxclose(0);
   	input_state = 2;


      inputint(timeout,"Vorgabe Dauer","Dauer von 0-510s (Standard: 20s)",0,510);
      getinputstate(input_state);

    if (input_state == 0)
    {
      inttostring(timeout,text_var);

        	userboxopen(0,1,20,1,50,"Steuern","    Kurbelgeh.Entl. "+text_var+" sec");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_KGEH",text_var,"");
	        INPAapiCheckJobStatus("OKAY");

	        delay(timeout*1000);
	        userboxclose(0);
	        start();
    }
   }


	ITEM( 7 ,"Ende")
	{
		userboxclose(0);    // bereits aktive User-Box schliessen

        	userboxopen(0,1,20,1,50,"Steuern","    Kurbelgeh.Entl. beendet");

	        // Ansteuern
	        INPAapiJob(sgbd,"STEUERN_ENDE_KGEH","","");
	        INPAapiCheckJobStatus("OKAY");
	        timeout=20;
	        tast=50;
	        delay(1000);
	        userboxclose(0);
	        start();
	}

	ITEM( 9 ,"Druck")  {
    printscreen();
    }
   ITEM( 10 ,"Zurück")
   {
    setscreen( s_steuern2 ,TRUE);
    setmenu( m_steuern2 );
   }

   ITEM( 20 ,"Exit")
   {
    exit();
   }
}

// **************************************
// *** Menue fuer IBS Powermanagement ***
// **************************************
MENU m_main_pm()
{
  INIT
  {
    setmenutitle("Powermanagement");
  }

  ITEM(1,"IDENT")  { setscreen(s_ibs_ident,TRUE); }
  ITEM(2,"PM Feld 1") { setscreen(s_pm_feld1,TRUE); }
  ITEM(3,"PM Feld 2") { setscreen(s_pm_feld2,TRUE); }
  ITEM(4,"PM Feld 3") { setscreen(s_pm_feld3,TRUE); }
  ITEM(5,"B Tausch")
  {
    INPAapiJob(sgbd,"STEUERN_BATTERIETAUSCH_REGISTRIEREN","","");
    INPAapiResultText(text_var, "JOB_STATUS", 1,"");
    if (text_var == "OKAY") { messagebox("Batterietausch B_fabttreg",text_var); }
    else { messagebox("STEUERN_BATTERIETAUSCH_REGISTRIEREN",text_var); stop(); }
  }

  ITEM(6,"Reset")
  {
    INPAapiJob(sgbd,"STEUERN_PM_HISTOGRAM_RESET","","");
    INPAapiResultText(text_var, "JOB_STATUS", 1,"");
    if (text_var == "OKAY") { messagebox("PM_HISTOGRAM_RESET",text_var); }
    else { messagebox("STEUERN_PM_HISTOGRAM_RESET",text_var); stop(); }
  }

  ITEM(7,"Start")
  {
    INPAapiJob(sgbd,"START_SYSTEMCHECK_PM_MESSEMODE","","");
    INPAapiResultText(text_var, "JOB_STATUS", 1,"");
    if (text_var == "OKAY") { messagebox("Start PM_MESSEMODE",text_var); }
    else { messagebox("START_SYSTEMCHECK_PM_MESSEMODE",text_var); stop(); }
  }

  ITEM(8,"Stop")
  {
    INPAapiJob(sgbd,"STOP_SYSTEMCHECK_PM_MESSEMODE","","");
    INPAapiResultText(text_var, "JOB_STATUS", 1,"");
    if (text_var == "OKAY") { messagebox("Stop PM_MESSEMODE",text_var); }
    else { messagebox("Stop PM_MESSEMODE",text_var); stop(); }
  }

  ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_status,TRUE);
    setmenu(m_status);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}


// **************************************
// *** Menue fuer MSA***
// **************************************
MENU m_msa()
{
  INIT
  {
    setmenutitle("Menü");
  }

  ITEM(1, "NG lernen")
  {
  	 userboxclose(0); viewclose();
  	 setscreen(s_msa_lern,TRUE);
  	 setmenu(m_msa_lern);
  }

  ITEM(2, "MSA akt.")
  {
  	 if(!msa_deak_var) {
  	 	INPAapiJob(sgbd, "STEUERN_ENDE_MSA_DEAK","","");
  	 	INPAapiResultText(text_var,"JOB_STATUS",1,"");
  	 	if (text_var == "OKAY")
  	 	 messagebox("MSA Steuern","MSA aktiviert");
  	 	else
  	 	 messagebox("MSA Steuern","Fehler in der Ausführung: STEUERN_ENDE_MSA_DEAK");
  	 	}
  	 else {
  	 	INPAapiJob(sgbd, "STEUERN_MSA_DEAK","","");
  	 	INPAapiResultText(text_var,"JOB_STATUS",1,"");
  	 	if (text_var == "OKAY")
  	 	 messagebox("MSA Steuern","MSA deaktiviert");
  	 	else
  	 	 messagebox("MSA Steuern","Fehler in der Ausführung: STEUERN_MSA_DEAK");
  	 	}
  	 setscreen(s_msa,TRUE);
  	}

  	ITEM(3, "MH Kontakt")
  	{
  		INPAapiJob( "D_CAS" ,"STATUS_CAS_DIAGNOSE","","");
  		INPAapiCheckJobStatus("OKAY");
  		INPAapiResultDigital(logik_var,"STAT_CT_BON",1);
  		if(logik_var)
  			messagebox("MSA Steuern","Motorhaube geöffnet");
  			else
  				messagebox("MSA Steuern","Motorhaube geschlossen");
  	}
  	ITEM(4, "MSA Status") {
  		setscreen( s_msa_stat,TRUE);
  		setmenu(m_msa_status);
  	}
  	ITEM(5, "MSA AV") {
  		setscreen( s_msa_av,TRUE);
  		setmenu(m_msa_status);
  	}
  	ITEM(6, "MSA AA") {
  		setscreen( s_msa_aa,TRUE);
  		setmenu(m_msa_status);
  	}
  	ITEM(7, "MSA EV") {
  		setscreen( s_msa_ev,TRUE);
  		setmenu(m_msa_status);
  	}
  	ITEM(8, "MSA EA") {
  		setscreen( s_msa_ea,TRUE);
  		setmenu(m_msa_status);
  	}

  	ITEM(9, "MSA AV DEAK") {
  		setscreen( s_msa_deak_av,TRUE);
  		setmenu(m_msa_deak_av);
  	}




  ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_steuern,TRUE);
    setmenu(m_steuern);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}


MENU m_msa_status()
{
  INIT
  {
    setmenutitle("Menü");
  }
	/*ITEM(1, "Stop refresh") {
		stop;
	}
	ITEM(2, "Refresh") {
		start;
	}*/

  	ITEM(4, "MSA Status") {
  		setscreen( s_msa_stat,TRUE);
  	}
  	ITEM(5, "MSA AV") {
  		setscreen( s_msa_av,TRUE);
  	}
  	ITEM(6, "MSA AA") {
  		setscreen( s_msa_aa,TRUE);
  	}
  	ITEM(7, "MSA EV") {
  		setscreen( s_msa_ev,TRUE);
  	}
  	ITEM(8, "MSA EA") {
  		setscreen( s_msa_ea,TRUE);
  	}

  	ITEM(9, "MSA AV DEAK") {
  		setscreen( s_msa_deak_av,TRUE);
  		setmenu(m_msa_deak_av);
  	}




  ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_msa,TRUE);
    setmenu(m_msa);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}

MENU m_msa_deak_av()
{
  string tmp1;
  string tmp2;
  string tmp3;
  int i;
  int len;
  int zeichen;
  int strstart;
  real bitfolge;
  INIT
  {
    setmenutitle("Menü");
  }
	ITEM(1, "Deak AV") {
		//inputint( ganz_zahl, "Deaktiviere AV Nr.", "Eingabe (1-17):", 1, 17);
		inputtext( text_var, "Deaktiviere AVs Nr.", "Eingabe (1-17) durch Strichpunkt getrennt z.B. 5;15");
      getinputstate( input_state);
      strlen(len,text_var);
      i=0;
      strstart=0;
      bitfolge=0;
      len = len-1;
      while(i<=len)
      {
      	midstr(tmp1,text_var,i,1);
      	stringtoint(tmp1,zeichen);
      	if (tmp1 == ";")
      	{

      		zeichen = i- strstart;
      		midstr(tmp2,text_var,strstart,zeichen);
      		stringtoint(tmp2,ganz_zahl);
      		if(ganz_zahl<=17)
      		{
      			exp(zahlen_var,2,ganz_zahl-1);
      			bitfolge = bitfolge + zahlen_var;
      		}

      		i=i+1;
      		strstart = i;

      	}
      	else if((zeichen == 0) && (tmp1 != "0") )
      	{
      		messagebox("Deaktiviere AVs","Fehlerhafte Eingabe");
      		bitfolge=0;
      		i=len+1;
      	}
      	else if(i==len)
      	{
      		zeichen = i- strstart+1;
      		midstr(tmp2,text_var,strstart,zeichen);
      		stringtoint(tmp2,ganz_zahl);
      		if(ganz_zahl<=17)
      		{
      			exp(zahlen_var,2,ganz_zahl-1);
      			bitfolge = bitfolge + zahlen_var;
      		}
      		i=i+1;
      		strstart = i;
      	}

      	else

      		i=i+1;
      }
      realtostring(bitfolge,"10.0",text_var);
      INPAapiJob(sgbd, "STEUERN_MSA_DEAK_AV",text_var,"");
      INPAapiCheckJobStatus("OKAY");

	}
	ITEM(2, "alle") {
		INPAapiJob(sgbd, "STEUERN_MSA_DEAK_AV","4294967295","");
		INPAapiResultText(text_var,"JOB_STATUS",1,"");
		if(text_var=="OKAY")
			messagebox("STEUERN_MSA_DEAK_AV","alle neutralisierbaren AVs deaktiviert");
		else
			messagebox("STEUERN_MSA_DEAK_AV",text_var);

	}

  	ITEM(3, "ENDE Deak") {
		INPAapiJob(sgbd, "STEUERN_ENDE_MSA_DEAK_AV","","");
		INPAapiResultText(text_var,"JOB_STATUS",1,"");
		if(text_var=="OKAY")
			messagebox("STEUERN_ENDE_MSA_DEAK_AV","Deaktivierung beendet");
		else
			messagebox("STEUERN_ENDE_MSA_DEAK_AV",text_var);

	}






  ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_msa,TRUE);
    setmenu(m_msa);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}


MENU m_msa_lern()
{
  INIT
  {
    setmenutitle("Menü");
  }


  ITEM( 1,"NG lernen")
  {
  	if(randbed)
  	 {
  	 INPAapiJob(sgbd, "STEUERN_NULLGANG_LERNEN","","");
  	 INPAapiResultText(text_var,"JOB_STATUS",1,"");
  	 if(text_var == "OKAY")
  	 {
  	 	delay(3000);
  	 	INPAapiJob(sgbd, "STATUS_NULLGANG_ERKENNUNG","","");
  	 	INPAapiResultAnalog(zahlen_var,"STAT_PHY_NG_LERN_WERT",1);
        	if(zahlen_var ==0)
        	{
        		messagebox("MSA Nullgang lernen","Fehler: Nullgangstellung nicht gelernt");
        	}
        	else
        	{
        		messagebox("MSA Nullgang lernen","Nullgangstellung gelernt");
        	}
  	 }
  	 else
  	  messagebox("MSA Nullgang lernen","Fehler: " + text_var);
  	 }
  	else
  		messagebox("MSA Nullgang lernen","Rangbedingungen nicht erfüllt! - Job nicht ausgeführt");
  	}



  ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_msa,TRUE);
    setmenu(m_msa);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}

MENU m_fort()
{
	INIT
	{
		setmenutitle("Fehlerort");
	}

	ITEM( 1,"Eingabe")
	{
	 input_state = 2;
    while (input_state != 0)
    {

      inputhex(fort_hex,"Fehlerort","HEXString Eingabe z.B. 0x2884","0x0000","0xFFFF");
      getinputstate(input_state);
    }
    if (input_state == 0)
    {

      blankscreen();
      setscreen(s_fort,TRUE);

    }
   }
   ITEM( 2,"Turbo min")
   {
   	fort_hex="0x2884";
   	blankscreen();
      setscreen(s_fort,TRUE);
   }
   ITEM( 3,"Turbo max")
   {
   	fort_hex="0x2885";
   	blankscreen();
      setscreen(s_fort,TRUE);
   }
   ITEM(10,"Zurück")
  {
    blankscreen();
    setscreen(s_steuern,TRUE);
    setmenu(m_steuern);
  }
  ITEM(20 ,"ENDE")  {userboxclose(0); viewclose(); exit();}
}

// **********************
// *** Funktionenmenü ***--------------------------------------------------------------------------F8-Taste-Hauptmenü
// **********************
//Wird aktiviert, deaktiviert über Variable "funktionen_flag"
MENU m_funktionen()
{//Die Tastenbelegungen müssen Sie Ihren Umfängen anpassen! Nur belegte Tasten ausgeben.

  INIT {
    setmenutitle("Funktionen");
  }
  ITEM( 1 ,"")  {
//    setscreen( s_??????,TRUE);
  }
  ITEM( 2 ,"")  {
//    setscreen( s_??????,TRUE);
  }
  ITEM( 3 ,"")  {
//    setscreen( s_??????,TRUE);
  }
  ITEM( 4 ,"")  {
//    setscreen( s_??????,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// ********************************
// *** Steuergeräte-Information ***----------------------------------------------------------------F13-Taste-Hauptmenü
// ********************************
MENU m_sg_information()
{//Die Tastenbelegungen müssen Sie Ihren Umfängen anpassen! Nur belegte Tasten ausgeben.
  INIT {
    setmenutitle("Steuergeräte-Information");

    //*********Eintragen:         **********************************************
    sg_information_titel= "!!!-Beispiel-Beispiel-Beispiel-!!!"; //wird von allen F-Tasten übernommen. z.B.: Motor, Getriebe, ACSM etc.
  }
  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>nicht verändern!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ITEM( 1 ,"Schnittstelle")  {
    setscreen( s_sg_information_schnittstellen,TRUE);
  }
  ITEM( 2 ,"Bordnetz")  {
    setscreen( s_sg_information_bordnetz,TRUE);
  }
  ITEM( 3 ,"Verbauort")  {
    setscreen( s_sg_information_verbauort,TRUE);
  }
  ITEM( 4 ,"Allgemeines")  {
    setscreen( s_sg_information_allgemeines,TRUE);
  }
  ITEM( 5 ,"Kundenfunkt.")  {
    setscreen( s_sg_information_kundenfunktion,TRUE);
  }
  //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<nicht verändern!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//OPTIONAL:
  ITEM( 6 ,"")  {
//    setscreen( s_sg_information_??????,TRUE);
  }
  ITEM( 7 ,"")  {
//    setscreen( s_sg_information_??????,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// ******************************************************************************************************************
// ***             S c r e e n a u f b a u          ***
// ****************************************************
// ***************************
// *** Scriptwechselscreen ***---------------------------------------------------------------------F3-Taste-Hauptmenü
// ***************************
SCREEN s_scriptwechsel()
{
//Zwingend:
  //>>>nicht verändern!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ftextout("INPA - Nacharbeitsprogramm-Wechsel",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("","")
  {
    ftextout("< F1 > Rücksprung zum letzten Nacharbeitsprogramm ("+letztes_inpa+")" 	, 4, 5,0,1);
    //<<<nicht verändern!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //Ab hier Steuergeräte eintragen auf die umgeschaltet werden soll. Anpassung auch unter "SCREEN m_scriptwechsel()" vornehmen!

//OPTIONAL:
    //Hier Beispiel: Gurtaufroller links und rechts (EMA)

    ftextout("< F2 > Car Access System (CAS)"                               , 6, 5,0,1);
/*
    ftextout("< F3 > ????????????"                                              , 8, 5,0,1);
    ftextout("< F4 > ????????????"                                              ,10, 5,0,1);
    ftextout("< F5 > ????????????"                                              ,12, 5,0,1);
    ftextout("< F6 > ????????????"                                              ,14, 5,0,1);
    ftextout("< F7 > ????????????"                                              ,16, 5,0,1);
    ftextout("< F8 > ????????????"                                              ,18, 5,0,1);
    ftextout("<Shift> + < F11>  ????????????"                                   , 4,45,0,1);
    ftextout("<Shift> + < F12>  ????????????"                                   , 6,45,0,1);
    ftextout("<Shift> + < F13>  ????????????"                                   , 8,45,0,1);
    ftextout("<Shift> + < F14>  ????????????"                                   ,10,45,0,1);
    ftextout("<Shift> + < F15>  ????????????"                                   ,12,45,0,1);
    ftextout("<Shift> + < F16>  ????????????"                                   ,14,45,0,1);
    ftextout("<Shift> + < F17>  ????????????"                                   ,16,45,0,1);
    ftextout("<Shift> + < F18>  ????????????"                                   ,18,45,0,1);
*/
    ftextout("< F9 >  Bildschirmdruck"          				,20, 5,0,1);
    ftextout("< F10>  Zurück"                   				,22, 5,0,1);
    ftextout("<Shift> + < F10>  Exit"           				,22,45,0,1);
  }
}

// ********************
// *** Statusscreen ***----------------------------------------------------------------------------F5-Taste-Hauptmenü
// ********************
SCREEN s_status()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("","")
  {
    ftextout("< F1 >  Analogwerte 1"            , 4,5,0,1);
    ftextout("< F2 >  Analogwerte 2"				  , 6,5,0,1);
    ftextout("< F3 >  Analogwerte 3"			     , 8,5,0,1);
    ftextout("< F4 >  Digital 1 Schalterstati"			     ,10,5,0,1);
    ftextout("< F5 >  Digital 2 Funktionsstati"		     ,12,5,0,1);
    ftextout("< F6 >  IBS - Powermanagement"                    ,14, 5,0,1);
    ftextout("< F7 >  Systemcheck"			     ,16,5,0,1);
    ftextout("< F8 >  Readiness"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// ***************************
// *** StatusAnalogscreen1 ***
// ***************************
SCREEN s_status_analog1()
{
  ftextout("Analogwerte 1",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;UB;ML;MSHFM;UPWG1;UPWG2;NMOT;TMOT;TANS","");
  INPAapiCheckJobStatus("OKAY");

  LINE("Batteriespannung","")
  {
    text(1,0,"Batteriespannung [V]");

    ergebnisAnalogAusgabe("STAT_BATTERIESPANNUNG_WERT", 2,0, 0.0, 20.0, 0.0, 20.0,"5.2");
    //INPAapiResultText(text_var,"STAT_UBATT_EINH",1,"");
    //text(2,34,text_var);

    text(1,43,"Luftmasse ECE [kg/h]");




    ergebnisAnalogAusgabe("STAT_LUFTMASSE_WERT",2,43, 0.0, 25.0, 6.0, 15.0, "2.2"); // nur ECE
    text(3,43,"Luftmasse US [kg/h]");
    ergebnisAnalogAusgabe("STAT_MSHFM_WERT",4,43, 0.0, 25.0, 6.0, 15.0, "2.2"); // nur US

    //INPAapiResultText(text_var,"STAT_UBATT_EINH",1,"");
    //text(2,78,text_var);

  }

  LINE("Pedalwertgeber","")
  {
    text(1,0,"Pedalwertgeber-Potispannung 1 [V]");
    ergebnisAnalogAusgabe("STAT_SPANNUNG_PWG1_WERT",2,0, 0.0, 5.0, 0.6, 1.0, "4.2");
	 //INPAapiResultText(text_var,"STAT_PWG_POTI_SPANNUNG_1_EINH",1,"");
	 //text(2,34,text_var);

	 text(1,43,"Pedalwertgeber-Potispannung 2 [V]");
  	 ergebnisAnalogAusgabe("STAT_SPANNUNG_PWG2_WERT",2,43, 0.0, 5.0, 0.675, 4.0, "4.2");
	 //INPAapiResultText(text_var,"STAT_PWG_POTI_SPANNUNG_2_EINH",1,"");
	 //text(2,78,text_var);
  }

  LINE("Motor","")
  {
    text(1,0,"Motordrehzahl [U/min]");
    ergebnisAnalogAusgabe("STAT_DREHZAHL_WERT",2,0, 0.0, 6000.0, 0.0, 6000.0, "4.2");
	 //INPAapiResultText(text_var,"STAT_MOTORDREHZAHL_EINH",1,"");
	 //text(2,34,text_var);

    text(1,43,"Motortemperatur [°C]");
    ergebnisAnalogAusgabe("STAT_MOTORTEMPERATUR_WERT", 2,43, 0.0, 120.0, 0.0, 120.0, "4.2");
	 //INPAapiResultText(text_var,"STAT_MOTORTEMPERATUR_EINH",1,"");
	 //text(2,78,text_var);
  }

  LINE("Ansauglufttemperatur","")
  {
    text(1,0,"Ansauglufttemperatur [°C]");
    ergebnisAnalogAusgabe("STAT_ANSAUGLUFTTEMPERATUR_WERT",2,0, -40.0, 120.0, -40.0, 120.0, "4.2");
	 //INPAapiResultText(text_var,"STAT_AN_LUFTTEMPERATUR_EINH",1,"");
	 //text(2,34,text_var);

  }



}

// ***************************
// *** StatusAnalogScreen2 ***
// ***************************
SCREEN s_status_analog2()
{
	ftextout("Analogwerte 2",1,0,1,0);
	INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;UUSHK;UULSUV;ORA;FR","");
	INPAapiCheckJobStatus("OKAY");


	LINE("Lambdasondenspannung","")
	{
		text(1,0,"Lambdasondenspannung vor KAT [V]"); //USHK
		ergebnisAnalogAusgabe("STAT_SPANNUNG_LSVK_ADC_WERT",2,0, 0.0, 2.0, 1.3, 1.6, "1.3");
		//INPAapiResultText(text_var,"STAT_ULSVK_EINH",1,"");
		//text(2,34,text_var);

		text(1,43,"Lambdasondenspannung nach KAT [V]"); //UULSUV
		ergebnisAnalogAusgabe("STAT_UUSHK_WERT",2,43, 0.0, 1.0, 0.0, 1.0, "1.3");
		//INPAapiResultText(text_var,"STAT_ULSHK_EINH",1,"");
		//text(2,78,text_var);

	}

	LINE("Lambdasteuerung","")
	{
		text(1,0,"Ausgang Lambdaregeler"); //FR
		ergebnisAnalogAusgabe("STAT_FR_WERT",2,0, 0.0, 2.0, 0.9, 1.1, "2.3");
		//INPAapiResultText(text_var,"STAT_INT_EINH",1,"");
		//text(2,34,text_var);


		text(1,43,"Additive Lambdaregelung"); //ORA
		ergebnisAnalogAusgabe("STAT_ORA_WERT",2,43, -5.0, 5.0, -3.0, 3.0, "2.3");
		//INPAapiResultText(text_var,"STAT_ADD_EINH",1,"");
		//text(2,78,text_var);

	}

	LINE("Lambdaregler","")
	{

		text(1,0,"Multiplikative Lambdaregelung");
		INPAapiJob( sgbd, "STATUS_MUL","","");
		ergebnisAnalogAusgabe("STAT_MUL_WERT",2,0, 0, 2, 0.9, 1.1, "2.3");
		//INPAapiResultText(text_var,"STAT_MUL_EINH",1,"");
		//text(2,34,text_var);
	}

	/*LINE("Geberradadaption","")
	{
		text(1,0,"Geberradadaption Einlass");
		INPAapiJob(sgbd,"STATUS_GEBERRAD_ADAPTION","","");
      INPAapiCheckJobStatus("OKAY");
      ergebnisAnalogAusgabe("STAT_GEBERRAD_ADAPTION_VSE_WERT",2,0, -20.0, 20.0, -10.0, 10.0,"5.1");
      INPAapiResultText(text_var,"STAT_GEBERRAD_ADAPTION_VSE_EINH",1,"");
      text(1,33,text_var);

      text(1,43,"Geberradadaption Auslass");
      INPAapiJob(sgbd,"STATUS_GEBERRAD_ADAPTION","","");
      INPAapiCheckJobStatus("OKAY");
      ergebnisAnalogAusgabe("STAT_GEBERRAD_ADAPTION_VSA_WERT",2,43, -20.0, 20.0, -10.0, 10.0,"5.1");
      INPAapiResultText(text_var,"STAT_GEBERRAD_ADAPTION_VSA_EINH",1,"");
      text(2,76,text_var);
   }
   */
}

// ***************************
// *** StatusAnalogScreen3 ***
// ***************************
SCREEN s_status_analog3()
{
	INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;LUTSKZYL1;LUTSKZYL3;LUTSKZYL4;LUTSKZYL2;MSNDKO;FKMSDK","");
	INPAapiCheckJobStatus("OKAY");

	LINE("","")
	{
		ftextout("Laufunruhewerte [1/sec]",1,0,1,0);
		textout("Zylinder 1",3,0);

		ergebnisAnalogAusgabe("STAT_ZYL1_LAUFUNRUHE_WERT",4,0, -8.0, 8.0, -8.0, 3.0, "5.3");


		textout("Zylinder 2",3,43);

		ergebnisAnalogAusgabe("STAT_ZYL3_LAUFUNRUHE_WERT",4,43, -8.0, 8.0, -8.0, 3.0, "5.3");


	}

	LINE("","")
	{
		text(1,0,"Zylinder 3");

		ergebnisAnalogAusgabe("STAT_ZYL4_LAUFUNRUHE_WERT",2,0, -8.0, 8.0, -8.0, 3.0, "5.3");

		text(1,43,"Zylinder 4");

		ergebnisAnalogAusgabe("STAT_ZYL2_LAUFUNRUHE_WERT",2,43, -8.0, 8.0, -8.0, 3.0, "5.3");

	}

	LINE("","")
	{
		ftextout("DK/HFM Abgleichwerte",1,0,1,0);
		text(3,0,"Leckluftmassenstrom [kg/h]");
		ergebnisAnalogAusgabe("STAT_MSNDKO_WERT",4,0, -10.0, 10.0, -10.0, 10.0, "5.3");




	}

	LINE("","")
	{
		//text(1,0,"Korr.fakt. schn. Massenstromabgleich");
		//ergebnisAnalogAusgabe("STAT_FKMSDKS_WERT",2,0, -10.0, 10.0, -10.0, 10.0, "5.3");


		text(1,43,"Korr.fakt. Massenstr. Neb.fü.sig.");
		ergebnisAnalogAusgabe("STAT_FKMSDK_WERT",2,43, 0.0, 100.0, 0.0, 100.0, "4.2");


	}

   LINE("","")
   {
      INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;ORA","");
	   INPAapiCheckJobStatus("OKAY");
	   ftextout("additive Gemischadaption Leerlauf Bank 1", 1,5,0,0);
	   ftextout("[%]",2,5,0,0);
	   ergebnisAnalogAusgabe("STAT_ORA_WERT",4,5,0.0, 100.0, 0.0, 100.0, "4.2");
	   
	   INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;FRAI","");
	   INPAapiCheckJobStatus("OKAY");
	   ftextout("multiplikative Gemischkorrektur der Gemischadaption", 1,43,0,0);
	   ftextout("",2,43,0,0);
	   ergebnisAnalogAusgabe("STAT_FRAI_WERT",4,43,0.0, 100.0, 0.0, 100.0, "4.2");
	
   }
   
   LINE("","")
   {
      INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;PWM_VCV_BAS_AD_VAR_2_ADD","");
	   INPAapiCheckJobStatus("OKAY");
	   ftextout("Additive Adaptionswert Mengenregelung", 1,5,0,0);
	   ftextout("[%]",2,5,0,0);
	   ergebnisAnalogAusgabe("STAT_PWM_VCV_BAS_AD_VAR_2_ADD_WERT",4,5,0.0, 100.0, 0.0, 100.0, "4.2");
	   
	   INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;FAC_PWM_VCV_BAS_AD_VAR_2","");
	   INPAapiCheckJobStatus("OKAY");
	   ftextout("Mult. Adaptionswert Mengenregelung", 1,43,0,0);
	   ftextout("",2,43,0,0);
	   ergebnisAnalogAusgabe("STAT_FAC_PWM_VCV_BAS_AD_VAR_2_WERT",4,43,0.0, 100.0, 0.0, 100.0, "4.2");
	
   }
   
   LINE("","")
   {
      INPAapiJob(sgbd,"STATUS_MESSWERTBLOCK_LESEN","1;DLAHI","");
	   INPAapiCheckJobStatus("OKAY");
	   ftextout("I-Anteil der stetigen LRHK", 1,5,0,0);
	   ftextout("",2,5,0,0);
	   ergebnisAnalogAusgabe("STAT_I_ANTEIL_LRHK_WERT",4,5,0.0, 100.0, 0.0, 100.0, "4.2");
   }

}
// **************************
// *** StatusDigitalscreen***
// **************************
SCREEN s_status_digital1()
{
  ftextout("Digitalwerte 1 - Schalterstati",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_SCHALTERSTATI","","");
  INPAapiCheckJobStatus("OKAY");

  LINE("","")
  {
    text(1,1,"Status Zündung");
    INPAapiResultDigital(logik_var,"STAT_KL15_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Startrelais");
    INPAapiResultDigital(logik_var,"STAT_ESTART_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    // Bremslichtschalter
    text(1,1,"Status Bremslichtschalter");
    INPAapiResultDigital(logik_var,"STAT_BL_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    // Bremslichttestschalter
    text(1,41,"Status Bremslichttestschalter");
    INPAapiResultDigital(logik_var,"STAT_BR_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Kupplung");
    INPAapiResultDigital(logik_var,"STAT_KUPPL_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Klimakompressor");
    INPAapiResultDigital(logik_var,"STAT_KO_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }


}

/*
SCREEN s_status_digital3()
{
  ftextout("Digitalwerte 3 - FGR",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_FGR","","");
  INPAapiCheckJobStatus("OKAY");

  LINE("","")
  {
    text(1,1,"Status FGR Austaste");
    INPAapiResultDigital(logik_var,"STAT_FGRAT_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status FGR Hauptschalter");
    INPAapiResultDigital(logik_var,"STAT_FGRHSA_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Taste 'Beschleunigung'");
    INPAapiResultDigital(logik_var,"STAT_FGRTBE_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Taste 'Setzen'");
    INPAapiResultDigital(logik_var,"STAT_FGRTSE_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Taste 'Verzögern'");
    INPAapiResultDigital(logik_var,"STAT_FGRTVE_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Taste 'Wiederaufnahme'");
    INPAapiResultDigital(logik_var,"STAT_FGRTWA_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status FGR-Lampe");
    INPAapiResultDigital(logik_var,"STAT_LFGR_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status ACC");
    INPAapiResultDigital(logik_var,"STAT_ACC_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }
}
*/

// ***************************
// *** StatusDigitalscreen2***
// ***************************
SCREEN s_status_digital2()
{
  ftextout("Digitalwerte 2 - Funktionsstati",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_FUNKTIONSSTATI","","");
  INPAapiCheckJobStatus("OKAY");

  LINE("","")
  {
    text(1,1,"Status Leerlauf");
    INPAapiResultDigital(logik_var,"STAT_LL_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Volllast");
    INPAapiResultDigital(logik_var,"STAT_VL_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Lambdasondenbereitschaft hinter KAT");
    INPAapiResultDigital(logik_var,"STAT_SBBHK_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Lambdasondenbereitschaft vor KAT");
    INPAapiResultDigital(logik_var,"STAT_SBBVK_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Lambdaregelung");
    INPAapiResultDigital(logik_var,"STAT_LR_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Park-Neutral");
    INPAapiResultDigital(logik_var,"STAT_PN_EIN",1);
    digitalout(logik_var, 3,41,"aus ","ein ");

  }
/*
  LINE("","")
  {
    text(1,1,"Status Kick-Down");
    INPAapiResultDigital(logik_var,"STAT_KD_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");


    text(1,41,"Status Sportmodus");
    INPAapiResultDigital(logik_var,"STAT_PEDSPORT_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");

}
*/

  LINE("","")
  {
    text(1,1,"Status ECU-Lock");
    INPAapiResultDigital(logik_var,"STAT_ECULOCK_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status Tankentlüftung mit hoher Beladung");
    INPAapiResultDigital(logik_var,"STAT_TEHB_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

  LINE("","")
  {
    text(1,1,"Status Schubabschneiden");
    INPAapiResultDigital(logik_var,"STAT_SA_EIN",1);
    digitalout(logik_var, 3,1,"ein ","aus ");

    text(1,41,"Status UMA Lernerfolg");
    INPAapiResultDigital(logik_var,"STAT_LRNRDY_EIN",1);
    digitalout(logik_var, 3,41,"ein ","aus ");
  }

}


// **************************
// *** Systemcheckscreen  ***
// **************************
SCREEN s_systemcheck()
{
	  int z1=1;
   ftextout("Systemcheck",z1,0,1,0);
   ftextout("",3,0,0,0);
   z1=4;
   ftextout(" < F1 >  TEV Systemtest ------ nur US",z1,5,0,1); z1=z1+2;
   ftextout(" < F2 >  LL-Erhöhung Bandende",z1,5,0,1); z1=z1+2;
   ftextout(" < F3 >  DMTL Systemtest ------ nur US",z1,5,0,1); z1=z1+2;
   ftextout(" < F4 >  Grundadaption",z1,5,0,1); z1=z1+2;
   ftextout(" < F5 >  IGR Systemtest",z1,5,0,1); z1=z1+2;
   ftextout(" < F6 >  Systemtest L-Sonde vor Kat",z1,5,0,1); z1=z1+2;
   ftextout(" < F7 >  Systemtest L-Sonde nach Kat",z1,5,0,1); z1=z1+2;
   ftextout(" < F8  > EOL Ruhestrommessung",z1,5,0,1);z1=z1+3;

   ftextout(" < F10 > Zurück",z1,5,0,1);
   ftextout("< Shift > + < F10 > INPA beenden"                ,z1,45,0,1);
   stop();
}
// *********************************
// *** Screen Systemdiagnose TEV ***
// *********************************
SCREEN s_systemcheck_tev()
{
  blankscreen();
  ftextout("Systemstest TankEntlüftungsVentil",0,15,1,1);
  textout(" < F1  > Start Systemtest TEV",3,5);
  textout(" < F2  > Stop Systemtest TEV",4,5);
  textout(" < F10 > Zurück",6,5);
  textout("< Shift > + < F10 > INPA beenden", 6,40);

  INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_TEV_FUNC","","");
  INPAapiCheckJobStatus("OKAY");
  ftextout("Status TEV-Check:",9,2,0,1);
  INPAapiResultInt(ganz_zahl,"STAT_SYSTEMCHECK_TEV_FUNC_WERT",1);
  inttostring(ganz_zahl,text_var);
  ftextout(text_var,11,20,0,1);

  INPAapiResultText(text_var,"STAT_SYSTEMCHECK_TEV_FUNC_TEXT",1,"");
  ftextout(text_var,13,20,0,1);



}

// *****************************
// *** LL-Erhöhung setzen    ***
// *****************************
SCREEN s_systemcheck_llerh()
{
  string temp;
  blankscreen();
  ftextout("Systemtest LL-Drehzahl verstellen",0,15,1,1);


  LINE("","") {
  	INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_LLERH","","");
  	INPAapiResultText(text_var,"STAT_LL_TEXT",1,"");
  	text_var = "Status :   " + text_var;
  	textout(text_var,1,1);
  }

  LINE("","") {
  	INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultInt(ganz_zahl,"STAT_MOTORDREHZAHL_WERT",1);
   inttostring(ganz_zahl,temp);
   textout("IST - Wert",1,1);
   ftextout(temp,3,1,1,1);
   textout("SOLL - Wert",1,40);
   inttostring(ll_wert,temp);
   ftextout(temp,3,40,1,1);
   }
}

// *****************************
// *** Systemcheck DMTL      ***
// *****************************
SCREEN s_systemcheck_dmtl()
{
  string s1;
  blankscreen();
  ftextout("Systemtest DMTL",0,15,1,1);


  LINE("","") {
  	INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_DMTL","","");
  	INPAapiResultInt( ganz_zahl,"STAT_FS_DMTL_WERT",1);
  	inttostring(ganz_zahl, s1);
  	INPAapiResultText(text_var,"STAT_FS_DMTL_TEXT",1,"");
  	text_var = "Status :   " + s1 + " " + text_var;
  	textout(text_var,1,1);
  }


}

// *********************************
// *** Systemcheck Grundadaption ***
// *********************************
SCREEN s_systemcheck_grund()
{
  blankscreen();
  ftextout("Systemtest Grundadaption",0,15,1,1);


  LINE("","") {
  	INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_GRUNDADAPT","","");
  	INPAapiResultText(text_var,"STAT_GAS_TEXT",1,"");
  	text_var = "Status :   " + text_var;
  	textout(text_var,1,1);
  }


}

// **********************************************
// *** Screen Systemdiagnose Ruhestrommessung ***
// **********************************************
SCREEN s_systemtest_ibs()
{
  string s1, text_var1, text_var2;
  bool b1;
  real r1;
  int i1, t1, status;

  ftextout("Systemtest Ruhestrommessung",1,0,1,0);

  textout(" < F1  > Start Systemtest Ruhestrommessung",3,5);
  textout(" < F10 > Zurück",5,5);
  textout("< Shift > + < F10 > INPA beenden", 5,45);

  INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");

  INPAapiResultText(s1,"JOB_STATUS",1,"");
  if (s1 != "OKAY")
  {
    messagebox("STATUS_ZUENDUNG",s1);
    stop();
  }
  else
  {
    textout("Klemme 15",21,5);
    ergebnisDigitalAusgabe("STAT_ZUENDUNG"         ,22, 5," JA     "," NEIN ");
    INPAapiJob(sgbd,"STATUS_RUHESTROMMESSUNG","","");
    INPAapiResultText(s1,"JOB_STATUS",1,"");
    if (s1 != "OKAY")
    {
      messagebox("STATUS_RUHESTROMMESSUNG",s1);
      stop();
    }
    else
    {
      textout("===  Status Ruhestrommessung ===",8,5);
      INPAapiResultInt(status,"STAT_FS_RUHESTROM_WERT",1);
      inttostring(status,s1);
      textout(blank,10,5);
      textout(s1,10,5);
      INPAapiResultText(s1,"STAT_FS_RUHESTROM_TEXT",1,"");
      textout(blank,12,5);
      textout(s1,12,5);
      text(25,5,"Ruhestrom");
      ergebnisAnalogAusgabe("STAT_STAT_RUHESTROM_WERT", 26, 5, 0.0, 0.300, 0.0, 0.080,"5.3");
      INPAapiResultText(s1,"STAT_STAT_RUHESTROM_EINH",1,"");
      text(26,41,s1);
      ftextout("Parametereingabe Ruhestrommessung",22,45,0,1);
      textout("1. Parameter = Maximale Ruhestromschwelle",23,45);
      textout("2. Parameter = Messtartbedingung",24,45);
      textout("3. Parameter = Dauer Mittelwertmessung",25,45);
      textout("4. Parameter = Timeoutzeit",26,45);
    }
  }
}

// ************************
// *** Systemcheck IGR  ***
// ************************
SCREEN s_systemcheck_igr()
{
  string s1;
  blankscreen();
  ftextout("Systemtest IGR",0,15,1,1);


  LINE("","") {
  	INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_IGR","","");
  	INPAapiResultInt(ganz_zahl,"STAT_FS_IGRD_WERT",1);
  	inttostring(ganz_zahl,s1);
  	INPAapiResultText(text_var,"STAT_FS_IGRD_TEXT",1,"");
  	text_var = "Status :   " + s1 + " " + text_var;
  	textout(text_var,1,1);
  }


}

// *************************
// *** Systemcheck LSVK  ***
// *************************
SCREEN s_systemcheck_lsvk()
{
  string s1;
  blankscreen();
  ftextout("Systemtest LSVK",0,15,1,1);


  LINE("","") {
        INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_LSVK","","");
        INPAapiResultInt(ganz_zahl,"STAT_FS_LSVK_WERT",1);
        inttostring(ganz_zahl,s1);
        INPAapiResultText(text_var,"STAT_FS_LSVK_TEXT",1,"");
        text_var = "Status :   " + s1 + " " + text_var;
        textout(text_var,1,1);
  }


}

// *************************
// *** Systemcheck LSHK  ***
// *************************
SCREEN s_systemcheck_lshk()
{
  string s1;
  blankscreen();
  ftextout("Systemtest LSHK",0,15,1,1);


  LINE("","") {
        INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_LSHK","","");
        INPAapiResultInt(ganz_zahl,"STAT_FS_LSHK_WERT",1);
        inttostring(ganz_zahl,s1);
        INPAapiResultText(text_var,"STAT_FS_LSHK_TEXT",1,"");
        text_var = "Status :   " + s1 + " " + text_var;
        textout(text_var,1,1);
  }


}

// *********************
// *** Steuernscreen ***----------------------------------------------------------------------------F5-Taste-Hauptmenü
// *********************
SCREEN s_steuern()
{
  int z1;
  
  ftextout("Ansteuern",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("","")
  {
  	 z1=4;
    ftextout("< F1 >  Adaptionen selektiv löschen",z1,5,0,1);
    ftextout("< Shift > + < F1 >  Fehlerortabfrage (Experten)",z1,45,0,1); z1=z1+2;
    ftextout("< F2 >  Stellgliedansteuerung 1",z1,5,0,1);z1=z1+2;
    ftextout("< F3 >  Stellgliedansteuerung 2",z1,5,0,1);z1=z1+2;
    ftextout("< F8 >  MSA",18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

SCREEN s_steuern1()
{
	int z1=1;
	timeout=20;
	tast=50;
  ftextout("Stellgliedansteuerung 1",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {


    ftextout("< F1 >  TEV ------ nur US",4,5,0,1);
    ftextout("< F2 >  E-Luefter",6,5,0,1);
    ftextout("< F3 >  DMTL ------ nur US",8,5,0,1);
    ftextout("< F4 >  MIL",10,5,0,1);
    ftextout("< F5 >  Drosselklappe",12,5,0,1);
    ftextout("< F6 >  EKP",14,5,0,1);
    ftextout("< F7 >  EML",16,5,0,1);
    ftextout("< F8 >  Mengensteuerventil - MSV",18,5,0,1);



    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}



SCREEN s_steuern2()
{
	int z1=1;
	timeout=20;
	tast=50;
  ftextout("Stellgliedansteuerung 2",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {


    ftextout("< F1 >  Lambdasondenheizung vor Kat",4,5,0,1);
    ftextout("< Shift > + < F1 >  Lambdasondenheizung hinter Kat",4,35,0,1);
    ftextout("< F2 >  Wasserpumpe Turbolader",6,5,0,1);
    ftextout("< F3 >  Kennfeldthermostat",8,5,0,1);
    ftextout("< F4 >  VANOS Einlass-Ventil",10,5,0,1);
    ftextout("< F5 >  Umluftventil",12,5,0,1);
    ftextout("< F6 >  Wastegate Ventil",14,5,0,1);
    ftextout("< F7 >  Kurbelgehäuseentlüftung",16,5,0,1);



    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}
// **************************************
// *** Screen für Adaptionen löschen  ***
// **************************************
SCREEN s_adap_loe()
{
  userboxclose(0);
  viewclose();
  ftextout("Adaptionen selektiv löschen",0,20,1,1);
  INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
  INPAapiCheckJobStatus("OKAY");
  INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
  if (zahlen_var == 0)
  {
  	INPAapiJob(sgbd,"STATUS_SCHALTERSTATI","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultDigital(logik_var,"STAT_KL15_EIN",1);
   if (logik_var == 1)
   {
   setmenu( m_adap_loe);
  	textout("< F1  > LL-Regelung"           	 	, 8, 5);
  	textout("< F2  > Klopfregelung"			, 9, 5);
  	textout("< F3  > vor KAT" 	   			,10, 5);
  	textout("< F4  > Lambdaregelung nach KAT"  	,11, 5);
  	textout("< F5  > Saugrohr Adaption"   		,12, 5);
  	textout("< F6  > Höhenadaption"          		,13, 5);
  	textout("< F7  > Adaption Fuel-Off / -On"        	,14, 5);
  	textout("< F8  > Lambdasondenalterung"           	,15, 5);
  	textout("< F9  > Druck"				,16, 5);
  	textout("< F10 > Zurück"                    		,17, 5);
  	textout("< Shift > + < F1 > Dynamikvorhalt"	  	, 8,45);
  	textout("< Shift > + < F2 > Bereichserkennung Benzin im Öl"    , 9,45);
   textout("< Shift > + < F3 > Batterietausch"    		,10,45);
  	textout("< Shift > + < F4 > Hinterachsübersetzung"	,11,45);
  	textout("< Shift > + < F5 > VANOS"		   	,12,45);
  	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
  	stop();
   }
  }
  else
  {
  	ftextout("Adaptionen nur bei stehendem Motor löschen ! ",3,5,1,1);
  	ftextout("Bitte Motor abstellen, Zündung ein"    , 6, 5,0,2);
  }
}


SCREEN s_tev()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Tankentlüftungsventil",0,20,1,1);


  	textout("< F1  > Ansteuerung mit 50%"           	 	, 8, 5);
  	textout("< F2  > Ansteuerung mit 90%"           	 	, 10, 5);
  	textout("< F4  > Eingabe Tastverhältnis" 	   			,14, 5);
  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_msv()
{
	tast=5;
	userboxclose(0);
  viewclose();
  ftextout("Steuern Mengensteuerventil",0,20,1,1);


  	textout("< F1  > Ansteuerung mit 5 MPa"           	 	, 8, 5);

  	textout("< F4  > Eingabe Solldruck" 	   			,14, 5);
  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

// **************************************
// *** Screen für E-Luefter ansteuern***
// **************************************
SCREEN s_e_luefter()
{
  userboxclose(0);
  viewclose();
  ftextout("E-Luefter ansteuern",0,20,1,1);

   setmenu( m_e_luefter);
  	textout("< F1  > E-Luefter an Stufe 1"           	 	, 8, 5);
  	textout("< F2  > E-Luefter an Stufe 2"           	 	, 10, 5);
  	textout("< F3  > E-Luefter aus" 	   			,12, 5);


  	textout("< F9  > Druck"				,16, 5);
  	textout("< F10 > Zurück"                    		,17, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
  	stop();


}

// ***********************************
// *** Screen für DMTL ansteuern   ***
// ***********************************
SCREEN s_dmtl()
{
	userboxclose(0);
	viewclose();
	ftextout("DMTL ",0,20,1,1);
	setmenu( m_dmtl);
	textout("< F1  > DMTL Pumpe"           	 	, 4, 5);
	textout("< F2  > DMTL Heizung" 	   			,6, 5);
	textout("< F3  > DMTL Ventil" 	   			,8, 5);

	textout("< F9  > Druck"				,16, 5);
	textout("< F10 > Zurück"                    		,17, 5);

	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
	stop();
}

// ****************************************
// *** Screen für DMTL Pumpe ansteuern  ***
// ****************************************
SCREEN s_dmtl_pump()
{
	userboxclose(0);
	viewclose();
	ftextout("DMTL Pumpe",0,20,1,1);
	INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
   if (zahlen_var == 0)
   {
	   setmenu( m_dmtl_pump);

   	//INPAapiJob(sgbd,"STATUS_STEUERN_DMTLP","","");
   	//INPAapiCheckJobStatus("OKAY");


   	//ergebnisAnalogAusgabe("STAT_DMTLP_WERT", 4,0, 0.0, 20.0, 0.0, 20.0,"5.2");
   	//ergebnisAnalogAusgabe("STAT_DMTLP_EINH", 4,20, 0.0, 20.0, 0.0, 20.0,"5.2");

   	textout("< F1  > DMTL Pumpe ein"           	 	, 4, 5);
   	textout("< F2  > DMTL Pumpe aus" 	   			, 6, 5);

   	textout("< F9  > Druck"				,16, 5);
   	textout("< F10 > Zurück"                    		,17, 5);

   	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
   	stop();
   }
  else
  {
  	ftextout("DMTL Pumpe nur bei stehendem Motor ansteuern ! ",3,5,1,1);
  	ftextout("Bitte Motor abstellen, Zündung ein"    , 6, 5,0,2);
  }
}


// ******************************************
// *** Screen für DMTL Heizung ansteuern  ***
// ******************************************
SCREEN s_dmtl_heat()
{
	userboxclose(0);
	viewclose();
	ftextout("DMTL Heizung",0,20,1,1);
	INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
   if (zahlen_var == 0)
   {
      setmenu( m_dmtl_heat);

   	//INPAapiJob(sgbd,"STATUS_STEUERN_DMTLH","","");
   	//INPAapiCheckJobStatus("OKAY");


   	//ergebnisAnalogAusgabe("STAT_DMTLH_WERT", 4,0, 0.0, 20.0, 0.0, 20.0,"5.2");
   	//ergebnisAnalogAusgabe("STAT_DMTLH_EINH", 4,20, 0.0, 20.0, 0.0, 20.0,"5.2");

   	textout("< F1  > DMTL Heizung ein"           	 	, 4, 5);
   	textout("< F2  > DMTL Heizung aus" 	   			, 6, 5);

   	textout("< F9  > Druck"				,16, 5);
   	textout("< F10 > Zurück"                    		,17, 5);

   	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
   	stop();
   }
   else
   {
  	   ftextout("DMTL Heizung nur bei stehendem Motor ansteuern ! ",3,5,1,1);
  	   ftextout("Bitte Motor abstellen, Zündung ein"    , 6, 5,0,2);
   }
}


// ******************************************
// *** Screen für DMTL Ventil  ansteuern  ***
// ******************************************
SCREEN s_dmtl_valve()
{
	userboxclose(0);
	viewclose();
	ftextout("DMTL Ventil",0,20,1,1);
	INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
   if (zahlen_var == 0)
   {
      setmenu( m_dmtl_valve);

   	//INPAapiJob(sgbd,"STATUS_STEUERN_DMTLV","","");
   	//INPAapiCheckJobStatus("OKAY");


   	//ergebnisAnalogAusgabe("STAT_DMTLH_WERT", 4,0, 0.0, 20.0, 0.0, 20.0,"5.2");
   	//ergebnisAnalogAusgabe("STAT_DMTLH_EINH", 4,20, 0.0, 20.0, 0.0, 20.0,"5.2");

   	textout("< F1  > DMTL Ventil ein"           	 	, 4, 5);
   	textout("< F2  > DMTL Ventil aus" 	   			, 6, 5);

   	textout("< F9  > Druck"				,16, 5);
   	textout("< F10 > Zurück"                    		,17, 5);

   	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
   	stop();
   }
   else
   {
  	   ftextout("DMTL ventil nur bei stehendem Motor ansteuern ! ",3,5,1,1);
  	   ftextout("Bitte Motor abstellen, Zündung ein"    , 6, 5,0,2);
   }
}
// **************************************
// *** Screen für MIL ansteuern***
// **************************************
SCREEN s_mil()
{
	userboxclose(0);
	viewclose();
	ftextout("MIL ansteuern",0,20,1,1);
	setmenu( m_mil);
	textout("< F1  > MIL an"           	 	, 8, 5);
	textout("< F2  > MIL aus" 	   			,10, 5);

	textout("< F9  > Druck"				,16, 5);
	textout("< F10 > Zurück"                    		,17, 5);

	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
	stop();
}

// ******************************************
// *** Screen für Drosselklappe ansteuern ***
// ******************************************
SCREEN s_dk()
{
	userboxclose(0);
	viewclose();
	ftextout("Drosselklappe ansteuern",0,20,1,1);
	setmenu( m_dk);
	textout("< F1  > Drosselklappe ansteuern"           	 	, 8, 5);
	textout("< F2  > Ansteuerung Drosselklappe aus" 	   			,10, 5);

	textout("< F9  > Druck"				,16, 5);
	textout("< F10 > Zurück"                    		,17, 5);

	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
	stop();
}

// ***********************************
// *** Screen für EKP ansteuern    ***
// ***********************************
SCREEN s_ekp()
{
	userboxclose(0);
	viewclose();
	ftextout("EKP ansteuern",0,20,1,1);
   //Abfrage ob Motordrehzahl == 0
   INPAapiJob(sgbd,"STATUS_MOTORDREHZAHL","","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
   if (zahlen_var == 0)
   {
      //Abfrage ob Klemme 15
  	   INPAapiJob(sgbd,"STATUS_SCHALTERSTATI","","");
      INPAapiCheckJobStatus("OKAY");
      INPAapiResultDigital(logik_var,"STAT_KL15_EIN",1);
      if (logik_var == 1)
      {
         setmenu( m_ekp);
      	textout("< F1  > EKP an"           	 	, 8, 5);
      	textout("< F2  > EKP aus" 	   			,10, 5);

      	textout("< F9  > Druck"				,16, 5);
      	textout("< F10 > Zurück"                    		,17, 5);

      	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
      	stop();
      }
   }
   else
   {
     	ftextout("EKP nur bei stehendem Motor ansteuern ! ",3,5,1,1);
     	ftextout("Bitte Motor abstellen, Zündung ein"    , 6, 5,0,2);
   }
}

// ***********************************
// *** Screen für EML ansteuern    ***
// ***********************************
SCREEN s_eml()
{
	userboxclose(0);
	viewclose();
	ftextout("EML ansteuern",0,20,1,1);
	setmenu( m_eml);
	textout("< F1  > EML an"           	 	, 8, 5);
	textout("< F2  > EML aus" 	   			,10, 5);

	textout("< F9  > Druck"				,16, 5);
	textout("< F10 > Zurück"                    		,17, 5);

	textout("< Shift > + < F10 > INPA beenden"            ,17,45);
	stop();
}


SCREEN s_lshvk()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Lambdasondenheizung vor Kat",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_lshhk()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Lambdasondenheizung hinter Kat",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_waput()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Wasserpumpe Turbolader ",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_kfk()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Kennfeldthermostat ",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_vanos_ein()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern VANOS Einlass-Ventil",0,20,1,1);


  	textout("< F1  > Ansteuerung mit 50%"           	 	, 8, 5);
  	textout("< F2  > Ansteuerung mit 90%"           	 	, 10, 5);
  	textout("< F4  > Eingabe Tastverhältnis" 	   			,14, 5);
  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_ulv()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Umluftventil ",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

SCREEN s_wgv()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Wastegate Ventil",0,20,1,1);


  	textout("< F1  > Ansteuerung mit 50%"           	 	, 8, 5);
  	textout("< F2  > Ansteuerung mit 90%"           	 	, 10, 5);
  	textout("< F4  > Eingabe Tastverhältnis" 	   			,14, 5);
  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}


SCREEN s_kgeh()
{

	userboxclose(0);
  viewclose();
  ftextout("Steuern Kurbelgehäuseentlüftung ",0,20,1,1);



  	textout("< F1  > Ansteuerung ein"           	 	, 8, 5);


  	textout("< F5  > Eingabe Ansteuerungsdauer" 	   			,16, 5);
  	textout("< F7  > Ende Ansteuerung" 	   			,20, 5);


  	textout("< F9  > Druck"				,24, 5);
  	textout("< F10 > Zurück"                    		,26, 5);

  	textout("< Shift > + < F10 > INPA beenden"            ,26,45);
  	stop();
}

// *********************
// *** MSA Hauptmenu ***
// *********************

SCREEN s_msa()
{
        userboxclose(0);
  		  viewclose();
        blankscreen();
        ftextout("Steuern MSA",1,0,1,0);
        ftextout("",3,0,0,0);
        INPAapiJob(sgbd,"STATUS_NULLGANG_ERKENNUNG","","");
        INPAapiCheckJobStatus("OKAY");



      LINE("","") {

      	ftextout("Nullgangsensor eingelernt ",1,1,0,0);
        	INPAapiResultAnalog(zahlen_var,"STAT_PHY_NG_LERN_WERT",1);
        	if(zahlen_var ==0)
        	{
        		logik_var=FALSE;
        	}
        	else
        	{
        		logik_var=TRUE;
        	}

        	digitalout(logik_var,3,1,"ja","nein");

        	ftextout("MSA Diagnose Aktivierungsstatus",1,41,0,1);
      	INPAapiJob(sgbd,"STATUS_MSA_DEAK","","");
      	INPAapiCheckJobStatus("OKAY");
        	INPAapiResultDigital(msa_deak_var,"STAT_STAT_MSA_DEAK",1);
        	msa_deak_var = !msa_deak_var;
        	digitalout(msa_deak_var,3,41,"MSA per Diagnose aktiviert ","MSA per Diagnose deaktiviert");
      }

      LINE("leer","") { }

      LINE("","") {
      	ftextout("< F1 >   Nullgang lernen",1,1,0,0);
      	if(!msa_deak_var)
      	{
      	 ftextout("< F2 >   MSA per Diagnose aktivieren",2,1,0,0);
      	 setitem(2, "MSA akt.",TRUE);
      	}
      	else
      	{
      	 ftextout("< F2 >   MSA per Diagnose deaktivieren (bis zum nächsten Motorstart)",2,1,0,0);
      	 setitem(2, "MSA deakt.",TRUE);
      	}
      	ftextout("< F3 >   Motorhaubenkontakt prüfen",3,1,0,0);
      	ftextout("< F4 >   Status MSA",4,1,0,0);
      	ftextout("< F5 >   Status MSA - Abschaltverhinderer",5,1,0,0);
      	ftextout("< F6 >   Status MSA - Abschaltaufforderer",6,1,0,0);
      	ftextout("< F7 >   Status MSA - Einschaltverhinderer",7,1,0,0);
      	ftextout("< F8 >   Status MSA - Einschaltaufforderer",8,1,0,0);
      	ftextout("< F9 >   Deaktiviere - Abschaltverhinderer",10,1,0,0);
     delay(2000);
      }
}

SCREEN s_msa_lern()
{

	randbed = TRUE;
	ftextout("MSA - Nullgang lernen",1,0,1,0);
   ftextout("",3,0,0,0);
   LINE("","")
   {
   ftextout("Randbedingungen:",1,0,0,4);
   ftextout("1) Motor läuft",3,10,0,0);
   ftextout("2) Gang in Nullposition",5,10,0,0);
   ftextout("3) Kupplung nicht betätigt",7,10,0,0);
   ftextout("4) Geschwindigkeit 0",9,10,0,0);
   ftextout("5) keine Person im Fahrzeug",11,10,0,0);
   }


   LINE("","")
   {
   	INPAapiJob( sgbd, "STATUS_NULLGANG_ERKENNUNG","","");
   	INPAapiCheckJobStatus("OKAY");
   	INPAapiResultAnalog( zahlen_var,"STAT_PHY_NG_POSITION_WERT",1);
   	ftextout("Aktuelle Position Nullgangsensor",1,1,0,0);
   	analogout(zahlen_var, 3,1,0,100,45,55,"2.1");

   	INPAapiResultAnalog( zahlen_var,"STAT_PHY_NG_LERN_WERT",1);
   	ftextout("angelernter Wert Nullgangsensor",1,41,0,0);
   	analogout(zahlen_var, 3,41,0,100,45,55,"2.1");
   }
   LINE("","")
   {
    ftextout("< F1 >   Nullgangstellung lernen",1,0,0,0);
    setitem(1,"NG lernen",TRUE);

   }


 }

SCREEN s_msa_stat()
{
        string s1;
	userboxclose(0);
	viewclose();
	blankscreen();
	INPAapiJob( sgbd, "STATUS_MSA","","");
	INPAapiCheckJobStatus("OKAY");
	INPAapiResultLong(longval,"STAT_STAT_MSA",1);
	ftextout("MSA Status",	1,0,1,0);
	ftextout("Bit",4,3,0,4);
        ftextout("Beschreibung",4,10,0,4);
	i=5;
	inttostring(i-5,s1);
	textout(s1,i,4);textout("MSA-Aktiv"						,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fehler MSA-Leitung"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fehler Nullgangsensor"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Nullgangposition noch nicht gelernt"			,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fehler Bremsunterdrucksensor"			,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fehler Plausibilität Nullgangsensorsignal"		,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fehler Plausibilität Bremsunterdrucksignal"		,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("CAN-Fehler"						,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Kupplungsignal unplausibel"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Kein gültiger Autoschlüssel erkannt"			,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fahrerabwesenheit / Motorhaube offen"		,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("MSA über Bedatung deaktiviert"			,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fertigungmodus aktiv"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Transportmodus aktiv"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Werkstattmodus aktiv"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Temporäre deaktivierung über Diagnose"		,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Schwerwiegender Motorfehler"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Kein MSA-Fahrzeug"					,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Startvorgang durch CAS abgebrochen"			,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Fahrzeug wurde angeschleppt"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Motor wurde abgewürgt"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("MSA-Led ist an"					,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("Motor nach Zündung an noch nicht gestartet"		,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i,4);textout("MSA-Led-Signal unplausibel"				,i,10);zeigebit(i-5,longval,i,43);i=i+1;inttostring(i-5,s1);


	delay(1500);

}

SCREEN s_msa_av()
{

	string s1;
	userboxclose(0);
	viewclose();
	blankscreen();
	INPAapiJob( sgbd, "STATUS_MSA","","");
	INPAapiCheckJobStatus("OKAY");
	ftextout("MSA Status - Abschaltverhinderer",	1,0,1,0);
	INPAapiResultLong(longval,"STAT_STAT_MSAAV",1);
        ftextout("Bit",4,3,0,4);
        ftextout("Beschreibung",4,10,0,4);
	i=5;
	inttostring(i-5,s1);
	textout(s1,i,4);ftextout("Abschaltverhinderer"					,i,10,0,1);zeigebit(i-5,longval,i,43);
	i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("AV Anzeige im CC"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Adaption läuft"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Motorfehler-AV"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("AV aus Allrad SG"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("PM-AV"						        ,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Aktivkohlefilter-AV"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Bremsunterdruck zu niedrig"				,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Kathalysatortemperatur-AV"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Motortemperatur-AV"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Umgebungstemperatur-AV"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Tankbefüllung-AV"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Stopp-Zeitfenster zu"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Regeneration Dieselpartikelfilter"				,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Komfortstopp nicht bereit"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Klima-AV"						        ,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Zylindergleichstellung"					,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);





	delay(1000);

}

SCREEN s_msa_deak_av()
{
	string s1;
	userboxclose(0);
	viewclose();
	blankscreen();

	ftextout("MSA Status - Abschaltverhinderer deaktivieren",	1,0,1,0);
	INPAapiJob( sgbd, "STATUS_MSA_DEAK_AV","","");
	INPAapiCheckJobStatus("OKAY");
	INPAapiResultLong(longval,"STAT_STAT_MSA_DEAK_AV",1);

	i=3;
	inttostring(i-2,s1);

	//textout(s1+": Kein Abschaltaufforderer"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Adaption-AV"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Diagnose-AV"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Klimarelais an"						,i,10);
	i=i+1;inttostring(i-2,s1);
	textout(s1+": PM-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	textout(s1+": Aktivkohlefilter-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Bremsunterdruck zu niedrig"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Kathalisatortemperatur-AV"						,i,10);
	i=i+1;inttostring(i-2,s1);
	textout(s1+": Motortemperatur-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	textout(s1+": Umgebungstemperatur-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	textout(s1+": Tankbefüllung-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Start-Zeitfenster zu"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Regeneration Dieselpartikelfilter"						,i,10);
	i=i+1;inttostring(i-2,s1);
	//textout(s1+": Motor gerade gestartet"						,i,10);
	i=i+1;inttostring(i-2,s1);
	textout(s1+": Klima-AV"						,i,10);zeigebit(i-3,longval,i,43);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Zylindergleichstellung (N43)"						,i,10);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Motordrehzahl zu hoch"						,i,10);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Fahrertür bei Motor an geöffnet"						,i,10);i=i+1;inttostring(i-2,s1);
	//textout(s1+": Motorhaube bei Motor an geöffnet"						,i,10);i=i+1;
	i=i+2;
	ftextout(" < F1 > einzelne AVs deaktivieren",i,1,0,0);i=i+1;
	ftextout(" < F2 > alle AVs deaktivieren",i,1,0,0);i=i+1;
	ftextout(" < F3 > ENDE Deaktivierung",i,1,0,0);


	delay(1500);
}


SCREEN s_msa_aa()
{
        string s1;
	userboxclose(0);
	viewclose();
	blankscreen();
	INPAapiJob( sgbd, "STATUS_MSA","","");
	INPAapiCheckJobStatus("OKAY");
	INPAapiResultLong(longval,"STAT_STAT_MSAAA",1);
        ftextout("MSA Status - Abschaltaufforderer",	1,0,1,0);
	ftextout("Bit",4,3,0,4);
        ftextout("Beschreibung",4,10,0,4);
	i=5;
	inttostring(i-5,s1);
	textout(s1,i,4);ftextout("Abschaltaufforderer"						,i,10,0,1);zeigebit(i-5,longval,i,43);
	i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Fahrzeuggeschwindigkeit"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Motordrehzahl zu hoch"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Mindestgeschwindigkeit"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);ftextout("- nicht verwendet -"				               	,i+1,12,0,2);ftextout("x",i+1,43,0,2);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Getriebe in Nullgang"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Kupplung nicht betätigt"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Lenkrad wird nicht gedreht"					,i+1,12);zeigebit(i-5,longval,i+1,43);





	delay(1000);

}


SCREEN s_msa_ev()
{
        string s1;
	userboxclose(0);
	viewclose();
	blankscreen();
	INPAapiJob( sgbd, "STATUS_MSA","","");
	INPAapiCheckJobStatus("OKAY");
	INPAapiResultLong(longval,"STAT_STAT_MSAEV",1);
        ftextout("MSA Status - Einschaltverhinderer",	1,0,1,0);
	ftextout("Bit",4,3,0,4);
        ftextout("Beschreibung",4,10,0,4);
	i=5;
	inttostring(i-5,s1);
	textout(s1,i,4);ftextout("Einschaltverhinderer"					,i,10,0,1);zeigebit(i-5,longval,i,43);
	i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Nicht in Nullgang"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Motor gerade gestoppt"					,i+1,12);zeigebit(i-5,longval,i+1,43);


	delay(1000);

}

SCREEN s_msa_ea()
{
        string s1;
	userboxclose(0);
	viewclose();
	blankscreen();
	INPAapiJob( sgbd, "STATUS_MSA","","");
	INPAapiCheckJobStatus("OKAY");
	INPAapiResultLong(longval,"STAT_STAT_MSAEA",1);
        ftextout("MSA Status - Einschaltaufforderer",	1,0,1,0);
	ftextout("Bit",4,3,0,4);
        ftextout("Beschreibung",4,10,0,4);
	i=5;
	inttostring(i-5,s1);
	textout(s1,i,4);ftextout("Einschaltaufforderer"					,i,10,0,1);zeigebit(i-5,longval,i,43);
	i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Kupplung betätigt"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);ftextout("- nicht verwendet -"					,i+1,12,0,2);ftextout("x",i+1,43,0,2);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Fahrzeug rollt an"						,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Bremsunterdruck zu niedrig"				,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("PM-EA"						        ,i+1,12);zeigebit(i-5,longval,i+1,43);i=i+1;inttostring(i-5,s1);
	textout(s1,i+1,4);textout("Klima-EA"						        ,i+1,12);zeigebit(i-5,longval,i+1,43);


	delay(1000);

}

SCREEN s_fort()
{
	string s1;
	int z1=1;
  userboxclose(0);
	viewclose();
	blankscreen();

  ftextout("Zyklus-/Fehlerflags einzelner Fehlerpfade",0,15,1,1);


  LINE("","") {
  	if(fort_hex!="")
  	{
        INPAapiJob(sgbd,"STATUS_FEHLERCODE",fort_hex,"");
        INPAapiResultDigital(logik_var,"STAT_FEHLERFLAG",1);
        ftextout("Fehlerflag: ",4,1,0,0);
        digitalout(logik_var,5,5,"1","0");
        INPAapiResultDigital(logik_var,"STAT_ZYKLUSFLAG",1);
        ftextout("Zyklusflag: ",4,41,0,0);
        digitalout(logik_var,5,45,"1","0");
      }
      z1=10;
      ftextout(" < F1 > Fehlerort eingeben HEX",z1,10,0,0);z1=z1+1;
      ftextout(" < F2 > Fehlerort Turbo (min)",z1,10,0,0);z1=z1+1;
      ftextout(" < F3 > Fehlerort Turbo (max)",z1,10,0,0);z1=z1+1;
      delay(1000);
  }
}

// *********************
// *** IBS Hauptmenu ***
// *********************
SCREEN s_main_pm()
{
  ftextout("PM Hauptmenü",3,20,1,1);
  textout("< F1 >  IBS Identifikation", 9,5);
  textout("< F2 >  PM 1 Byte Feld"    ,10,5);
  textout("< F3 >  PM 2 Byte Feld"    ,11,5);
  textout("< F4 >  PM 3 Byte Feld"    ,12,5);
  textout("< F5 >  Batterietausch registrieren" ,13,5);
  textout("< F6 >  Histogramm Reset"  ,14,5);
  textout("< F7 >  Start PM MESSEMODE",15,5);
  textout("< F8 >  Stop  PM MESSEMODE",16,5);
  textout("< F10>  Zurück"            ,19,5);
  textout("< Shift > + < F10>  INPA beenden"  ,19,45);
  stop();
}

// ************************
// *** IBS Ident-Screen ***
// ************************
SCREEN s_ibs_ident()
{
  string s1;
  long l1;

  INPAapiJob(sgbd,"IDENT_IBS","","");

  ftextout("Identifikation Batteriesensor",0,20,1,1);
  INPAapiResultText(s1, "JOB_STATUS", 1,"");
  if (s1 != "OKAY")
  {
    messagebox("IDENT_IBS",s1);
  }
  else
  {
    textout("=============================================================================================",2,0);
    ergebnisAusgabeTxt("BMWTeilenummer:"    ,"ID_BMW_NR"         ,3,0,0,30);
    ergebnisAusgabeTxt("Seriennummer:"      ,"SERIENNUMMER"      ,4,0,0,30);
    ergebnisAusgabeInt("Hardwareversion:"   ,"HW_REF"            ,5,0,0,30);
    ergebnisAusgabeInt("Programmstand:"     ,"ZIF_PROGRAMMSTAND" ,7,0,0,30);
    ergebnisAusgabeInt("Programmversion:"   ,"ZIF_STATUS"        ,8,0,0,30);
  }
stop();
}

// ************************
// *** PM 1 Byte-Feld  ***
// ************************
SCREEN s_pm_feld1()
{
  string s1;

  INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_PM_INFO_1","","");

  INPAapiResultText(s1, "JOB_STATUS", 1,"");
  if (s1 != "OKAY")
  {
    messagebox("PM_FELD1",s1);
  }
  else
  {
    ftextout("PM Infofeld 1",1,0,1,0);
    ergebnisAusgabeAnalog("km Stand aktuell"    , "STAT_KM_STAND_AKTUELL_WERT"  , "7.2", 5, 0, 0,25);
    ergebnisAusgabeAnalog("km Stand vor 1 Tag"  , "STAT_KM_STAND_VOR_1_TAG_WERT", "7.2", 6, 0, 0,25);
    ergebnisAusgabeAnalog("km Stand vor 2 Tagen", "STAT_KM_STAND_VOR_2_TAG_WERT", "7.2", 7, 0, 0,25);
    ergebnisAusgabeAnalog("km Stand vor 3 Tagen", "STAT_KM_STAND_VOR_3_TAG_WERT", "7.2", 8, 0, 0,25);
    ergebnisAusgabeAnalog("km Stand vor 4 Tagen", "STAT_KM_STAND_VOR_4_TAG_WERT", "7.2", 9, 0, 0,25);
    ergebnisAusgabeAnalog("km Stand vor 5 Tagen", "STAT_KM_STAND_VOR_5_TAG_WERT", "7.2", 10, 0, 0,25);
    ergebnisAusgabeAnalog(" letzter Batterietausch bei km", "STAT_BATTERIETAUSCH_LETZTER_WERT"     , "7.2",6,35, 0,25);
    ergebnisAusgabeAnalog("2letzter Batterietausch bei km", "STAT_BATTERIETAUSCH_ZWEITLETZTER_WERT", "7.2",7,35, 0,25);
    ergebnisAusgabeAnalog("3letzter Batterietausch bei km", "STAT_BATTERIETAUSCH_DRITTLETZTER_WERT", "7.2",8,35, 0,25);
    ergebnisAusgabeAnalog("4letzter Batterietausch bei km", "STAT_BATTERIETAUSCH_VIERTLETZTER_WERT", "7.2",9,35, 0,25);
    //ergebnisAusgabeAnalog("5letzter Batterietausch bei km", "STAT_BATTERIETAUSCH_FUENFTLETZTER_WERT","7.2",8,35, 0,25);
    ergebnisAusgabeAnalog("Stunden im Ladungsbereich  0 - 20", "STAT_ZEIT_IM_LADUNGSBEREICH_0_20_WERT"  ,"7.2",13,35, 0,25);
    ergebnisAusgabeAnalog("Stunden im Ladungsbereich 20 - 40", "STAT_ZEIT_IM_LADUNGSBEREICH_20_40_WERT" ,"7.2",14,35, 0,25);
    ergebnisAusgabeAnalog("Stunden im Ladungsbereich 40 - 60", "STAT_ZEIT_IM_LADUNGSBEREICH_40_60_WERT" ,"7.2",15,35, 0,25);
    ergebnisAusgabeAnalog("Stunden im Ladungsbereich 60 - 80", "STAT_ZEIT_IM_LADUNGSBEREICH_60_80_WERT" ,"7.2",16,35, 0,25);
    ergebnisAusgabeAnalog("Stunden im Ladungsbereich 80 -100", "STAT_ZEIT_IM_LADUNGSBEREICH_80_100_WERT","7.2",17,35, 0,25);
    ergebnisAusgabeAnalog("Minuten bei Temperatur   bis 0" , "STAT_ZEIT_IM_TEMPERATURBEREICH_BIS_0_WERT","7.2",13, 0, 0,25);
    ergebnisAusgabeAnalog("Minuten bei Temperatur  0 - 20" , "STAT_ZEIT_IM_TEMPERATURBEREICH_0_20_WERT" ,"7.2",14, 0, 0,25);
    ergebnisAusgabeAnalog("Minuten bei Temperatur 20 - 40" , "STAT_ZEIT_IM_TEMPERATURBEREICH_20_40_WERT","7.2",15, 0, 0,25);
    ergebnisAusgabeAnalog("Minuten bei Temperatur 40 - 60" , "STAT_ZEIT_IM_TEMPERATURBEREICH_40_60_WERT","7.2",16, 0, 0,25);
    ergebnisAusgabeAnalog("Minuten bei Temperatur über 60" , "STAT_ZEIT_IM_TEMPERATURBEREICH_AB_60_WERT","7.2",17, 0, 0,25);
    ergebnisAusgabeAnalog("Batterieladung gesamte Ah",   "STAT_BATTERIELADUNG_GESAMT_WERT"   ,"7.2",20, 0, 0,25);
    ergebnisAusgabeAnalog("Batterieentladung gesamte Ah","STAT_BATTERIEENTLADUNG_GESAMT_WERT","7.2",20,35, 0,25);
    ergebnisAusgabeAnalog("Batterieladung Bilanz Ah",   "STAT_BATTERIELADUNG_BILANZ_WERT"   ,"7.2",21, 0, 0,25);
    ergebnisAusgabeAnalog("Batterieentladung während Motorlauf",   "STAT_BATTENTLADUNG_GESAMT_BEI_MOTOR_LAEUFT_WERT"   ,"7.2",21, 35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 0 - 80"    , "STAT_RUHESTROM_0_80_GESAMT_WERT"     ,"7.2",10, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 80 - 200"  , "STAT_RUHESTROM_80_200_GESAMT_WERT"   ,"7.2",11, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 200 - 1000", "STAT_RUHESTROM_200_1000_GESAMT_WERT" ,"7.2",12, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges über 1000" , "STAT_RUHESTROM_AB_1000_GESAMT_WERT"  ,"7.2",13, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV  0 - 80"   , "STAT_RUHESTROM_0_80_GESAMT_OHNE_SV_WERT"     ,"7.2",10,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV 80 - 200"  , "STAT_RUHESTROM_80_200_GESAMT_OHNE_SV_WERT"   ,"7.2",11,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV 200 - 1000", "STAT_RUHESTROM_200_1000_GESAMT_OHNE_SV_WERT" ,"7.2",12,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV über 1000" , "STAT_RUHESTROM_AB_1000_GESAMT_OHNE_SV_WERT"  ,"7.2",13,35, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler BSD Parity",       "STAT_IBS_FEHLERZAEHLER_BSD_PARITY_WERT",       "5.0",24, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler Watchdog Reset",   "STAT_IBS_FEHLERZAEHLER_WATCHDOG_RESET_WERT",   "5.0",25, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler Power on Reset",   "STAT_IBS_FEHLERZAEHLER_POWER_ON_RESET_WERT",   "5.0",26, 0, 0,25);
    ergebnisAusgabeAnalog("KTBS Fehler BSD erweitert",   "STAT_KTBS_FEHLERZAEHLER_BSD_ERWEITERT_WERT",   "5.0",24,35, 0,25);
    ergebnisAusgabeAnalog("KTIBS Fehler BSD",            "STAT_KTIBS_FEHLERZAEHLER_BSD_WERT",            "5.0",25,35, 0,25);
    ergebnisAusgabeAnalog("KTIBS Fehler EBSD Checksumme","STAT_KTIBS_FEHLERZAEHLER_EBSD_CHECKSUMME_WERT","5.0",26,35, 0,25);
    delay(1000);
  }
}

// ************************
// *** PM 2 Byte-Feld  ***
// ************************
SCREEN s_pm_feld2()
{
  string s1;

  INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_PM_INFO_2","","");

  INPAapiResultText(s1, "JOB_STATUS", 1,"");
  if (s1 != "OKAY")
  {
    messagebox("PM_FELD2",s1);
  }
  else
  {
    ftextout("PM Infofeld 2",1,0,1,0);
    ergebnisAusgabeAnalog("Ah Q SOC aktuell"    , "STAT_Q_SOC_AKTUELL_WERT"  , "7.2", 3, 0, 0,25);
    ergebnisAusgabeAnalog("Ah Q SOC vor 1 Tag"  , "STAT_Q_SOC_VOR_1_TAG_WERT", "7.2", 4, 0, 0,25);
    ergebnisAusgabeAnalog("Ah Q SOC vor 2 Tagen", "STAT_Q_SOC_VOR_2_TAG_WERT", "7.2", 5, 0, 0,25);
    ergebnisAusgabeAnalog("Ah Q SOC vor 3 Tagen", "STAT_Q_SOC_VOR_3_TAG_WERT", "7.2", 6, 0, 0,25);
    ergebnisAusgabeAnalog("Ah Q SOC vor 4 Tagen", "STAT_Q_SOC_VOR_4_TAG_WERT", "7.2", 7, 0, 0,25);
    ergebnisAusgabeAnalog("Ah Q SOC vor 5 Tagen", "STAT_Q_SOC_VOR_5_TAG_WERT", "7.2", 8, 0, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit aktuell"    , "STAT_STARTFAEHIGKEITSGRENZE_AKTUELL_WERT"  , "7.2", 3,35, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit vor 1 Tag"  , "STAT_STARTFAEHIGKEITSGRENZE_VOR_1_TAG_WERT", "7.2", 4,35, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit vor 2 Tagen", "STAT_STARTFAEHIGKEITSGRENZE_VOR_2_TAG_WERT", "7.2", 5,35, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit vor 3 Tagen", "STAT_STARTFAEHIGKEITSGRENZE_VOR_3_TAG_WERT", "7.2", 6,35, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit vor 4 Tagen", "STAT_STARTFAEHIGKEITSGRENZE_VOR_4_TAG_WERT", "7.2", 7,35, 0,25);
    ergebnisAusgabeAnalog("% Startfähigkeit vor 5 Tagen", "STAT_STARTFAEHIGKEITSGRENZE_VOR_5_TAG_WERT", "7.2", 8,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand aktuell"    , "STAT_LADUNGSZUSTAND_AKTUELL_WERT"  , "7.2",10,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand vor 1 Tag"  , "STAT_LADUNGSZUSTAND_VOR_1_TAG_WERT", "7.2",11,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand vor 2 Tagen", "STAT_LADUNGSZUSTAND_VOR_2_TAG_WERT", "7.2",12,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand vor 3 Tagen", "STAT_LADUNGSZUSTAND_VOR_3_TAG_WERT", "7.2",13,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand vor 4 Tagen", "STAT_LADUNGSZUSTAND_VOR_4_TAG_WERT", "7.2",14,35, 0,25);
    ergebnisAusgabeAnalog("% Ladungszustand vor 5 Tagen", "STAT_LADUNGSZUSTAND_VOR_5_TAG_WERT", "7.2",15,35, 0,25);
    ergebnisAusgabeAnalog("Batterie Kapazität in Ah", "STAT_BATTERIE_KAPAZITAET_WERT", "7.2",10, 0, 0,25);
    ergebnisAusgabeAnalog("SOH",                      "STAT_SOH_WERT",                 "7.2",11, 0, 0,25);
    ergebnisAusgabeAnalog("SOC-Fit",                  "STAT_SOC_FIT_WERT",             "7.2",12, 0, 0,25);
    ergebnisAusgabeAnalog("Saison Temperatur in C",   "STAT_TEMP_SAISON_WERT",         "7.2",13, 0, 0,25);
    ergebnisAusgabeAnalog("Kalibrier Ereignisse",     "STAT_KALIBRIER_EVENT_CNT_WERT", "4.0",14, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler Download Checksumme", "STAT_IBS_FEHLERZAEHLER_DOWNLOAD_CHECKSUMME_WERT", "4.0",17, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler EEPROM Diagnose",     "STAT_IBS_FEHLERZAEHLER_EEPROM_DIAGNOSE_WERT",     "4.0",18, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler RAM Diagnose",        "STAT_IBS_FEHLERZAEHLER_RAM_DIAGNOSE_WERT",        "4.0",19, 0, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler PROM Diagnose",       "STAT_IBS_FEHLERZAEHLER_PROM_DIAGNOSE_WERT",       "4.0",17,35, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler I2C NAC Diagnose",    "STAT_IBS_FEHLERZAEHLER_I2C_NAC_DIAGNOSE_WERT",    "4.0",18,35, 0,25);
    ergebnisAusgabeAnalog("IBS Fehler I2C Bus Collision",   "STAT_IBS_FEHLERZAEHLER_I2C_BUS_COLLISION_WERT",   "4.0",19,35, 0,25);
    delay(1000);
  }
}

// *******************************
// *** PM 3 Byte-Feld Seite 2  ***
// *******************************
SCREEN s_pm_feld3()
{
  string s1;

  INPAapiJob(sgbd,"STATUS_SYSTEMCHECK_PM_INFO_1","","");

  INPAapiResultText(s1, "JOB_STATUS", 1,"");
  if (s1 != "OKAY")
  {
    messagebox("PM_FELD3",s1);
  }
  else
  {
    ftextout("PM Infofeld 3",1,0,1,0);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 0 - 80"    , "STAT_RUHESTROM_0_80_GESAMT_WERT"                 ,"7.2", 5, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 80 - 200"  , "STAT_RUHESTROM_80_200_GESAMT_WERT"               ,"7.2", 6, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges 200 - 1000", "STAT_RUHESTROM_200_1000_GESAMT_WERT"             ,"7.2", 7, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom ges über 1000" , "STAT_RUHESTROM_AB_1000_GESAMT_WERT"              ,"7.2", 8, 0, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV  0 - 80"   , "STAT_RUHESTROM_0_80_GESAMT_OHNE_SV_WERT"     ,"7.2", 5,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV 80 - 200"  , "STAT_RUHESTROM_80_200_GESAMT_OHNE_SV_WERT"   ,"7.2", 6,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV 200 - 1000", "STAT_RUHESTROM_200_1000_GESAMT_OHNE_SV_WERT" ,"7.2", 7,35, 0,25);
//    ergebnisAusgabeAnalog("Minuten Ruhestrom oSV über 1000" , "STAT_RUHESTROM_AB_1000_GESAMT_OHNE_SV_WERT"  ,"7.2", 8,35, 0,25);

    text(3,0,"Status Ruhestrom aktuell:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_AKTUELL",1,"");
    ftextout(text_var,3,25,0,0);

    text(4,0,"Status Ruhestrom vor 1 Zyklus:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_1_ZYKLUS",1,"");
    ftextout(text_var,4,25,0,0);

    text(5,0,"Status Ruhestrom vor 2 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_2_ZYKLEN",1,"");
    ftextout(text_var,5,25,0,0);

    text(6,0,"Status Ruhestrom vor 3 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_3_ZYKLEN",1,"");
    ftextout(text_var,6,25,0,0);

    text(7,0,"Status Ruhestrom vor 4 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_4_ZYKLEN",1,"");
    ftextout(text_var,7,25,0,0);

    text(8,0,"Status Ruhestrom vor 5 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_5_ZYKLEN",1,"");
    ftextout(text_var,8,25,0,0);

    text(9,0,"Status Ruhestrom vor 6 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_6_ZYKLEN",1,"");
    ftextout(text_var,9,25,0,0);

    text(10,0,"Status Ruhestrom vor 7 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_7_ZYKLEN",1,"");
    ftextout(text_var,10,25,0,0);

    text(11,0,"Status Ruhestrom vor 8 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_8_ZYKLEN",1,"");
    ftextout(text_var,11,25,0,0);

    text(12,0,"Status Ruhestrom vor 9 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_9_ZYKLEN",1,"");
    ftextout(text_var,12,25,0,0);

    text(13,0,"Status Ruhestrom vor 10 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_10_ZYKLEN",1,"");
    ftextout(text_var,13,25,0,0);

    text(14,0,"Status Ruhestrom vor 11 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_11_ZYKLEN",1,"");
    ftextout(text_var,14,25,0,0);

    text(15,0,"Status Ruhestrom vor 12 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_12_ZYKLEN",1,"");
    ftextout(text_var,15,25,0,0);

    text(16,0,"Status Ruhestrom vor 13 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_13_ZYKLEN",1,"");
    ftextout(text_var,16,25,0,0);

    text(17,0,"Status Ruhestrom vor 14 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_14_ZYKLEN",1,"");
    ftextout(text_var,17,25,0,0);

    text(18,0,"Status Ruhestrom vor 15 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_15_ZYKLEN",1,"");
    ftextout(text_var,18,25,0,0);

    text(19,0,"Status Ruhestrom vor 16 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_16_ZYKLEN",1,"");
    ftextout(text_var,19,25,0,0);

    text(20,0,"Status Ruhestrom vor 17 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_17_ZYKLEN",1,"");
    ftextout(text_var,20,25,0,0);

    text(21,0,"Status Ruhestrom vor 18 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_18_ZYKLEN",1,"");
    ftextout(text_var,21,25,0,0);

    text(22,0,"Status Ruhestrom vor 19 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_19_ZYKLEN",1,"");
    ftextout(text_var,22,25,0,0);

    text(23,0,"Status Ruhestrom vor 20 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_20_ZYKLEN",1,"");
    ftextout(text_var,23,25,0,0);

    text(24,0,"Status Ruhestrom vor 21 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_21_ZYKLEN",1,"");
    ftextout(text_var,24,25,0,0);

    text(25,0,"Status Ruhestrom vor 22 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_22_ZYKLEN",1,"");
    ftextout(text_var,25,25,0,0);

    text(26,0,"Status Ruhestrom vor 23 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_23_ZYKLEN",1,"");
    ftextout(text_var,26,25,0,0);

    text(27,0,"Status Ruhestrom vor 24 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_24_ZYKLEN",1,"");
    ftextout(text_var,27,25,0,0);

    text(28,0,"Status Ruhestrom vor 25 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_25_ZYKLEN",1,"");
    ftextout(text_var,28,25,0,0);

    text(29,0,"Status Ruhestrom vor 26 Zyklen:");
    INPAapiResultText(text_var,"STAT_RUHESTROM_VOR_26_ZYKLEN",1,"");
    ftextout(text_var,29,25,0,0);

    delay(1000);
  }
}
SCREEN s_readiness()
{
  int z1;
  z1=1;
  ftextout("Status Readiness",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_READINESS","","");
  INPAapiCheckJobStatus("OKAY");

  LINE("","") {
       INPAapiResultText( text_var,"STAT_ANZ_FEHLERCODES",1,"");
       ftextout("Anzahl Fehler im Fehlerspeicher: " + text_var,1,5,0,0);

       INPAapiResultDigital(logik_var,"STAT_MIL",1);
       ftextout("Status MIL",1,45,0,0);
       digitalout(logik_var,3,45,"EIN","AUS");

  }
  LINE("2","") {
       INPAapiResultText( text_var,"STAT_AUSSETZERERKENNUNG",1,"");
       ftextout( "Aussetzererkennung:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_KRAFTSTOFSYSTEM",1,"");
       ftextout( "Kraftstoffsystem:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_GLOBALE_KOMPONENTEN",1,"");
       ftextout( "Globale Komponenten:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_KAT_EIN",1,"");
       ftextout( "Kat-Diagnose:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_HEIZUNG_KAT",1,"");
       ftextout( "Katalysator Heizung:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_CDTES",1,"");
       ftextout( "Tankentlüftungssystem:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_CDSLS",1,"");
       ftextout( "Sekundärluftpumpe:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_KLIMA",1,"");
       ftextout( "Klima-Kühlflüssigkeit:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_LHEIZUNG",1,"");
       ftextout( "Lamdasondenheizung:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_LAMBDA",1,"");
       ftextout( "Diagnosefreigabe Lambda:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;

       INPAapiResultText( text_var,"STAT_EGR",1,"");
       ftextout( "Diagnosefreigabe EGR:", z1, 5,0,0);
       ftextout( blank,z1,25,0,2);
       ftextout( text_var,z1,25,0,2);
       z1=z1+1;
        }

}

// ************************
// *** Funktionenscreen ***------------------------------------------------------------------------F8-Taste-Hauptmenü
// ************************
//Wird aktiviert, deaktiviert über Variable "funktionen_flag"
SCREEN s_funktionen()
{
  ftextout("Funktionen",1,0,1,0);
  ftextout("Steuergeräte übergreifende Status und/oder Steuerfunktionen",2,17,0,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);
  LINE("","")
  {//Tastenbelegung müssen Sie Ihren Umfängen anpassen! Nur belegte Tasten ausgeben.
    ftextout("< F1 > ??????????????????????"                            , 4, 5,0,1);
//    ftextout("< F2 > ??????????????????????"                            , 7, 5,0,1);
//    ftextout("< F3 > ??????????????????????"                            ,10, 5,0,1);
//    ftextout("< F4 > ??????????????????????"                            ,13, 5,0,1);
//    ftextout("< F5 > ??????????????????????"                            ,16, 5,0,1);
    ftextout("< F9 >  Bildschirmdruck"                        	,20, 5,0,1);
    ftextout("< F10>  Zurück"              	                        ,22, 5,0,1);
    ftextout("<Shift> + < F10>  Exit"                          	,22,45,0,1);
  }
}

// **************************************
// *** Steuergeräte-Informationscreen ***
// **************************************
SCREEN s_sg_information()
{
  int zeile;
  int offset= 2;

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);
  ftextout("Aktuelles INPA:",4,0,0,1);
  ftextout(titel,4,15,0,5);

  LINE("","")
  {
    zeile= 4;
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>nicht verändern!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    ftextout("< F1 >  Schnittstellen"                         ,zeile, 5,0,1); zeile= zeile+offset;
    ftextout("< F2 >  Bordnetz"                               ,zeile, 5,0,1); zeile= zeile+offset;
    ftextout("< F3 >  Verbauort"                              ,zeile, 5,0,1); zeile= zeile+offset;
    ftextout("< F4 >  Allgemeines"                            ,zeile, 5,0,1); zeile= zeile+offset;
    ftextout("< F5 >  Kundenfunktion"                         ,zeile, 5,0,1); zeile= zeile+offset;
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<nicht verändern!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//OPTIONAL:
//Kopiervorlage:
//  ftextout("< F? >  ???????????????"                          ,zeile, 5,0,1); zeile= zeile+offset;

    ftextout("< F9 >  Bildschirmdruck"                        ,20, 5,0,1);
    ftextout("< F10>  Zurück"                                 ,22, 5,0,1);
    ftextout("<Shift> + < F10>  Exit"                         ,22,45,0,1);
  }
}

SCREEN s_sg_information_schnittstellen()
{
  int zeile;
  int offset    =  2;
  int busspalte1=  0;
  int busspalte2= 13;
  int ecuspalte1= 10;
  int ecuspalte2= 29;
  int erklspalte= 42;

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);

  ftextout(sg_information_titel + " Schnittstellen:",4,0,0,1);
  ftextout("Bus:",5,0,0,1);
  zeile= 6;


  //---ab hier befüllen
//!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//FA-CAN
  ftextout("FA-CAN------"         ,zeile,busspalte1,0,0);        ftextout("ACSM",zeile,ecuspalte1,1,1); ftextout("<at>Gurtkontakte<at>"                          ,zeile,erklspalte,0,0); zeile= zeile+offset;
  ftextout("FA-CAN------"         ,zeile,busspalte1,0,0);        ftextout("DME"  ,zeile,ecuspalte1,1,1); ftextout("<at>Bremspedal, Gaspedal<at>"                 ,zeile,erklspalte,0,0); zeile= zeile+offset;
  ftextout("FA-CAN------"         ,zeile,busspalte1,0,0);        ftextout("ICM-Q/L",zeile,ecuspalte1,1,1); ftextout("<at>Quer/Längsdynamik<at>"                  ,zeile,erklspalte,0,0); zeile= zeile+offset;

//FA-CAN-->ZGW--> Body-CAN, K-CAN
  zeile= zeile+1;
  ftextout("FA-CAN-------"        ,zeile,busspalte1,0,0);        ftextout("ZGW"    ,zeile,ecuspalte1,1,1); zeile= zeile+offset;
  ftextout("+--------Body-CAN----",zeile,busspalte2,0,0);        ftextout("CAS"    ,zeile,ecuspalte2,1,1); ftextout("<at>Klemme30b für Logik, WakeUp-Leitung<at>",zeile,erklspalte,0,0); zeile= zeile+offset;
  ftextout("+--------Body-CAN----",zeile,busspalte2,0,0);        ftextout("JBBF"   ,zeile,ecuspalte2,1,1); ftextout("<at>Türkontakte<at>"                        ,zeile,erklspalte,0,0); zeile= zeile+offset;
  ftextout("+--------FlexRay----------",zeile,busspalte2-3,0,0); ftextout("DSC"    ,zeile,ecuspalte2,1,1); ftextout("<at>Fahrwerkdaten<at>"                      ,zeile,erklspalte,0,0); zeile= zeile+offset;
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
}

SCREEN s_sg_information_bordnetz()
{
  int nr;
  string nr_;
  int zeile;
  int offset = 1;
  int spalte = 4;

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);
  ftextout("Bordnetz:",4,0,0,1);
  nr= 1;//--> 1.) ... 2.)...... wird automatisch nummeriert
  inttostring(nr,nr_);
  zeile= 6;

  //---ab hier befüllen
//!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//   Die Klammeraffen, At-Zeichen wurden durch <at> ersetzt, um diese BEISPIEL-Texte nicht zusätzich übersetzen zu müssen.


  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Stromversorgung Last<at>"                                                   ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("<at>Klemme30 (Dauerplus)<at>"                                                   ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>Jede EMA ist einzeln abgesichert über jeweils eine 30A ATO Sicherung<at>"   ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Stromversorgung Logik<at>"                                                  ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("<at>Klemme30B (Schaltbar per Relais über CAS)<at>"                              ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>Beide EMAs sind gemeinsam abgesichert über eine 5A Mini Sicherung<at>"      ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Gemeinsame Masse für Logik und Last<at>"                              ,zeile,spalte,0,1); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Busanbindung<at>"                                                     ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("FA-CAN"                                                                   ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>Wakeup-Leitung<at>"                                                   ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>keine integrierten Terminierungswiderstände / Busabschluß<at>"        ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Notwendige Kommunikationspartner für Funktionstest<at>:"              ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("ACSM3, Airbag, <at>Signale: Gurtkontakte<at>"                             ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("CAS, CarAccessSystem, <at>Signale: Klemmen, Klemme30b, WakeUp-Leitung<at>",zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("JBBF, <at>Junction Box Beifahrer<at>, <at>Signale: Türkontakte<at>"       ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Weitere Kommunikationspartner<at>:"                                   ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("DME, <at>DigitaleMotorelektronik, Signale: Bremspedal, Gaspedal<at>"      ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("ICMQL, Integrated Chassis Management: <at>Quer/Längsdynamik<at>"          ,zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>DSC, Dynamische Stabilitätskontrolle, Signale: Fahrwerkdaten<at>"     ,zeile,spalte,0,0); zeile= zeile+offset+1;
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//Kopiervorlage: Nur Fragezeichen ersetzen, fertig!
//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!

//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!
}

SCREEN s_sg_information_verbauort()
{
  int zeile;
  int offset = 1;
  int spalte2= 13;//Startposition für Ort

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);
  ftextout("Verbauort:",4,0,0,1);
  zeile= 6;

  //---ab hier befüllen
  ftextout("EMA-<at>Steuergerät<at>",zeile, 0,0,1); ftextout(": <at>In der B-Säule<at>",zeile,spalte2,0,0); zeile= zeile+offset;
  ftextout("EMA-<at>Aufroller<at>"  ,zeile, 0,0,1); ftextout(": <at>In der B-Säule<at>",zeile,spalte2,0,0); zeile= zeile+offset;
//Kopiervorlage: Nur Fragezeichen ersetzen, fertig!
//  ftextout("???????????????",zeile, 0,0,1); ftextout(": ???????????????"           ,zeile,spalte2,0,1); zeile= zeile+offset;
}

SCREEN s_sg_information_allgemeines()
{
  int nr;
  string nr_;
  int zeile;
  int offset = 1;
  int spalte = 4;

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);
  ftextout("Allgemeines:",4,0,0,1);
  nr= 1;//--> 1.) ... 2.)...... wird automatisch nummeriert
  inttostring(nr,nr_);
  zeile= 6;

  //---ab hier befüllen
//!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Anderen Steuergeräten ist nicht bekannt, ob eine EMA verbaut ist.<at>"      ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("<at>D.h., daß keine CAN-Nachrichten auf den Bus gelegt werden.<at>"             ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Anlieferung im Fertigungsmodus.<at>"                                        ,zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("  -->  <at>Keine Straffung des Gurtbandes möglich.<at>"                         ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Codier- und Flashbar.<at>"                                                  ,zeile,spalte,0,1); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Zwei Varianten: Links + Rechts, Gehäuse sind mechanisch unterschiedlich<at>",zeile,spalte,0,1); zeile= zeile+offset+1;
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//Kopiervorlage: Nur Fragezeichen ersetzen, fertig!
//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!

//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!
}

SCREEN s_sg_information_kundenfunktion()
{
  int nr;
  string nr_;
  int zeile;
  int offset = 1;
  int spalte = 4;

  ftextout(sg_information_titel + " Steuergeräte-Information",1,0,1,0);
  ftextout("Kundenfunktion:",4,0,0,1);
  nr= 1;//--> 1.) ... 2.)...... wird automatisch nummeriert
  inttostring(nr,nr_);
  zeile= 6;

  //---ab hier befüllen

//!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Gurtlose entfernen<at>",zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("<at>Durch leichtes Straffen des Gurtes (in Aufrollrichtung) wird die sog. Gurtlose entfernt.<at>",zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>Bedingung: Fahrzeug wach, Tür geschlossen, Gurt gesteckt.<at>"                               ,zeile,spalte,0,0); zeile= zeile+offset+1;

  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
  ftextout("<at>Gefahrenstraffung@",zeile,spalte,0,1); zeile= zeile+offset;
  ftextout("<at>Auf Basis von Fahrwerkdaten erkennt der Algorithmus eine möglich<at>",zeile,spalte,0,0); zeile= zeile+offset;
  ftextout("<at>gefährliche Fahrsituation (Vollbremsung, Schleudern, ) und strafft den Gurt mit ca. 200N.<at>",zeile,spalte,0,0); zeile= zeile+offset+1;
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!!!!!!!!!!!!!Beispiel!!!!!!!!!!!!!!!!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//Kopiervorlage: Nur Fragezeichen ersetzen, fertig!
//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!

//  ftextout(nr_+".)",zeile,0,0,1); nr= nr+1; inttostring(nr,nr_);
//  ftextout("?????",zeile,spalte,0,1); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset;
//  ftextout("?????",zeile,spalte,0,0); zeile= zeile+offset+1; //Letzte Zeile immer +1!
}
// -- EOF --
