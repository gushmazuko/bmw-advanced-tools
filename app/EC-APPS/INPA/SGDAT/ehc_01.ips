//**********************************************************************
//*
//* Nacharbeitssource für Inpa
//*
//* Sourcedatei EHC_01.src
//*
//**********************************************************************
//* History         :
//* 30.03.2006 GA V0.01 Ersterstellung Grundumfang für UDS (ISO 14229)
//* 02.11.06 ok v0.03 Anpassungen für I260
//* 29.11.2006 sh V0.05 Ersterstellung für EHC_01, Version 0.05 wegen Synchronisation mit EF-6x
//* 10.05.2007 sh v0.06 Anpassungen TI-432
//* 25.05.2007 sh v0.10 Komplettüberarbeitung TI-432
//* 31.05.2007 sh v0.11 Überarbeitung, Fehlerbeseitigung
//* 31.05.2007 sh V0.11 Fahrgestellnummer lesen deaktiviert (Ident)
//* 24.07.2007 asc V0.20 Vertauscherprüfung aus TAUSCH70 an F01 angepasst und eingefügt
//* 30.07.2007 sh V0.21 Ansteuerzeit bei Vertauscherprüfung erhöht (60 enspricht etwa 10 sec) Fehler in SG
//*                     Jobs bei Grobleckprüfung auf UDS
//* 30.07.2007 sh V0.22 Grobleckprüfung korrigiert
//* 30.07.2007 sh V0.23 Vertauscherprüfung deaktiviert wegen Fehler bei Zeitverhalten
//* 12.10.2007 sh V0.24 Wartezeiten bei Kompressor- und Ventilansteuerung eingebaut
//* 29.10.2007 asc V0.30 Anlaufverhalten den Kompressors beim Heben verändert
//* 02.11.2007 asc V0.40 Ausschaltverhalten bei Handsteuerung definiert
//* 12.11.2007 asc V0.41 Korrektur Handsteuerung
//* 12.12.2007 sh  V0.50 Überarbeitung Vertauscherprüfung
//* 14.12.2007 sh  V0.51 Test und Korrektur allgemein
//* 17.12.2007 sh  V1.00 Version 1.00 wegen SGBD
//* 11.01.2008 sh  V1.01 Korrektur OrgFastfilterwerte
//* 11.01.2008 sh  V1.02 Energiesparmode bei Ansteuerung Hand und Aktuatoren
//* 15.01.2008 sh  V1.03 Korrektur Energiesparmode bei Handansteuerung "1" statt "2"
//* 17.01.2008 sh  V1.10 Korrektur und Ergänzung Anzeige Status Analogwerte
//* 18.01.2008 sh  V1.11 Korrektur Anzeige Offsetwert rechts und englische Texte
//**********************************************************************

#include "inpa.h"
#include "BMW_STD.H"

// Titel, Version, Verantwortung, Steuergerät
string titel  ="Luftfederung F01, F07, F11,";                         // Titel Nacharbeitsprogramm
string version="1.11";                                                  // Version Nacharbeitsprogramm
string origin ="BMW TI-432 Helmich";                                    // Verantwortung Nacharbeitsprogramm
string sgbd   ="EHC_01";                                                // Steuergerät
string gruppe ="G_EHC";                                                 // Gruppendatei

string speicher_lesen_parameter="LAR;FLASH;UIFM;-ROMI;-ROMX;-RAMIS;-RAMIL;-RAMXX;-NVRAM";
// Moegliche Speicher-Parameter: "LAR;FLASH;UIFM;ROMI;ROMX;RAMIS;RAMIL;RAMXX;NVRAM";
// Bei Leerstring erfolgt kein Menüpunkt Speicher Lesen

// allgemeine globale Variable
int zahlen_var_int = 0;
int ganz_zahl;
int input_state;         // Eingabestatus
int input_ok = 0;        // Eingabe  mit OK beendet
int resctr;              // ok
int ansteuerzeit = 0;    // Ansteuerzeit fuer Kompressor und Ventile
int steuerzeit_ist = 0;  // Ist-Ansteuerzeit Variable (E65/E61 mit Faktor)
int delta_links  = 0;    // Eingabevariable fuer Hoehenstandsabgleich
int delta_rechts = 0;    // Eingabevariable fuer Hoehenstandsabgleich
int schon_abgeglichen=0; // Variable, ob Hoehentsandsabgleich durchgefuehrt wurde oder nicht

string text_var;
string rest="";
string steuern_ventil_li = "";  // Variable fuer Balgventil hinten links
string steuern_ventil_re = "";  // Variable fuer Balgventil hinten rechts
string steuern_ventil_ab = "";  // Variable fuer Ablassventil

string steuern_hl_auf    = "";  // Variable fuer hinten links heben
string steuern_hl_ab     = "";  // Variable fuer hinten links senken
string steuern_hr_auf    = "";  // Variable fuer hinten rechts heben
string steuern_hr_ab     = "";  // Variable fuer hinten rechts senken

string steuern_ha_ab     = "";  // Variable fuer Hinterachse heben
string steuern_ha_auf    = "";  // Variable fuer Hinterachse senken
string steuern_comp      = "";    // Variable fuer Kompressoransteuerung

bool   ventil_ab_init = FALSE;  // Variable zur Steuerung des Anfahrens des Kompressors
bool   logik_var;

string string_var;
string job_state;           // JOB_STATUS Variable

real   zahlen_var;

int byte_1 = 0;             // Pruefstempelbyte
int byte_2 = 0;             // Pruefstempelbyte
int byte_3 = 0;             // Pruefstempelbyte

int pruefwert = 0;          // 85 fuer Fahrzeug im Achsmeßstand abgeglichen
//string pruefwert_txt = "";  // String Variable fuer Kontrollbyte

int betriebsmodus_puffer = 0;
int betriebsmodus_puffer_2 = 0;
int betriebsmodus_puffer_3 = 0;

string str_cbd_lu = "";         // Variable fuer LevelUp Byte in der CBD
int    int_cbd_lu = 0;          // Variable fuer LevelUp Byte als Integer fuer Abfrage
string str_cbd_sip = "";        // Variable fuer SIP Byte in der CBD
int    int_cbd_sip = 0;         // Variable fuer SIP Byte als Integer fuer Abfrage

string str_sw_fsv = "";         // Variable fuer SW-Nummer
int    int_sw_fsv = 0;          // Variable fuer SW-Nummer als Integer

string byte1_txt = "";
string byte2_txt = "";
string byte3_txt = "";

string pruefbyte_txt = "";     // String Variable fuer Kontrollbyte
int    pruefbyte = 0;          // 85 fuer Fahrzeug im Achsmeßstand abgeglichen
int    fafi_hl_leak  = 0;
int    fafi_hr_leak  = 0;

// Boolsche Variablen zur Ansteuerung der Hinterachse

bool ha_auf = FALSE;
bool hl_auf = FALSE;
bool hr_auf = FALSE;
bool ha_ab  = FALSE;
bool hl_ab  = FALSE;
bool hr_ab  = FALSE;
bool h_aus  = FALSE;
bool komp   = FALSE;
bool v_hl   = FALSE;
bool v_hr   = FALSE;
bool v_ab   = FALSE;


bool bandmodus = FALSE;
bool verlademodus = FALSE;
bool werkstattmodus = FALSE;
bool lowtolmodus = FALSE;
bool levelupmodus = FALSE;
bool levelupmodus_zahl2bool = FALSE;
bool dumpmodus = FALSE;
bool sipmodus = FALSE;

bool Komp_Status= FALSE;


// Variablen zur Grobleckpruefung

bool EHC_LECK_OK = FALSE;
bool kl_15_ein = FALSE;
bool status_bandmodus     = FALSE;
bool alte_werte_lesen     = FALSE;
bool lesen_filterwerte    = FALSE;
bool vergleich_alt_neu_li = FALSE;
bool vergleich_alt_neu_re = FALSE;
bool bandmodus_reset      = FALSE;

int fafi_hl_aktuell = 0;
int fafi_hr_aktuell = 0;

real real_hl_leak=0;
real real_hr_leak=0;

real real_hinten_links=0;
real real_hinten_rechts=0;

real temp1=0;               // Variable fuer Differenz Fastfilterwert hinten links
real temp2=0;               // Variable fuer Differenz Fastfilterwert hinten rechts

string temp1_txt="";
string temp2_txt="";

string fafi_hl_leak_txt="";
string fafi_hinten_links_txt="";

string fafi_hr_leak_txt="";
string fafi_hinten_rechts_txt="";

int betriebsmodus = 0;
string betriebsmodus_txt = "";

string fehlertext_1="";
string fehlertext_2="";

int levelup_int = 0;
string levelup_int_txt = "";

// Ansteuervariablen zum Heben und Senken der Achse

string funktion = "";     // Textvariable fuer aktivierte Funktion
//int    ansteuerzeit=5;      // 100 = 10 sec Standard- Ansteuerzeit fuer Kompressor und Ventile
//string steuern_vent_li = "";  // Variable fuer Balgventil hinten links
//string steuern_vent_re = "";  // Variable fuer Balgventil hinten rechts
//string steuern_vent_ab = "";  // Variable fuer Ablassventil
//string steuern_comp    = "";  // Variable fuer Kompressoransteuerung
//string argumente    = "";     // Variable zur Ansteuerung der Hinterachse

// Ansteuervariablen zum Hoehenstandsabgleich

string abweich_links;
string abweich_rechts;
int delta_abweich=0;
string min_abweich="0";
string hoehe_links,hoehe_rechts,offset_li_alt,offset_re_alt,offset_li_neu,offset_re_neu;
string abw_links,abw_rechts,aufl_links,aufl_rechts;

// ***********************************************************
// **********    Bildschirm-Manager-Variablen   **************
// ***********************************************************

string z1,z4;
int    s1,s4;
int view_flag=0;
string leer_string= "";



// *************************************************************
// *******     Globale Variablen der EHC- Prüfung       ********
// *************************************************************

bool zuendung_ein_test        = FALSE;
bool c_fg_lesen               = FALSE;
bool bandmodus_aktiv          = FALSE;
bool io_status_lesen_1        = FALSE;
bool links_hinten_auf         = FALSE;
bool rechts_hinten_auf        = FALSE;
bool vergleich_hinten_links   = FALSE;
bool vergleich_hinten_rechts  = FALSE;
bool bandmodus_ruecksetzen    = FALSE;
bool vergleich_hinten         = FALSE;
bool WEITER                   = FALSE;
bool CHANGE_TEST              = FALSE;

int komp_temp_1 = 0;             // Temperatur Kompressor vor Befüllung (kalt, Raumtemperatur)
int komp_temp_2 = 0;             // Temperatur Kompressor nach Befüllung (warm)
int fafi_hinten_links_1  = 0;    //
// int fafi_hinten_links_2  = 0; // lokal
int fafi_hinten_rechts_1 = 0;    //
// int fafi_hinten_rechts_2 = 0; // lokal

int farbe;
int hintergrund;

int state=0;
int sets;
int ErrorCode;
int APIBUSY  = 0;
int APIREADY = 1;
int APIBREAK = 2;
int APIERROR = 3;

bool load_formular_ok, default_druckfeld_ok, print_formular_ok, forget_formular_ok;

//string fehlertext_1 = "";
//string fehlertext_2 = "";

string fg_nummer_txt = "";
string text_var1,text_var2,text_var3,text_var4,text_var5,text_var6;
string step="";





// start of :#include "BMW_STD.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BMW_STD.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.05.2000 rd V0.01 Ersterstellung
//* 23.06.2000 rd V0.02 Überarbeitung für E65 und E85
//* 04.07.2000 rd V0.03 Überarbeitung der Funktionen
//* 08.11.2000 rd V0.04 AIF Lesen Results überarbeitet
//* 01.03.2001 rd V0.05 m_status_flag neu hinzu
//* 02.03.2001 rd V0.06 m_steuern_flag neu hinzu
//* 18.05.2001 rd V0.07 AIF-Ausgabe verbessert
//* 25.04.2002 rd V0.08 Erweiterung HS_LESEN
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Erweiterung Ident für DS2
//* 19.11.2002 rd V1.02 FS_MODE erweitert um PCODEs
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//*            rd V2.00 Entfernung EldiAuftragLesen, EldiAuftragEingeben
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Hinweis im Hauptfenster, wenn Simulationsmodus aktiv ist.
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//**********************************************************************
string package="3.01";

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************

// Umrechnungsfaktoren deutsch / englisch
real   m_c    = 1.0;        // Grad Celsius -> Fahrenheit z = x * m_c + a_c
real   a_c    = 0.0;
real   m_km   = 1.0;     // km           -> miles      z = x * m_km
real   m_l    = 1.0;     // Liter        -> Gallon US  z = x * m_l

// für Info
string sgbd_ecu;
string sgbd_origin;
string sgbd_revision;
string sgbd_package;
string sgbd_sprache;
string sgbd_comment;
string gruppe_ecu;
string gruppe_origin;
string gruppe_revision;
string gruppe_comment;

// für Status-Menü
bool   m_status_flag=TRUE;
// True Status-Menü wird angezeigt

// für Steuern-Menü
bool   m_steuern_flag=TRUE;
// True Steuern-Menü wird angezeigt

// für FS_LESEN speichern
bool   fs_lesen_save_as_flag;

// für IS_LESEN speichern
bool   is_lesen_save_as_flag;

// für HS_LESEN speichern
bool   hs_lesen_save_as_flag;

// für FS_LESEN
bool   fs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LESEN
bool   is_lesen_flag;
// True wenn JOB vorhanden

// für HS_LESEN
bool   hs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LOESCHEN
bool   is_loeschen_flag;
// True wenn JOB vorhanden

// für HS_LOESCHEN
bool   hs_loeschen_flag;
// True wenn JOB vorhanden

// Handle für FS_LESEN
int    f_ort_nr_buffer   = 0;
int    f_ort_text_buffer = 0;

//  In INPA.INI wird festgelegt ob
//   nach FS- IS-, HS-Löschen automatisch wieder gelesen wird.
bool   deleteread_flag;

// Wenn Ediabas im Simulationsmode läuft, dies im Hauptfenster anzeigen
bool   simulation_flag;

// für Ident Screen, bzw. SVK Screen bei UDS (ISO 14229)
int ident_typ;
// 1= DS2
// 2= BMW Fast
// 3= UDS (ISO 14229)


// für SPEICHER_LESEN
bool   speicher_lesen_flag;
// True wenn JOB vorhanden
bool   speicher_lesen_lar_flag;
bool   speicher_lesen_uifm_flag;
bool   speicher_lesen_romi_flag;
bool   speicher_lesen_romx_flag;
bool   speicher_lesen_nvram_flag;
bool   speicher_lesen_ramis_flag;
bool   speicher_lesen_ramxx_flag;
bool   speicher_lesen_flash_flag;
bool   speicher_lesen_ramil_flag;

// für Speicher lesen Ausgabe
string speicher_lesen_text         = "";
string speicher_lesen_seg_adr_anz  = "";
string speicher_lesen_adresse      = "0x000000";
int    speicher_lesen_anzahl       = 64;

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern ScriptInit(); // befindet sich im Hauptprogramm

// start of :#include "BATTERIE.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BATTERIE.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 01.04.2004 rd V2.01 Im Fehlerfalle delay eingebaut
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* ShowBatteryIgnition
//*
//* Anzeige des Batterie- und Zündungs-Status
//*
//**********************************************************************
ShowBatteryIgnition()
{
  bool   fehlerflag;    // Fehler aufgetreten
  bool   fehlerflag2;   // Fehler aufgetreten
  bool   zuendung;      // Zündung ein/aus
  bool   batterie;      // Batterie ein/aus
  int    wert;          // allgemeine Variable

  ftextout("Batterie :", 0,5,1,0);
  ftextout("Zündung  :", 0,45,1,0);

  INPAapiJob("UTILITY","STATUS_UBATT","","");
  INP1apiResultInt(fehlerflag,wert,"STAT_UBATT",1);
  if ((fehlerflag!=TRUE) || (wert==0))
  {
    batterie=FALSE;
    zuendung=FALSE;
  }
  else
  {
    batterie=TRUE;
    INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
    INP1apiResultInt(fehlerflag2,wert,"STAT_ZUENDUNG",1);
    if ((fehlerflag2!=TRUE) || (wert==0))
      zuendung=FALSE;
    else
      zuendung=TRUE;
  }
  digitalout(batterie, 0,20,"","");
  if (batterie==TRUE)
    ftextout("ein  ", 0,25,1,0);
  else
  {
    if (fehlerflag==TRUE)
    {
      ftextout("aus  ", 0,25,1,0);
    }
    else
    {
      ftextout("---  ", 0,25,1,0);
    }
  }

  digitalout(zuendung, 0,62,"","");
  if (zuendung==TRUE)
    ftextout("ein  ", 0,67,1,0);
  else
  {
    if (fehlerflag2==TRUE)
    {
      ftextout("aus  ", 0,67,1,0);
    }
    else
    {
      ftextout("---  ", 0,67,1,0);
    }
  }

  if ((fehlerflag!=TRUE) || (fehlerflag2!=TRUE))
  {
    delay(2000);
  }
}
// -- EOF --
// end of :#include "BATTERIE.SRC"
// start of :#include "GRP_INFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GRP_INFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 EDIABAS.INI-Abfrage ob Simulationsmode aktiv ist
//* 18.10.2006 GA V3.01 Abfrage ob EDIABAS im Simulationsmodus läuft ist jetzt nicht mehr auf Pfad c:\windows\ediabas.ini beschränkt
//**********************************************************************

//**********************************************************************
//*
//* GruppenDateiInfo
//*
//* Versionsinformationen über Gruppendatei
//*
//**********************************************************************
import32 "C" lib "api32.DLL::__apiGetConfig" ApiGetConfig(in:long Handle,in: string Name,out: string Buffer, returns: int ReturnedValue);
GruppenDateiInfo( in: string grp,
                  inout: string grp_ecu, inout: string grp_origin,
                  inout: string grp_revision, inout: string grp_comment)
{
  string CurDir;
  string Temp;
  string Puffer;
  int    Size;
  long   PufferSize;
  int    ret_int;
  string BS;
  string CR;
  int    pos1;
  int    pos2;
  int    simulation;
  int    input;
  long   Handle;
  int    Returned;
  string ini_path= "??????????????????????";//Variable muß ausreichend lang vorbelegt sein!
  //                C:\ec-apps\ediabas\bin

  chr( 92, BS ); // '\'
  chr( 13, CR );

  // Pfad für EDIBAS.INI ermitteln
  // WERT 2 wurde durch Tests ermittelt
  Handle=2;
  ApiGetConfig(Handle,"EDIABASINIPATH",ini_path,Returned);
  //Abfrage, ob EDIABAS im Simulationsmodus betrieben wird. Hinweisfenster erfolgt im Hauptfenster s_main
  GetPrivateProfileInt("Configuration","Simulation",2,ini_path+BS+"ediabas.ini",simulation);
  if (simulation == 1) simulation_flag= TRUE;
  else simulation_flag= FALSE;

  Size=256;
  space(CurDir,Size);
  GetCurrentDirectory(256, CurDir, ret_int);
  SetCurrentDirectory("\EDIABAS\BIN", ret_int);

  Size=1024;
  space(Puffer,Size);
  inttolong(Size, PufferSize);
  XTRACT("\ediabas\ecu"+ BS + grp + ".grp", 1, Puffer, PufferSize, ret_int);

  grp_ecu="";
  instr(pos1, 0, Puffer, "ECU:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 4;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_ecu, Puffer, pos1, pos2 - pos1);
  }

  grp_origin="";
  instr(pos1, 0, Puffer, "ORIGIN:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 7;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_origin, Puffer, pos1, pos2 - pos1);
  }

  grp_revision="";
  instr(pos1, 0, Puffer, "REVISION:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 9;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
    midstr(grp_revision, Puffer, pos1, pos2 - pos1);
  }

  grp_comment="";
  pos1=0;
  pos2=0;
  while ((pos1 >= 0) && (pos2 >= 0))
  {
    instr(pos1, pos2, Puffer, "ECUCOMMENT:");
    if (pos1 >= 0)
    {
      pos1 = pos1 + 11;
      instr(pos2, pos1, Puffer, CR );
      if (pos2 > pos1)
      {
        midstr(Temp, Puffer, pos1, pos2 - pos1);
        grp_comment=grp_comment+Temp+",";
      }
    }
  }
  SetCurrentDirectory(CurDir, ret_int);
}
// -- EOF --
// end of :#include "GRP_INFO.SRC"
// start of :#include "SGBDINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SGBDINFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern SgbdInfo(in: string sg,
                inout: string sg_ecu, inout: string sg_origin,
                inout: string sg_revision, inout: string sg_package,
                inout: string sg_comment, inout: string sg_sprache);

//**********************************************************************
//*
//* SgbdInfo
//*
//* Versionsinformationen über SGBD
//*
//**********************************************************************
SgbdInfo( in: string sg,
          inout: string sg_ecu, inout: string sg_origin,
          inout: string sg_revision, inout: string sg_package,
          inout: string sg_comment, inout: string sg_sprache)
{
  INPAapiJob(sg,"INFO","","");
  INPAapiResultText(sg_ecu,"ECU",1,"");
  INPAapiResultText(sg_revision,"REVISION",1,"");
  INPAapiResultText(sg_package,"PACKAGE",1,"");
  INPAapiResultText(sg_origin,"ORIGIN",1,"");
  INPAapiResultText(sg_comment,"COMMENT",1,"");
  INPAapiResultText(sg_sprache,"SPRACHE",1,"");
}

// -- EOF --
// end of :#include "SGBDINFO.SRC"
// start of :#include "SGBDINPA.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SgbdInpa.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Gezielte Ausgabe, wenn Gruppendatei oder SGBD nicht existiert
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 18.10.2006 GA V3.01 Check bezüglich auf Gruppen-Simulationsdatei, sowie "Identification error" erweitert
//* 24.10.2006 GA V3.02 Überprüfung ob T_GRTB.PRG vorhanden eingebaut
//**********************************************************************

//**********************************************************************
//*
//* SgbdInpaCheck
//*
//* Überprüfung ob SGBD zu INPA passt
//*
//**********************************************************************
SgbdInpaCheck()
{
  string sgbd_version;             // für Versionskontrolle
  string inpa_version;             // für Versionskontrolle
  string inpa_sprache="deutsch"; // für Sprachvariante
  string variante="???";           // für Variantenkontrolle
  string err_text;                 // Fehlertext
  int    errorcode;                // Errorcode
  bool   fehlerflag;               // Fehlerflag
  string temp;
  string temp1;
  string temp2;
  int    i;
  int    k;
  int    kk;                       // für neue VersionsnummernKontrolle
  int    ii;
  int    a;
  int    aa;
  int    i1;
  int    i2;
  int    i3;                       // für neue VersionsnummernKontrolle
  string sgbd_String_Lang;
  string sgbd_von_inpa_version;
  string ver_temp;
  string ver_temp1;
  string ver_temp2;
  string ver_temp3="--";
  real   Version_SGBD;
  real   Version_INPA;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  int    ret_int;
  int    Size;
  int    filecheck;
  string hinweis_text;

  settitle(titel+" Version "+version);
  a=0;
  ii=0;
  i3=0;
  kk=0;
  aa=0;
  i=0;
  k=0;
  fehlerflag=FALSE;
  temp1="";
  temp2="";

  instr(i,k,","+gruppe+",",",");
  while ((i >= 0) && (fehlerflag == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppe+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppe+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(fehlerflag,variante,"VARIANTE",0,"");
      if (fehlerflag == TRUE) gruppe=temp;
      else
      {
        INP1apiErrorCode(errorcode);
        if (errorcode == 36)//Fehlende oder fehlerhafte Simulationsdatei
        {
           Size=256;
           space(CurDir,Size);
           GetCurrentDirectory(256, CurDir, ret_int);
           SetCurrentDirectory("\EDIABAS\SIM", ret_int);
           fileexist(temp+".SIM",filecheck);
           SetCurrentDirectory(CurDir, ret_int);
           if (filecheck == 0)
           {
             temp1= temp1+", "+temp+".SIM";//Fehlerhafte Simulationsdatei
           }
           else
           {
             temp2= temp2+", "+temp+".SIM";//Fehlende Simulationsdatei
           }
        }
      }
    }
  }

  instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
  instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
  if ((i == 0) || (k == 0))
       hinweis_text= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
  else hinweis_text= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an

  if (fehlerflag == FALSE)
  {
     //Fehlende oder fehlerhafte Gruppen-Simulationsdatei
     if (errorcode == 36)
     {
        //Fehlerhafte Simulationsdatei
        if (temp1 != "")
        {
          strlen(k,temp1);
          instr(i,k,temp1+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp1+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp1,temp1,1,k);//Kommata vor und hinter temp1 ausschneiden
          temp1= "Fehlerhafte Simulationsdatei: "+temp1+CRLF;
        }
        //Fehlende Simulationsdatei
        if (temp2 != "")
        {
          strlen(k,temp2);
          instr(i,k,temp2+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp2+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp2,temp2,1,k);//Kommata vor und hinter temp2 ausschneiden
          temp2= "Fehlende Simulationsdatei  : "+temp2+CRLF;
        }

        messagebox("Variantenkontrolle",
                   "Fehler!"+CRLF+
                   temp1+//Fehlerfafte Gruppen-Simulationsdateien
                   temp2+//Fehlende     -//-
                   "Das Programm wird abgebrochen!");
        exit();
     }

     //Gruppendatei vorhanden?
     Size=256;
     space(CurDir,Size);
     GetCurrentDirectory(256, CurDir, ret_int);
     SetCurrentDirectory("\EDIABAS\ECU", ret_int);
     fileexist(gruppe+".GRP",filecheck);
     SetCurrentDirectory(CurDir, ret_int);
     if (filecheck == 0)//Gruppendatei vorhanden, SGBD-, Kommunikationsfehler hier ausgeben
     {
       INP1apiErrorText(err_text);//Fehler beim Aufruf der VARIANTE?
       if (errorcode == 92)//92=SYS-0002: SG-Variantenbeschreibungsdatei (SGBD) nicht gefunden
       {
         //T_GRTB.PRG vorhanden?
         Size=256;
         space(CurDir,Size);
         GetCurrentDirectory(256, CurDir, ret_int);
         SetCurrentDirectory("\EDIABAS\ECU", ret_int);
         fileexist("T_GRTB.PRG",filecheck);
         SetCurrentDirectory(CurDir, ret_int);
         if (filecheck == 0)//T_GRTB.PRG ist vorhanden, somit fehlt die SGBD.
         {
           messagebox("Variantenkontrolle",
                      "Fehler!"+CRLF+
                      err_text+". "+CRLF+
                      " "+CRLF+
                      "Das Steuergerät läßt sich zwar über die Gruppendatei: "+gruppe+".GRP"+" ansprechen,"+CRLF+
                      "aber zur Diagnose fehlt eine entsprechende SGBD (*.PRG) im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                      " "+CRLF+
                      "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                      " "+CRLF+
                      "Das Programm wird abgebrochen!");
         }
         else//T_GRT.PRG fehlt
         {
           messagebox("Variantenkontrolle",
                     "Fehler!"+CRLF+
                     err_text+". "+CRLF+
                     " "+CRLF+
                     "Die Datei T_GRTB.PRG fehlt im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                     " "+CRLF+
                     "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                     " "+CRLF+
                     "Das Programm wird abgebrochen!");
         }
       }
       else if (errorcode == 102)//102= Identification error
       {
         instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
         instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
         if ((i == 0) || (k == 0))
              temp1= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
         else temp1= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                    hinweis_text+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
       else //alle anderen Fehler
       {
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    " "+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
     }
     else//Gruppendatei nicht vorhanden
     {
        messagebox("Variantenkontrolle",
        "Fehler! Gruppendatei : "+gruppe+".GRP "+CRLF+
        "existiert nicht im Verzeichnis ..\EDIABAS\ECU"+CRLF+
        " "+CRLF+
        "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
        " "+CRLF+
        "Das Programm wird abgebrochen!");
     }
     exit();
  }

  i1=0;
  i2=0;
  instr(i1,0,","+sgbd+",",","+variante+",");
  if (i1 < 0)
  {
    instr(i2,0,","+sgbd+",",","+variante+"/");
    if (i2 < 0)
    {
      messagebox("Variantenkontrolle",
                 "Gesuchtes Steuergerät: '"+sgbd+"' nicht gefunden. "+CRLF+
                 "Gefundenes Steuergerät: '"+variante+"'. "+CRLF+
                 " "+CRLF+
                 "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                 hinweis_text+CRLF+
                 " "+CRLF+
                 "Das Programm wird abgebrochen!");
      exit();
    }

    ver_temp3 = "--";
    instr(ii,i2,sgbd+",",",");
    if (ii >= 0)
    {
      midstr(ver_temp3,sgbd+",",i2,ii);
      instr(i3,0,ver_temp3,"/");
      if (i3 >= 0)
      {
        a = i2+i3+1;
        aa = ii-i2+i3-1;
        midstr(ver_temp3,sgbd+",",a,aa);
      }
    }
  }

  sgbd_String_Lang = sgbd;
  sgbd=variante;

//
// Info: Informatinon bei aufruf ohne BMW_STD.SRC
//
// ####################################################
// # //für Info                                       #
// #   string sgbd_ecu;                               #
// #   string sgbd_origin;                            #
// #   string sgbd_revision;                          #
// #   string sgbd_package;                           #
// #   string sgbd_sprache;                           #
// #   string sgbd_comment;                           #
// #   string gruppe_ecu;                             #
// #   string gruppe_origin;                          #
// #   string gruppe_revision;                        #
// #   string gruppe_comment;                         #
// #                                                  #
// #   #include "SgbdInfo.src"                        #
// ####################################################
//
//
  SgbdInfo(sgbd, sgbd_ecu, sgbd_origin, sgbd_revision, sgbd_package, sgbd_comment, sgbd_sprache);
// Bitte VARIABLEN als Globale variable aktivieren und Include (siehe Block //INFO)
//
//

  //Versionskontrolle Auf 3 stellen vor / hinter dem "."
  instr(i3,0,ver_temp3,"V");
  if(i3>=0)
  {
    instr(i2,0,ver_temp3,",");
    midstr(ver_temp3,ver_temp3,i3+1,i2-1);
    stringtoreal(ver_temp3,Version_INPA);
    realtostring(Version_INPA,"3.3",ver_temp3);
    midstr(sgbd_von_inpa_version,ver_temp3,0,2);
  }
  stringtoreal(version,Version_INPA);
  realtostring(Version_INPA,"3.3",version);
  midstr(inpa_version,version,0,2);

  stringtoreal(sgbd_revision,Version_SGBD);
  realtostring(Version_SGBD,"3.3",sgbd_revision);
  midstr(sgbd_version,sgbd_revision,0,2);

  temp=inpa_version;
  temp1=sgbd_version;

  if (ver_temp3 == "--")
  {
    // Vergleichen mit Versionsnummer INPA & SGBD
    if (inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!");
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }
  else
  {
    // Vergleichen mit Versionsnummer INPA(SGBD Vorwahl) & SGBD
    if (sgbd_von_inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!"+CRLF+CRLF+
                 "SGBD Version: "+ ver_temp3 +" (in INPA) "+CRLF+
                 "SGBD Version: "+ sgbd_revision +CRLF+
                 "INPA Version: "+ version);
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }

  if (inpa_sprache != sgbd_sprache)
  {
    messagebox("Sprachvariantenkontrolle",
               "Nicht zusammenpassende Sprachvariante. "+CRLF+
               "Fehlfunktion ist möglich!");
  }
}

// -- EOF --
// end of :#include "SGBDINPA.SRC"
// start of :#include "GRPCHECK.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GrpCheck.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//* 20.04.2007 GA V3.02 FS-, IS-, HS_LESEN werden in einzelnen Tempdateien in ..\EDIABAS\BIN abgelegt
//**********************************************************************

//**********************************************************************
//*
//* GroupCheck
//*
//* Überprüfung der Gruppen-Info
//*
//**********************************************************************
GroupCheck()
{
  string err_text;                 // Fehlertext
  bool   fehlerflag;               // Fehlerflag
  string temp;
  int    sgbd_saetze;              // für Funktionen-Suche in SGBD
  string job_name;                 // JOBNMAE in SGBD
  int    i;

  fehlerflag=FALSE;
  i=0;

  GruppenDateiInfo(gruppe, gruppe_ecu, gruppe_origin, gruppe_revision, gruppe_comment);

  // Vorbelegung der Flags
  fs_lesen_flag       = FALSE;
  is_lesen_flag       = FALSE;
  speicher_lesen_flag = FALSE;
  is_loeschen_flag    = FALSE;
  hs_loeschen_flag    = FALSE;

  INPAapiJob(sgbd,"_JOBS","","");

  INP1apiResultSets(fehlerflag, sgbd_saetze);
  if (fehlerflag == FALSE)
  {
    INP1apiErrorText(err_text);
    messagebox("Unerwarteter Fehler", // sollte nie kommen
                err_text+". "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }
  i = 1;
  while ( i <= sgbd_saetze)
  {
    INPAapiResultText(job_name,"JOBNAME",i,"");
    if (job_name == "FS_LESEN" )       fs_lesen_flag=TRUE;
    if (job_name == "IS_LESEN" )       is_lesen_flag=TRUE;
    if (job_name == "HS_LESEN" )       hs_lesen_flag=TRUE;
    if (job_name == "IS_LOESCHEN" )    is_loeschen_flag=TRUE;
    if (job_name == "HS_LOESCHEN" )    hs_loeschen_flag=TRUE;
    if (job_name == "SPEICHER_LESEN" ) speicher_lesen_flag=TRUE;

    if ((fs_lesen_flag == TRUE) &&
        (is_lesen_flag == TRUE) &&
        (hs_lesen_flag == TRUE) &&
        (is_loeschen_flag == TRUE) &&
        (hs_loeschen_flag == TRUE) &&
        (speicher_lesen_flag) == TRUE) i = sgbd_saetze;
    i = i + 1;
  }
  if (speicher_lesen_parameter == "")  speicher_lesen_flag = FALSE;

  if (speicher_lesen_flag == TRUE)
  {
    instr(i, 0, ";"+speicher_lesen_parameter+";", ";LAR;");
    if ( i == -1 ) speicher_lesen_lar_flag = FALSE; else speicher_lesen_lar_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";FLASH;");
    if ( i == -1 ) speicher_lesen_flash_flag = FALSE; else speicher_lesen_flash_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";UIFM;");
    if ( i == -1 ) speicher_lesen_uifm_flag = FALSE; else speicher_lesen_uifm_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMI;");
    if ( i == -1 ) speicher_lesen_romi_flag = FALSE; else speicher_lesen_romi_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIS;");
    if ( i == -1 ) speicher_lesen_ramis_flag = FALSE; else speicher_lesen_ramis_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIL;");
    if ( i == -1 ) speicher_lesen_ramil_flag = FALSE; else speicher_lesen_ramil_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";NVRAM;");
    if ( i == -1 ) speicher_lesen_nvram_flag = FALSE; else speicher_lesen_nvram_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMX;");
    if ( i == -1 ) speicher_lesen_romx_flag = FALSE; else speicher_lesen_romx_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMXX;");
    if ( i == -1 ) speicher_lesen_ramxx_flag = FALSE; else speicher_lesen_ramxx_flag = TRUE;
  }

  //IDENT-Typ ermitteln: DS2, BMW Fast oder UDS?
  INP1apiJob(sgbd,"IDENT","","");
  INP1apiResultText(fehlerflag,temp,"ID_DATUM_KW",1,"");//Hat nur DS2
  if ((fehlerflag == TRUE) && (temp != ""))
  {
    ident_typ= 1;//DS2
  }
  else//UDS, BMW Fast
  {
    INP1apiResultText(fehlerflag,temp,"ID_SGBD_INDEX",1,"");
    if ((fehlerflag == TRUE) && (temp != "")) ident_typ= 3; //Hat nur UDS (ISO 14229)
    else ident_typ= 2; //sonst BMW Fast
  }
}
// -- EOF --
// end of :#include "GRPCHECK.SRC"
// start of :#include "FS_LESEN.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen FS_LESEN.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 21.11.2000 rd V0.10 Umweltbedingungen als Zahl oder Text ( 0-n, Hex )
//* 02.03.2001 rd V0.11 Shadowspeicher umbenannt in Infospeicher
//* 25.04.2002 rd V1.00 Erweiterung HS_LESEN
//* 22.10.2002 rd V1.01 Erweiterung FS_LESEN
//*               V1.01 PCODE und PCODE7 Ausgabe neu
//*               V1.01 Fehlerbehandlung verbessert
//* 19.11.2002 iS V1.02 Fehlerbehandlung F_ORT_TEXT, F_UW_ANZ, F_PCODE
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Fehlerausgaben korrigiert und erweitert
//* 28.06.2006 GA V3.01 Bei UDS: Ausgabe "F_UW_DATUM_ZEIT" durch "F_UW_ZEIT" ersetzt, da Result entfällt
//* 19.10.2006 GA V3.02 Bei DS2: wurde nicht angezogen da if-Bedingung nicht korrekt gewesen ist.
//*            GA V3.02 Result: F_UW_ZEIT von Unterprg.: fs_protokoll_uwb in fs_protokoll_uwb_uds verschoben
//*            GA V3.02 Result: F_EREIGNIS_DTC: Text wurde inverse ausgegeben
//* 07.02.2007 GA V3.03 Result: F_EREIGNIS_DTC: Erklärender Text, was ein Ereinis DTC ist, war falsch
//**********************************************************************

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************
int    _FsMode        = 0x7FF; // alles ein
string _FsFileMode    = "w";
string _PreInfoFile   = "";
string _PostInfoFile  = "";
string _ApiFsJobName  = "FS_LESEN";

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern INPAapiFsMode_neu ( in: int FsMode, in: string FsFileMode,
                           in: string PreInfoFile, in: string PostInfoFile,
                           in: string ApiFsJobName);

extern INPAapiFsLesen_neu( in: string ecu, in: string FileName);

extern fs_protokoll_ort(in: int nr);
extern fs_protokoll_ort_uds(in: int nr);
extern fs_protokoll_PCode(in: int nr);
extern fs_protokoll_PCode7(in: int nr);
extern fs_protokoll_SAECode(in: int nr);
extern fs_protokoll_hfk(in: int nr);
extern fs_protokoll_hfk_uds(in: int nr);
extern fs_protokoll_art(in: int nr);
extern fs_protokoll_art_uds(in: int nr);
extern fs_protokoll_art_e(in: int nr);
extern fs_protokoll_uwb(in: int nr);
extern fs_protokoll_uwb_uds(in: int nr);
extern fs_protokoll_hex(in: int nr);
extern fs_protokoll_telantwort(in: int nr);

//**********************************************************************
//*
//* INPAapiFsMode_neu kompatibel mit INPAapiFsMode
//*
//**********************************************************************
INPAapiFsMode_neu(  in: int    FsMode,
                    in: string FsFileMode,
                    in: string PreInfoFile,
                    in: string PostInfoFile,
                    in: string ApiFsJobName)
{
  _FsMode       = FsMode;
  _FsFileMode   = FsFileMode;
  _PreInfoFile  = PreInfoFile;
  _PostInfoFile = PostInfoFile;
  _ApiFsJobName = ApiFsJobName;


  INPAapiFsMode(_FsMode, _FsFileMode, _PreInfoFile, _PostInfoFile, _ApiFsJobName);
  if (_ApiFsJobName=="") _ApiFsJobName="FS_LESEN";
}

//**********************************************************************
//*
//* INPAapiFsLesen_neu kompatibel mit INPAapiFsLesen
//*
//**********************************************************************
INPAapiFsLesen_neu( in: string ecu, in: string FileName)
{
  string _ecu;
  string _FileName;
  bool   rc;
  int    i;
  int    k;
  int    len;
  int    x1;
  long   xL;
  string temp1;
  string temp2;
  string temp3;
  string temp11;
  string temp12;
  string temp21;
  string temp22;
  int    F_VERSION;
  string JOB_STATUS;
  string JOB_MESSAGE;
  string VARIANTE;
  int    SETS;
  int    UW_SETS;
  string FS_CODE;
  string F_PCODE;
  string F_PCODE7;
  string F1_VERSION;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string errorcode_text;           // EDIABAS Fehlernummer als Text

  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  _ecu      = ecu;
  _FileName = FileName;


  //SGBD-Version auslesen
  sgbd_version= "???";
  INPAapiJob(_ecu,"INFO","","");
  INP1apiResultText(rc, sgbd_version, "REVISION", 1, "");

  INPAapiJob(_ecu, _ApiFsJobName,"","");
  INP1apiResultInt(rc, F_VERSION, "F_VERSION",1 );

  INP1apiErrorCode(errorcode);

//UDS:
  if ((rc == TRUE) && ( F_VERSION == 3 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort_uds(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="??????";
            StrArrayWrite(f_ort_text_buffer,i,temp1);

            INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
            if (rc == TRUE)
            {
              GetBinaryDataString (temp1,len);
              midstr(temp1,temp1,0,6);
            }
            else
            {
              temp1= "??????";
              filewrite("");
              filewrite("### Fehler beim Lesen des Results: F_HEX_CODE ###");
              filewrite("");
              INP1apiErrorCode(errorcode);
              if (errorcode != 0)
              {
                inttostring(errorcode, errorcode_text);
                INP1apiErrorText(error_text);
                error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
                ftextout(error_text ,2,0,0,0);
              }
            }
            StrArrayWrite(f_ort_nr_buffer,i,temp1);

            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort_uds(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_SAECode(1);//0x200 von BMW Fast für PCode genommen
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk_uds(1);
                k=1;

                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb_uds(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite("0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);

                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite("0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//BMW FAST:
  else if ((rc == TRUE) && ( F_VERSION == 2 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="????";

            StrArrayWrite(f_ort_text_buffer,i,temp1);
            INPAapiResultInt(x1, "F_ORT_NR", i);
            inttohexstring(x1, 4, temp1);
            StrArrayWrite(f_ort_nr_buffer,i,temp1);
            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_PCode(1);
                if ((_FsMode & 0x400) != 0) fs_protokoll_PCode7(1);
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk(1);
                k=1;
                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite( "0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                {
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                }
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);
                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite( "0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//DS2
  else if (errorcode == 134)//134=SYS-0014: Result nicht gefunden: 'F_VERSION'
  {
    INPAapiFsLesen( _ecu, _FileName);
  }
//Fehlerhafter Aufruf
  else
  {
    INPAapiCheckJobStatus("OKAY");//Damit der Bediener die Fehlermeldung bestätigen muß
    getdate(temp1);
    gettime(temp2);
    INP1apiErrorText(temp3);
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite( "");
    filewrite( "Datum    : "+temp1+" "+temp2);
    filewrite( "ECU      : "+_ecu);
    filewrite( "JobStatus: "+JOB_STATUS+"-->"+temp3) ;
    filewrite( "-------------------------------------------------------------------------------");
    fileclose();
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für DS2 und BMW Fast
//*
//**********************************************************************
fs_protokoll_ort(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  INP1apiResultInt(rc,x1, "F_ORT_NR", i);
  if (rc == TRUE)
  {
    inttohexstring(x1, 4, temp1);
  }
  else
  {
    temp1="????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für UDS (ISO 14229)
//*
//**********************************************************************
fs_protokoll_ort_uds(in: int nr)
{
  int    i;
  int    len;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");

  INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
  if (rc == TRUE)
  {
    if (_ApiFsJobName == "FS_LESEN")
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,0,6);
    }
    else//IS_LESEN
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,2,6);//Byte 0, Zeichen 0 und 1 sind das severity Byte!
    }

  }
  else
  {
    temp1= "??????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"??????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE
//*
//**********************************************************************
fs_protokoll_PCode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcodeText;
  string tempPcodeString;
  string tempPcodeHex;

  i=nr;
  INP1apiResultText(rc,tempPcodeString, "F_PCODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcodeText, "F_PCODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcodeHex);
        tempPcodeHex= "0x"+tempPcodeHex;
      }
      else
      {
        tempPcodeHex = "????";
      }
    }
    else
    {
      tempPcodeText = "????";
    }

    if (tempPcodeString == "??")
    {
      filewrite( "");
      filewrite( tempPcodeHex+"  "+tempPcodeText);
    }
    else
    {
      if (tempPcodeString != "--")
      {
        filewrite( "");
        filewrite( tempPcodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE7
//*
//**********************************************************************
fs_protokoll_PCode7(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcode7Text;
  string tempPcode7String;
  string tempPcode7Hex;

  i=nr;
  INP1apiResultText(rc,tempPcode7String, "F_PCODE7_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcode7Text, "F_PCODE7_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE7", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcode7Hex);
        tempPcode7Hex= "0x"+tempPcode7Hex;
      }
      else
      {
        tempPcode7Hex = "????";
      }
    }
    else
    {
      tempPcode7Text = "????";
    }

    if (tempPcode7String == "??")
    {
      filewrite( "");
      filewrite( tempPcode7Hex+"  "+tempPcode7Text);
    }
    else
    {
      if (tempPcode7String != "--")
      {
        filewrite( "");
        filewrite( tempPcode7Text);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe SAE Code für UDS
//*
//**********************************************************************
fs_protokoll_SAECode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempSAECodeText;
  string tempSAECodeString;
  string tempSAECodeHex;

  i=nr;
  INP1apiResultText(rc,tempSAECodeString, "F_SAE_CODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempSAECodeText, "F_SAE_CODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_SAE_CODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempSAECodeHex);
        tempSAECodeHex= "0x"+tempSAECodeHex;
      }
      else
      {
        tempSAECodeHex = "????";
      }
    }
    else
    {
      tempSAECodeText = "????";
    }

    if (tempSAECodeString == "??")
    {
      filewrite( "");
      filewrite( tempSAECodeHex+"    "+tempSAECodeText);
    }
    else
    {
      if (tempSAECodeString != "--")
      {
        filewrite( "");
        filewrite( tempSAECodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit
//*
//**********************************************************************
fs_protokoll_hfk(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;
  int f_hfk;
  int f_lz;

  i=nr;
  filewrite( "");

  INP1apiResultInt(rc,f_hfk,"F_HFK",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_hfk,temp1);
    if (f_hfk < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    filewrite( "Fehlerhäufigkeit: "+ temp1);
  }

  INP1apiResultInt(rc,f_lz,"F_LZ",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_lz,temp1);
    if (f_lz < 10) temp1= " "+temp1;//Formatierung der Nr des Logistikzählers, wenn sie kleiner 10 ist
    filewrite( "Logistikzähler  : "+ temp1);
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit für UDS
//*
//**********************************************************************
fs_protokoll_hfk_uds(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  //FS Überlauf
  INP1apiResultInt(rc,x1, "F_UEBERLAUF", i);
  if ((rc == TRUE) && (x1==1))
  {
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    if (_ApiFsJobName == "IS_LESEN")
      filewrite("++++++++++++++++++++++++ Infospeicher ist übergelaufen! +++++++++++++++++++++++");
    else
      filewrite("+++++++++++++++++++++++ Fehlerspeicher ist übergelaufen! ++++++++++++++++++++++");
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    filewrite( "");
  }

  //Fehlerhäufigkeit
  INP1apiResultInt(rc,x1, "F_HFK", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
   {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    }
  }
  filewrite( "Fehlerhäufigkeit: "+ temp1);

  //Heilungszähler
  INP1apiResultInt(rc,x1, "F_HLZ", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
    {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung des Heilungszählers, wenn er kleiner 10 ist
    }
  }
  filewrite( "Heilungszähler  : "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten
//*
//**********************************************************************
fs_protokoll_art(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_SYMPTOM_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe erweiterte Fehlerarten
//*
//**********************************************************************
fs_protokoll_art_e(in: int nr)
{
  int    i;
  int    k;
  int    F_ART_ANZ;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  INP1apiResultInt(rc,F_ART_ANZ, "F_ART_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_ART_ANZ > 0 )
    {
      k=0;
      while ( k < F_ART_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);
        INP1apiResultText(rc,temp1, "F_ART"+temp2+"_TEXT", i, "");
        if (rc == FALSE)  temp1 ="????";
        if (temp1 !="--") filewrite( "   "+ temp1);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten für UDS
//*
//**********************************************************************
fs_protokoll_art_uds(in: int nr)
{//Symptome entfallen bei UDS!
  int    i;
  int    x1;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  //Neu bei UDS:
  INP1apiResultInt(rc,x1, "F_EREIGNIS_DTC", i);
  if (rc == TRUE)
  {
    if (x1==0)
    {
      filewrite("   Dies ist kein Ereignis DTC. Das SG ist für den Fehlerspeicheintrag (DTC) verantwortlich.");
    }
    else if (x1==1)
    {
      filewrite("   Dies ein Ereignis DTC. Das SG ist somit nicht für den Fehlereintrag (DTC) verantwortlich.");
      filewrite("   Z.B. falsche oder fehlende Netzwerkinformationen.");
    }
    else
    {
      filewrite("   Fehler in SGBD! In Tabelle FOrtTexte, Spalte EREIGNIS_DTC muß 0 oder 1 stehen!");
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb(in: int nr)
{
  int    i;
  int    k;
  int    len;
  int    F_UW_ANZ;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  real   realval;
  int    pos;

  i=nr;
/*  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");
*/
  INP1apiResultText(rc,temp1, "F_UW_KM", i, "8L");
  if (rc == FALSE) temp1="    ????";
  if ((temp1 == "524280") && (ident_typ != 3)) temp1 = "-1";//Fehlerüberlauf für DS2 und BMW FAST, UDS liefert es von alleine

  temp2 =    "Kilometerstand                        ";
  filewrite( "   " + temp2 + temp1 + "     km");


  INP1apiResultInt(rc,F_UW_ANZ, "F_UW_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_UW_ANZ > 0 )
    {
      k=0;
      while ( k < F_UW_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);

        INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
        if (rc == TRUE)
        {
          AnsiUpper(temp3,temp3);
        }
        else
        {
          temp3 = "????";
        }
        if ((temp3 == "0-N") || (temp3 == "HEX"))
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-20T");
          if (rc == FALSE) temp1="????                ";
          if (temp1 !="--                  ") //"--" + 18 Zeichen

          {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "28T");
              if (rc == FALSE) temp3="????                        ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
          }
        }
        else
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-40T");
          if (rc == FALSE) temp1="????                                    ";
          if (temp1 !="--                                      ")
           {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "8.2R");
              if (rc == FALSE) temp3=" ????   ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
           }
         }
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb_uds(in: int nr)
{
  int    i;
 // int    k;
//  int    len;
//  int    F_UW_ANZ;
  bool   rc;
  string temp1;
//  string temp2;
//  string temp3;
//  real   realval;
//  int    pos;

  i=nr;
  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");

  fs_protokoll_uwb(i);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Hexcode
//*
//**********************************************************************
fs_protokoll_hex(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;

  chr(10,nl);
  i=nr;
  filewrite( "");
  INP1apiResultBinary(rc,"F_HEX_CODE", i);
  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????";
  }
  filewrite( "Fehlercode: "+temp2);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Telegrammantwort(en)
//* Wird nur bei Fehlerhaften FS_LESEN_DETAIL ausgegeben
//*
//**********************************************************************
fs_protokoll_telantwort(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  string temp4;
  string temp5;

  chr(10,nl);
  i=nr;
  filewrite( "");

  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_SNAPSHOT", i);
    else INP1apiResultBinary(rc,"_RESPONSE_2000", i);//IS_LESEN
  }
  else//1=DS2, 2=BMW Fast
  {
    INP1apiResultBinary(rc,"_TEL_ANTWORT", i);
  }


  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????--> Zur Analyse IFH-Trace benutzen!";
  }

  //2. Telegramm nur für UDS ausgeben
  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_EXTENDED_DATA", i);
    else INP1apiResultBinary(rc,"_RESPONSE_200X", i);//IS_LESEN

    if (rc == TRUE)
    {
      GetBinaryDataString (temp1, x1);
      x2 = 0;
      x3 = 0;
      temp4="";
      while ( x2 < x1 )
       {
         midstr(temp3, temp1, x2, 2);
         temp4 = temp4 + temp3;
         x2 = x2 + 2;
         x3 = x3 + 1;
         if ( x2 < x1 )
         {
           if ( x3 < 16 )//Leerzeichen zwischen den Bytes
           {
             if ( x3 == 8 )
               temp4 = temp4 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
             else temp4 = temp4 + " ";
           }
           else
           {
             x3 = 0;
             temp4 = temp4 + nl + "            ";
           }
         }
      }
    }
    else
    {
      temp4 = "????--> Zur Analyse IFH-Trace benutzen!";
    }

    filewrite("Telegramm-Antwort ab Service Identifier zur Analyse");
    if (_ApiFsJobName == "FS_LESEN")
    {
      filewrite("Data      : "+temp2);
      filewrite("Snapshot  : "+temp4);
    }
    else//IS_LESEN
    {
      filewrite("2000      : "+temp2);
      filewrite("200X      : "+temp4);
    }
  }
  else//DS2, BMW Fast
  {
  filewrite("Telegramm-");
  filewrite("Antwort   : "+temp2);
  }
}
// -- EOF --
// end of :#include "FS_LESEN.SRC"
// start of :#include "INITEXIT.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INITEXIT.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Scriptinit verlagert
//* 12.03.2003 iS V1.01 Anpassung SgbdInpaCheck()GroupCheck();
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//**********************************************************************

// **************************
// *** inpainit, inpaexit ***
// **************************
inpainit()
{
  bool   rc;
  string temp;
  int    i;

  INPAapiInit();
  chrinit();

  // Handle für FS_LESEN
  StrArrayCreate(rc,f_ort_nr_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_nr_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  StrArrayCreate(rc,f_ort_text_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_text_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  SgbdInpaCheck();
  GroupCheck();
  setmenu(m_main);
  setscreen(s_main,TRUE);

  //INPA.INI einlesen,
  //um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
  //hinter "SCRIPTS" muß DeleteRead stehen, um die Funktion freizuschalten
  ExtraScript("DeleteRead", deleteread_flag);

  //m FS,IS,HS zu speichern
  ExtraScript("SaveAs", fs_lesen_save_as_flag);
  is_lesen_save_as_flag=fs_lesen_save_as_flag;
  hs_lesen_save_as_flag=fs_lesen_save_as_flag;

  //INPA.INI-Einstellung, falls Funktionen gewünscht:
  //[EXTRA]
  //SCRIPTS               =  DeleteRead,SaveAs
  //Wichtig: Nach dem Komma kein Leerzeichen benutzen!

  ScriptInit();
}

inpaexit()
{
  INPAapiEnd();

  // Handle für FS_LESEN
  StrArrayDestroy(f_ort_nr_buffer);
  StrArrayDestroy(f_ort_text_buffer);
}

// -- EOF --
// end of :#include "INITEXIT.SRC"

// **************************
// *** Hauptmenü          ***
// **************************
MENU m_main()
{
  INIT  {
    setmenutitle("Hauptmenü");

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      setitem(2, "Ident", TRUE);
    }
    else
    {
      setitem(2, "SVK", TRUE);//ISO 14229
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setitem( 4 , "Fehler"  , TRUE);
    }

    if (m_status_flag == TRUE)
    {
      setitem( 5 , "Status"  , TRUE);
    }

    if (m_steuern_flag == TRUE)
    {
      setitem( 6 , "Steuern"  , TRUE);
    }

    if (speicher_lesen_flag == TRUE)
    {
      setitem( 7 , "Speicher"  , TRUE);
    }
  }
  ITEM( 1 ,"Info")  {
    userboxclose(1);
    setscreen(s_info,TRUE);
  }
  ITEM( 2 ,"Ident")  {
    userboxclose(1);
    if (ident_typ == 1)
      setscreen(s_ident_ds2,TRUE);
    else if (ident_typ == 2)
      setscreen(s_ident,TRUE);
    else setscreen(s_svk_lesen,TRUE);
  }
  ITEM( 3 ,"")  {
    userboxclose(1);
    setscreen(s_main,TRUE);
  }
  ITEM( 4 ,"")  {
    userboxclose(1);
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setscreen( s_fehler ,TRUE);
      setmenu(m_fehler);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 5 ,"")  {
    userboxclose(1);
    if (m_status_flag == TRUE)
    {
      setscreen(s_status,TRUE);
      setmenu(m_status);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 6 ,"")  {
    userboxclose(1);
    if (m_steuern_flag == TRUE)
    {
      setscreen(s_steuern,TRUE);
      setmenu(m_steuern);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(1);
    if (speicher_lesen_flag == TRUE)
    {
      setscreen(s_speicher,TRUE);
      setmenu(m_speicher);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Ende")  {
    exit();
  }
  ITEM( 11,  "KVP") {
    setscreen(s_info,TRUE);
    callwin( "kvp_edit "+titel+";"+version+";"+sgbd+": "+sgbd_ecu+";"+sgbd_revision);
  }
  ITEM( 12 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 14 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 15 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Fehlermenü         ***
// **************************
MENU m_fehler()
{
  int    ErrorCode;
  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  string DateiName="";
  int    aufrufIO;
  string JOB_STATUS;
  bool   fehlerflag;

  INIT {
    setmenutitle("Fehlerspeicher");
    if (fs_lesen_flag == TRUE)
    {
      setitem( 1 , "FS lesen"    , TRUE);
      setitem( 2 , "FS löschen"  , TRUE);
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 3 , "IS lesen"    , TRUE);
      if (is_loeschen_flag == TRUE)
           setitem( 4 , "IS löschen"  , TRUE);
      else setitem( 4 , ""  , FALSE);//Nicht alle SGs haben IS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 5 , "HS lesen"    , TRUE);
      if (hs_loeschen_flag == TRUE)
           setitem( 6 , "HS löschen"  , TRUE);
      else setitem( 6 , ""  , FALSE);//Nicht alle SGs haben HS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
  }
  ITEM( 1 ,"")  {
    userboxclose(0);
    viewclose();
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
      userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Fehlerspeicher lesen");
      setitem( 9 , "FS drucken"  , TRUE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
    }
  }
  ITEM( 2 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      INPAapiJob(sgbd,"FS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher wurde gelöscht!",1,3,0,0);

        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPTS = DeleteRead
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
             userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Fehlerspeicher lesen");
             setitem( 9 , "FS drucken"  , TRUE);
             if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 3 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Infospeicher lesen","");
      userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Infospeicher lesen");
      setitem( 8 , "IS drucken"  , TRUE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
    }
  }
  ITEM( 4 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"IS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Infospeicher lesen","");
             userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Infospeicher lesen");
             setitem( 8 , "IS drucken"  , TRUE);
             if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 5 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
      userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Historienspeicher lesen");
      setitem( 7 , "HS drucken"  , TRUE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
    }
  }
  ITEM( 6 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (hs_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"HS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
             userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Historienspeicher lesen");
             setitem( 7 , "HS drucken"  , TRUE);
             if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 7 ,"")  {
    if (hs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
    }
  }
  ITEM( 8 ,"")  {
    if (is_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 9 ,"")  {
    if (fs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(17 ,"")  {
    if ((hs_lesen_flag == TRUE) && (hs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Historienspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
      }
    }
  }
  ITEM(18 ,"")  {
    if ((is_lesen_flag == TRUE) && (is_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Infospeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(19 ,"")  {
    if ((fs_lesen_flag == TRUE) && (fs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Fehlerspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    viewclose();
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    viewclose();
    exit();
  }
}

// **************************
// *** Speichermenü       ***
// **************************
MENU m_speicher()
{
  int    input_ok=0;
  int    input_state;
  string text_var;

  INIT {
    setmenutitle("Speicher lesen");
    if (speicher_lesen_lar_flag==TRUE)    setitem( 1 , "LAR"  , TRUE);
    if (speicher_lesen_flash_flag==TRUE)  setitem( 2 , "FLASH", TRUE);
    if (speicher_lesen_uifm_flag==TRUE)   setitem( 3 , "UIFM" , TRUE);
    if (speicher_lesen_romi_flag==TRUE)   setitem( 4 , "ROMI" , TRUE);
    if (speicher_lesen_ramis_flag==TRUE)  setitem( 5 , "RAMIS", TRUE);
    if (speicher_lesen_ramil_flag==TRUE)  setitem( 6 , "RAMIL", TRUE);
    if (speicher_lesen_nvram_flag==TRUE)  setitem( 7 , "NVRAM", TRUE);
    if (speicher_lesen_romx_flag==TRUE)   setitem(14 , "ROMX" , TRUE);
    if (speicher_lesen_ramxx_flag==TRUE)  setitem(15 , "RAMXX", TRUE);
  }
  ITEM( 1 ,"")  {
    if (speicher_lesen_lar_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"LAR lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="LAR lesen";
        speicher_lesen_seg_adr_anz="LAR;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 2 ,"")  {
    if (speicher_lesen_flash_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"FLASH lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="FLASH lesen";
        speicher_lesen_seg_adr_anz="FLASH;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 3 ,"")  {
    if (speicher_lesen_uifm_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"UIFM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="UIFM lesen";
        speicher_lesen_seg_adr_anz="UIFM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 4 ,"")  {
    if (speicher_lesen_romi_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMI lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMI lesen";
        speicher_lesen_seg_adr_anz="ROMI;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 5 ,"")  {
    if (speicher_lesen_ramis_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIS lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIS lesen";
        speicher_lesen_seg_adr_anz="RAMIS;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 6 ,"")  {
    if (speicher_lesen_ramil_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIL lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIL lesen";
        speicher_lesen_seg_adr_anz="RAMIL;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 7 ,"")  {
    if (speicher_lesen_nvram_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"NVRAM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="NVRAM lesen";
        speicher_lesen_seg_adr_anz="NVRAM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 8 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 12 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 14 ,"")  {
    if (speicher_lesen_romx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMX lesen";
        speicher_lesen_seg_adr_anz="ROMX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 15 ,"")  {
    if (speicher_lesen_ramxx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMXX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMXX lesen";
        speicher_lesen_seg_adr_anz="RAMXX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 18 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Hauptscreen        ***
// **************************
SCREEN s_main()
{
  string text_var;

  userboxclose(0);
  ftextout("Hauptmenü",1,0,1,0);
  ftextout("",3,0,0,0);

  if (simulation_flag == TRUE)
  {
    userboxopen(1,14,30,5,48,"Hinweis","");
    userboxftextout(1,"INPA bzw. EDIABAS läuft im Simulationsmodus!",1,3,0,24);
    userboxsetcolor(1,0,4);
  }

  if (ident_typ != 3)
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
  }

  LINE("","")
  {
    if (ident_typ != 3)//Nur bei DS2 und BMW Fast vorhanden
    {
      ftextout("BMW Teilenummer",1,0,0,0);
      ftextout(":",1,19,0,0);
      INPAapiResultText(text_var,"ID_BMW_NR",1,"");
      ftextout(text_var,1,20,0,1);

      ftextout("Herstelldatum",1,43,0,0);
      ftextout(":",1,59,0,0);
      if (ident_typ == 1)//DS2
      {
        ftextout("KW / Jahr",1,68,0,0);
        ftextout("/",1,63,0,1);
        INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
        ftextout(text_var,1,60,0,1);
        INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
        ftextout(text_var,1,65,0,1);
      }
      else if (ident_typ == 2)//BMW FAST
      {
        INPAapiResultText(text_var,"ID_DATUM",1,"");
        ftextout(text_var,1,60,0,1);
      }
    }

    ftextout("< F1 >  Information"              , 4,5,0,1);

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      ftextout("< F2 >  Identifikation"           , 6,5,0,1);
    }
    else
    {
      ftextout("< F2 >  Steuergeräteverbaukennung"           , 6,5,0,1);//UDS (ISO 14229)
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
        ftextout("< F4 >  Fehlerspeicher"           ,10,5,0,1);

    if (m_status_flag == TRUE)
        ftextout("< F5 >  Status lesen"             ,12,5,0,1);

    if (m_steuern_flag == TRUE)
        ftextout("< F6 >  Ansteuern"                ,14,5,0,1);

    if (speicher_lesen_flag == TRUE)
        ftextout("< F7 >  Speicher lesen"           ,16,5,0,1);

    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F1 >  KVP-Editor"     , 4,45,0,1);
    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Infoscreen         ***
// **************************
SCREEN s_info ()
{
  int i;
  int slen;
  int pos;
  int pos2;
  int anzahl;
  string temp;

  ftextout("Information",1,0,1,0);
  ftextout("Nacharbeitsprogramm",4,0,0,0);             ftextout(":", 4,33,0,1); ftextout(titel,4,35,0,1);
  ftextout("Version",5,1,0,0);                         ftextout(":", 5,33,0,1); ftextout(version,5,35,0,1);
  ftextout("Package",6,1,0,0);                         ftextout(":", 6,33,0,1); ftextout(package,6,35,0,1);
  ftextout("Verantwortung",7,1,0,0);                   ftextout(":", 7,33,0,1); ftextout(origin,7,35,0,1);

  ftextout("Gruppendatei",10,0,0,0);                   ftextout(":",10,33,0,1); ftextout(gruppe,10,35,0,1);
  ftextout("Bezeichnung",11,1,0,0);                    ftextout(":",11,33,0,1); ftextout(gruppe_ecu,11,35,0,1);
  ftextout("Version",12,1,0,0);                        ftextout(":",12,33,0,1); ftextout(gruppe_revision,12,35,0,1);
  ftextout("Verantwortung",13,1,0,0);                  ftextout(":",13,33,0,1); ftextout(gruppe_origin,13,35,0,1);
  ftextout("Identifizierbare SGBD'en",14,1,0,0);

  strlen(slen, gruppe_comment);
  anzahl=44;
  pos=0;
  if ( slen <= anzahl )
  {
    ftextout(":",14,33,0,1); ftextout(gruppe_comment,14,35,0,1);
  }
  else
  {
    instr(pos2, anzahl, gruppe_comment, ",");
    if (pos2 > 0) anzahl=pos2+1;
    midstr(temp, gruppe_comment, pos, anzahl); ftextout(":",14,33,0,1); ftextout(temp,14,35,0,1);
    i=14;
    pos=pos+anzahl;
    while ( pos < slen )
    {
      i=i+1;
      anzahl=75;
      instr(pos2, pos + anzahl, gruppe_comment, ",");
      if (pos2 > 0) anzahl=pos2+1-pos;
      midstr(temp, gruppe_comment, pos, anzahl); ftextout(temp,i,1,0,1);
      pos=pos+anzahl;
      if ( i >= 18 )
      {
        if ( pos < slen ) ftextout(temp+" . . .",i,1,0,1);
        pos=slen;
      }
    }
  }

  ftextout("Steuergerätebeschreibungsdatei",21,0,0,0); ftextout(":",21,33,0,1); ftextout(sgbd,21,35,0,1);
  ftextout("Steuergerät",22,1,0,0);                    ftextout(":",22,33,0,1); ftextout(sgbd_ecu,22,35,0,1);
  ftextout("Version",23,1,0,0);                        ftextout(":",23,33,0,1); ftextout(sgbd_revision,23,35,0,1);
  ftextout("Package",24,1,0,0);                        ftextout(":",24,33,0,1); ftextout(sgbd_package,24,35,0,1);
  ftextout("Verantwortung",25,1,0,0);                  ftextout(":",25,33,0,1); ftextout(sgbd_origin,25,35,0,1);
  ftextout("Sprache",26,1,0,0);                        ftextout(":",26,33,0,1); ftextout(sgbd_sprache,26,35,0,1);
  if (sgbd_comment!="")
  {
    ftextout("Kommentar",27,1,0,0);
    ftextout(":",27,33,0,1);
    ftextout(sgbd_comment,27,35,0,1);
  }
}

// **************************
// *** Identscreen DS2    ***
// **************************
SCREEN s_ident_ds2()
{
  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"IDENT","","");
  INPAapiCheckJobStatus("OKAY");
  LINE("","")
  {
    ftextout("BMW Teilenummer",1,0,1,0);
    ftextout(":",1,33,1,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,35,1,1);

    ftextout("Hardwarenummer",4,0,1,0);
    ftextout(":",4,33,1,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,4,35,1,1);

    ftextout("Softwarenummer",7,0,1,0);
    ftextout(":",7,33,1,0);
    INPAapiResultText(text_var,"ID_SW_NR",1,"");
    ftextout(text_var,7,35,1,1);

    ftextout("Lieferant",10,0,1,0);
    ftextout(":",10,33,1,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,10,35,1,1);

    ftextout("Codier-Index",13,0,1,0);
    ftextout(":",13,33,1,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,13,35,1,1);

    ftextout("Diagnose-Index",16,0,1,0);
    ftextout(":",16,33,1,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,16,35,1,1);

    ftextout("Bus-Index",19,0,1,0);
    ftextout(":",19,33,1,0);
    INPAapiResultText(text_var,"ID_BUS_INDEX",1,"");
    ftextout(text_var,19,35,1,1);

    ftextout("Herstelldatum",22,0,1,0);
    ftextout(":",22,33,1,0);
    ftextout("KW / Jahr",22,55,1,0);
    ftextout("/",22,41,1,1);
    INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
    ftextout(text_var,22,35,1,1);
    INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
    ftextout(text_var,22,45,1,1);
  }
}

// ****************************
// *** Identscreen BMW Fast ***
// ****************************
SCREEN s_ident()
{
  string text_var;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext

  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,1);

  LINE("Identifikation","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");

    ftextout("BMW Teilenummer",1,0,0,0);
    ftextout(":",1,43,0,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,45,0,1);

    ftextout("Codier-Index",3,0,0,0);
    ftextout(":",3,43,0,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,3,45,0,1);

    ftextout("Varianten-Index",5,0,0,0);
    ftextout(":",5,43,0,0);
    INPAapiResultText(text_var,"ID_VAR_INDEX",1,"");
    ftextout(text_var,5,45,0,1);

    ftextout("Diagnose-Index",7,0,0,0);
    ftextout(":",7,43,0,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,7,45,0,1);

    ftextout("Hardwarenummer",9,0,0,0);
    ftextout(":",9,43,0,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,9,45,0,1);

    ftextout("Softwarenummer   Funktionssoftware",11,0,0,0);
    ftextout(":",11,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_FSV",1,"");
    ftextout(text_var,11,45,0,1);

    ftextout("Softwarenummer   Betriebssystem",13,0,0,0);
    ftextout(":",13,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_OSV",1,"");
    ftextout(text_var,13,45,0,1);

    ftextout("Softwarenummer   Nachrichtenkatalog",15,0,0,0);
    ftextout(":",15,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_MCV",1,"");
    ftextout(text_var,15,45,0,1);

    ftextout("Softwarenummer  (Reserve) Zur Zeit nicht benutzt",17,0,0,0);
    ftextout(":",17,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_RES",1,"");
    ftextout(text_var,17,45,0,1);

    ftextout("Herstelldatum",19,0,0,0);
    ftextout(":",19,43,0,0);
    INPAapiResultText(text_var,"ID_DATUM",1,"");
    ftextout(text_var,19,45,0,1);

    ftextout("Lieferant",21,0,0,0);
    ftextout(":",21,43,0,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,21,45,0,1);
  }
// *** AIF, Anwender-Information
// *** auf 2. Seite von IDENT

  LINE("Anwender-Information","")
  {
    INPAapiJob(sgbd,"AIF_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("",10,0,0,0);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Anwenderinfofeld (AIF_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: AIF_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      INPAapiResultInt(ganz_zahl,"AIF_ANZ_DATEN",1);
      if (ganz_zahl > 18)                // lange AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Datensatz Nr.",7,0,0,0);
        ftextout(":",7,43,0,0);
        INPAapiResultText(text_var,"AIF_SW_NR",1,"");
        ftextout(text_var,7,45,0,1);

        ftextout("Behörden Nr.",9,0,0,0);
        ftextout(":",9,43,0,0);
        INPAapiResultText(text_var,"AIF_BEHOERDEN_NR",1,"");
        ftextout(text_var,9,45,0,1);

        ftextout("Händler Nr.",11,0,0,0);
        ftextout(":",11,43,0,0);
        INPAapiResultText(text_var,"AIF_HAENDLER_NR",1,"");
        ftextout(text_var,11,45,0,1);

        ftextout("Tester Nr.",13,0,0,0);
        ftextout(":",13,43,0,0);
        INPAapiResultText(text_var,"AIF_SERIEN_NR",1,"");
        ftextout(text_var,13,45,0,1);

        ftextout("km-Stand",15,0,0,0);
        ftextout(":",15,43,0,0);
        INPAapiResultText(text_var,"AIF_KM",1,"");
        ftextout(text_var,15,45,0,1);

        ftextout("Programm-Stand",17,0,0,0);
        ftextout(":",17,43,0,0);
        INPAapiResultText(text_var,"AIF_PROG_NR",1,"");
        ftextout(text_var,17,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
      else                              //18 Byte -> kurze AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
    }
  }

LINE("CFG Lesen","")
  {
    INPAapiJob(sgbd,"C_FG_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("Codierdaten",0,0,0,1);
    ftextout("",10,0,0,0);// um auf einer neuen Seite darzustellen

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Fahrgestellnummer lesen (CFG_LESEN) vorhanden          " ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: C_FG_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Fahrgestell Nr.",3,0,0,0);
      ftextout(":",3,43,0,0);
      INPAapiResultText(text_var,"FG_NR",1,"");
      ftextout(text_var,3,45,0,1);
    }

    INPAapiJob(sgbd,"C_AEI_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Codierdatenänderungsindex (C_AEI_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Codierdatenänderungsindex",6,0,0,0);
      ftextout(":",6,43,0,0);
      INPAapiResultText(text_var,"COD_AE_INDEX",1,"");
      ftextout(text_var,6,45,0,1);
    }
  }
}

// ****************************************************************************
// *** Identinformationen werden über SVK_LESEN ermittelt                   ***
// *** SVK: SteuergeräeVerbauKennung Soft- und Hardware für UDS (ISO 14229) ***
// ****************************************************************************
SCREEN s_svk_lesen()
{
  string text_var;
  string text_var2;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  bool   eingabeWeiter;
  int    input_state;              // Eingabestatus
  int    input_ok=1;               // Eingabe  mit Nein beendet
  int    i;
  int    offset;
  int    einheiten_anz;
  int    pos;
  real   realval;
  real   realval2;
  long   longval;
  long   rest_long;
  long   multiplik_long;

  ftextout("Steuergeräteverbaukennung Soft- und Hardware",1,0,1,0);
  ftextout("",2,0,0,1);
  LINE("Hersteller Information","")
  {//HERSTELLINFO_LESEN ist kein Pflichtjob! (Stand: 03.2006)
    INPAapiJob(sgbd,"HERSTELLINFO_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Herstellerinformationen vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: HERSTELLINFO_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Herstelldatum",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"ID_DATUM",1,"");
      ftextout(text_var,1,45,0,1);

      ftextout("Lieferant",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
      ftextout(text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("Ident","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
/*    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Ident vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else */if (((fehlerflag == FALSE) /*&& (errorcode != 98)*/) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: IDENT",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Steuergeräte-Adresse",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultInt(ganz_zahl,"ID_SG_ADR",1);
      inttohexstring(ganz_zahl,4,text_var);
      //Führende Nullen ausblenden
      if (ganz_zahl <= 255) midstr(text_var,text_var,2,2);
      ftextout("0x"+text_var,1,45,0,1);

      ftextout("SGBD-Index",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultBinary("_RESPONSE",1);
      GetBinaryDataString (text_var,i);
      midstr(text_var,text_var,6,11);

      ftextout("0x"+text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("SVK","")
  {
    INPAapiJob(sgbd,"SVK_LESEN","","");
    //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
    sets=0;
    INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) || (sets <= 1))
    {
      ftextout("Fehler beim Lesen von Job: SVK_LESEN",1,0,0,0);
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
        ftextout(error_text ,2,0,0,0);
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        ftextout(error_text,2,0,0,0);
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
      ftextout("" ,3,0,0,0);
    }
    else
    {
      INPAapiResultText(text_var,"PROG_DATUM",sets,"");
      ftextout("Programm-Datum",0,0,0,0);
      ftextout(":",0,41,0,0);
      ftextout(text_var,0,45,0,1);

      INPAapiResultText(text_var,"PROG_KM",sets,"");
      if (text_var == "-1") text_var= "- - -";
      ftextout("Programm-km",1,0,0,0);
      ftextout(":",1,41,0,0);
      ftextout(text_var,1,45,0,1);

      INPAapiResultText(text_var,"ANZAHL_EINHEITEN",sets,"");
      INPAapiResultInt(einheiten_anz,"ANZAHL_EINHEITEN",sets);
      ftextout("Anzahl Prozeßklassen",2,0,0,0);
      ftextout(":",2,41,0,0);
      ftextout(text_var,2,45,0,1);

      ftextout("Prozeßklasse",5,2,0,1);
      ftextout("SGBM Identifier ",5,43,0,1);
      ftextout("Version",5,62,0,1);

      i=1;
      offset=0;
      while(i<=einheiten_anz)
      {
        inttostring(i,text_var2);
        INPAapiResultText(text_var,"PROZESSKLASSE_TEXT",i,"");
        ftextout(text_var2+") "+text_var,6+offset,0,0,0);

        //SGBM Identifier
        ftextout(":",6+offset,41,0,0);
        INPAapiResultText(text_var,"SGBM_IDENTIFIER",i,"");
        ftextout(text_var,6+offset,45,0,1);

        //Version
        INPAapiResultText(text_var,"VERSION",i,"");
        ftextout(text_var,6+offset,62,0,1);
        i=i+1;//um nächsten Set zu laden
        offset=offset+1;
      }
    }
  }
}

// **************************
// *** Speicherscreen     ***
// **************************
SCREEN s_speicher()
{
  ftextout("Speicher lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (speicher_lesen_lar_flag==TRUE)    ftextout("< F1 >  LAR lesen"               , 4,5,0,1);
    if (speicher_lesen_flash_flag==TRUE)  ftextout("< F2 >  FLASH lesen"             , 6,5,0,1);
    if (speicher_lesen_uifm_flag==TRUE)   ftextout("< F3 >  UIFM lesen"              , 8,5,0,1);
    if (speicher_lesen_romi_flag==TRUE)   ftextout("< F4 >  ROMI lesen"              ,10,5,0,1);
    if (speicher_lesen_ramis_flag==TRUE)  ftextout("< F5 >  RAMIS lesen"             ,12,5,0,1);
    if (speicher_lesen_ramil_flag==TRUE)  ftextout("< F6 >  RAMIL lesen"             ,14,5,0,1);
    if (speicher_lesen_nvram_flag==TRUE)  ftextout("< F7 >  NVRAM lesen"             ,16,5,0,1);
    if (speicher_lesen_romx_flag==TRUE)   ftextout("<Shift> + < F4 >  ROMX lesen"    ,10,45,0,1);
    if (speicher_lesen_ramxx_flag==TRUE)  ftextout("<Shift> + < F5 >  RAMXX lesen"   ,12,45,0,1);

    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Speicherscreen     ***
// *** Ausgabe            ***
// **************************
SCREEN s_speicher_ausgabe()
{
  string text_var;
  string job_state;

  ftextout(speicher_lesen_text,1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"SPEICHER_LESEN",speicher_lesen_seg_adr_anz,"");
  INPAapiResultText(job_state,"JOB_STATUS",1,"");
  LINE("","")
  {
    ftextout("Startadresse",1,0,0,0);
    ftextout(":",1,18,0,1);
    ftextout(speicher_lesen_adresse,1,20,0,1);
    ftextout("Anzahl",3,0,0,0);
    ftextout(":",3,18,0,1);
    inttostring(speicher_lesen_anzahl,text_var);
    ftextout(text_var,3,20,0,1);
    ftextout("Daten",5,0,0,0);
    ftextout(":",5,18,0,1);
    if(job_state != "OKAY")
      ftextout(job_state,5,20,0,1);
    else
    {
      INPAapiResultBinary("DATEN",1);
      hexdump(speicher_lesen_adresse,speicher_lesen_anzahl,5,20);
    }
  }
}

// **************************
// *** Fehlerscreen       ***
// **************************
SCREEN s_fehler()
{
  ftextout("Fehlerspeicher",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (fs_lesen_flag == TRUE)
    {
      ftextout("< F1 >  Fehlerspeicher lesen"      , 4,5,0,1);
      ftextout("< F2 >  Fehlerspeicher löschen"    , 6,5,0,1);
      ftextout("< F9 >  Fehlerspeicher drucken"    ,20,5,0,1);
      if (fs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F9 >  Fehlerspeicher speichern"   ,20,45,0,1);
    }

    if (is_lesen_flag == TRUE)
    {
      ftextout("< F3 >  Infospeicher lesen"        , 8,5,0,1);
      if (is_loeschen_flag == TRUE) ftextout("< F4 >  Infospeicher löschen"      ,10,5,0,1);
      ftextout("< F8 >  Infospeicher drucken"      ,18,5,0,1);
      if (is_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F8 >  Infospeicher speichern"     ,18,45,0,1);
    }

    if (hs_lesen_flag == TRUE)
    {
      ftextout("< F5 >  Historienspeicher lesen"   ,12,5,0,1);
      if (hs_loeschen_flag == TRUE) ftextout("< F6 >  Historienspeicher löschen" ,14,5,0,1);
      ftextout("< F7 >  Historienspeicher drucken" ,16,5,0,1);
      if (hs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F7 >  Historienspeicher speichern",16,45,0,1);
    }
    ftextout("< F10>  Zurück"                    ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"            ,22,45,0,1);
  }
}
// -- EOF --
// end of :#include "BMW_STD.SRC"


meldung_1(in: string text)
{
  text = text+"                                                    ";  // Platzhalter für Text
  ftextout(text,7,5,1,1);     // Ausgabe Text Ablaufschritte
}

meldung_2(in: string text)
{
  text = text+"                                     ";  // Platzhalter für Text
  ftextout(text,25,5,1,1);     // Ausgabe Anzeigetexte
}
meldung_3(in: string text)
{
  text = text+"            ";   // Platzhalter für Text
  ftextout(text,27,18,1,1);     // Ausgabe Fastfilter links)
}

meldung_4(in: string text)
{
  text = text+"                                          ";           // Platzhalter für Text
  ftextout(text,25,45,1,1);    // Ausgabe Anzeigetexte
}

meldung_5(in: string text)
{
  text = text+"   ";           // Platzhalter für Text
  ftextout(text,27,58,1,1);    // Ausgabe Fastfilter rechts
}


print_line(in: string text, in: int zeile, in: int spalte)
{
   if (zeile == 1) { z1 = text;   s1 = spalte; }
   if (zeile == 4) { z4 = text;   s4 = spalte; }
}


delete_line(in: int zeile)
{
   if (zeile == 1) { z1 = leer_string; }
   if (zeile == 4) { z4 = leer_string; }
}



action_box_open(in: string text1, in: string text2, in: string text3)
{
   userboxopen(1,8,0,14,89,"Arbeitshinweis", "");
   userboxftextout(1,text1,1,3,2,2);
   userboxftextout(1,text2,4,3,2,2);
   userboxftextout(1,text3,7,3,2,2);

}

action_box_meldung(in: string text1, in: string text2)
{
   userboxopen(1,8,0,14,89,"Meldung", "");
//   userboxsetcolor(1,0,9); //                    oliv
   userboxsetcolor(1,0,8);   // Hintergrundfarbe gelb
   userboxftextout(1,text1,1,18,2,0);
   userboxftextout(1,text2,4,18,2,0);
}

message_box_open(in: string meldetext1,in: string meldetext2,in: string meldetext3)
{
   userboxopen(2,8,0,14,89,"Meldung", "");
   userboxsetcolor(2,1,12);
   userboxclear(2);
   userboxftextout(2,meldetext1,1,3,2,1);
   userboxftextout(2,meldetext2,4,3,2,1);
   userboxftextout(2,meldetext3,7,3,2,1);
}

message_box_iO()
{
   farbe=10;   // hellgrün
   userboxopen(2,17,0,7,89,"Meldung", "");
   userboxsetcolor(2,1,farbe);
   userboxftextout(2,"i. O.",1,36,2,1);
   delay(300);
}

message_box_niO(in: string meldetext1,in: string meldetext2,in: string meldetext3,in: string meldetext4)
{
   farbe=8;  // gelb
//   farbe=4;  // rot
   userboxopen(2,8,0,14,89,"Meldung", "");
   userboxsetcolor(2,1,farbe);
   userboxftextout(2,meldetext1,1,3,2,1);
   userboxftextout(2,meldetext2,4,3,2,1);
   userboxftextout(2,meldetext3,7,3,2,1);
   userboxftextout(2,meldetext4,10,3,2,1);
}


action_box_close()
{
   userboxclose(1);
}

message_box_close()
{
   userboxclose(2);
}


delete_screen()
{
   action_box_close();
   message_box_close();
}


endebehandlung()
   {
     bool rc;

     if (CHANGE_TEST == TRUE)
      {
         fehlertext_1="";                       // Loeschen
         fehlertext_2="";                       // Loeschen
//         setjobstatus(0);                       // Job Status i.O.


      }
     else
      {
//         setjobstatus(1);           // Job Status n.i.O.
         PEMProtokollZeile (rc, "");
         PEMProtokollZeile (rc, "Vertauscherprüfung");
         PEMProtokollZeile (rc, "");
         PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_1);
         PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_2);
         PEMProtokollZeile (rc, "");
      }

     delay(1000);

   }


// ****************************************************
// ***             Initialisierungsfunktion         ***
// ****************************************************
ScriptInit()
{
  settitle(titel+" Version "+version);
}

// ****************************************************
// ***             M e n ü a u f b a u              ***
// ****************************************************
// **************************
// *** Statusmenü         ***
// **************************
MENU m_status()
{
  INIT {
    setmenutitle("Status lesen");
  }
  ITEM( 1 ,"Analog")  {
    userboxclose(0);
    setscreen( s_status_analog ,TRUE);
  }
  ITEM( 2 ,"Digital")  {
    userboxclose(0);
    setscreen( s_status_digital ,TRUE);
  }
  ITEM( 3 ,"Online")  {
    userboxclose(0);
    setscreen( s_status_online ,TRUE);
  }
  ITEM( 4 ,"FaFi schreiben")  {
    userboxclose(0);
    setscreen( s_fastfilter_lesen_schreiben ,FALSE);
  }
  ITEM( 5 ,"FaFi lesen")  {
    userboxclose(0);
    setscreen( s_status_grobleckwerte ,TRUE);
  }
  ITEM( 6 ,"Pruef")  {
    userboxclose(0);
    setscreen( s_status_pruefstempel ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(0);
    setscreen( s_status ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    userboxclose(0);
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    userboxclose(0);
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    exit();
  }
}

// **************************
// *** Steuernmenü        ***
// **************************
MENU m_steuern()
{
  INIT {
    setmenutitle("Steuern");
  }
  ITEM( 1 ,"Hand")
   {
    userboxclose(0);
    setcolor(1,4);
    setscreen( s_steuern_dig,TRUE);
    setmenu( m_steuern_dig);
//    INPAapiJob(sgbd,"status_lesen","ARG;STATUS_MODECONTROL_SG","");   
//    INPAapiCheckJobStatus("OKAY");
    INPAapiJob(sgbd,"ENERGIESPARMODE","1","");   
    delay(2000);  // ok
    INPAapiCheckJobStatus("OKAY");
   }

  ITEM( 2 ,"Aktoren")
   {
     userboxclose(0);
     setcolor(1,4);
     setscreen( s_steuern_akt,TRUE);
     setmenu( m_steuern_akt);
//     INPAapiJob(sgbd,"status_lesen","ARG;STATUS_MODECONTROL_SG","");   
//     INPAapiCheckJobStatus("OKAY");
     INPAapiJob(sgbd,"ENERGIESPARMODE","1","");   
     delay(2000);  // ok
     INPAapiCheckJobStatus("OKAY");
   }

  ITEM( 3 ,"Modi")
   {
     userboxclose(0);
     setscreen( s_steuern_mod,TRUE);
     setmenu( m_steuern_mod);
   }

  ITEM( 4 ,"Abgleich")
   {
     userboxclose(0);
     setscreen( s_abgleich,TRUE );
     setmenu( m_abgleich );
   }

  ITEM( 5 ,"Grobleck")
   {
     setscreen( s_steuern_grobleck,FALSE );
     setmenu( m_grobleck );
   }

  ITEM( 6 ,"Vertausch")
   {
     setscreen( s_tausch,FALSE );
     setmenu( m_tausch );
   }

  ITEM( 7 ,"Sondermodi")
   {
     userboxclose(0);
     setscreen( s_steuern_smod,TRUE);
     setmenu( m_steuern_smod);
   }

  ITEM( 9 ,"Druck")  {
    printscreen();
  }

  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }

  ITEM( 20 ,"Exit")  {
    exit();
  }
}

MENU m_steuern_mod()
{
  INIT
  {
    setmenutitle("Steuern");
  }
   // argument : MODE
   //  type    : int
   //  comment : 0x00: Normalmode
   //            0x01: Fertigungsmode
   //            0x02: Transportmode
   //            0x03: Flashmode

  ITEM( 1 ,"BandMod")
  {
    lowtolmodus = FALSE;
    INPAapiJob(sgbd,"ENERGIESPARMODE","1","");   
    delay(2000);  // ok
    INPAapiCheckJobStatus("OKAY");
  }

  ITEM( 2 ,"VerlMod")
  {
    lowtolmodus = FALSE;
    INPAapiJob(sgbd,"ENERGIESPARMODE","2","");   
    delay(2000);  // ok
    INPAapiCheckJobStatus("OKAY");
  }

  ITEM( 3 ,"")   { //ok
    lowtolmodus = FALSE;
    }

  ITEM( 4 ,"LowTolMod")   {
    betriebsmodus=1;                      // Low Tolerance Modus setzen
    inttostring(betriebsmodus,betriebsmodus_txt);
    INPAapiJob(sgbd,"steuern_routine","ARG;STEUERN_LOWTOL_MODE;STR",""); //ok
    INPAapiCheckJobStatus("OKAY");  // ok
    INPAapiResultText(job_state,"JOB_STATUS",1,""); // ok

    if (job_state == "OKAY")
     {
       lowtolmodus = TRUE;
     }
    else
     {
       lowtolmodus = FALSE;
     }
    }
  ITEM( 5 ,"Modus AUS")   { //ok
    lowtolmodus = FALSE;
    INPAapiJob(sgbd,"ENERGIESPARMODE","0","");   
    delay(2000);  // ok
    INPAapiCheckJobStatus("OKAY");
    }

  ITEM( 10 ,"Zurueck")
  {
   lowtolmodus = FALSE;
   setscreen( s_steuern ,TRUE);
   setmenu( m_steuern);
  }

  ITEM( 20 ,"Exit")
  {
   exit();
  }
}

MENU m_steuern_smod()
{
  INIT
  {
    setmenutitle("Steuern");
  }

  ITEM(1 ,"Dmod Ein") {  //ok
  INPAapiJob(sgbd,"status_lesen","ARG;STATUS_MODECONTROL_SG","");
    INPAapiCheckJobStatus("OKAY");

    INPAapiResultInt(betriebsmodus,"STAT_E_MODECONTROL_WERT",1);
    betriebsmodus_puffer_3 = betriebsmodus;
    if ((betriebsmodus_puffer_3 & 0x01) == 0)
     {
     betriebsmodus = betriebsmodus + 1;
      inttostring(betriebsmodus,betriebsmodus_txt);
      INPAapiJob(sgbd,"steuern_io","ARG;STEUERN_SG_MODUS;STA;"+betriebsmodus_txt,"");
      delay(2000);  // ok, "Ein" kommt durch diesen Aufruf nach dem Reset! -> kein Fehler!
      INPAapiCheckJobStatus("OKAY");
     }
    }

  ITEM(2 ,"Dmod Aus") {  //ok
    INPAapiJob(sgbd,"status_lesen","ARG;STATUS_MODECONTROL_SG","");
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultInt(betriebsmodus,"STAT_E_MODECONTROL_WERT",1);
    betriebsmodus_puffer_3 = betriebsmodus;
    if ((betriebsmodus_puffer_3 & 0x01) == 1)
     {
      betriebsmodus = betriebsmodus - 1;
      inttostring(betriebsmodus,betriebsmodus_txt);
      INPAapiJob(sgbd,"steuern_io","ARG;STEUERN_SG_MODUS;STA;"+betriebsmodus_txt,"");
      delay(2000);  // ok
      INPAapiCheckJobStatus("OKAY");
     }
    }

//us  ITEM(3 ,"")       {
//us    if((int_cbd_lu == 0) || (int_cbd_lu == 255))
//us     {
//us     }
//us    else
//us     {
//us       levelup_int=1;                      // Levelup Modus setzen
//us       inttostring(levelup_int,levelup_int_txt);
//us       INPAapiJob(sgbd,"STEUERN_LEVELUP_FUNKTION_AKTIVIEREN",levelup_int_txt,"");
//us       INPAapiCheckJobStatus("OKAY");
//us       INPAapiResultText(job_state,"JOB_STATUS",1,"");
//us     }
//us    }

//us  ITEM(4 ,"")       {
//us    if((int_cbd_lu == 0) || (int_cbd_lu == 255))
//us     {
//us     }
//us    else
//us     {
//us       levelup_int=0;                      // Levelup Modus ruecksetzen
//us       inttostring(levelup_int,levelup_int_txt);
//us       INPAapiJob(sgbd,"STEUERN_LEVELUP_FUNKTION_AKTIVIEREN",levelup_int_txt,"");
//us       INPAapiCheckJobStatus("OKAY");
//us       INPAapiResultText(job_state,"JOB_STATUS",1,"");
//us     }
//us    }

//us  ITEM(5 ,"")       {
//us    if(int_cbd_sip >= 1)
//us     {
//us       INPAapiJob(sgbd,"_STEUERN_TILT_FUNKTION","1","");
//us       INPAapiCheckJobStatus("OKAY");
//us     }
//us    }

//us  ITEM(6 ,"")       {
//us    if(int_cbd_sip >= 1)
//us     {
//us       INPAapiJob(sgbd,"_STEUERN_TILT_FUNKTION","2","");
//us       INPAapiCheckJobStatus("OKAY");
//us     }
//us    }

//us  ITEM(7 ,"")       {
//us    if(int_cbd_sip >= 1)
//us     {
//us       INPAapiJob(sgbd,"_STEUERN_TILT_FUNKTION","0","");
//us       INPAapiCheckJobStatus("OKAY");
//us     }
//us    }

  ITEM( 10 ,"Zurueck")
  {
   setscreen( s_steuern ,TRUE);
   setmenu( m_steuern);
  }

  ITEM( 20 ,"Exit")
  {
   exit();
  }
}


MENU m_steuern_dig()
{
  INIT
  {
   setmenutitle("Steuern");
  }

  ITEM( 1 ,"HA auf")
  {
   ha_ab  = FALSE;
   hl_auf = FALSE;
   hl_ab  = FALSE;
   hr_auf = FALSE;
   hr_ab  = FALSE;
   ha_auf = TRUE;
  }

  ITEM( 2 ,"HA ab")
   {
    funktion = "Hinterachse ab";
    ha_auf = FALSE;
    ha_ab  = TRUE;
    hl_auf = FALSE;
    hl_ab  = FALSE;
    hr_auf = FALSE;
    hr_ab  = FALSE;
   }
  ITEM( 3 ,"HL auf")
   {
    ha_auf = FALSE;
    ha_ab  = FALSE;
    hl_auf = TRUE;
    hl_ab  = FALSE;
    hr_auf = FALSE;
    hr_ab  = FALSE;
   }

  ITEM( 4 ,"HL ab")
  {
   ha_auf = FALSE;
   ha_ab  = FALSE;
   hl_auf = FALSE;
   hl_ab  = TRUE;
   hr_auf = FALSE;
   hr_ab  = FALSE;
  }
  ITEM( 5 ,"HR auf")
  {
   ha_auf = FALSE;
   ha_ab  = FALSE;
   hl_auf = FALSE;
   hl_ab  = FALSE;
   hr_auf = TRUE;
   hr_ab  = FALSE;
  }

  ITEM( 6 ,"HR ab")
  {
   ha_auf = FALSE;
   ha_ab  = FALSE;
   hl_auf = FALSE;
   hl_ab  = FALSE;
   hr_auf = FALSE;
   hr_ab  = TRUE;
  }

  ITEM( 8 ,"Aus")
  {
   ha_auf = FALSE;
   ha_ab  = FALSE;
   hl_auf = FALSE;
   hl_ab  = FALSE;
   hr_auf = FALSE;
   hr_ab  = FALSE;
   h_aus = TRUE;
  }
 
  
  ITEM( 9 ,"Druck")
  {
    printscreen();
  }

  ITEM( 10 ,"Zurueck")
  {
    ha_auf = FALSE;
    ha_ab  = FALSE;
    hl_auf = FALSE;
    hl_ab  = FALSE;
    hr_auf = FALSE;
    hr_ab  = FALSE;
    ventil_ab_init = FALSE; // zum Heben muss neu initialisiert werden

    INPAapiJob(sgbd,"ENERGIESPARMODE","0","");   
    delay(2000);  // ok
    INPAapiCheckJobStatus("OKAY");

    setcolor(1,0);
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );
  }

  ITEM( 20 ,"Exit")
  {
   exit();
  }
}

MENU m_steuern_akt()
{
  INIT
  {
   setmenutitle("Steuern");
  }
  ITEM( 1 ,"Ventil HL")
  {
   v_hl   = TRUE;
  }
  ITEM( 2 ,"Ventil HR")
   {
    v_hr   = TRUE;
   }
  ITEM( 3 ,"Ablass")
   {
    v_ab   = TRUE;
   }
  ITEM( 4 ,"Komp")  //ok
  {
   komp   = TRUE;
  }
  ITEM( 5 ,"V. HL zu") //ok
  {
   v_hl   = FALSE;
  }
  ITEM( 6 ,"V. HR zu") //ok
  {
   v_hr   = FALSE;
  }
  ITEM( 7 ,"V. Ab zu") //ok
  {
   v_ab   = FALSE;
  }
  ITEM( 8 ,"Komp. aus") //ok
  {
   komp   = FALSE;
  }
  ITEM( 9 ,"AUS")
  {
   komp   = FALSE;
   v_hl   = FALSE;
   v_hr   = FALSE;
   v_ab   = FALSE;
  }
  ITEM( 19 ,"AUS")
  {
   komp   = FALSE;
   v_hl   = FALSE;
   v_hr   = FALSE;
   v_ab   = FALSE;
  }
  ITEM( 10 ,"Zurueck")
  {
   komp   = FALSE;
   v_hl   = FALSE;
   v_hr   = FALSE;
   v_ab   = FALSE;
   setcolor(1,0);

   INPAapiJob(sgbd,"ENERGIESPARMODE","0","");   
   INPAapiCheckJobStatus("OKAY");

   setscreen( s_steuern ,TRUE);
   setmenu( m_steuern );
  }

  ITEM( 20 ,"Ende")
  {
   exit();
  }
}


MENU m_grobleck()
{
  INIT
  {
    setmenutitle( "Auswahlmenue Funktion");
  }

  ITEM( 1, "Info" )
  {
    infobox("Information","Vergleicht gespeicherte Fastfilterwerte mit aktuellen Werten");
  }

  ITEM( 2, "Start" )
  {
   userboxclose(0);
   setstatemachine ( EHC_GROBLECK );
  }
  ITEM( 3, "" )
  {
//    stop ();
  }

  ITEM( 10, "Zurueck" )
  {
    userboxclose(0);
    userboxclose(2);
    setcolor(1,0);
    setscreen( s_main ,TRUE);
    setmenu( m_main );
//    exit();
//    setstatemachine( F10_ABBRUCH );
  }

  ITEM( 20, "Exit" )
  {
    exit();
  }
}


MENU m_tausch ()
 {
  INIT {
      setmenutitle( "Auswahlmenü Funktion");
    }
  ITEM( 1 , "Info")  {
     infobox("Information","F01 Vertauscherprüfung 1-Achsluftfederung");
   }
  ITEM( 2 , "Start")  {
     setstatemachine(EHC_F01_VERTAUSCHERPRUEFUNG);    
     start();
   }
  ITEM( 3 , "Stop")  {
    stop();
   }
  ITEM( 4 , "")
   {
   }
  ITEM( 5 , "")  {
   }
  ITEM( 6 , "")  {
   }
  ITEM( 7 , "")  {
   }
  ITEM( 8 , "")  {
   }
  ITEM( 9 , "")  {
   }
  ITEM( 10 , "Zurück")
   {
     userboxclose(2);
     setcolor(1,0);
     setscreen( s_main ,TRUE);
     setmenu( m_main );
//     setstatemachine(F10_ABBRUCH);
   }
  ITEM( 20 , "Ende")
   {
     exit();
   }
 }

STATEMACHINE  F10_ABBRUCH()
{
  INIT
   {
     delete_screen();
     setcolor(1,4);
     message_box_niO("Abbruch","","EHC Vertauscherprüfung","");
     delay (2000);
     CHANGE_TEST = FALSE;
     fehlertext_1 = "Abbruchtaste F10 gedrückt";
     endebehandlung();
   }
}

STATEMACHINE EHC_GROBLECK()
{

int bandmodus = 0;

    INIT
    {
       setscreen ( s_steuern_grobleck,FALSE);
       setstate ( STATUS_ZUENDUNG );
    }
    STATUS_ZUENDUNG
    {
//         INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
//         INPAapiResultDigital(kl_15_ein, "STAT_ZUENDUNG", 1);

       kl_15_ein = TRUE;

       if (kl_15_ein == TRUE)
        {
          zuendung_ein_test = TRUE;
          delay(1000);
          ftextout("Abfrage Status Bandmodus                                                 ",5,0,1,0);
          setstate ( ABFRAGE_BANDMODUS );
        }
       else   // *****  Zuendung ist faelschlicherweise aus ***********
        {
           zuendung_ein_test = FALSE;
           callstatemachine ( AUSWERTUNG_L );
        }
    }


    ABFRAGE_BANDMODUS                                     // 2.Schritt
    {                                                     // lesen, ob Bandmodus gesetzt
//       infobox("","Bandmodus abfragen");

       job_state="";
       INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
       INPAapiResultInt(bandmodus,"STAT_PRODUKTIONSMODE_EIN",1);
       INPAapiCheckJobStatus("OKAY");

       if (bandmodus == 1)
        {
           status_bandmodus = TRUE;
           delay(1000);
           ftextout("Grobleckwerte lesen                                        ",5,0,1,0);
           setstate ( ALTE_WERTE_LESEN );
        }
       else  // *********** Jobstatus nicht OKAY   *************
        {
           status_bandmodus = FALSE;
           callstatemachine ( AUSWERTUNG_L );
        }
    }


    ALTE_WERTE_LESEN                              // 3. Schritt, alte Fastfilterwerte lesen,
    {                                             //    die bei MoTest gespeichert wurden
//       infobox("Lesen","alte Werte");

       job_state="";
       INPAapiJob(sgbd,"status_lesen","ARG;STATUS_GROBLECK","");
       INPAapiResultInt(fafi_hl_leak,"STAT_H_RL_FASTFILTER_WERT",1);   // 1. Byte, alte Werte links
       INPAapiResultInt(fafi_hr_leak,"STAT_H_RR_FASTFILTER_WERT",1);   // 1. Byte, alte Werte rechts
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");

       if (job_state == "OKAY")
        {
           alte_werte_lesen = TRUE;
           delay(1000);
           ftextout("Neue Werte lesen                                        ",5,0,1,0);
           setstate (STATUS_LESEN_SENSOREN);
        }
       else   // *****  Jobstatus nicht OKAY ***********
        {
           alte_werte_lesen = FALSE;
           callstatemachine ( AUSWERTUNG_L );
        }
    }


    STATUS_LESEN_SENSOREN                       // 4. Schritt, aktuelle Fastfilter-Werte lesen
    {
//      infobox ("Lesen", "aktuelle Filterwerte");

      job_state = "";
      INPAapiJob(sgbd,"status_lesen","ARG;STATUS_FILTERWERTE","");
      INPAapiResultInt(fafi_hl_aktuell,"STAT_FASTFILTER_RL_WERT",1);
      INPAapiResultInt(fafi_hr_aktuell,"STAT_FASTFILTER_RR_WERT",1);
      INPAapiResultText(job_state,"JOB_STATUS",1,"");

      if (job_state == "OKAY")
       {
          lesen_filterwerte = TRUE;
          ftextout("Werte vergleichen                                        ",5,0,1,0);
          delay(1000);
          setstate ( SENSOR_WERTE_VERGLEICHEN );
       }
      else
       {
          lesen_filterwerte = FALSE;
          callstatemachine ( AUSWERTUNG_L );
       }
    }


    SENSOR_WERTE_VERGLEICHEN                   // 5. Schritt Sensorwerte vergleichen
    {                                          //    die gespeicherten Werte von ELDI/MoTest
                                               //    und die aktuellen Werte

//   *************   Umwandlung int Variable in real-Werte   *******************

    inttoreal(fafi_hl_leak,real_hl_leak);
    inttoreal(fafi_hr_leak,real_hr_leak);

    inttoreal(fafi_hl_aktuell,real_hinten_links);
    inttoreal(fafi_hr_aktuell,real_hinten_rechts);


// ********************************************************************************
// * Alte und aktuelle Fastfilter-Werte vergleichen. Wenn die Differenz zwischen  *
// * neuen und alten Werten >= 20 mm ist, wird auf ein Grobleck im System         *
// * geschlossen. Fehlermeldung und Fahrzeug abstecken.                           *
// ********************************************************************************

    temp1 = real_hinten_links  - real_hl_leak;      // Differenz hinten links
    temp2 = real_hinten_rechts - real_hr_leak;      // Differenz hinten rechts


//   *******   Umwandlung in positiven Wert, wenn Wert negativ wird   ***********

    if (temp1<0) temp1 = -temp1;    //  hinten li
    if (temp2<0) temp2 = -temp2;    //  hinten re


//   *************   Umwandlung real Variable in string   ***********************

    realtostring (temp1,"3.0",temp1_txt);
    realtostring (temp2,"3.0",temp2_txt);


// ****************  Werte hinten links und rechts anzeigen ********************

    ftextout("Hinten links" ,19, 5,1,1);
    ftextout("gespeicherte Werte :"  ,22, 5,0,1);
    inttostring(fafi_hl_leak,fafi_hl_leak_txt);
    ftextout(fafi_hl_leak_txt   ,22,22,0,1);

    ftextout("aktuelle Werte :"      ,23, 5,0,1);
    inttostring(fafi_hl_aktuell,fafi_hinten_links_txt);
    ftextout(fafi_hinten_links_txt,23,22,0,1);

    ftextout("Differenz :"    ,26, 5,1,1);
    ftextout(temp1_txt          ,26,20,1,1);

    ftextout("Hinten rechts",19,40,1,1);
    ftextout("gespeicherte Werte :"  ,22,40,0,1);
    inttostring(fafi_hr_leak,fafi_hr_leak_txt);
    ftextout(fafi_hr_leak_txt   ,22,57,0,1);

    ftextout("aktuelle Werte :"      ,23,40,0,1);
    inttostring(fafi_hr_aktuell,fafi_hinten_rechts_txt);
    ftextout(fafi_hinten_rechts_txt,23,57,0,1);

    ftextout("Differenz :"    ,26,40,1,1);
    ftextout(temp2_txt          ,26,55,1,1);


//       *******************   Werte Hinterachse vergleichen   *************************

         if (temp1 >=20)          // ist Aenderung hinten links groesser oder gleich 20 mm
          {
             delay (3000);
             vergleich_alt_neu_li = FALSE;
             callstatemachine ( AUSWERTUNG_L );
          }
             if (temp2>=20)       // ist Aenderung hinten rechts groesser oder gleich 20 mm
              {
                delay (3000);
                vergleich_alt_neu_re = FALSE;
                callstatemachine ( AUSWERTUNG_L );
              }
         else
          {
            vergleich_alt_neu_li = TRUE;
            vergleich_alt_neu_re = TRUE;
            delay(3000);
            ftextout("Bandmodus zuruecksetzen                                        ",5,0,1,0);

            setstate ( BANDMODUS_RUECKSETZEN );
          }
    }


    BANDMODUS_RUECKSETZEN                       // 6. Schritt
    {                                                      //    alle Modi zuruecksetzen
//      infobox("","Bandmodus ruecksetzen");
      betriebsmodus = 0;
      job_state = "";
      inttostring(betriebsmodus,betriebsmodus_txt);
      INPAapiJob(sgbd,"ENERGIESPARMODE","0","");
      INPAapiResultText(job_state,"JOB_STATUS",1,"");

      if (job_state == "OKAY")
       {
//        hier INPAapiJob(sgbd,"status_lesen","ARG;MODECONTROL_SG",";betriebsmodus_txt);  einfuegen
//        ruecklesen, ob zurueckgesetzt

          bandmodus_reset = TRUE;
          delay(1000);
          callstatemachine ( AUSWERTUNG_L );
       }
      else  // *********** Jobstatus nicht OKAY   *************
       {
          bandmodus_reset = FALSE;
          callstatemachine ( AUSWERTUNG_L );
       }
    }
}


STATEMACHINE AUSWERTUNG_L()
{

    INIT
    {

//      infobox("","Auswertung");

      if (( zuendung_ein_test == TRUE ) && ( status_bandmodus == TRUE ) &&
          ( lesen_filterwerte == TRUE ) && ( vergleich_alt_neu_li == TRUE ) &&
          ( vergleich_alt_neu_re == TRUE ) && ( bandmodus_reset == TRUE ))

       {
           EHC_LECK_OK = TRUE;
           setcolor(1,10);      // Bildschirm gruen
           message_box_open("Ende Lecktest","","Prüfung i.O.");
           delay(3000);
 //          message_box_close();
           returnstatemachine();
       }
      else  // *********** Pruefung nicht OKAY   *************
       {
            // Fehlerauswertung mit Fehlertextzuweisung

           EHC_LECK_OK = FALSE;
           setcolor(1,4);       // Bildschirm rot

           if (zuendung_ein_test == FALSE)
            {
              fehlertext_1 = "Zuendung ist aus";
            }
           else
            {
              if (status_bandmodus == FALSE)
               {
                 fehlertext_1 = "ENERGIESPARMODE nicht gesetzt";
                 fehlertext_2 =  job_state;
               }
              else
               {
                 if (alte_werte_lesen == FALSE)
                  {
                    fehlertext_1 = "STATUS_LESEN,ARG;STATUS_GROBLECK";
                    fehlertext_2 =  job_state;
                  }
                 else
                  {
                   if (lesen_filterwerte == FALSE)
                    {
                      fehlertext_1 = "STATUS_LESEN,ARG;STATUS_FILTERWERTE";
                      fehlertext_2 = job_state;
                    }
                   else
                    {
                      if (vergleich_alt_neu_li == FALSE)
                       {
                         fehlertext_1 = "Höhenstand hinten links stark verändert";
                         fehlertext_2 = "Luftfederung überprüfen!";
                       }
                      else
                       {
                         if (vergleich_alt_neu_re == FALSE)
                          {
                            fehlertext_1 = "Höhenstand hinten rechts stark verändert";
                            fehlertext_2 = "Luftfederung überprüfen!";
                          }
                         else
                          {
                            if (bandmodus_reset == FALSE)
                             {
                               fehlertext_1 = "ENERGIESPARMODE Aus";
                               fehlertext_2 = job_state;
                             }
                          }
                       }
                    }
                  }
               }
            }    // Ident
         }
         message_box_niO("Ende Lecktest",fehlertext_1,fehlertext_2,"");
         delay(500);
         returnstatemachine();
    }
}


MENU m_abgleich()
{
  INIT {
    setmenutitle("Abgleichen");
  }
  ITEM( 1 ,"")   {
    setscreen(s_abgleich,TRUE);
    }
  ITEM( 2 ,"")   {
    setscreen(s_abgleich,TRUE);
    }
  ITEM( 8 ,"Abgleich")  {

    input2int(delta_links,delta_rechts,"Fahrzeughöhe abgleichen",
            "Bitte geben Sie die Abweichung von der Sollhöhe in mm ein! Formel: Isthöhe - Sollhöhe = Eingabewert",
            "links","rechts",-255,255,-255,255);

    getinputstate(input_state);
    if (input_state==input_ok)
    {
      schon_abgeglichen=1;
      inttostring(delta_links,abweich_links);
      inttostring(delta_rechts,abweich_rechts);

      INPAapiJob(sgbd,"steuern_io","ARG;STEUERN_ABGLEICH_HOEHENSTAND;STA;"+abweich_links+";"+abweich_rechts+";"+min_abweich,"");  //us angepasst
      INPAapiCheckJobStatus("OKAY");

      INPAapiResultText(hoehe_links,"STAT_SG_HOEHE_LINKS_WERT",1,"4.0R");
      INPAapiResultText(hoehe_rechts,"STAT_SG_HOEHE_RECHTS_WERT",1,"4.0R");
      INPAapiResultText(offset_li_alt,"STAT_OFFSET_LINKS_ALT_WERT",1,"4.0R");
      INPAapiResultText(offset_re_alt,"STAT_OFFSET_RECHTS_ALT_WERT",1,"4.0R");
      INPAapiResultText(offset_li_neu,"STAT_OFFSET_LINKS_NEU_WERT",1,"4.0R");
      INPAapiResultText(offset_re_neu,"STAT_OFFSET_RECHTS_NEU_WERT",1,"4.0R");
      INPAapiResultText(abw_links,"STAT_ABWEICHUNG_LINKS_WERT",1,"4.0R");
      INPAapiResultText(abw_rechts,"STAT_ABWEICHUNG_RECHTS_WERT",1,"4.0R");
      INPAapiResultText(aufl_links,"STAT_AUFLOESUNG_LINKS_WERT",1,"4.0R");
      INPAapiResultText(aufl_rechts,"STAT_AUFLOESUNG_RECHTS_WERT",1,"4.0R");

      setscreen(s_abgleich,TRUE);
    }
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurueck")  {
    schon_abgeglichen=0;
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}


// ***********************************************************
// ***             S t a t u s s c r e e n                 ***
// ***********************************************************

SCREEN s_status()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  Status Analog lesen"      , 4,5,0,1);
    ftextout("< F2 >  Status Digital lesen"     , 6,5,0,1);
    ftextout("< F3 >  Status Onlinedaten lesen" , 8,5,0,1);
    ftextout("< F4 >  Fastfilter Werte fuer Grobleckprüfung schreiben" ,10,5,0,1);
    ftextout("< F5 >  Fastfilter Werte fuer Grobleckprüfung lesen" ,12,5,0,1);
    ftextout("< F6 >  Pruefstempel lesen"       ,14,5,0,1);
//    ftextout("< F7 >  Kontrollbyte Achsmeßstand schreiben" ,16,5,0,1);

    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// ******************************************************************
// ***          S t a t u s A n a l o g s c r e e n               ***
// ******************************************************************

SCREEN s_status_analog()
{
  ftextout("Status Analog lesen",0,0,1,1);
  ftextout("",2,0,0,0);

//Spannungswerte Sensor und U Batt lesen
  INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_ANALOGWERTE","");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  LINE("Batteriespannung","")
  {
    text(1,0,"Batteriespannung");
    text(2,0,"[Volt]");
    INPAapiResultAnalog(zahlen_var,"STAT_ANALOG_UKL30_WERT",1);   //us angepasst
    analogout(zahlen_var, 3, 0,0.0,18.0,9.0,16.0,"2.1");
  }

  LINE("Spannungsversorgungen","")
  {
//  Spannungsversorgung Sensor hinten links 
    text(1,0,"Spannungsversorgung Sensor hinten links");
    text(2,0,"[Volt]");
    INPAapiResultAnalog(zahlen_var,"STAT_ANALOG_USENS1_WERT",1);   //us angepasst
    analogout(zahlen_var, 3, 0,3.0,7.0,4.5,5.5,"2.1");

//  Spannung Sensor hinten rechts
    text(1,40,"Spannungsversorgung Sensor hinten rechts");
    text(2,40,"[Volt]");
    INPAapiResultAnalog(zahlen_var,"STAT_ANALOG_USENS2_WERT",1);   //us angepasst
    analogout(zahlen_var, 3, 40,3.0,7.0,4.5,5.5,"2.1");
  }

  LINE("Spannungswerte Sensoren","")
  {
//  Spannungswert Sensor hinten links 
    text(1,0,"Spannungswert Sensor hinten links");
    text(2,0,"[Volt]");
    INPAapiResultAnalog(zahlen_var,"STAT_ANALOG_RL_WERT",1);   //us angepasst
    analogout(zahlen_var,3,0, 0.0, 5.0, 0.5, 4.5, "2.1");

//  Spannung Sensor hinten rechts
    text(1,40,"Spannungswert Sensor hinten rechts");
    text(2,40,"[Volt]");
    INPAapiResultAnalog(zahlen_var,"STAT_ANALOG_RR_WERT",1);   //us angepasst
    analogout(zahlen_var,3,40, 0.0, 5.0, 0.5, 4.5, "2.1");
  }
}


// **************************
// *** StatusDigitalscreen***
// **************************
SCREEN s_status_digital()
{
  ftextout("Status Digital lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"status_lesen","ARG;STATUS_REGLERWERTE","");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  LINE("Fahr-Status-Byte","")
  {
    text(0,1,"Klemme 15");
    INPAapiResultDigital(logik_var,"STAT_STATE_IGN_NR",1);              //ok
    digitalout(logik_var,0,16,"aktiv          ","nicht aktiv ");

    text(2,1,"Status Motor");
    INPAapiResultDigital(logik_var,"STAT_STATE_ENGINE_NR",1);   //ok
    digitalout(logik_var, 2,16,"aktiv          ","nicht aktiv ");

    text(4,1,"Status faehrt");
    INPAapiResultInt(zahlen_var_int,"STAT_STATE_SPEED_NR",1);   // ok
    if (zahlen_var_int>0) logik_var=1; else logik_var=0;
    inttostring(zahlen_var_int,string_var);
    digitalout(logik_var,4,16,"","");
    ftextout("-> "+string_var+" km/h       ",4,21,0,1);

 // text(6,1,"Regelung gesperrt");
 // INPAapiResultDigital(logik_var,"",1);
 // digitalout(logik_var, 6,16,"aktiv          ","nicht aktiv ");

    text(8,1,"Status Tuer");
    INPAapiResultDigital(logik_var,"STAT_STATE_DOOR_NR",1);             // ok
    digitalout(logik_var, 8,16,"aktiv           ","nicht aktiv ");

    text(10,1,"Anwahl Post");
    INPAapiResultDigital(logik_var,"STAT_STATE_DO_POST_NR",1);  // ok
    digitalout(logik_var, 10,16,"aktiv          ","nicht aktiv ");

//  Status Betriebsmodi lesen
    ftextout("Bandmodus",20,1,0,0);
    ftextout("Verlademodus",20,41,0,0);
//    ftextout("Werkstattmodus",23,1,0,0);

    INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultDigital(bandmodus,"STAT_PRODUKTIONSMODE_EIN",1);
    digitalout(bandmodus, 20,16,"aktiv      !","nicht aktiv ");

    INPAapiResultDigital(verlademodus,"STAT_TRANSPORTMODE_EIN",1);
    digitalout(verlademodus, 20,53,"aktiv      !","nicht aktiv ");

//    Dummy Modus im Steuergerät
//    digitalout(werkstattmodus, 23,16,"aktiv      !","nicht aktiv ");

  }
}

// ******************************************************************
// ***                   StatusOnlinescreen                       ***
// ******************************************************************

SCREEN s_status_online()
{
  ftextout("Status Online lesen",0,0,1,1);
  ftextout("",1,0,1,0);

  LINE("SensorWerte","")
   {
    ftextout("Sensor-Rohwerte",0,0,0,1);
    text(1, 1,"Sensor hinten links [mm]");
    text(1,41,"Sensor hinten rechts [mm]");

    INPAapiJob(sgbd,"status_lesen","ARG;STATUS_FILTERWERTE","");
    INPAapiCheckJobStatus("OKAY");

    INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RL_WERT",1);    
    analogout(zahlen_var, 2, 1,-120,120,-120,120,"3.0");

    INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RR_WERT",1);    
    analogout(zahlen_var, 2, 41,-120,120,-120,120,"3.0");

    ftextout("Fast Filter Werte",4,0,0,1);
    text(5, 1,"Sensor hinten links [mm]");
    text(5,41,"Sensor hinten rechts [mm]");

    INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RL_WERT",1);    
    analogout(zahlen_var, 6, 1,-120.0,120.0,-120.0,120.0,"3.0");

    INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RR_WERT",1);    
    analogout(zahlen_var, 6, 41,-120.0,120.0,-120.0,120.0,"3.0");

    ftextout("Slow Filter Werte",8,0,0,1);
    text(9,1,"Sensor hinten links [mm]");
    text(9,41,"Sensor hinten rechts [mm]");

    INPAapiResultAnalog(zahlen_var,"STAT_SLOWFILTER_RL_WERT",1);    
    analogout(zahlen_var, 10, 1,-120.0,120.0,-120.0,120.0,"3.0");

    INPAapiResultAnalog(zahlen_var,"STAT_SLOWFILTER_RR_WERT",1);    
    analogout(zahlen_var, 10, 41,-120.0,120.0,-120.0,120.0,"3.0");
   }

  LINE("ReglerWerte","")
   {
    ftextout("Reglermodus",1,0,0,1);
    ftextout("Zustand                                       Aktoren",1,35,0,1);

    INPAapiJob(sgbd,"status_lesen","ARG;STATUS_REGLERWERTE","");    
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultInt(zahlen_var_int,"STAT_STATE_MODE_NR",1);    

    inttostring(zahlen_var_int,string_var); ftextout(string_var,1,12,0,0);
    text(3,1,"sleep");
    if (zahlen_var_int==1) digitalout(1,3,8,"","");
    else digitalout(0, 3, 8,"","");

    text(3,15,"lift");
    if (zahlen_var_int==8)digitalout(1, 3,22,"","");
    else digitalout (0, 3, 22,"","");

    text(5,1,"normal");
    if (zahlen_var_int==3)digitalout(1, 5,8,"","");
    else digitalout (0, 5, 8,"","");

    text(7,1,"drive");
    if (zahlen_var_int==4)digitalout(1, 7,8,"","");
    else digitalout (0, 7, 8,"","");

    text(5,15,"curve");
    if (zahlen_var_int==5)digitalout(1, 5,22,"","");
    else digitalout (0, 5, 22,"","");

    text(9,1,"pre");
    if (zahlen_var_int==2)digitalout(1, 9,8,"","");
    else digitalout (0, 9, 8,"","");

    text(7,15,"post");
    if (zahlen_var_int==9)digitalout(1, 7,22,"","");
    else digitalout (0, 7, 22,"","");

    INPAapiResultInt(zahlen_var_int,"STAT_STATE_KERB_NR",1);    
    text(5,29,"kerb-bit");
    if (zahlen_var_int==1)digitalout(1, 5,36,"","");
    else digitalout (0, 5, 36,"","");

    INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;20","");    
    INPAapiCheckJobStatus("OKAY");
    text(3,58,"Kompressor");
    INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);    
    if (zahlen_var_int==0) digitalout(0,4,60,"","");
    else digitalout(1, 4, 60,"","");

    INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;19","");    
    INPAapiCheckJobStatus("OKAY");
    text(6,58,"Ablassventil");
    INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);    
    if (zahlen_var_int==0) digitalout(0,7,60,"","");
    else digitalout(1, 7, 60,"","");

    INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;17","");    
    INPAapiCheckJobStatus("OKAY");
    text(8,50,"Ventil HL");
    INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);    
    if (zahlen_var_int==0) digitalout(0,9,51,"","");
    else digitalout(1, 9,51 ,"","");

    INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;18","");    
    INPAapiCheckJobStatus("OKAY");
    text(8,67,"Ventil HR");
    INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);    
    if (zahlen_var_int==0) digitalout(0,9,68,"","");
    else digitalout(1, 9, 68,"","");

    stringtoint(str_cbd_lu,int_cbd_lu);
    if((int_cbd_lu == 0) || (int_cbd_lu == 255))
     {
     }
    else
     {
//us     INPAapiJob(sgbd,"STATUS_LEVELUP_LESEN","","");
//us     INPAapiCheckJobStatus("OKAY");
     text(3,29,"Levelup");
//us     INPAapiResultInt(zahlen_var_int,"STAT_ZUSTAND_LEVELUP",1);
     if (zahlen_var_int==1)digitalout(1, 3,36,"","");
     else if (zahlen_var_int==0)digitalout (0, 3, 36,"","");
     else
         {  digitalout(1,3,36,"","");
            delay(1000);
            digitalout (0,3,36,"","");
            delay(1000);
         }
     }

//us    INPAapiJob(sgbd,"_lesen_tilt_status","","");
//us    INPAapiCheckJobStatus("OKAY");
//us    INPAapiResultText(str_cbd_sip,"TILT_CODIERT",1,"");
    stringtoint(str_cbd_sip,int_cbd_sip);
    if(int_cbd_sip >= 1)
     {
     text(7,29,"SIP");
//us     INPAapiJob(sgbd,"_lesen_tilt_status","","");
//us     INPAapiCheckJobStatus("OKAY");
//us     INPAapiResultInt(zahlen_var_int,"TILT_ZUSTAND",1);
     if (zahlen_var_int>=1)digitalout(1, 7,36,"","");
     else digitalout (0, 7, 36,"","");
     if (zahlen_var_int==1) text(7,41,"VL");
     else if (zahlen_var_int==2) text(7,41,"VR");
     else if (zahlen_var_int==4) text(7,41,"HL");
     else if (zahlen_var_int==8) text(7,41,"HR");
     }
   }

    LINE("Fehler","")
   {
    ftextout("Fehler",1,0,0,1);
    INPAapiJob(sgbd,"FS_LESEN","","");
    INPAapiResultSets(zahlen_var_int);
    if (zahlen_var_int ==1) digitalout(0,2,8,"","");
    else digitalout(1,2,8,"","");
   }
}

// ******************************************************************
// ***           Screen fastfilter_lesen_schreiben                ***
// ******************************************************************

SCREEN s_fastfilter_lesen_schreiben()
{
  ftextout("FASTFILTER WERTE LESEN SCHREIBEN",0,0,1,1);

     ftextout("Fastfilter Werte fuer Grobleckprüfung ablegen",3,0,1,0);

     INPAapiJob(sgbd,"steuern_io","ARG;STEUERN_FASTFILTER_WERTE_LESEN_SCHREIBEN;STA","");   
     INPAapiCheckJobStatus("OKAY");
     INPAapiJob(sgbd,"ENERGIESPARMODE","1","");   
     INPAapiCheckJobStatus("OKAY");

     userboxopen(0,10,08,10,70,"Fastfilterwerte lesen schreiben","");
     userboxftextout(0,"Fastfilterwerte fuer Grobleckprüfung geschrieben",1,3,1,0);
     userboxftextout(0,"Achtung!... Bandmodus wurde  aktiviert",3,3,1,0);
     userboxftextout(0,"Min. 1 Stunde warten, dann Grobleckprüfung",5,3,1,0);
}

// ******************************************************************
// ***       Screen gespeicherte Fastfilterwerte anzeigen         ***
// ******************************************************************

SCREEN s_status_grobleckwerte()
{
  ftextout("Grobleck lesen",0,0,1,1);

  LINE("Gespeicherte Fastfilterwerte und Kontrollbyte","")
   {
     ftextout("Anzeige gespeicherte Fastfilterwerte und Kontrollbyte",1,0,1,0);

     INPAapiJob(sgbd,"status_lesen","ARG;STATUS_GROBLECK","");       //us angepasst
     INPAapiResultInt(fafi_hl_leak,"STAT_H_RL_FASTFILTER_WERT",1);   //us angepasst     1. Byte, gespeicherter Werte links
     INPAapiResultInt(pruefbyte,"STAT_PRUEFBYTE_WERT",1);            //us angepasst     2. Pruefstempel Hx55 vom Achsmeßstand bei i.O.
     INPAapiResultInt(fafi_hr_leak,"STAT_H_RR_FASTFILTER_WERT",1);   //us angepasst     3. Byte, gespeicherter Werte rechts

     ftextout("Hinten links :" ,10, 5,1,1);
     inttostring(fafi_hl_leak,fafi_hl_leak_txt);
     ftextout(fafi_hl_leak_txt,10,27,1,1);

     ftextout("Hinten rechts :",10,40,1,1);
     inttostring(fafi_hr_leak,fafi_hr_leak_txt);
     ftextout(fafi_hr_leak_txt,10,64,1,1);

     ftextout("Kontrollbyte vom Achsmeßstand :",15,5,1,1);
     inttostring(pruefbyte,pruefbyte_txt);   //us eingefuegt
     ftextout(pruefbyte_txt,15,64,1,1);

   }
}

/* momentan nicht benutzt sh 22.05.2007
// ******************************************************************
// ***              Kontrollbyte schreiben Screen                 ***
// ******************************************************************

SCREEN s_kontrollbyte_schreiben()
{
  ftextout("Kontrollbyte Achsmessstand schreiben",0,0,1,1);

  LINE("Kontrollbyte vom Achsmessstand schreiben","")
   {
     ftextout("< F7 >  Eingabebox aufrufen" , 16, 5,0,1);

   }
}
*/


// ******************************************************************
// ***              Status Pruefstempel lesen Screen              ***
// ******************************************************************

SCREEN s_status_pruefstempel()
{
  ftextout("Pruefstempel lesen",0,0,1,1);
  ftextout("",2,0,0,0);
  INPAapiJob(sgbd,"PRUEFSTEMPEL_LESEN","","");
  INPAapiCheckJobStatus("OKAY");

  LINE("Anzeige Pruefstempelwerte","")
   {
     ftextout("Anzeige Pruefstempelwerte",0,0,1,0);
     INPAapiResultInt(byte_1,"BYTE1",1);
     INPAapiResultInt(byte_2,"BYTE2",1);
     INPAapiResultInt(byte_3,"BYTE3",1);
// 1.Byte
     ftextout("Pruefstempel 1. Byte:",4,5,0,0);
     inttostring(byte_1,byte1_txt);
     ftextout(byte1_txt,4,25,0,1);
// 2.Byte
     ftextout("Pruefstempel 2. Byte:",6,5,0,0);
     inttostring(byte_2,byte2_txt);
     ftextout(byte2_txt,6,25,0,1);
// 3.Byte
     ftextout("Pruefstempel 3. Byte:",8,5,0,0);
     inttostring(byte_3,byte3_txt);
     ftextout(byte3_txt,8,25,0,1);
   }
}


// ******************************************************************
// ***              S t e u e r n s c r e e n                     ***
// ******************************************************************
SCREEN s_steuern()
{
  ftextout("Ansteuern",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  Handsteuern"        ,  4, 5,0,1);
    ftextout("< F2 >  Aktorensteuern"     ,  6, 5,0,1);
    ftextout("< F3 >  Modi einstellen"    ,  8, 5,0,1);
    ftextout("< F4 >  Abgleichen"         , 10, 5,0,1);
    ftextout("< F5 >  Grobleckprüfung"    , 12, 5,0,1);
    ftextout("< F6 >  Vertauscherprüfung" , 14, 5,0,1);
    ftextout("< F7 >  Sondermodi" , 16, 5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

SCREEN s_steuern_mod()
{
 ftextout("Einstellen Modi",0,0,1,1);
 ftextout("",2,0,0,0);
 ftextout("< F1 >  Bandmodus Ein"  ,04,5,0,1);
 ftextout("< F2 >  Verlademodus Ein"  ,06,5,0,1);
// ftextout("< F3 >  Werkstattmodus Ein"     ,08,5,0,1);
 ftextout("< F4 >  LowTolmodus Ein"     ,04,43,0,1);
 ftextout("< F5 >  Modi ausschalten (Regelmodus)"   ,12,5,0,1);

 // Status Produktionsmode lesen
    INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");   //us angepasst
    INPAapiResultDigital(bandmodus,"STAT_PRODUKTIONSMODE_EIN",1);   //us angepasst
    INPAapiCheckJobStatus("OKAY");
    ftextout("Bandmodus",15,3,0,0);
    digitalout(bandmodus, 15,16,"aktiv!              ","nicht aktiv ");

 // Status Transportmodus lesen
    INPAapiJob(sgbd,"STATUS_ENERGIESPARMODE","","");   //us angepasst
    INPAapiResultDigital(verlademodus,"STAT_TRANSPORTMODE_EIN",1);   //us angepasst
    INPAapiCheckJobStatus("OKAY");
    ftextout("Verlademodus",18,3,0,0);
    digitalout(verlademodus, 18,16,"aktiv!              ","nicht aktiv");
    
    ftextout("LowTolmodus",15,41,0,0);
    digitalout(lowtolmodus, 15,54,"aktiv!              ","nicht aktiv");

//  ftextout("Werkstattmodus",21,3,0,0);
//  digitalout(werkstattmodus, 21,16,"aktiv!              ","nicht aktiv");

  INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");    
  INPAapiCheckJobStatus("OKAY");

  ftextout("Fast Filter Wert",24,3,0,1);
  text(25,3,"Sensor hinten links [mm]");

  ftextout("Fast Filter Wert",24,41,0,1);
  text(25,41,"Sensor hinten rechts [mm]");

  INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RL_WERT",1);    
  analogout(zahlen_var, 26, 3,-40.0,40.0,-10.0,10.0,"3.0");

  INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RR_WERT",1);    
  analogout(zahlen_var, 26, 41,-40.0,40.0,-10.0,10.0,"3.0");
}


SCREEN s_steuern_smod()
{
 ftextout("Einstellen Sondermodi",0,0,1,1);
 ftextout("",2,0,0,0);
 ftextout("< F1 >  Dumpmodus Ein"  ,04,5,0,1);
 ftextout("< F2 >  Dumpmodus Aus"  ,06,5,0,1);


 // Status Betriebsmodi lesen
    INPAapiJob(sgbd,"status_lesen","ARG;STATUS_MODECONTROL_SG","");    
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultInt(betriebsmodus,"STAT_E_MODECONTROL_WERT",1);    

    betriebsmodus_puffer_3 = betriebsmodus;
    if ((betriebsmodus_puffer_3 & 0x01) == 0)
    {
     //Dumpmodus inaktiv
     dumpmodus = FALSE;
    }
    betriebsmodus_puffer_3 = betriebsmodus;

    if ((betriebsmodus_puffer_3 & 0x01) == 1)
    {
     //Dumpmodus aktiv
     dumpmodus = TRUE;
    }

   ftextout("Dumpmodus",17,3,0,0);
   digitalout(dumpmodus, 17,16,"aktiv!              ","nicht aktiv ");

  INPAapiJob(sgbd,"status_lesen","ARG;STATUS_FILTERWERTE","");
  INPAapiCheckJobStatus("OKAY");

  ftextout("Fast Filter Wert",24,3,0,1);
  text(25,3,"Sensor hinten links [mm]");

  ftextout("Fast Filter Wert",24,41,0,1);
  text(25,41,"Sensor hinten rechts [mm]");

  INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RL_WERT",1);
  analogout(zahlen_var, 26, 3,-40.0,40.0,-10.0,10.0,"3.0");

  INPAapiResultAnalog(zahlen_var,"STAT_FASTFILTER_RR_WERT",1);
  analogout(zahlen_var, 26, 41,-40.0,40.0,-10.0,10.0,"3.0");
}


SCREEN s_steuern_dig()
{
  setstatemachine( ANSTEUERN );   // Ansteuerfunktion

  ftextout("Handsteuern",0,0,1,1);
  ftextout("Vorsicht bei der Benutzung!",2,0,0,0);
  ftextout("",3,0,0,0);
  delay(100);

  LINE("Werte","")
   {
   text(0,1,"Sensor hinten links [mm]");
   text(4,1,"Sensor hinten rechts [mm]");

// Status lesen Filterwerte 
   INPAapiJob(sgbd,"status_lesen","ARG;STATUS_FILTERWERTE","");
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RL_WERT",1);
   analogout(zahlen_var, 1, 1,-120,120,-120,120,"3.0");
   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RR_WERT",1);
   analogout(zahlen_var, 5, 1,-120,120,-120,120,"3.0");

// Status Kompresssor
   INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;20","");   
   INPAapiCheckJobStatus("OKAY");
   text(0,50,"Kompressor");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);         
   if (zahlen_var_int==0) digitalout(0,1,52,"","");
   else digitalout(1, 1, 52,"","");

// Status Ablassventil
   INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;19","");   
   INPAapiCheckJobStatus("OKAY");
   text(3,50,"Ablassventil");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   
   if (zahlen_var_int==0) digitalout(0,4,52,"","");
   else digitalout(1, 4, 52,"","");

// Status Ventil hinten links
   INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;17","");   
   INPAapiCheckJobStatus("OKAY");
   text(5,42,"Ventil HL");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   
   if (zahlen_var_int==0) digitalout(0,6,43,"","");
   else digitalout(1, 6,43 ,"","");

// Status Ventil hinten rechts
   INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;18","");   
   INPAapiCheckJobStatus("OKAY");
   text(5,59,"Ventil HR");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   
   if (zahlen_var_int==0) digitalout(0,6,60,"","");
   else digitalout(1, 6, 60,"","");
   }

  LINE("Text","")
  {
    ftextout("Hinterachse          < F1 > heben       < F2 > senken" ,3,5,0,1);
    ftextout("hinten links       < F3 > heben       < F4 > senken" ,5,5,0,1);
    ftextout("hinten rechts      < F5 > heben       < F6 > senken" ,7,5,0,1);

    ftextout("< F8 >  Aus"    , 9,20,0,1);
    ftextout("< F9 >  Druck"  ,14, 5,0,1);
    ftextout("< F10>  Zurueck                                              <Shift> + < F10>  Ende" ,16,5,0,1);
  }
}


SCREEN s_steuern_akt()
{

  setstatemachine( ANSTEUERN );
  ftextout("Aktoren ansteuern",0,0,1,1);
  ftextout("Vorsicht bei der Benutzung!",2,0,0,0);
  ftextout("",3,0,0,0);
  delay(100);

  LINE("Werte","")
   {
   text(0,1,"Sensor hinten links [mm]");
   text(4,1,"Sensor hinten rechts [mm]");

   INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE",""); // ok
   INPAapiCheckJobStatus("OKAY");

   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RL_WERT",1);
   analogout(zahlen_var, 1, 1,-120,120,-120,120,"3.0");
   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RR_WERT",1);
   analogout(zahlen_var, 5, 1,-120,120,-120,120,"3.0");

   INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE",""); // ok
   INPAapiCheckJobStatus("OKAY");
   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RL_WERT",1);
   analogout(zahlen_var, 1, 1,-120,120,-120,120,"3.0");
   INPAapiResultAnalog(zahlen_var,"STAT_ORGFASTFILTER_RR_WERT",1);
   analogout(zahlen_var, 5, 1,-120,120,-120,120,"3.0");

   INPAapiJob(sgbd,"STEUERN_IO","ARG;STATUS_SIGNALE_NUMERISCH;STA;20","");   
   INPAapiCheckJobStatus("OKAY");
   text(0,50,"Kompressor");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   
   if (zahlen_var_int==0) digitalout(0,1,52,"","");
   else digitalout(1, 1, 52,"","");

   INPAapiJob(sgbd,"STEUERN_IO","ARG;STATUS_SIGNALE_NUMERISCH;STA;19","");   
   INPAapiCheckJobStatus("OKAY");
   text(3,50,"Ablassventil");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   
   if (zahlen_var_int==0) digitalout(0,4,52,"","");
   else digitalout(1, 4, 52,"","");

   INPAapiJob(sgbd,"STEUERN_IO","ARG;STATUS_SIGNALE_NUMERISCH;STA;17","");   //us angepasst
   INPAapiCheckJobStatus("OKAY");
   text(5,42,"Ventil HL");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   //us angepasst
   if (zahlen_var_int==0) digitalout(0,6,43,"","");
   else digitalout(1, 6,43 ,"","");

   INPAapiJob(sgbd,"STEUERN_IO","ARG;STATUS_SIGNALE_NUMERISCH;STA;18","");   //us angepasst
   INPAapiCheckJobStatus("OKAY");
   text(5,59,"Ventil HR");
   INPAapiResultInt(zahlen_var_int,"STAT_ANSTEUERUNG_AKTIV",1);   //us angepasst
   if (zahlen_var_int==0) digitalout(0,6,60,"","");
   else digitalout(1, 6, 60,"","");
   }

  LINE("Text","")
  {
    ftextout("< F1 > Ventil hinten links auf" ,8,5,0,1);
    ftextout("< F5 > Ventil hinten links zu"  ,9,5,0,1);
       
    ftextout("< F2 > Ventil hinten rechts auf" ,8,45,0,1);   
    ftextout("< F6 > Ventil hinten rechts zu"  ,9,45,0,1);   
    
    ftextout("< F3 > Ablassventil auf" ,5,30,0,1);   
    ftextout("< F7 > Ablassventil zu"  ,6,30,0,1);   

    ftextout("< F4 > Kompressor an"    ,2,30,0,1);  
    ftextout("< F8 > Kompressor aus"   ,3,30,0,1);  

    ftextout("< F9 >  ALLES AUS",11,30,0,1);
    ftextout("< F10>  Zurueck"  ,16,5,0,1);
    ftextout("<Shift> + < F10>  Ende" ,16,45,0,1);
   }
}


// ******************************************************************
// ***                        Abgleichscreen                      ***
// ******************************************************************

SCREEN s_abgleich()
{
  ftextout("Fahrzeughöhe abgleichen",0,0,1,1);
  ftextout("",2,0,0,0);
  if(schon_abgeglichen==1)
    {
    ftextout("Offsetwerte aus Steuergeraet vor Abgleich[mm]:",4,10,0,0);
    ftextout("links",3,53,0,0);
    ftextout("rechts",3,70,0,0);
    ftextout(hoehe_links,4,53,0,1);
    ftextout(hoehe_rechts,4,70,0,1);
    ftextout("Counterwerte aus Steuergeraet:",7,10,0,0);
    ftextout("links",6,53,0,0);
    ftextout("rechts",6,70,0,0);
    ftextout("alt",7,60,0,0);
    ftextout("neu",9,60,0,0);
    ftextout(offset_li_alt,7,53,0,1);
    ftextout(offset_re_alt,7,70,0,1);
    ftextout(offset_li_neu,9,53,0,1);
    ftextout(offset_re_neu,9,70,0,1);
    ftextout("Offsetwerte aus Steuergeraet nach Abgleich[mm]:",12,10,0,0);
    ftextout("links",11,53,0,0);
    ftextout("rechts",11,70,0,0);
    ftextout(abw_links,12,53,0,1);
    ftextout(abw_rechts,12,70,0,1);
    ftextout("Sensoraufloesung aus Steuergeraet [1/mm]:",15,10,0,0);
    ftextout("links",14,53,0,0);
    ftextout("rechts",14,70,0,0);
    ftextout(aufl_links,15,53,0,1);
    ftextout(aufl_rechts,15,70,0,1);
    }

  ftextout("Fahrzeugsollhöhe",17,0,1,0);
  ftextout("gemessen vom Felgenhorn unten bis zur hoechsten Stelle des Radhausausschnitts",19,0,0,1);
  ftextout("L6"    ,21,0,1,0);    // ok

  ftextout("Felgendurchmesser" ,23, 0,0,0);
  ftextout("17 Zoll"           ,23,36,0,0);
  ftextout("18 Zoll"           ,23,42,0,0);
  ftextout("19 Zoll"           ,23,48,0,0);
  ftextout("20 Zoll"           ,23,54,0,0);

  ftextout("Sollhöhe [mm]"    ,24, 0,0,0);
  ftextout("Serie L6:"        ,24,12,0,0);
  ftextout("---"                 ,24,36,0,1);
  ftextout("644"                 ,24,42,0,1);
  ftextout("657"                 ,24,48,0,1);
  ftextout("670"                 ,24,54,0,1);
  delay(100);
}

SCREEN s_steuern_grobleck()
{
  ftextout("Grobleckprüfung",0,0,2,1);

     ftextout("Prüfung nur sinnvoll wenn:",7,0,1,0);
     ftextout("vorher die Fastfilter-Werte gespeichert",9,0,1,0);
     ftextout("der Bandmodus gesetzt wurde",11,0,1,0);
     ftextout("Wartezeit min. 1 Stunde",13,0,1,0);

  LINE("","")
  {
  }
}

STATEMACHINE ANSTEUERN()
{
INIT
{
  ansteuerzeit = 2;
//  steuerzeit_ist = ansteuerzeit;      // 2 sec
  ventil_ab_init = FALSE;
  setstate(STATE1);
}

STATE1
{

if (komp == TRUE)
{
  inttostring(ansteuerzeit,steuern_comp);
  steuern_comp = "1;"+steuern_comp+";20";   
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   
  INPAapiCheckJobStatus("OKAY");
}


if (v_hl == TRUE)
{
  inttostring(ansteuerzeit,steuern_ventil_li);
  steuern_ventil_li = "1;"+steuern_ventil_li+";17";     //   Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   
  INPAapiCheckJobStatus("OKAY");
}
/* funktioniert nicht, da immer true, wenn nicht v_hl
else
{
  inttostring(ansteuerzeit,steuern_ventil_li);
  steuern_ventil_li = "0;"+steuern_ventil_li+";17";     //   Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   
  INPAapiCheckJobStatus("OKAY");
}
*/

if (v_hr == TRUE)
{
  inttostring(ansteuerzeit,steuern_ventil_re);
  steuern_ventil_re = "1;"+steuern_ventil_re+";18";     //   Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");   
  INPAapiCheckJobStatus("OKAY");
 }


if (v_ab == TRUE)
 {
  inttostring(ansteuerzeit,steuern_ventil_ab);
  steuern_ventil_ab = "1;"+steuern_ventil_ab+";19";       // Variable fuer Ablassventil
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   
  INPAapiCheckJobStatus("OKAY");
 }


 if (hr_auf == TRUE)
 {
  inttostring(ansteuerzeit,steuern_hr_auf);
  steuern_hr_auf = "1;"+steuern_hr_auf+";0xC1";  
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_hr_auf,"");   
  INPAapiCheckJobStatus("OKAY");

/* I350
  // Ablassventil ansteuern
  if (ventil_ab_init == FALSE)
  {
        inttostring(steuerzeit_ist,steuern_ventil_ab);
          steuern_ventil_ab = "1;15;19";   //us angepasst     1. Ablassventil insgesamt 1500ms öffnen
          INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
          INPAapiCheckJobStatus("OKAY");


// 2. Kompressor nach 1000ms ansteuern
  delay (1000);
  inttostring(steuerzeit_ist+7,steuern_comp); // Ansteuerintervall + 750ms Kompressorvorlauf
  steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(500); // 500ms warten bevor Ablassventil geschlossen wird
  steuern_ventil_ab = "0;10;19";   //us angepasst     3. Ablassventil schließen
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(250); // 4. noch 250ms warten bevor Balgventil angesteuert wird
  ventil_ab_init = TRUE; // Anfahren abgeschlossen
  }
        else {
                inttostring(steuerzeit_ist,steuern_comp);
                steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
                INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
                INPAapiCheckJobStatus("OKAY");
        }

  inttostring(steuerzeit_ist,steuern_ventil_re);
  steuern_ventil_re = "1;"+steuern_ventil_re+";18";   //us angepasst     Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
 */
 }
 
 
 if (hl_auf == TRUE)
 {
  inttostring(ansteuerzeit,steuern_hl_auf);
  steuern_hl_auf = "1;"+steuern_hl_auf+";0xC2";  
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_hl_auf,"");   
  INPAapiCheckJobStatus("OKAY");


/* I350
  // Ablassventil ansteuern
  if (ventil_ab_init == FALSE)
  {
        inttostring(steuerzeit_ist,steuern_ventil_ab);
          steuern_ventil_ab = "1;15;19";   //us angepasst     1. Ablassventil insgesamt 1500ms öffnen
          INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
          INPAapiCheckJobStatus("OKAY");


// 2. Kompressor nach 1000ms ansteuern
  delay (1000);
  inttostring(steuerzeit_ist+7,steuern_comp); // Ansteuerintervall + 750ms Kompressorvorlauf
  steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(500); // 500ms warten bevor Ablassventil geschlossen wird
  steuern_ventil_ab = "0;10;19";   //us angepasst     3. Ablassventil schließen
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(250); // 4. noch 250ms warten bevor Balgventil angesteuert wird
  ventil_ab_init = TRUE; // Anfahren abgeschlossen
  }
        else {
                inttostring(steuerzeit_ist,steuern_comp);
                steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
                INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
                INPAapiCheckJobStatus("OKAY");
        }
  inttostring(steuerzeit_ist,steuern_ventil_li);
  steuern_ventil_li = "1;"+steuern_ventil_li+";17";     //us angepasst     Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
*/
}

 if (hr_ab == TRUE)
 {
  inttostring(ansteuerzeit,steuern_hr_ab);
  steuern_hr_ab = "2;"+steuern_hr_ab+";0xC1";  
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_hr_ab,"");   
  INPAapiCheckJobStatus("OKAY");

/*
  inttostring(steuerzeit_ist,steuern_ventil_ab);
  steuern_ventil_ab = "1;"+steuern_ventil_ab+";19";    //us angepasst     Variable fuer Ablassventil
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  inttostring(steuerzeit_ist,steuern_ventil_re);
  steuern_ventil_re = "1;"+steuern_ventil_re+";18";    //us angepasst     Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");  //us angepasst
  INPAapiCheckJobStatus("OKAY");

  ventil_ab_init = FALSE; // zum Heben muss neu initialisiert werden
 */
 }

 if (hl_ab == TRUE)
 {
   inttostring(ansteuerzeit,steuern_hl_ab);
   steuern_hl_ab = "2;"+steuern_hl_ab+";0xC1";  
   INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_hl_ab,"");   
   INPAapiCheckJobStatus("OKAY");
 
/*   
   inttostring(steuerzeit_ist,steuern_ventil_ab);
   steuern_ventil_ab = "1;"+steuern_ventil_ab+";19";  //us angepasst     Variable fuer Ablassventil
   INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
   INPAapiCheckJobStatus("OKAY");

   inttostring(steuerzeit_ist,steuern_ventil_li);
   steuern_ventil_li = "1;"+steuern_ventil_li+";17";       //us angepasst     Variable fuer Balgventil hinten links
   INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
   INPAapiCheckJobStatus("OKAY");

   ventil_ab_init = FALSE; // zum Heben muss neu initialisiert werden
*/ 
 }


if (ha_auf == TRUE)
{
  
  inttostring(ansteuerzeit,steuern_ha_auf);
  steuern_ha_auf = "1;"+steuern_ha_auf+";0xC3";  
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ha_auf,"");   
  INPAapiCheckJobStatus("OKAY");

/*
// Ablassventil ansteuern
  if (ventil_ab_init == FALSE)
  {
        inttostring(steuerzeit_ist,steuern_ventil_ab);
          steuern_ventil_ab = "1;15;19";   //us angepasst     1. Ablassventil insgesamt 1500ms öffnen
          INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   
          INPAapiCheckJobStatus("OKAY");

// 2. Kompressor nach 1000ms ansteuern
  delay (1000);
  inttostring(steuerzeit_ist+7,steuern_comp); // Ansteuerintervall + 750ms Kompressorvorlauf
  steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(500); // 500ms warten bevor Ablassventil geschlossen wird
  steuern_ventil_ab = "0;10;19";   //us angepasst     3. Ablassventil schließen
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  delay(250); // 4. noch 250ms warten bevor Balgventil angesteuert wird
  ventil_ab_init = TRUE; // Anfahren abgeschlossen
  }
        else {
                inttostring(steuerzeit_ist,steuern_comp);
                steuern_comp = "1;"+steuern_comp+";20";   //us angepasst
                INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
                INPAapiCheckJobStatus("OKAY");
        }

// Ventil hinten links ansteuern
  inttostring(steuerzeit_ist,steuern_ventil_li);
  steuern_ventil_li = "1;"+steuern_ventil_li+";17";     //us angepasst     Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

// Ventil hintenrechts ansteuern
  inttostring(steuerzeit_ist,steuern_ventil_re);
  steuern_ventil_re = "1;"+steuern_ventil_re+";18";     //us angepasst     Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
*/
 }

 
 if (ha_ab == TRUE)
 {
   inttostring(ansteuerzeit,steuern_ha_ab);
   steuern_ha_ab = "2;"+steuern_ha_ab+";0xC3";  
   INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ha_ab,"");   
   INPAapiCheckJobStatus("OKAY");

/*
  inttostring(steuerzeit_ist,steuern_ventil_ab);
  steuern_ventil_ab = "1;"+steuern_ventil_ab+";19";   //us angepasst     Variable fuer Ablassventil
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  inttostring(steuerzeit_ist,steuern_ventil_li);
  steuern_ventil_li = "1;"+steuern_ventil_li+";17";     //us angepasst     Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  inttostring(steuerzeit_ist,steuern_ventil_re);
  steuern_ventil_re = "1;"+steuern_ventil_re+";18";    //us angepasst     Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
  ventil_ab_init = FALSE; // zum Heben muss neu initialisiert werden
*/
 }


 if (h_aus == TRUE)
 {
//   inttostring(ansteuerzeit,steuern_ha_ab);
//   steuern_ha_ab = "0;"+steuern_ha_ab+";0xC3";  
//   INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ha_ab,"");   
//   INPAapiCheckJobStatus("OKAY");


  //Balgventile zu
/* 
  inttostring(steuerzeit_ist,steuern_ventil_li);
  steuern_ventil_li = "0;"+steuern_ventil_li+";17";     //us angepasst     Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  inttostring(steuerzeit_ist,steuern_ventil_re);
  steuern_ventil_re = "0;"+steuern_ventil_re+";18";    //us angepasst     Variable fuer Balgventil hinten rechts
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");

  //Kompressor aus
  inttostring(steuerzeit_ist,steuern_comp);
  steuern_comp = "0;"+steuern_comp+";20";   //us angepasst
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_comp,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
 
  inttostring(steuerzeit_ist,steuern_ventil_li);
  steuern_ventil_li = "0;"+steuern_ventil_li+";17";     //us angepasst     Variable fuer Balgventil hinten links
  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");   //us angepasst
  INPAapiCheckJobStatus("OKAY");
*/

  //Ablassventil öffnen
//  steuern_ventil_ab = "1;10;19";   //us angepasst     Ablassventil  öffnen
//  INPAapiJob(sgbd,"steuern","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_ab,"");   //us angepasst
//  INPAapiCheckJobStatus("OKAY");
//  ventil_ab_init = FALSE; // zum Heben muss neu initialisiert werden
//  h_aus=FALSE; //Flag zurücksetzen
  }

 }
}



SCREEN s_tausch ()
{
   ftextout("EHC Vertauscherprüfung 1-Achsluftfederung", 2,5,1,1);
}

//   ************************************************************************
//   ***  S t a r t   S t a t e m a c h i n e   A b l a u f  G E S A M T  ***
//   ***           Statemachine Vertauscherprüfung 1. Ebene               ***
//   *************************************************************************



STATEMACHINE EHC_F01_VERTAUSCHERPRUEFUNG()
{

        INIT
        {
           ftextout("EHC Vertauscherprüfung 1-Achsluftfederung", 2,5,1,1);
//           meldung_1("Fahrgestellnummer lesen");
           callstatemachine (FAHRGESTELLNUMMER_LESEN);                         // 1. Schritt
                                                                               // Fahrgestellnummer lesen für Statistikfile
           if (c_fg_lesen == TRUE)                                             // C:\vertau.dat
           {
             setstate (BANDMODUS);
           }
          else
           {
             setstate (ENDE_AUSWERTUNG);
           }
        }


        BANDMODUS                                                              // 2. Schritt
        {                                                                      // Bandmodus setzen
           meldung_1("Bandmodus setzen");
           callstatemachine (SET_BANDMODUS);

           if (bandmodus_aktiv == TRUE)
           {
             setstate (SENSOREN_LESEN_HA_1_LINKER_TEST);
           }
          else
           {
             setstate (ENDE_AUSWERTUNG);
           }
        }


        SENSOREN_LESEN_HA_1_LINKER_TEST                                        // 3. Schritt
        {                                                                      // Status lesen Sensoren Hinterachse
           meldung_1("Fastfilter- Werte hinten lesen");
           callstatemachine (STATUS_FASTFILTER_1_LINKS);
// infobox("Status Fastfilter lesen","Linke Seite");

           if (io_status_lesen_1 == TRUE)
            {
// infobox("io_status_lesen_1","TRUE");

              setstate (HINTEN_LINKS_AUF);
            }
           else
            {
//infobox("io_status_lesen_1","FALSE");

              setstate (ENDE_AUSWERTUNG);
            }
        }


        HINTEN_LINKS_AUF                                                       // 4. Schritt
        {                                                                      // hinten links aufregeln
           meldung_1("Balgventil hinten links aktivieren");
           callstatemachine (HINTEN_LINKS_AKTIVIEREN);

           if (links_hinten_auf == TRUE)
            {
               setstate (SENSOREN_LESEN_HA_2_LINKER_TEST);
            }
           else
            {
               setstate (ENDE_AUSWERTUNG);
            }
        }


        SENSOREN_LESEN_HA_2_LINKER_TEST                                        // 5. Schritt
        {                                                                      // aktuelle Sensorwerte lesen
           meldung_1("Sensor- Werte hinten vergleichen");              // und vergleichen
           callstatemachine (SENSOREN_LESEN_VERGLEICHEN_LINKER_TEST);

           if (vergleich_hinten_links == TRUE)
            {
              setstate (SENSOREN_LESEN_HA_1_RECHTER_TEST);
            }
           else
            {
              setstate (ENDE_AUSWERTUNG);
            }
        }


        SENSOREN_LESEN_HA_1_RECHTER_TEST                                       // 6. Schritt
        {                                                                      // Status lesen Sensoren Hinterachse
           meldung_1("Fastfilter- Werte hinten lesen");
           callstatemachine (STATUS_FASTFILTER_1_RECHTS);

           if (io_status_lesen_1 == TRUE)
            {
//              meldung_1("                                     ");
              setstate (HINTEN_RECHTS_AUF);
            }
           else
            {
              setstate (ENDE_AUSWERTUNG);
            }
        }


        HINTEN_RECHTS_AUF                                                      // 7. Schritt
        {                                                                      // hinten rechts aufregeln
           meldung_1("Balgventil hinten rechts aktivieren");
           callstatemachine (HINTEN_RECHTS_AKTIVIEREN);

           if (rechts_hinten_auf == TRUE)
            {
               setstate (SENSOREN_LESEN_HA_2_RECHTER_TEST);
            }
           else
            {
               setstate (ENDE_AUSWERTUNG);
            }
        }


        SENSOREN_LESEN_HA_2_RECHTER_TEST                                       // 8. Schritt
        {                                                                      // aktuelle Sensorwerte lesen
           meldung_1("Sensor- Werte hinten vergleichen");              // und vergleichen
           callstatemachine (SENSOREN_LESEN_VERGLEICHEN_RECHTER_TEST);

           if (vergleich_hinten_rechts == TRUE)
            {
              setstate (BANDMODUS_RUECKSETZEN);
            }
           else
            {
              setstate (ENDE_AUSWERTUNG);
            }
        }


        BANDMODUS_RUECKSETZEN                                                  // 9. Schritt
        {                                                                      // Bandmodus wieder zurücksetzen
           meldung_1("Bandmodus wieder rücksetzen");
           callstatemachine (RESET_BANDMODUS);

           if (bandmodus_ruecksetzen == TRUE)
            {
              setstate (ENDE_AUSWERTUNG);
            }
           else
            {
              setstate (ENDE_AUSWERTUNG);
            }
        }


        ENDE_AUSWERTUNG                                                        // 10. Schritt
        {                                                                      // Auswertung und "endebehandlung"
           meldung_1("Test auswerten");
           callstatemachine (AUSWERTUNG);

           setstate (ENDE_PRUEFUNG);
        }

        ENDE_PRUEFUNG

        {
           endebehandlung();      // Dokumentation und Fehlerausdruck
        }


}      // Ende Statemachine "TAUSCH", 1. Ebene, Ablauf gesamt



// *****************************************************************
// **********    Statemachines  S_VERTAU 2. Ebene     **************
// **********    Aufruf Job's und Auswertungen        **************
// *****************************************************************



STATEMACHINE FAHRGESTELLNUMMER_LESEN()           // 1. Schritt
{

    INIT
    {

       INPAapiJob(sgbd,"IDENT","","");
       INPAapiResultText(job_state,"JOB_STATUS",1,"");

       if (job_state == "OKAY")
        {
           c_fg_lesen = TRUE;
           delay(500);
           returnstatemachine();
        }
       else   // *****  Jobstatus nicht OKAY ***********
        {
           c_fg_lesen = FALSE;
           returnstatemachine();
        }
    }
}


STATEMACHINE SET_BANDMODUS()           // 2. Schritt
{

    int betriebsmodus = 2;
    string betriebsmodus_txt = "";

    INIT
    {

       job_state="";
       inttostring(betriebsmodus,betriebsmodus_txt);
       INPAapiJob(sgbd,"ENERGIESPARMODE","1","");
       INPAapiResultText(job_state,"JOB_STATUS",1,"");

       if (job_state == "OKAY")
        {
           bandmodus_aktiv = TRUE;
           delay(2000);             // 2 sec warten, wegen Reset SG
           returnstatemachine();
        }
       else   // ***** Jobstatus nicht OKAY  ***********
        {
           bandmodus_aktiv = FALSE;
           returnstatemachine();
        }
    }
}


STATEMACHINE STATUS_FASTFILTER_1_LINKS()               // Status lesen Sensoren hinten links und rechts
{                                                      // für linken Test

// int fafi_hinten_links_1  = 0;
// int fafi_hinten_rechts_1 = 0;
// bool io_status_lesen_1  = FALSE;

    INIT
    {
       INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
       INPAapiResultInt(fafi_hinten_links_1,"STAT_FASTFILTER_RL_WERT", 1);
       INPAapiResultInt(fafi_hinten_rechts_1,"STAT_FASTFILTER_RR_WERT", 1);
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");

       if (job_state == "OKAY")
        {
           io_status_lesen_1 = TRUE;
           delay(500);
           returnstatemachine();
        }
       else   // *****  Jobstatus nicht OKAY ***********
        {
           io_status_lesen_1 = FALSE;
           returnstatemachine();
        }
    }
}


STATEMACHINE HINTEN_LINKS_AKTIVIEREN()
{
int ansteuerung_aktiv   =  0;
int schleifenzaehler    =  0;
int restzeit            =  0;
int ansteuerzeit        =  8;       // ca 8 sec für Kompressor und Ventile
int steuerzeit_ist      =  0;
int anzeige_fafi_links  =  0;
int anzeige_fafi_rechts =  0;


string rest = "";
string funktion = "";            // Textvariable für aktivierte Funktion
string steuern_ventil_li = "";   // Variable für Balgventil hinten links
string steuern_ventil_re = "";   // Variable für Balgventil hinten rechts
string steuern_ventil_ab = "";   // Variable für Ablassventil
string steuern_comp      = "";   // Variable für Kompressoransteuerung
string fafi_hi_li_txt    = "";   // Variable für Anzeige
string fafi_hi_re_txt    = "";   // Variable für Anzeige


//    Kommentar
//    steuern_vent_li = "1;"+ansteuerzeit;0xC2"  // Variable für Balgventil hinten links und Kompressor
//    steuern_vent_re = "1;"+ansteuerzeit;0xC1"  // Variable für Balgventil hinten rechts und Kompressor
//    steuern_comp    = "1;"+ansteuerzeit;20"    // Variable für Kompressoransteuerung
//    steuern_vent_ab = "1;"+ansteuerzeit;19"    // Variable für Ablassventil

/*
WERT    TEXT
0x11    Balgventil hinten links
0x12    Balgventil hinten rechts
0x13    Ablassventil
0x14    Kompressoransteuerung
0x15    Sensorspannungsversorgung hinten links
0x16    Sensorsspannungsversorgung hinten rechts
0x17    Selbsthaltung vom uController
0xC1    Heben/SenkenSequenz hinten rechts
0xC2    Heben/SenkenSequenz hinten links
0xC3    Heben/SenkenSequenz hinten
0x41    Betriebsmodus
0xFF    nicht definiert
*/

bool hl_auf = FALSE;
// bool hr_auf = FALSE;
// bool ha_ab  = FALSE;
// bool hl_ab  = FALSE;
// bool hr_ab  = FALSE;


  INIT
  {
    restzeit = ansteuerzeit;
    hl_auf = TRUE;
    funktion = "hinten links auf";     // Textvariable für aktivierte Funktion

    setstate(AUSLOESEN);
  }

    AUSLOESEN
    {

// ******************************************************************
// ***                   hinten links auf                         ***
// ******************************************************************

//    Argumente für Ventil hinten links und Kompressor als string variable übergeben
      inttostring(ansteuerzeit,steuern_ventil_li);
      steuern_ventil_li = "1;"+steuern_ventil_li+";0xC2";     // // 0xC2 = 194, Variable für Balgventil hinten links und Kompressor
      INPAapiJob(sgbd,"STEUERN","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_li,"");
      INPAapiResultText(job_state,"JOB_STATUS",1,"");

      setstate (VENTIL_ABFRAGEN);
    }


    VENTIL_ABFRAGEN
    {

//       while(Ventil und Kompressor aktiv)
//       INPAapiJob(sgbd,"steuern_io","ARG;STATUS_SIGNALE_NUMERISCH;STA;0xC2","");   // Kompressor und Ventil links
//       INPAapiResultInt(ansteuerung_aktiv, "STAT_ANSTEUERUNG_AKTIV", 1);

//       while(ansteuerung_aktiv = 1)
       while(schleifenzaehler < ansteuerzeit)
       {
          text_var="";
          job_state="";
          INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
          INPAapiResultInt(anzeige_fafi_links, "STAT_FASTFILTER_RL_WERT", 1);
          INPAapiResultInt(anzeige_fafi_rechts, "STAT_FASTFILTER_RR_WERT", 1);
          INPAapiResultText(job_state,"JOB_STATUS",1,"");
          inttostring(anzeige_fafi_links,fafi_hi_li_txt);
          inttostring(anzeige_fafi_rechts,fafi_hi_re_txt);

          userboxopen(0,10,7,11,70,"Ansteuerung",text_var);
          text_var="Die Aktivierung wird für die gewählte Zeit ausgelöst!";
          userboxftextout(0,text_var,1,1,0,1);
          text_var=" .... Bitte warten";
          userboxftextout(0,text_var,3,1,0,1);
          userboxftextout(0,"Angesteuerter Ausgang: ",5,1,1,0);
          userboxftextout(0,funktion,5,42,1,1);

          ftextout("Fastfilter links:", 26,5,1,1);
          ftextout("Fastfilter rechts:", 26,45,1,1);

          fafi_hi_li_txt = fafi_hi_li_txt+"    ";
          ftextout(fafi_hi_li_txt, 26,30,1,1);

          fafi_hi_re_txt = fafi_hi_re_txt+"    ";
          ftextout(fafi_hi_re_txt, 26,71,1,1);

          schleifenzaehler = schleifenzaehler+1;
          inttostring(restzeit,rest);
          userboxftextout(0,"restliche Ansteuerzeit [sec]:",8,1,1,0);
          rest=rest+"  ";
          userboxftextout(0,rest,8,44,1,1);
          restzeit=restzeit-1;
          delay(900);  // war 1000, 900 wg. Zeitverzug aus Aufrufen
          userboxclear(0);

       }
//       setcolor(1,0);
       userboxclose(0);
//       setscreen(s_steuern,TRUE);
//       setmenu(m_steuern);
       setstate(WARTE);
    }
       WARTE
     {
        links_hinten_auf  = TRUE;

        ftextout("EHC Vertauscherprüfung 1-Achsluftfederung", 2,5,1,1);

        returnstatemachine();
     }
}


STATEMACHINE SENSOREN_LESEN_VERGLEICHEN_LINKER_TEST()      // Sensorwerte nach Ansteuerung lesen
{                                                          // und vergleichen für linken Test

int fafi_hinten_links_2  = 0;
int fafi_hinten_rechts_2 = 0;

    INIT
    {

// infobox ("hinten", "vergleichen");

       job_state="";
       INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
       INPAapiResultInt(fafi_hinten_links_2, "STAT_FASTFILTER_RL_WERT", 1);
       INPAapiResultInt(fafi_hinten_rechts_2, "STAT_FASTFILTER_RR_WERT", 1);
       INPAapiResultText(job_state,"JOB_STATUS",1,"");

       if (job_state == "OKAY")
        {
//         Formel: Die Differenz der linken Werte minus der Differenz der rechten Werte, muß > 0 sein!

           if((fafi_hinten_links_2 - fafi_hinten_links_1) - (fafi_hinten_rechts_2 - fafi_hinten_rechts_1) > 0)
            {
               vergleich_hinten_links = TRUE;
               returnstatemachine();
            }
           else
            {
               vergleich_hinten_links = FALSE;
               meldung_1("                                    ");
               delay(1000);
               returnstatemachine();
            }
        }
       else  // *********** Jobstatus nicht OKAY   *************
        {
           vergleich_hinten_links = FALSE;
           meldung_1("                                    ");
           returnstatemachine();
        }
    }
}


STATEMACHINE STATUS_FASTFILTER_1_RECHTS()                  // Status lesen Sensoren hinten links und rechts
{                                                          // für rechten Test

// bool  io_status_lesen_1  = FALSE;

    INIT
    {
       INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
       INPAapiResultInt(fafi_hinten_links_1,"STAT_FASTFILTER_RL_WERT", 1);
       INPAapiResultInt(fafi_hinten_rechts_1,"STAT_FASTFILTER_RR_WERT", 1);
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");

       if (job_state == "OKAY")
        {
           io_status_lesen_1 = TRUE;
           delay(500);
           returnstatemachine();
        }
       else   // *****  Jobstatus nicht OKAY ***********
        {
           io_status_lesen_1 = FALSE;
           returnstatemachine();
        }
    }
}


STATEMACHINE HINTEN_RECHTS_AKTIVIEREN()
{

int schleifenzaehler    =  0;
int restzeit            =  0;
int ansteuerzeit        =  8;      //  entspricht etwa 8 sec.Ansteuerzeit für Kompressor und Ventile
int steuerzeit_ist      =  0;
int anzeige_fafi_links  =  0;
int anzeige_fafi_rechts =  0;



string rest = "";
string funktion = "";           // Textvariable für aktivierte Funktion
string steuern_ventil_li = "";  // Variable für Balgventil hinten links
string steuern_ventil_re = "";  // Variable für Balgventil hinten rechts
string steuern_ventil_ab = "";  // Variable für Ablassventil
string steuern_comp      = "";  // Variable für Kompressoransteuerung
string fafi_hi_li_txt    = "";  // Variable für Anzeige
string fafi_hi_re_txt    = "";  // Variable für Anzeige

//    Kommentar
//    steuern_vent_li = "1";Zeit;0xC2"    // Variable für Balgventil hinten links und Kompressor
//    steuern_vent_re = "1";Zeit;0xC1"    // Variable für Balgventil hinten rechts und Kompressor
//    steuern_comp    = "1";Zeit;20"      // Variable für Kompressoransteuerung
//    steuern_vent_ab = "1";Zeit;19"      // Variable für Ablassventil

/*
WERT    TEXT
0x11    Balgventil hinten links
0x12    Balgventil hinten rechts
0x13    Ablassventil
0x14    Kompressoransteuerung
0x15    Sensorspannungsversorgung hinten links
0x16    Sensorsspannungsversorgung hinten rechts
0x17    Selbsthaltung vom uController
0xC1    Heben/SenkenSequenz hinten rechts
0xC2    Heben/SenkenSequenz hinten links
0xC3    Heben/SenkenSequenz hinten
0x41    Betriebsmodus
0xFF    nicht definiert
*/


// bool ha_auf = FALSE;
// bool hl_auf = FALSE;
bool hr_auf = FALSE;
// bool ha_ab  = FALSE;
// bool hl_ab  = FALSE;
// bool hr_ab  = FALSE;


  INIT
  {
    restzeit = ansteuerzeit;
    steuerzeit_ist = ansteuerzeit;      // ca. 10 sec sec Ansteuerzeit für Kompressor und Ventile parametriert
    hr_auf = TRUE;
    funktion = "hinten rechts auf";     // Textvariable für aktivierte Funktion

    setstate(AUSLOESEN);
  }

    AUSLOESEN
    {

// ******************************************************************
// ***                   hinten rechts auf                         ***
// ******************************************************************

//    Argumente für Ventil hinten rechts an string variable übergeben
      inttostring(ansteuerzeit,steuern_ventil_re);
      steuern_ventil_re = "1;"+steuern_ventil_re+";0xC1";     // Variable für Balgventil hinten rechts
      INPAapiJob(sgbd,"STEUERN","ARG;STEUERN_DIGITALSIGNALE;"+steuern_ventil_re,"");
      INPAapiResultText(job_state,"JOB_STATUS",1,"");

      setstate (VENTIL_ABFRAGEN);
    }


    VENTIL_ABFRAGEN
    {
//     while(Ventil und Kompressor aktiv)

       while(schleifenzaehler < ansteuerzeit)
       {
          text_var="";
          job_state="";
          INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
          INPAapiResultInt(anzeige_fafi_links, "STAT_FASTFILTER_RL_WERT", 1);
          INPAapiResultInt(anzeige_fafi_rechts, "STAT_FASTFILTER_RR_WERT", 1);
          INPAapiResultText(job_state,"JOB_STATUS",1,"");
          inttostring(anzeige_fafi_links,fafi_hi_li_txt);
          inttostring(anzeige_fafi_rechts,fafi_hi_re_txt);

          userboxopen(0,10,7,11,70,"Ansteuerung",text_var);
          text_var="Die Aktivierung wird für die gewählte Zeit ausgelöst!";
          userboxftextout(0,text_var,1,1,0,1);
          text_var=" .... Bitte warten";
          userboxftextout(0,text_var,3,1,0,1);
          userboxftextout(0,"Angesteuerter Ausgang: ",5,1,1,0);
          userboxftextout(0,funktion,5,42,1,1);

          ftextout("Fastfilter links:", 26,5,1,1);
          ftextout("Fastfilter rechts:", 26,45,1,1);

          fafi_hi_li_txt = fafi_hi_li_txt+"    ";
          ftextout(fafi_hi_li_txt, 26,30,1,1);

          fafi_hi_re_txt = fafi_hi_re_txt+"    ";
          ftextout(fafi_hi_re_txt, 26,71,1,1);

          schleifenzaehler = schleifenzaehler+1;
          inttostring(restzeit,rest);
          userboxftextout(0,"restliche Ansteuerzeit [sec]:",8,1,1,0);
          rest=rest+"  ";
          userboxftextout(0,rest,8,44,1,1);
          restzeit=restzeit-1;
          delay(900);  // war 1000, 900 wg. Zeitverzug aus Aufrufen
          userboxclear(0);
       }
//       setcolor(1,0);
       userboxclose(0);
//       setscreen(s_steuern,TRUE);
//       setmenu(m_steuern);
       setstate(WARTE);
    }
       WARTE
     {
        rechts_hinten_auf  = TRUE;

        ftextout("EHC Vertauscherprüfung 1-Achsluftfederung", 2,5,1,1);

        returnstatemachine();
     }
}


STATEMACHINE SENSOREN_LESEN_VERGLEICHEN_RECHTER_TEST()                   // Sensorwerte nach Ansteuerung lesen
{                                                                        // und vergleichen rechter Test

int fafi_hinten_links_2  = 0;
int fafi_hinten_rechts_2 = 0;

    INIT
    {

// infobox ("hinten", "vergleichen");

       job_state="";
       INPAapiJob(sgbd,"STATUS_LESEN","ARG;STATUS_FILTERWERTE","");
       INPAapiResultInt(fafi_hinten_links_2, "STAT_FASTFILTER_RL_WERT", 1);
       INPAapiResultInt(fafi_hinten_rechts_2, "STAT_FASTFILTER_RR_WERT", 1);
       INPAapiResultText(job_state,"JOB_STATUS",1,"");

       if (job_state == "OKAY")
        {
//         Formel: Die Differenz der rechten Werte minus der Differenz der linken Werte, muß > 0 sein!

           if((fafi_hinten_rechts_2 - fafi_hinten_rechts_1) - (fafi_hinten_links_2 - fafi_hinten_links_1) > 0)
            {
               vergleich_hinten_rechts = TRUE;
               returnstatemachine();
            }
           else
            {
               vergleich_hinten_rechts = FALSE;
               meldung_1("                                    ");
               delay(500);
               returnstatemachine();
            }
        }
       else  // *********** Jobstatus nicht OKAY   *************
        {
           vergleich_hinten_rechts = FALSE;
           meldung_1("                                    ");
           returnstatemachine();
        }
    }
}


STATEMACHINE RESET_BANDMODUS()                                  // 6. Schritt
{

    int betriebsmodus = 0;
    string betriebsmodus_txt = "";

    INIT
    {
       job_state="";

       INPAapiJob(sgbd,"ENERGIESPARMODE","0","");   
       delay(2000);  // ok
       INPAapiResultText(job_state,"JOB_STATUS",1,"");
 
       if (job_state == "OKAY")
        {
           bandmodus_ruecksetzen = TRUE;
           delay(2000);
           returnstatemachine();
        }
       else   // *****  Jobstatus nicht OKAY ***********
        {
           bandmodus_ruecksetzen = FALSE;
           returnstatemachine();
        }
    }
}


STATEMACHINE AUSWERTUNG()
{

    INIT
    {
      if (( c_fg_lesen == TRUE ) && ( bandmodus_aktiv == TRUE ) && ( io_status_lesen_1 == TRUE ) &&
         ( links_hinten_auf == TRUE ) && ( rechts_hinten_auf == TRUE ) && ( vergleich_hinten_links == TRUE ) &&
         ( vergleich_hinten_rechts == TRUE ) && ( bandmodus_ruecksetzen == TRUE ))
       {
           CHANGE_TEST = TRUE;
           setcolor(1,10);      // Bildschirm grün
           message_box_open("Ende Vertauscherprüfung","","Prüfung i.O.");
           delay(3000);
           returnstatemachine();
       }
      else  // *********** Pruefung nicht OKAY   *************
       {
            // Fehlerauswertung mit Fehlertextzuweisung

           CHANGE_TEST = FALSE;
           setcolor(1,4);       // Bildschirm rot

           if ( c_fg_lesen == FALSE )
            {
              fehlertext_1 = "Ident";
              fehlertext_2 =  job_state;
            }
           else
            {
              if (bandmodus_aktiv == FALSE)
               {
                 fehlertext_1 = "Bandmodus setzen";
                 fehlertext_2 =  job_state;
               }
              else
               {
                 if ( io_status_lesen_1 == FALSE )
                  {
                    fehlertext_1 = "Lesen Filterwerte";
                    fehlertext_2 =  job_state;
                  }
                 else
                  {
                    if ( links_hinten_auf == FALSE )
                     {
                        fehlertext_1 = "Balgventil hinten links aktivieren";
                        fehlertext_2 = job_state;
                     }
                    else
                     {
                        if ( vergleich_hinten_links == FALSE )
                         {
                           fehlertext_1 = "Vergleich Fastfilter Werte";
                           fehlertext_2 = "Test linke Seite n.i.O.";
                         }
                        else
                         {
                           if ( rechts_hinten_auf == FALSE )
                            {
                              fehlertext_1 = "Balgventil hinten links aktivieren";
                              fehlertext_2 = job_state;
                            }
                           else
                            {
                              if ( vergleich_hinten_rechts == FALSE )
                               {
                                 fehlertext_1 = "Vergleich Fastfilter Werte";
                                 fehlertext_2 = "Test rechte Seite n.i.O.";
                               }
                              else
                               {
                                 if ( bandmodus_ruecksetzen == FALSE )
                                  {
                                    fehlertext_1 = "Bandmodus rücksetzen";
                                    fehlertext_2 = job_state;
                                  }
                               }
                            }
                         }
                     }
                  }
               }
            }

          message_box_niO("Ende Vertauscherprüfung",fehlertext_1,"",fehlertext_2);
          delay(3000);
          returnstatemachine();
       }
    }
}

// -- EOF --
