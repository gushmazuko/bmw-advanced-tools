//**********************************************************************
//*
//* INPA Nacharbeitsprogramm für ARS
//*
//* Sourcedatei ARS_70.SRC
//*
//**********************************************************************
//* History : 
//* 
//* 13.10.2004 scho/sh V0.30   Kopie von ARS_60 und Anpassung an ARS_70
//*                             include inb_ars in inb_70 umbenannt
//* 07.12.2004 scho    V0.301  Neuer Menuepunkt bei Steuern: Rampenlogik
//*                            Beschriftung bei beweglichen roten Balken verbessert
//* 27.01.2004 scho    V0.400  Ansteuerung der Rampenlogik vereinfacht
//*                            Einige Eingabefelder ins Menue verschoben
//* 04.07.2005 ss      V0.410  Anzeigetexte korrigiert
//*                            Merge der src Files BMW und Conti
//* 07.07.2005 ss      V0.411  Inbetriebnahme Script angepasst s. INB_70.SRC
//*
//* 14.07.2005 sh      V0.412  Drehzahlerhöhung beim auf 250 begrenzt wegen SG SW
//* 12.09.2005 ss      V1.000  Erweiterung und Anpassung auf SGBD V1.000
//* 16.12.2005 ss      V1.001  Motorvariante "N62_TUE2" hinzu
//* 16.01.2006 sh      V1.002  Motorvariante "D62M57A0" hinzu
//* 17.01.2006 scho    V1.100  Funktionalitaet Hoehenstandssensoren eingefuegt
//* 10.04.2006 sj      V1.101  Anpassung neue Versionsnummer SGBD
//* 24.04.2006 an      V1.102  Ausgabe PAF und DAF angepaßt
//* 25.04.2006 an      V1.102  Höhenstandsdarstellung geändert
//* 26.04.2006 an      V1.103  Parametereingabe bei Höhenst. und Sensoren eingefügt
//* 26.04.2006 an      V1.103  Ausgabeformat Steigungen angepasst
//* 27.04.2006 sh      V5.000  letzter Stand Inpa und include zusammengefasst, Versionsnummer an SGBD angepasst
//* 30.08.2006 sh      V5.100  Neue Motorvariante hinzu, N73H_R0, 12 Zyl. Wasserstoff
//* 29.09.2006 sh      V5.200  Neue Motorvariante hinzu, MSD85 (N63 8 Zylinder)
//* 29.11.2006 an      V5.300  Korrektur CAN Sign. Höhenstände, bei CC-Meldungsauslösung FS sperren, danach freigeben 
//* 08.05.2007 sh      V5.400  Aenderung 5.300 war nicht referenziert 
//* 11.05.2007 sh      V5.410  Ansteuerung Wasserstoffmotor N73 im include inb_70 korrigiert 
//* 19.10.2007 sh      V5.500  Drehzahl bei N54 auf 800 U/min reduziert (inb_70), wegen Problemen bei der Inbetriebnahme, Kennlinienfehler
//* 23.01.2008 sh      V5.600  Drehzahl wieder auf 905 U/min erhöht. Identisch mit Cascade.
//*************************************************************************

#include "inpa.h"
#include "bmw_std.h"


// Titel, Version, Verantwortung, Steuergeraet
string titel  ="Aktive Rollstabilisierung";  // Titel Nacharbeitsprogramm
string version="5.600";                        // Version Nacharbeitsprogramm
string origin ="BMW TI-432 Helmich";           // Verantwortung Nacharbeitsprogramm
string sgbd   ="ARS_70/V5.X";                  // Steuergeraet
string gruppe ="D_ARS";                        // Gruppendatei

string speicher_lesen_parameter="LAR;FLASH;UIFM;-ROMI;-ROMX;-RAMIS;-RAMIL;-RAMXX;-NVRAM";
// Moegliche Speicher-Parameter: "LAR;FLASH;UIFM;ROMI;ROMX;RAMIS;RAMIL;RAMXX;NVRAM";
// Bei Leerstring erfolgt kein Menuepunkt Speicher Lesen

// allgemeine globale Variable
string text_var;
real   zahlen_var;
int    ganz_zahl;
bool   logik_var;
string job_state;    // JOB_STATUS Variable
int    input_state;  // Eingabestatus
int input_state_VA;  // Eingabestatus des PropVA Ventils 's_mehr_ventile_steuern'
int input_state_HA;
int    input_ok=0;   // Eingabe  mit OK beendet

int toggle_1;
int toggle_2;
int toggle_3;
int toggle_4;
int toggle_5;

int para_lernen_4;
int para_lernen_5;
int para_lernen_6;


// PT CAN Signale
int allgemein = 0;
int geschw = 0;
int drehzahl = 0;
int beschl = 0;
int temperatur = 0;
int diverses = 0;
int hoehenstand = 0;

int aif_nr = 0;

// Ventile bestromen ANSTEUERN
real strom_sv_ventil;
real strom_rv_ventil;
real strom_va_ventil;
real strom_ha_ventil;

// Steuergeraete Reset wrid nur einmal ausgefuehrt
bool sg_reset_einmal = TRUE;
bool sv_ein_aus = FALSE;
bool rv_ein_aus = FALSE;
bool ramp_mode_ein_aus = FALSE;
bool PropVA_ein_aus = FALSE;
bool PropHA_ein_aus = FALSE;

int strom_sv_1 = 0;
int strom_sv_2 = 0;
int strom_sv_3 = 0;
int strom_sv_4 = 0;

int strom_rv_1 = 0;
int strom_rv_2 = 0;
int strom_rv_3 = 0;
int strom_rv_4 = 0;

int strom_va_1 = 0;
int strom_va_2 = 0;
int strom_va_3 = 0;

int strom_ha_1 = 0;
int strom_ha_2 = 0;
int strom_ha_3 = 0;

int strom_sv_mA = 0;
int strom_rv_mA = 0;

int strom_va_mA = 0;
int strom_ha_mA = 0;

int va_ramp_art = 0;
int ha_ramp_art = 0;
int rampenvorgabe = 0;

int va_ramp_zeit = 0;
int ha_ramp_zeit = 0;
int va_ramp_wert = 0;
int ha_ramp_wert = 0;

string strom_var_va = "";
string strom_var_ha = "";

bool warnung_erfolgt = FALSE;

// Ansteuervariablen zum Hoehenstandsabgleich
int hs_abgleichen_1 = 0;
int hs_abgleichen_2 = 0;
int hs_abgleichen_3 = 0;
int hs_abgleichen_4 = 0;
int hs_abgleichen_5 = 0;
int hs_abgleichen_6 = 0;
int hs_abgleichen_7 = 0;
int hs_abgleichen_8 = 0;

// start of :#include "bmw_std.src"
//**********************************************************************
//*
//* INPA Library-Funktionen BMW_STD.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.05.2000 rd V0.01 Ersterstellung
//* 23.06.2000 rd V0.02 Überarbeitung für E65 und E85
//* 04.07.2000 rd V0.03 Überarbeitung der Funktionen
//* 08.11.2000 rd V0.04 AIF Lesen Results überarbeitet
//* 01.03.2001 rd V0.05 m_status_flag neu hinzu
//* 02.03.2001 rd V0.06 m_steuern_flag neu hinzu
//* 18.05.2001 rd V0.07 AIF-Ausgabe verbessert
//* 25.04.2002 rd V0.08 Erweiterung HS_LESEN
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Erweiterung Ident für DS2
//* 19.11.2002 rd V1.02 FS_MODE erweitert um PCODEs
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//*            rd V2.00 Entfernung EldiAuftragLesen, EldiAuftragEingeben
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Hinweis im Hauptfenster, wenn Simulationsmodus aktiv ist.
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//**********************************************************************
string package="3.01";

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************

// Umrechnungsfaktoren deutsch / englisch
real   m_c    = 1.0;        // Grad Celsius -> Fahrenheit z = x * m_c + a_c
real   a_c    = 0.0;
real   m_km   = 1.0;     // km           -> miles      z = x * m_km
real   m_l    = 1.0;     // Liter        -> Gallon US  z = x * m_l

// für Info
string sgbd_ecu;
string sgbd_origin;
string sgbd_revision;
string sgbd_package;
string sgbd_sprache;
string sgbd_comment;
string gruppe_ecu;
string gruppe_origin;
string gruppe_revision;
string gruppe_comment;

// für Status-Menü
bool   m_status_flag=TRUE;
// True Status-Menü wird angezeigt

// für Steuern-Menü
bool   m_steuern_flag=TRUE;
// True Steuern-Menü wird angezeigt

// für FS_LESEN speichern
bool   fs_lesen_save_as_flag;

// für IS_LESEN speichern
bool   is_lesen_save_as_flag;

// für HS_LESEN speichern
bool   hs_lesen_save_as_flag;

// für FS_LESEN
bool   fs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LESEN
bool   is_lesen_flag;
// True wenn JOB vorhanden

// für HS_LESEN
bool   hs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LOESCHEN
bool   is_loeschen_flag;
// True wenn JOB vorhanden

// für HS_LOESCHEN
bool   hs_loeschen_flag;
// True wenn JOB vorhanden

// Handle für FS_LESEN
int    f_ort_nr_buffer   = 0;
int    f_ort_text_buffer = 0;

//  In INPA.INI wird festgelegt ob
//   nach FS- IS-, HS-Löschen automatisch wieder gelesen wird.
bool   deleteread_flag;

// Wenn Ediabas im Simulationsmode läuft, dies im Hauptfenster anzeigen
bool   simulation_flag;

// für Ident Screen, bzw. SVK Screen bei UDS (ISO 14229)
int ident_typ;
// 1= DS2
// 2= BMW Fast
// 3= UDS (ISO 14229)


// für SPEICHER_LESEN
bool   speicher_lesen_flag;
// True wenn JOB vorhanden
bool   speicher_lesen_lar_flag;
bool   speicher_lesen_uifm_flag;
bool   speicher_lesen_romi_flag;
bool   speicher_lesen_romx_flag;
bool   speicher_lesen_nvram_flag;
bool   speicher_lesen_ramis_flag;
bool   speicher_lesen_ramxx_flag;
bool   speicher_lesen_flash_flag;
bool   speicher_lesen_ramil_flag;

// für Speicher lesen Ausgabe
string speicher_lesen_text         = "";
string speicher_lesen_seg_adr_anz  = "";
string speicher_lesen_adresse      = "0x000000";
int    speicher_lesen_anzahl       = 64;

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern ScriptInit(); // befindet sich im Hauptprogramm

// start of :#include "BATTERIE.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BATTERIE.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 01.04.2004 rd V2.01 Im Fehlerfalle delay eingebaut
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* ShowBatteryIgnition
//*
//* Anzeige des Batterie- und Zündungs-Status
//*
//**********************************************************************
ShowBatteryIgnition()
{
  bool   fehlerflag;    // Fehler aufgetreten
  bool   fehlerflag2;   // Fehler aufgetreten
  bool   zuendung;      // Zündung ein/aus
  bool   batterie;      // Batterie ein/aus
  int    wert;          // allgemeine Variable

  ftextout("Batterie :", 0,5,1,0);
  ftextout("Zündung  :", 0,45,1,0);

  INPAapiJob("UTILITY","STATUS_UBATT","","");
  INP1apiResultInt(fehlerflag,wert,"STAT_UBATT",1);
  if ((fehlerflag!=TRUE) || (wert==0))
  {
    batterie=FALSE;
    zuendung=FALSE;
  }
  else
  {
    batterie=TRUE;
    INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
    INP1apiResultInt(fehlerflag2,wert,"STAT_ZUENDUNG",1);
    if ((fehlerflag2!=TRUE) || (wert==0))
      zuendung=FALSE;
    else
      zuendung=TRUE;
  }
  digitalout(batterie, 0,20,"","");
  if (batterie==TRUE)
    ftextout("ein  ", 0,25,1,0);
  else
  {
    if (fehlerflag==TRUE)
    {
      ftextout("aus  ", 0,25,1,0);
    }
    else
    {
      ftextout("---  ", 0,25,1,0);
    }
  }

  digitalout(zuendung, 0,62,"","");
  if (zuendung==TRUE)
    ftextout("ein  ", 0,67,1,0);
  else
  {
    if (fehlerflag2==TRUE)
    {
      ftextout("aus  ", 0,67,1,0);
    }
    else
    {
      ftextout("---  ", 0,67,1,0);
    }
  }

  if ((fehlerflag!=TRUE) || (fehlerflag2!=TRUE))
  {
    delay(2000);
  }
}
// -- EOF --
// end of :#include "BATTERIE.SRC"
// start of :#include "GRP_INFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GRP_INFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 EDIABAS.INI-Abfrage ob Simulationsmode aktiv ist
//* 18.10.2006 GA V3.01 Abfrage ob EDIABAS im Simulationsmodus läuft ist jetzt nicht mehr auf Pfad c:\windows\ediabas.ini beschränkt
//**********************************************************************

//**********************************************************************
//*
//* GruppenDateiInfo
//*
//* Versionsinformationen über Gruppendatei
//*
//**********************************************************************
import32 "C" lib "api32.DLL::__apiGetConfig" ApiGetConfig(in:long Handle,in: string Name,out: string Buffer, returns: int ReturnedValue);
GruppenDateiInfo( in: string grp,
                  inout: string grp_ecu, inout: string grp_origin,
                  inout: string grp_revision, inout: string grp_comment)
{
  string CurDir;
  string Temp;
  string Puffer;
  int    Size;
  long   PufferSize;
  int    ret_int;
  string BS;
  string CR;
  int    pos1;
  int    pos2;
  int    simulation;
  int    input;
  long   Handle;
  int    Returned;
  string ini_path= "??????????????????????";//Variable muß ausreichend lang vorbelegt sein!
  //                C:\ec-apps\ediabas\bin

  chr( 92, BS ); // '\'
  chr( 13, CR );

  // Pfad für EDIBAS.INI ermitteln
  // WERT 2 wurde durch Tests ermittelt
  Handle=2;
  ApiGetConfig(Handle,"EDIABASINIPATH",ini_path,Returned);
  //Abfrage, ob EDIABAS im Simulationsmodus betrieben wird. Hinweisfenster erfolgt im Hauptfenster s_main
  GetPrivateProfileInt("Configuration","Simulation",2,ini_path+BS+"ediabas.ini",simulation);
  if (simulation == 1) simulation_flag= TRUE;
  else simulation_flag= FALSE;

  Size=256;
  space(CurDir,Size);
  GetCurrentDirectory(256, CurDir, ret_int);
  SetCurrentDirectory("\EDIABAS\BIN", ret_int);

  Size=1024;
  space(Puffer,Size);
  inttolong(Size, PufferSize);
  XTRACT("\ediabas\ecu"+ BS + grp + ".grp", 1, Puffer, PufferSize, ret_int);

  grp_ecu="";
  instr(pos1, 0, Puffer, "ECU:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 4;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_ecu, Puffer, pos1, pos2 - pos1);
  }

  grp_origin="";
  instr(pos1, 0, Puffer, "ORIGIN:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 7;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_origin, Puffer, pos1, pos2 - pos1);
  }

  grp_revision="";
  instr(pos1, 0, Puffer, "REVISION:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 9;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
    midstr(grp_revision, Puffer, pos1, pos2 - pos1);
  }

  grp_comment="";
  pos1=0;
  pos2=0;
  while ((pos1 >= 0) && (pos2 >= 0))
  {
    instr(pos1, pos2, Puffer, "ECUCOMMENT:");
    if (pos1 >= 0)
    {
      pos1 = pos1 + 11;
      instr(pos2, pos1, Puffer, CR );
      if (pos2 > pos1)
      {
        midstr(Temp, Puffer, pos1, pos2 - pos1);
        grp_comment=grp_comment+Temp+",";
      }
    }
  }
  SetCurrentDirectory(CurDir, ret_int);
}
// -- EOF --
// end of :#include "GRP_INFO.SRC"
// start of :#include "SGBDINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SGBDINFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern SgbdInfo(in: string sg,
                inout: string sg_ecu, inout: string sg_origin,
                inout: string sg_revision, inout: string sg_package,
                inout: string sg_comment, inout: string sg_sprache);

//**********************************************************************
//*
//* SgbdInfo
//*
//* Versionsinformationen über SGBD
//*
//**********************************************************************
SgbdInfo( in: string sg,
          inout: string sg_ecu, inout: string sg_origin,
          inout: string sg_revision, inout: string sg_package,
          inout: string sg_comment, inout: string sg_sprache)
{
  INPAapiJob(sg,"INFO","","");
  INPAapiResultText(sg_ecu,"ECU",1,"");
  INPAapiResultText(sg_revision,"REVISION",1,"");
  INPAapiResultText(sg_package,"PACKAGE",1,"");
  INPAapiResultText(sg_origin,"ORIGIN",1,"");
  INPAapiResultText(sg_comment,"COMMENT",1,"");
  INPAapiResultText(sg_sprache,"SPRACHE",1,"");
}

// -- EOF --
// end of :#include "SGBDINFO.SRC"
// start of :#include "SGBDINPA.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SgbdInpa.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Gezielte Ausgabe, wenn Gruppendatei oder SGBD nicht existiert
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 18.10.2006 GA V3.01 Check bezüglich auf Gruppen-Simulationsdatei, sowie "Identification error" erweitert
//* 24.10.2006 GA V3.02 Überprüfung ob T_GRTB.PRG vorhanden eingebaut
//**********************************************************************

//**********************************************************************
//*
//* SgbdInpaCheck
//*
//* Überprüfung ob SGBD zu INPA passt
//*
//**********************************************************************
SgbdInpaCheck()
{
  string sgbd_version;             // für Versionskontrolle
  string inpa_version;             // für Versionskontrolle
  string inpa_sprache="deutsch"; // für Sprachvariante
  string variante="???";           // für Variantenkontrolle
  string err_text;                 // Fehlertext
  int    errorcode;                // Errorcode
  bool   fehlerflag;               // Fehlerflag
  string temp;
  string temp1;
  string temp2;
  int    i;
  int    k;
  int    kk;                       // für neue VersionsnummernKontrolle
  int    ii;
  int    a;
  int    aa;
  int    i1;
  int    i2;
  int    i3;                       // für neue VersionsnummernKontrolle
  string sgbd_String_Lang;
  string sgbd_von_inpa_version;
  string ver_temp;
  string ver_temp1;
  string ver_temp2;
  string ver_temp3="--";
  real   Version_SGBD;
  real   Version_INPA;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  int    ret_int;
  int    Size;
  int    filecheck;
  string hinweis_text;

  settitle(titel+" Version "+version);
  a=0;
  ii=0;
  i3=0;
  kk=0;
  aa=0;
  i=0;
  k=0;
  fehlerflag=FALSE;
  temp1="";
  temp2="";

  instr(i,k,","+gruppe+",",",");
  while ((i >= 0) && (fehlerflag == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppe+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppe+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(fehlerflag,variante,"VARIANTE",0,"");
      if (fehlerflag == TRUE) gruppe=temp;
      else
      {
        INP1apiErrorCode(errorcode);
        if (errorcode == 36)//Fehlende oder fehlerhafte Simulationsdatei
        {
           Size=256;
           space(CurDir,Size);
           GetCurrentDirectory(256, CurDir, ret_int);
           SetCurrentDirectory("\EDIABAS\SIM", ret_int);
           fileexist(temp+".SIM",filecheck);
           SetCurrentDirectory(CurDir, ret_int);
           if (filecheck == 0)
           {
             temp1= temp1+", "+temp+".SIM";//Fehlerhafte Simulationsdatei
           }
           else
           {
             temp2= temp2+", "+temp+".SIM";//Fehlende Simulationsdatei
           }
        }
      }
    }
  }

  instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
  instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
  if ((i == 0) || (k == 0))
       hinweis_text= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
  else hinweis_text= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an

  if (fehlerflag == FALSE)
  {
     //Fehlende oder fehlerhafte Gruppen-Simulationsdatei
     if (errorcode == 36)
     {
        //Fehlerhafte Simulationsdatei
        if (temp1 != "")
        {
          strlen(k,temp1);
          instr(i,k,temp1+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp1+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp1,temp1,1,k);//Kommata vor und hinter temp1 ausschneiden
          temp1= "Fehlerhafte Simulationsdatei: "+temp1+CRLF;
        }
        //Fehlende Simulationsdatei
        if (temp2 != "")
        {
          strlen(k,temp2);
          instr(i,k,temp2+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp2+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp2,temp2,1,k);//Kommata vor und hinter temp2 ausschneiden
          temp2= "Fehlende Simulationsdatei  : "+temp2+CRLF;
        }

        messagebox("Variantenkontrolle",
                   "Fehler!"+CRLF+
                   temp1+//Fehlerfafte Gruppen-Simulationsdateien
                   temp2+//Fehlende     -//-
                   "Das Programm wird abgebrochen!");
        exit();
     }

     //Gruppendatei vorhanden?
     Size=256;
     space(CurDir,Size);
     GetCurrentDirectory(256, CurDir, ret_int);
     SetCurrentDirectory("\EDIABAS\ECU", ret_int);
     fileexist(gruppe+".GRP",filecheck);
     SetCurrentDirectory(CurDir, ret_int);
     if (filecheck == 0)//Gruppendatei vorhanden, SGBD-, Kommunikationsfehler hier ausgeben
     {
       INP1apiErrorText(err_text);//Fehler beim Aufruf der VARIANTE?
       if (errorcode == 92)//92=SYS-0002: SG-Variantenbeschreibungsdatei (SGBD) nicht gefunden
       {
         //T_GRTB.PRG vorhanden?
         Size=256;
         space(CurDir,Size);
         GetCurrentDirectory(256, CurDir, ret_int);
         SetCurrentDirectory("\EDIABAS\ECU", ret_int);
         fileexist("T_GRTB.PRG",filecheck);
         SetCurrentDirectory(CurDir, ret_int);
         if (filecheck == 0)//T_GRTB.PRG ist vorhanden, somit fehlt die SGBD.
         {
           messagebox("Variantenkontrolle",
                      "Fehler!"+CRLF+
                      err_text+". "+CRLF+
                      " "+CRLF+
                      "Das Steuergerät läßt sich zwar über die Gruppendatei: "+gruppe+".GRP"+" ansprechen,"+CRLF+
                      "aber zur Diagnose fehlt eine entsprechende SGBD (*.PRG) im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                      " "+CRLF+
                      "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                      " "+CRLF+
                      "Das Programm wird abgebrochen!");
         }
         else//T_GRT.PRG fehlt
         {
           messagebox("Variantenkontrolle",
                     "Fehler!"+CRLF+
                     err_text+". "+CRLF+
                     " "+CRLF+
                     "Die Datei T_GRTB.PRG fehlt im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                     " "+CRLF+
                     "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                     " "+CRLF+
                     "Das Programm wird abgebrochen!");
         }
       }
       else if (errorcode == 102)//102= Identification error
       {
         instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
         instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
         if ((i == 0) || (k == 0))
              temp1= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
         else temp1= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                    hinweis_text+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
       else //alle anderen Fehler
       {
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    " "+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
     }
     else//Gruppendatei nicht vorhanden
     {
        messagebox("Variantenkontrolle",
        "Fehler! Gruppendatei : "+gruppe+".GRP "+CRLF+
        "existiert nicht im Verzeichnis ..\EDIABAS\ECU"+CRLF+
        " "+CRLF+
        "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
        " "+CRLF+
        "Das Programm wird abgebrochen!");
     }
     exit();
  }

  i1=0;
  i2=0;
  instr(i1,0,","+sgbd+",",","+variante+",");
  if (i1 < 0)
  {
    instr(i2,0,","+sgbd+",",","+variante+"/");
    if (i2 < 0)
    {
      messagebox("Variantenkontrolle",
                 "Gesuchtes Steuergerät: '"+sgbd+"' nicht gefunden. "+CRLF+
                 "Gefundenes Steuergerät: '"+variante+"'. "+CRLF+
                 " "+CRLF+
                 "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                 hinweis_text+CRLF+
                 " "+CRLF+
                 "Das Programm wird abgebrochen!");
      exit();
    }

    ver_temp3 = "--";
    instr(ii,i2,sgbd+",",",");
    if (ii >= 0)
    {
      midstr(ver_temp3,sgbd+",",i2,ii);
      instr(i3,0,ver_temp3,"/");
      if (i3 >= 0)
      {
        a = i2+i3+1;
        aa = ii-i2+i3-1;
        midstr(ver_temp3,sgbd+",",a,aa);
      }
    }
  }

  sgbd_String_Lang = sgbd;
  sgbd=variante;

//
// Info: Informatinon bei aufruf ohne BMW_STD.SRC
//
// ####################################################
// # //für Info                                       #
// #   string sgbd_ecu;                               #
// #   string sgbd_origin;                            #
// #   string sgbd_revision;                          #
// #   string sgbd_package;                           #
// #   string sgbd_sprache;                           #
// #   string sgbd_comment;                           #
// #   string gruppe_ecu;                             #
// #   string gruppe_origin;                          #
// #   string gruppe_revision;                        #
// #   string gruppe_comment;                         #
// #                                                  #
// #   #include "SgbdInfo.src"                        #
// ####################################################
//
//
  SgbdInfo(sgbd, sgbd_ecu, sgbd_origin, sgbd_revision, sgbd_package, sgbd_comment, sgbd_sprache);
// Bitte VARIABLEN als Globale variable aktivieren und Include (siehe Block //INFO)
//
//

  //Versionskontrolle Auf 3 stellen vor / hinter dem "."
  instr(i3,0,ver_temp3,"V");
  if(i3>=0)
  {
    instr(i2,0,ver_temp3,",");
    midstr(ver_temp3,ver_temp3,i3+1,i2-1);
    stringtoreal(ver_temp3,Version_INPA);
    realtostring(Version_INPA,"3.3",ver_temp3);
    midstr(sgbd_von_inpa_version,ver_temp3,0,2);
  }
  stringtoreal(version,Version_INPA);
  realtostring(Version_INPA,"3.3",version);
  midstr(inpa_version,version,0,2);

  stringtoreal(sgbd_revision,Version_SGBD);
  realtostring(Version_SGBD,"3.3",sgbd_revision);
  midstr(sgbd_version,sgbd_revision,0,2);

  temp=inpa_version;
  temp1=sgbd_version;

  if (ver_temp3 == "--")
  {
    // Vergleichen mit Versionsnummer INPA & SGBD
    if (inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!");
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }
  else
  {
    // Vergleichen mit Versionsnummer INPA(SGBD Vorwahl) & SGBD
    if (sgbd_von_inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!"+CRLF+CRLF+
                 "SGBD Version: "+ ver_temp3 +" (in INPA) "+CRLF+
                 "SGBD Version: "+ sgbd_revision +CRLF+
                 "INPA Version: "+ version);
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }

  if (inpa_sprache != sgbd_sprache)
  {
    messagebox("Sprachvariantenkontrolle",
               "Nicht zusammenpassende Sprachvariante. "+CRLF+
               "Fehlfunktion ist möglich!");
  }
}

// -- EOF --
// end of :#include "SGBDINPA.SRC"
// start of :#include "GRPCHECK.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GrpCheck.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//* 20.04.2007 GA V3.02 FS-, IS-, HS_LESEN werden in einzelnen Tempdateien in ..\EDIABAS\BIN abgelegt
//**********************************************************************

//**********************************************************************
//*
//* GroupCheck
//*
//* Überprüfung der Gruppen-Info
//*
//**********************************************************************
GroupCheck()
{
  string err_text;                 // Fehlertext
  bool   fehlerflag;               // Fehlerflag
  string temp;
  int    sgbd_saetze;              // für Funktionen-Suche in SGBD
  string job_name;                 // JOBNMAE in SGBD
  int    i;

  fehlerflag=FALSE;
  i=0;

  GruppenDateiInfo(gruppe, gruppe_ecu, gruppe_origin, gruppe_revision, gruppe_comment);

  // Vorbelegung der Flags
  fs_lesen_flag       = FALSE;
  is_lesen_flag       = FALSE;
  speicher_lesen_flag = FALSE;
  is_loeschen_flag    = FALSE;
  hs_loeschen_flag    = FALSE;

  INPAapiJob(sgbd,"_JOBS","","");

  INP1apiResultSets(fehlerflag, sgbd_saetze);
  if (fehlerflag == FALSE)
  {
    INP1apiErrorText(err_text);
    messagebox("Unerwarteter Fehler", // sollte nie kommen
                err_text+". "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }
  i = 1;
  while ( i <= sgbd_saetze)
  {
    INPAapiResultText(job_name,"JOBNAME",i,"");
    if (job_name == "FS_LESEN" )       fs_lesen_flag=TRUE;
    if (job_name == "IS_LESEN" )       is_lesen_flag=TRUE;
    if (job_name == "HS_LESEN" )       hs_lesen_flag=TRUE;
    if (job_name == "IS_LOESCHEN" )    is_loeschen_flag=TRUE;
    if (job_name == "HS_LOESCHEN" )    hs_loeschen_flag=TRUE;
    if (job_name == "SPEICHER_LESEN" ) speicher_lesen_flag=TRUE;

    if ((fs_lesen_flag == TRUE) &&
        (is_lesen_flag == TRUE) &&
        (hs_lesen_flag == TRUE) &&
        (is_loeschen_flag == TRUE) &&
        (hs_loeschen_flag == TRUE) &&
        (speicher_lesen_flag) == TRUE) i = sgbd_saetze;
    i = i + 1;
  }
  if (speicher_lesen_parameter == "")  speicher_lesen_flag = FALSE;

  if (speicher_lesen_flag == TRUE)
  {
    instr(i, 0, ";"+speicher_lesen_parameter+";", ";LAR;");
    if ( i == -1 ) speicher_lesen_lar_flag = FALSE; else speicher_lesen_lar_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";FLASH;");
    if ( i == -1 ) speicher_lesen_flash_flag = FALSE; else speicher_lesen_flash_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";UIFM;");
    if ( i == -1 ) speicher_lesen_uifm_flag = FALSE; else speicher_lesen_uifm_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMI;");
    if ( i == -1 ) speicher_lesen_romi_flag = FALSE; else speicher_lesen_romi_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIS;");
    if ( i == -1 ) speicher_lesen_ramis_flag = FALSE; else speicher_lesen_ramis_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIL;");
    if ( i == -1 ) speicher_lesen_ramil_flag = FALSE; else speicher_lesen_ramil_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";NVRAM;");
    if ( i == -1 ) speicher_lesen_nvram_flag = FALSE; else speicher_lesen_nvram_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMX;");
    if ( i == -1 ) speicher_lesen_romx_flag = FALSE; else speicher_lesen_romx_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMXX;");
    if ( i == -1 ) speicher_lesen_ramxx_flag = FALSE; else speicher_lesen_ramxx_flag = TRUE;
  }

  //IDENT-Typ ermitteln: DS2, BMW Fast oder UDS?
  INP1apiJob(sgbd,"IDENT","","");
  INP1apiResultText(fehlerflag,temp,"ID_DATUM_KW",1,"");//Hat nur DS2
  if ((fehlerflag == TRUE) && (temp != ""))
  {
    ident_typ= 1;//DS2
  }
  else//UDS, BMW Fast
  {
    INP1apiResultText(fehlerflag,temp,"ID_SGBD_INDEX",1,"");
    if ((fehlerflag == TRUE) && (temp != "")) ident_typ= 3; //Hat nur UDS (ISO 14229)
    else ident_typ= 2; //sonst BMW Fast
  }
}
// -- EOF --
// end of :#include "GRPCHECK.SRC"
// start of :#include "FS_LESEN.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen FS_LESEN.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 21.11.2000 rd V0.10 Umweltbedingungen als Zahl oder Text ( 0-n, Hex )
//* 02.03.2001 rd V0.11 Shadowspeicher umbenannt in Infospeicher
//* 25.04.2002 rd V1.00 Erweiterung HS_LESEN
//* 22.10.2002 rd V1.01 Erweiterung FS_LESEN
//*               V1.01 PCODE und PCODE7 Ausgabe neu
//*               V1.01 Fehlerbehandlung verbessert
//* 19.11.2002 iS V1.02 Fehlerbehandlung F_ORT_TEXT, F_UW_ANZ, F_PCODE
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Fehlerausgaben korrigiert und erweitert
//* 28.06.2006 GA V3.01 Bei UDS: Ausgabe "F_UW_DATUM_ZEIT" durch "F_UW_ZEIT" ersetzt, da Result entfällt
//* 19.10.2006 GA V3.02 Bei DS2: wurde nicht angezogen da if-Bedingung nicht korrekt gewesen ist.
//*            GA V3.02 Result: F_UW_ZEIT von Unterprg.: fs_protokoll_uwb in fs_protokoll_uwb_uds verschoben
//*            GA V3.02 Result: F_EREIGNIS_DTC: Text wurde inverse ausgegeben
//* 07.02.2007 GA V3.03 Result: F_EREIGNIS_DTC: Erklärender Text, was ein Ereinis DTC ist, war falsch
//**********************************************************************

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************
int    _FsMode        = 0x7FF; // alles ein
string _FsFileMode    = "w";
string _PreInfoFile   = "";
string _PostInfoFile  = "";
string _ApiFsJobName  = "FS_LESEN";

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern INPAapiFsMode_neu ( in: int FsMode, in: string FsFileMode,
                           in: string PreInfoFile, in: string PostInfoFile,
                           in: string ApiFsJobName);

extern INPAapiFsLesen_neu( in: string ecu, in: string FileName);

extern fs_protokoll_ort(in: int nr);
extern fs_protokoll_ort_uds(in: int nr);
extern fs_protokoll_PCode(in: int nr);
extern fs_protokoll_PCode7(in: int nr);
extern fs_protokoll_SAECode(in: int nr);
extern fs_protokoll_hfk(in: int nr);
extern fs_protokoll_hfk_uds(in: int nr);
extern fs_protokoll_art(in: int nr);
extern fs_protokoll_art_uds(in: int nr);
extern fs_protokoll_art_e(in: int nr);
extern fs_protokoll_uwb(in: int nr);
extern fs_protokoll_uwb_uds(in: int nr);
extern fs_protokoll_hex(in: int nr);
extern fs_protokoll_telantwort(in: int nr);

//**********************************************************************
//*
//* INPAapiFsMode_neu kompatibel mit INPAapiFsMode
//*
//**********************************************************************
INPAapiFsMode_neu(  in: int    FsMode,
                    in: string FsFileMode,
                    in: string PreInfoFile,
                    in: string PostInfoFile,
                    in: string ApiFsJobName)
{
  _FsMode       = FsMode;
  _FsFileMode   = FsFileMode;
  _PreInfoFile  = PreInfoFile;
  _PostInfoFile = PostInfoFile;
  _ApiFsJobName = ApiFsJobName;


  INPAapiFsMode(_FsMode, _FsFileMode, _PreInfoFile, _PostInfoFile, _ApiFsJobName);
  if (_ApiFsJobName=="") _ApiFsJobName="FS_LESEN";
}

//**********************************************************************
//*
//* INPAapiFsLesen_neu kompatibel mit INPAapiFsLesen
//*
//**********************************************************************
INPAapiFsLesen_neu( in: string ecu, in: string FileName)
{
  string _ecu;
  string _FileName;
  bool   rc;
  int    i;
  int    k;
  int    len;
  int    x1;
  long   xL;
  string temp1;
  string temp2;
  string temp3;
  string temp11;
  string temp12;
  string temp21;
  string temp22;
  int    F_VERSION;
  string JOB_STATUS;
  string JOB_MESSAGE;
  string VARIANTE;
  int    SETS;
  int    UW_SETS;
  string FS_CODE;
  string F_PCODE;
  string F_PCODE7;
  string F1_VERSION;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string errorcode_text;           // EDIABAS Fehlernummer als Text

  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  _ecu      = ecu;
  _FileName = FileName;


  //SGBD-Version auslesen
  sgbd_version= "???";
  INPAapiJob(_ecu,"INFO","","");
  INP1apiResultText(rc, sgbd_version, "REVISION", 1, "");

  INPAapiJob(_ecu, _ApiFsJobName,"","");
  INP1apiResultInt(rc, F_VERSION, "F_VERSION",1 );

  INP1apiErrorCode(errorcode);

//UDS:
  if ((rc == TRUE) && ( F_VERSION == 3 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort_uds(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="??????";
            StrArrayWrite(f_ort_text_buffer,i,temp1);

            INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
            if (rc == TRUE)
            {
              GetBinaryDataString (temp1,len);
              midstr(temp1,temp1,0,6);
            }
            else
            {
              temp1= "??????";
              filewrite("");
              filewrite("### Fehler beim Lesen des Results: F_HEX_CODE ###");
              filewrite("");
              INP1apiErrorCode(errorcode);
              if (errorcode != 0)
              {
                inttostring(errorcode, errorcode_text);
                INP1apiErrorText(error_text);
                error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
                ftextout(error_text ,2,0,0,0);
              }
            }
            StrArrayWrite(f_ort_nr_buffer,i,temp1);

            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort_uds(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_SAECode(1);//0x200 von BMW Fast für PCode genommen
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk_uds(1);
                k=1;

                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb_uds(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite("0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);

                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite("0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//BMW FAST:
  else if ((rc == TRUE) && ( F_VERSION == 2 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="????";

            StrArrayWrite(f_ort_text_buffer,i,temp1);
            INPAapiResultInt(x1, "F_ORT_NR", i);
            inttohexstring(x1, 4, temp1);
            StrArrayWrite(f_ort_nr_buffer,i,temp1);
            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_PCode(1);
                if ((_FsMode & 0x400) != 0) fs_protokoll_PCode7(1);
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk(1);
                k=1;
                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite( "0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                {
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                }
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);
                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite( "0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//DS2
  else if (errorcode == 134)//134=SYS-0014: Result nicht gefunden: 'F_VERSION'
  {
    INPAapiFsLesen( _ecu, _FileName);
  }
//Fehlerhafter Aufruf
  else
  {
    INPAapiCheckJobStatus("OKAY");//Damit der Bediener die Fehlermeldung bestätigen muß
    getdate(temp1);
    gettime(temp2);
    INP1apiErrorText(temp3);
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite( "");
    filewrite( "Datum    : "+temp1+" "+temp2);
    filewrite( "ECU      : "+_ecu);
    filewrite( "JobStatus: "+JOB_STATUS+"-->"+temp3) ;
    filewrite( "-------------------------------------------------------------------------------");
    fileclose();
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für DS2 und BMW Fast
//*
//**********************************************************************
fs_protokoll_ort(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  INP1apiResultInt(rc,x1, "F_ORT_NR", i);
  if (rc == TRUE)
  {
    inttohexstring(x1, 4, temp1);
  }
  else
  {
    temp1="????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für UDS (ISO 14229)
//*
//**********************************************************************
fs_protokoll_ort_uds(in: int nr)
{
  int    i;
  int    len;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");

  INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
  if (rc == TRUE)
  {
    if (_ApiFsJobName == "FS_LESEN")
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,0,6);
    }
    else//IS_LESEN
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,2,6);//Byte 0, Zeichen 0 und 1 sind das severity Byte!
    }

  }
  else
  {
    temp1= "??????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"??????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE
//*
//**********************************************************************
fs_protokoll_PCode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcodeText;
  string tempPcodeString;
  string tempPcodeHex;

  i=nr;
  INP1apiResultText(rc,tempPcodeString, "F_PCODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcodeText, "F_PCODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcodeHex);
        tempPcodeHex= "0x"+tempPcodeHex;
      }
      else
      {
        tempPcodeHex = "????";
      }
    }
    else
    {
      tempPcodeText = "????";
    }

    if (tempPcodeString == "??")
    {
      filewrite( "");
      filewrite( tempPcodeHex+"  "+tempPcodeText);
    }
    else
    {
      if (tempPcodeString != "--")
      {
        filewrite( "");
        filewrite( tempPcodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE7
//*
//**********************************************************************
fs_protokoll_PCode7(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcode7Text;
  string tempPcode7String;
  string tempPcode7Hex;

  i=nr;
  INP1apiResultText(rc,tempPcode7String, "F_PCODE7_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcode7Text, "F_PCODE7_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE7", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcode7Hex);
        tempPcode7Hex= "0x"+tempPcode7Hex;
      }
      else
      {
        tempPcode7Hex = "????";
      }
    }
    else
    {
      tempPcode7Text = "????";
    }

    if (tempPcode7String == "??")
    {
      filewrite( "");
      filewrite( tempPcode7Hex+"  "+tempPcode7Text);
    }
    else
    {
      if (tempPcode7String != "--")
      {
        filewrite( "");
        filewrite( tempPcode7Text);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe SAE Code für UDS
//*
//**********************************************************************
fs_protokoll_SAECode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempSAECodeText;
  string tempSAECodeString;
  string tempSAECodeHex;

  i=nr;
  INP1apiResultText(rc,tempSAECodeString, "F_SAE_CODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempSAECodeText, "F_SAE_CODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_SAE_CODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempSAECodeHex);
        tempSAECodeHex= "0x"+tempSAECodeHex;
      }
      else
      {
        tempSAECodeHex = "????";
      }
    }
    else
    {
      tempSAECodeText = "????";
    }

    if (tempSAECodeString == "??")
    {
      filewrite( "");
      filewrite( tempSAECodeHex+"    "+tempSAECodeText);
    }
    else
    {
      if (tempSAECodeString != "--")
      {
        filewrite( "");
        filewrite( tempSAECodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit
//*
//**********************************************************************
fs_protokoll_hfk(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;
  int f_hfk;
  int f_lz;

  i=nr;
  filewrite( "");

  INP1apiResultInt(rc,f_hfk,"F_HFK",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_hfk,temp1);
    if (f_hfk < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    filewrite( "Fehlerhäufigkeit: "+ temp1);
  }

  INP1apiResultInt(rc,f_lz,"F_LZ",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_lz,temp1);
    if (f_lz < 10) temp1= " "+temp1;//Formatierung der Nr des Logistikzählers, wenn sie kleiner 10 ist
    filewrite( "Logistikzähler  : "+ temp1);
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit für UDS
//*
//**********************************************************************
fs_protokoll_hfk_uds(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  //FS Überlauf
  INP1apiResultInt(rc,x1, "F_UEBERLAUF", i);
  if ((rc == TRUE) && (x1==1))
  {
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    if (_ApiFsJobName == "IS_LESEN")
      filewrite("++++++++++++++++++++++++ Infospeicher ist übergelaufen! +++++++++++++++++++++++");
    else
      filewrite("+++++++++++++++++++++++ Fehlerspeicher ist übergelaufen! ++++++++++++++++++++++");
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    filewrite( "");
  }

  //Fehlerhäufigkeit
  INP1apiResultInt(rc,x1, "F_HFK", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
   {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    }
  }
  filewrite( "Fehlerhäufigkeit: "+ temp1);

  //Heilungszähler
  INP1apiResultInt(rc,x1, "F_HLZ", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
    {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung des Heilungszählers, wenn er kleiner 10 ist
    }
  }
  filewrite( "Heilungszähler  : "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten
//*
//**********************************************************************
fs_protokoll_art(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_SYMPTOM_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe erweiterte Fehlerarten
//*
//**********************************************************************
fs_protokoll_art_e(in: int nr)
{
  int    i;
  int    k;
  int    F_ART_ANZ;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  INP1apiResultInt(rc,F_ART_ANZ, "F_ART_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_ART_ANZ > 0 )
    {
      k=0;
      while ( k < F_ART_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);
        INP1apiResultText(rc,temp1, "F_ART"+temp2+"_TEXT", i, "");
        if (rc == FALSE)  temp1 ="????";
        if (temp1 !="--") filewrite( "   "+ temp1);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten für UDS
//*
//**********************************************************************
fs_protokoll_art_uds(in: int nr)
{//Symptome entfallen bei UDS!
  int    i;
  int    x1;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  //Neu bei UDS:
  INP1apiResultInt(rc,x1, "F_EREIGNIS_DTC", i);
  if (rc == TRUE)
  {
    if (x1==0)
    {
      filewrite("   Dies ist kein Ereignis DTC. Das SG ist für den Fehlerspeicheintrag (DTC) verantwortlich.");
    }
    else if (x1==1)
    {
      filewrite("   Dies ein Ereignis DTC. Das SG ist somit nicht für den Fehlereintrag (DTC) verantwortlich.");
      filewrite("   Z.B. falsche oder fehlende Netzwerkinformationen.");
    }
    else
    {
      filewrite("   Fehler in SGBD! In Tabelle FOrtTexte, Spalte EREIGNIS_DTC muß 0 oder 1 stehen!");
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb(in: int nr)
{
  int    i;
  int    k;
  int    len;
  int    F_UW_ANZ;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  real   realval;
  int    pos;

  i=nr;
/*  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");
*/
  INP1apiResultText(rc,temp1, "F_UW_KM", i, "8L");
  if (rc == FALSE) temp1="    ????";
  if ((temp1 == "524280") && (ident_typ != 3)) temp1 = "-1";//Fehlerüberlauf für DS2 und BMW FAST, UDS liefert es von alleine

  temp2 =    "Kilometerstand                        ";
  filewrite( "   " + temp2 + temp1 + "     km");


  INP1apiResultInt(rc,F_UW_ANZ, "F_UW_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_UW_ANZ > 0 )
    {
      k=0;
      while ( k < F_UW_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);

        INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
        if (rc == TRUE)
        {
          AnsiUpper(temp3,temp3);
        }
        else
        {
          temp3 = "????";
        }
        if ((temp3 == "0-N") || (temp3 == "HEX"))
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-20T");
          if (rc == FALSE) temp1="????                ";
          if (temp1 !="--                  ") //"--" + 18 Zeichen

          {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "28T");
              if (rc == FALSE) temp3="????                        ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
          }
        }
        else
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-40T");
          if (rc == FALSE) temp1="????                                    ";
          if (temp1 !="--                                      ")
           {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "8.2R");
              if (rc == FALSE) temp3=" ????   ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
           }
         }
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb_uds(in: int nr)
{
  int    i;
 // int    k;
//  int    len;
//  int    F_UW_ANZ;
  bool   rc;
  string temp1;
//  string temp2;
//  string temp3;
//  real   realval;
//  int    pos;

  i=nr;
  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");

  fs_protokoll_uwb(i);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Hexcode
//*
//**********************************************************************
fs_protokoll_hex(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;

  chr(10,nl);
  i=nr;
  filewrite( "");
  INP1apiResultBinary(rc,"F_HEX_CODE", i);
  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????";
  }
  filewrite( "Fehlercode: "+temp2);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Telegrammantwort(en)
//* Wird nur bei Fehlerhaften FS_LESEN_DETAIL ausgegeben
//*
//**********************************************************************
fs_protokoll_telantwort(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  string temp4;
  string temp5;

  chr(10,nl);
  i=nr;
  filewrite( "");

  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_SNAPSHOT", i);
    else INP1apiResultBinary(rc,"_RESPONSE_2000", i);//IS_LESEN
  }
  else//1=DS2, 2=BMW Fast
  {
    INP1apiResultBinary(rc,"_TEL_ANTWORT", i);
  }


  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????--> Zur Analyse IFH-Trace benutzen!";
  }

  //2. Telegramm nur für UDS ausgeben
  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_EXTENDED_DATA", i);
    else INP1apiResultBinary(rc,"_RESPONSE_200X", i);//IS_LESEN

    if (rc == TRUE)
    {
      GetBinaryDataString (temp1, x1);
      x2 = 0;
      x3 = 0;
      temp4="";
      while ( x2 < x1 )
       {
         midstr(temp3, temp1, x2, 2);
         temp4 = temp4 + temp3;
         x2 = x2 + 2;
         x3 = x3 + 1;
         if ( x2 < x1 )
         {
           if ( x3 < 16 )//Leerzeichen zwischen den Bytes
           {
             if ( x3 == 8 )
               temp4 = temp4 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
             else temp4 = temp4 + " ";
           }
           else
           {
             x3 = 0;
             temp4 = temp4 + nl + "            ";
           }
         }
      }
    }
    else
    {
      temp4 = "????--> Zur Analyse IFH-Trace benutzen!";
    }

    filewrite("Telegramm-Antwort ab Service Identifier zur Analyse");
    if (_ApiFsJobName == "FS_LESEN")
    {
      filewrite("Data      : "+temp2);
      filewrite("Snapshot  : "+temp4);
    }
    else//IS_LESEN
    {
      filewrite("2000      : "+temp2);
      filewrite("200X      : "+temp4);
    }
  }
  else//DS2, BMW Fast
  {
  filewrite("Telegramm-");
  filewrite("Antwort   : "+temp2);
  }
}
// -- EOF --
// end of :#include "FS_LESEN.SRC"
// start of :#include "INITEXIT.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INITEXIT.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Scriptinit verlagert
//* 12.03.2003 iS V1.01 Anpassung SgbdInpaCheck()GroupCheck();
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//**********************************************************************

// **************************
// *** inpainit, inpaexit ***
// **************************
inpainit()
{
  bool   rc;
  string temp;
  int    i;

  INPAapiInit();
  chrinit();

  // Handle für FS_LESEN
  StrArrayCreate(rc,f_ort_nr_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_nr_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  StrArrayCreate(rc,f_ort_text_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_text_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  SgbdInpaCheck();
  GroupCheck();
  setmenu(m_main);
  setscreen(s_main,TRUE);

  //INPA.INI einlesen,
  //um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
  //hinter "SCRIPTS" muß DeleteRead stehen, um die Funktion freizuschalten
  ExtraScript("DeleteRead", deleteread_flag);

  //m FS,IS,HS zu speichern
  ExtraScript("SaveAs", fs_lesen_save_as_flag);
  is_lesen_save_as_flag=fs_lesen_save_as_flag;
  hs_lesen_save_as_flag=fs_lesen_save_as_flag;

  //INPA.INI-Einstellung, falls Funktionen gewünscht:
  //[EXTRA]
  //SCRIPTS               =  DeleteRead,SaveAs
  //Wichtig: Nach dem Komma kein Leerzeichen benutzen!

  ScriptInit();
}

inpaexit()
{
  INPAapiEnd();

  // Handle für FS_LESEN
  StrArrayDestroy(f_ort_nr_buffer);
  StrArrayDestroy(f_ort_text_buffer);
}

// -- EOF --
// end of :#include "INITEXIT.SRC"

// **************************
// *** Hauptmenü          ***
// **************************
MENU m_main()
{
  INIT  {
    setmenutitle("Hauptmenü");

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      setitem(2, "Ident", TRUE);
    }
    else
    {
      setitem(2, "SVK", TRUE);//ISO 14229
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setitem( 4 , "Fehler"  , TRUE);
    }

    if (m_status_flag == TRUE)
    {
      setitem( 5 , "Status"  , TRUE);
    }

    if (m_steuern_flag == TRUE)
    {
      setitem( 6 , "Steuern"  , TRUE);
    }

    if (speicher_lesen_flag == TRUE)
    {
      setitem( 7 , "Speicher"  , TRUE);
    }
  }
  ITEM( 1 ,"Info")  {
    userboxclose(1);
    setscreen(s_info,TRUE);
  }
  ITEM( 2 ,"Ident")  {
    userboxclose(1);
    if (ident_typ == 1)
      setscreen(s_ident_ds2,TRUE);
    else if (ident_typ == 2)
      setscreen(s_ident,TRUE);
    else setscreen(s_svk_lesen,TRUE);
  }
  ITEM( 3 ,"")  {
    userboxclose(1);
    setscreen(s_main,TRUE);
  }
  ITEM( 4 ,"")  {
    userboxclose(1);
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setscreen( s_fehler ,TRUE);
      setmenu(m_fehler);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 5 ,"")  {
    userboxclose(1);
    if (m_status_flag == TRUE)
    {
      setscreen(s_status,TRUE);
      setmenu(m_status);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 6 ,"")  {
    userboxclose(1);
    if (m_steuern_flag == TRUE)
    {
      setscreen(s_steuern,TRUE);
      setmenu(m_steuern);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(1);
    if (speicher_lesen_flag == TRUE)
    {
      setscreen(s_speicher,TRUE);
      setmenu(m_speicher);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Ende")  {
    exit();
  }
  ITEM( 11,  "KVP") {
    setscreen(s_info,TRUE);
    callwin( "kvp_edit "+titel+";"+version+";"+sgbd+": "+sgbd_ecu+";"+sgbd_revision);
  }
  ITEM( 12 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 14 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 15 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Fehlermenü         ***
// **************************
MENU m_fehler()
{
  int    ErrorCode;
  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  string DateiName="";
  int    aufrufIO;
  string JOB_STATUS;
  bool   fehlerflag;

  INIT {
    setmenutitle("Fehlerspeicher");
    if (fs_lesen_flag == TRUE)
    {
      setitem( 1 , "FS lesen"    , TRUE);
      setitem( 2 , "FS löschen"  , TRUE);
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 3 , "IS lesen"    , TRUE);
      if (is_loeschen_flag == TRUE)
           setitem( 4 , "IS löschen"  , TRUE);
      else setitem( 4 , ""  , FALSE);//Nicht alle SGs haben IS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 5 , "HS lesen"    , TRUE);
      if (hs_loeschen_flag == TRUE)
           setitem( 6 , "HS löschen"  , TRUE);
      else setitem( 6 , ""  , FALSE);//Nicht alle SGs haben HS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
  }
  ITEM( 1 ,"")  {
    userboxclose(0);
    viewclose();
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
      userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Fehlerspeicher lesen");
      setitem( 9 , "FS drucken"  , TRUE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
    }
  }
  ITEM( 2 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      INPAapiJob(sgbd,"FS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher wurde gelöscht!",1,3,0,0);

        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPTS = DeleteRead
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
             userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Fehlerspeicher lesen");
             setitem( 9 , "FS drucken"  , TRUE);
             if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 3 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Infospeicher lesen","");
      userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Infospeicher lesen");
      setitem( 8 , "IS drucken"  , TRUE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
    }
  }
  ITEM( 4 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"IS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Infospeicher lesen","");
             userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Infospeicher lesen");
             setitem( 8 , "IS drucken"  , TRUE);
             if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 5 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
      userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Historienspeicher lesen");
      setitem( 7 , "HS drucken"  , TRUE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
    }
  }
  ITEM( 6 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (hs_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"HS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
             userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Historienspeicher lesen");
             setitem( 7 , "HS drucken"  , TRUE);
             if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 7 ,"")  {
    if (hs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
    }
  }
  ITEM( 8 ,"")  {
    if (is_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 9 ,"")  {
    if (fs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(17 ,"")  {
    if ((hs_lesen_flag == TRUE) && (hs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Historienspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
      }
    }
  }
  ITEM(18 ,"")  {
    if ((is_lesen_flag == TRUE) && (is_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Infospeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(19 ,"")  {
    if ((fs_lesen_flag == TRUE) && (fs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Fehlerspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    viewclose();
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    viewclose();
    exit();
  }
}

// **************************
// *** Speichermenü       ***
// **************************
MENU m_speicher()
{
  int    input_ok=0;
  int    input_state;
  string text_var;

  INIT {
    setmenutitle("Speicher lesen");
    if (speicher_lesen_lar_flag==TRUE)    setitem( 1 , "LAR"  , TRUE);
    if (speicher_lesen_flash_flag==TRUE)  setitem( 2 , "FLASH", TRUE);
    if (speicher_lesen_uifm_flag==TRUE)   setitem( 3 , "UIFM" , TRUE);
    if (speicher_lesen_romi_flag==TRUE)   setitem( 4 , "ROMI" , TRUE);
    if (speicher_lesen_ramis_flag==TRUE)  setitem( 5 , "RAMIS", TRUE);
    if (speicher_lesen_ramil_flag==TRUE)  setitem( 6 , "RAMIL", TRUE);
    if (speicher_lesen_nvram_flag==TRUE)  setitem( 7 , "NVRAM", TRUE);
    if (speicher_lesen_romx_flag==TRUE)   setitem(14 , "ROMX" , TRUE);
    if (speicher_lesen_ramxx_flag==TRUE)  setitem(15 , "RAMXX", TRUE);
  }
  ITEM( 1 ,"")  {
    if (speicher_lesen_lar_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"LAR lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="LAR lesen";
        speicher_lesen_seg_adr_anz="LAR;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 2 ,"")  {
    if (speicher_lesen_flash_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"FLASH lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="FLASH lesen";
        speicher_lesen_seg_adr_anz="FLASH;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 3 ,"")  {
    if (speicher_lesen_uifm_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"UIFM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="UIFM lesen";
        speicher_lesen_seg_adr_anz="UIFM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 4 ,"")  {
    if (speicher_lesen_romi_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMI lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMI lesen";
        speicher_lesen_seg_adr_anz="ROMI;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 5 ,"")  {
    if (speicher_lesen_ramis_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIS lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIS lesen";
        speicher_lesen_seg_adr_anz="RAMIS;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 6 ,"")  {
    if (speicher_lesen_ramil_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIL lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIL lesen";
        speicher_lesen_seg_adr_anz="RAMIL;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 7 ,"")  {
    if (speicher_lesen_nvram_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"NVRAM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="NVRAM lesen";
        speicher_lesen_seg_adr_anz="NVRAM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 8 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 12 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 14 ,"")  {
    if (speicher_lesen_romx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMX lesen";
        speicher_lesen_seg_adr_anz="ROMX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 15 ,"")  {
    if (speicher_lesen_ramxx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMXX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMXX lesen";
        speicher_lesen_seg_adr_anz="RAMXX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 18 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Hauptscreen        ***
// **************************
SCREEN s_main()
{
  string text_var;

  userboxclose(0);
  ftextout("Hauptmenü",1,0,1,0);
  ftextout("",3,0,0,0);

  if (simulation_flag == TRUE)
  {
    userboxopen(1,14,30,5,48,"Hinweis","");
    userboxftextout(1,"INPA bzw. EDIABAS läuft im Simulationsmodus!",1,3,0,24);
    userboxsetcolor(1,0,4);
  }

  if (ident_typ != 3)
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
  }

  LINE("","")
  {
    if (ident_typ != 3)//Nur bei DS2 und BMW Fast vorhanden
    {
      ftextout("BMW Teilenummer",1,0,0,0);
      ftextout(":",1,19,0,0);
      INPAapiResultText(text_var,"ID_BMW_NR",1,"");
      ftextout(text_var,1,20,0,1);

      ftextout("Herstelldatum",1,43,0,0);
      ftextout(":",1,59,0,0);
      if (ident_typ == 1)//DS2
      {
        ftextout("KW / Jahr",1,68,0,0);
        ftextout("/",1,63,0,1);
        INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
        ftextout(text_var,1,60,0,1);
        INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
        ftextout(text_var,1,65,0,1);
      }
      else if (ident_typ == 2)//BMW FAST
      {
        INPAapiResultText(text_var,"ID_DATUM",1,"");
        ftextout(text_var,1,60,0,1);
      }
    }

    ftextout("< F1 >  Information"              , 4,5,0,1);

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      ftextout("< F2 >  Identifikation"           , 6,5,0,1);
    }
    else
    {
      ftextout("< F2 >  Steuergeräteverbaukennung"           , 6,5,0,1);//UDS (ISO 14229)
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
        ftextout("< F4 >  Fehlerspeicher"           ,10,5,0,1);

    if (m_status_flag == TRUE)
        ftextout("< F5 >  Status lesen"             ,12,5,0,1);

    if (m_steuern_flag == TRUE)
        ftextout("< F6 >  Ansteuern"                ,14,5,0,1);

    if (speicher_lesen_flag == TRUE)
        ftextout("< F7 >  Speicher lesen"           ,16,5,0,1);

    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F1 >  KVP-Editor"     , 4,45,0,1);
    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Infoscreen         ***
// **************************
SCREEN s_info ()
{
  int i;
  int slen;
  int pos;
  int pos2;
  int anzahl;
  string temp;

  ftextout("Information",1,0,1,0);
  ftextout("Nacharbeitsprogramm",4,0,0,0);             ftextout(":", 4,33,0,1); ftextout(titel,4,35,0,1);
  ftextout("Version",5,1,0,0);                         ftextout(":", 5,33,0,1); ftextout(version,5,35,0,1);
  ftextout("Package",6,1,0,0);                         ftextout(":", 6,33,0,1); ftextout(package,6,35,0,1);
  ftextout("Verantwortung",7,1,0,0);                   ftextout(":", 7,33,0,1); ftextout(origin,7,35,0,1);

  ftextout("Gruppendatei",10,0,0,0);                   ftextout(":",10,33,0,1); ftextout(gruppe,10,35,0,1);
  ftextout("Bezeichnung",11,1,0,0);                    ftextout(":",11,33,0,1); ftextout(gruppe_ecu,11,35,0,1);
  ftextout("Version",12,1,0,0);                        ftextout(":",12,33,0,1); ftextout(gruppe_revision,12,35,0,1);
  ftextout("Verantwortung",13,1,0,0);                  ftextout(":",13,33,0,1); ftextout(gruppe_origin,13,35,0,1);
  ftextout("Identifizierbare SGBD'en",14,1,0,0);

  strlen(slen, gruppe_comment);
  anzahl=44;
  pos=0;
  if ( slen <= anzahl )
  {
    ftextout(":",14,33,0,1); ftextout(gruppe_comment,14,35,0,1);
  }
  else
  {
    instr(pos2, anzahl, gruppe_comment, ",");
    if (pos2 > 0) anzahl=pos2+1;
    midstr(temp, gruppe_comment, pos, anzahl); ftextout(":",14,33,0,1); ftextout(temp,14,35,0,1);
    i=14;
    pos=pos+anzahl;
    while ( pos < slen )
    {
      i=i+1;
      anzahl=75;
      instr(pos2, pos + anzahl, gruppe_comment, ",");
      if (pos2 > 0) anzahl=pos2+1-pos;
      midstr(temp, gruppe_comment, pos, anzahl); ftextout(temp,i,1,0,1);
      pos=pos+anzahl;
      if ( i >= 18 )
      {
        if ( pos < slen ) ftextout(temp+" . . .",i,1,0,1);
        pos=slen;
      }
    }
  }

  ftextout("Steuergerätebeschreibungsdatei",21,0,0,0); ftextout(":",21,33,0,1); ftextout(sgbd,21,35,0,1);
  ftextout("Steuergerät",22,1,0,0);                    ftextout(":",22,33,0,1); ftextout(sgbd_ecu,22,35,0,1);
  ftextout("Version",23,1,0,0);                        ftextout(":",23,33,0,1); ftextout(sgbd_revision,23,35,0,1);
  ftextout("Package",24,1,0,0);                        ftextout(":",24,33,0,1); ftextout(sgbd_package,24,35,0,1);
  ftextout("Verantwortung",25,1,0,0);                  ftextout(":",25,33,0,1); ftextout(sgbd_origin,25,35,0,1);
  ftextout("Sprache",26,1,0,0);                        ftextout(":",26,33,0,1); ftextout(sgbd_sprache,26,35,0,1);
  if (sgbd_comment!="")
  {
    ftextout("Kommentar",27,1,0,0);
    ftextout(":",27,33,0,1);
    ftextout(sgbd_comment,27,35,0,1);
  }
}

// **************************
// *** Identscreen DS2    ***
// **************************
SCREEN s_ident_ds2()
{
  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"IDENT","","");
  INPAapiCheckJobStatus("OKAY");
  LINE("","")
  {
    ftextout("BMW Teilenummer",1,0,1,0);
    ftextout(":",1,33,1,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,35,1,1);

    ftextout("Hardwarenummer",4,0,1,0);
    ftextout(":",4,33,1,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,4,35,1,1);

    ftextout("Softwarenummer",7,0,1,0);
    ftextout(":",7,33,1,0);
    INPAapiResultText(text_var,"ID_SW_NR",1,"");
    ftextout(text_var,7,35,1,1);

    ftextout("Lieferant",10,0,1,0);
    ftextout(":",10,33,1,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,10,35,1,1);

    ftextout("Codier-Index",13,0,1,0);
    ftextout(":",13,33,1,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,13,35,1,1);

    ftextout("Diagnose-Index",16,0,1,0);
    ftextout(":",16,33,1,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,16,35,1,1);

    ftextout("Bus-Index",19,0,1,0);
    ftextout(":",19,33,1,0);
    INPAapiResultText(text_var,"ID_BUS_INDEX",1,"");
    ftextout(text_var,19,35,1,1);

    ftextout("Herstelldatum",22,0,1,0);
    ftextout(":",22,33,1,0);
    ftextout("KW / Jahr",22,55,1,0);
    ftextout("/",22,41,1,1);
    INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
    ftextout(text_var,22,35,1,1);
    INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
    ftextout(text_var,22,45,1,1);
  }
}

// ****************************
// *** Identscreen BMW Fast ***
// ****************************
SCREEN s_ident()
{
  string text_var;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext

  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,1);

  LINE("Identifikation","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");

    ftextout("BMW Teilenummer",1,0,0,0);
    ftextout(":",1,43,0,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,45,0,1);

    ftextout("Codier-Index",3,0,0,0);
    ftextout(":",3,43,0,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,3,45,0,1);

    ftextout("Varianten-Index",5,0,0,0);
    ftextout(":",5,43,0,0);
    INPAapiResultText(text_var,"ID_VAR_INDEX",1,"");
    ftextout(text_var,5,45,0,1);

    ftextout("Diagnose-Index",7,0,0,0);
    ftextout(":",7,43,0,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,7,45,0,1);

    ftextout("Hardwarenummer",9,0,0,0);
    ftextout(":",9,43,0,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,9,45,0,1);

    ftextout("Softwarenummer   Funktionssoftware",11,0,0,0);
    ftextout(":",11,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_FSV",1,"");
    ftextout(text_var,11,45,0,1);

    ftextout("Softwarenummer   Betriebssystem",13,0,0,0);
    ftextout(":",13,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_OSV",1,"");
    ftextout(text_var,13,45,0,1);

    ftextout("Softwarenummer   Nachrichtenkatalog",15,0,0,0);
    ftextout(":",15,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_MCV",1,"");
    ftextout(text_var,15,45,0,1);

    ftextout("Softwarenummer  (Reserve) Zur Zeit nicht benutzt",17,0,0,0);
    ftextout(":",17,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_RES",1,"");
    ftextout(text_var,17,45,0,1);

    ftextout("Herstelldatum",19,0,0,0);
    ftextout(":",19,43,0,0);
    INPAapiResultText(text_var,"ID_DATUM",1,"");
    ftextout(text_var,19,45,0,1);

    ftextout("Lieferant",21,0,0,0);
    ftextout(":",21,43,0,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,21,45,0,1);
  }
// *** AIF, Anwender-Information
// *** auf 2. Seite von IDENT

  LINE("Anwender-Information","")
  {
    INPAapiJob(sgbd,"AIF_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("",10,0,0,0);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Anwenderinfofeld (AIF_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: AIF_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      INPAapiResultInt(ganz_zahl,"AIF_ANZ_DATEN",1);
      if (ganz_zahl > 18)                // lange AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Datensatz Nr.",7,0,0,0);
        ftextout(":",7,43,0,0);
        INPAapiResultText(text_var,"AIF_SW_NR",1,"");
        ftextout(text_var,7,45,0,1);

        ftextout("Behörden Nr.",9,0,0,0);
        ftextout(":",9,43,0,0);
        INPAapiResultText(text_var,"AIF_BEHOERDEN_NR",1,"");
        ftextout(text_var,9,45,0,1);

        ftextout("Händler Nr.",11,0,0,0);
        ftextout(":",11,43,0,0);
        INPAapiResultText(text_var,"AIF_HAENDLER_NR",1,"");
        ftextout(text_var,11,45,0,1);

        ftextout("Tester Nr.",13,0,0,0);
        ftextout(":",13,43,0,0);
        INPAapiResultText(text_var,"AIF_SERIEN_NR",1,"");
        ftextout(text_var,13,45,0,1);

        ftextout("km-Stand",15,0,0,0);
        ftextout(":",15,43,0,0);
        INPAapiResultText(text_var,"AIF_KM",1,"");
        ftextout(text_var,15,45,0,1);

        ftextout("Programm-Stand",17,0,0,0);
        ftextout(":",17,43,0,0);
        INPAapiResultText(text_var,"AIF_PROG_NR",1,"");
        ftextout(text_var,17,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
      else                              //18 Byte -> kurze AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
    }
  }

LINE("CFG Lesen","")
  {
    INPAapiJob(sgbd,"C_FG_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("Codierdaten",0,0,0,1);
    ftextout("",10,0,0,0);// um auf einer neuen Seite darzustellen

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Fahrgestellnummer lesen (CFG_LESEN) vorhanden          " ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: C_FG_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Fahrgestell Nr.",3,0,0,0);
      ftextout(":",3,43,0,0);
      INPAapiResultText(text_var,"FG_NR",1,"");
      ftextout(text_var,3,45,0,1);
    }

    INPAapiJob(sgbd,"C_AEI_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Codierdatenänderungsindex (C_AEI_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Codierdatenänderungsindex",6,0,0,0);
      ftextout(":",6,43,0,0);
      INPAapiResultText(text_var,"COD_AE_INDEX",1,"");
      ftextout(text_var,6,45,0,1);
    }
  }
}

// ****************************************************************************
// *** Identinformationen werden über SVK_LESEN ermittelt                   ***
// *** SVK: SteuergeräeVerbauKennung Soft- und Hardware für UDS (ISO 14229) ***
// ****************************************************************************
SCREEN s_svk_lesen()
{
  string text_var;
  string text_var2;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  bool   eingabeWeiter;
  int    input_state;              // Eingabestatus
  int    input_ok=1;               // Eingabe  mit Nein beendet
  int    i;
  int    offset;
  int    einheiten_anz;
  int    pos;
  real   realval;
  real   realval2;
  long   longval;
  long   rest_long;
  long   multiplik_long;

  ftextout("Steuergeräteverbaukennung Soft- und Hardware",1,0,1,0);
  ftextout("",2,0,0,1);
  LINE("Hersteller Information","")
  {//HERSTELLINFO_LESEN ist kein Pflichtjob! (Stand: 03.2006)
    INPAapiJob(sgbd,"HERSTELLINFO_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Herstellerinformationen vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: HERSTELLINFO_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Herstelldatum",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"ID_DATUM",1,"");
      ftextout(text_var,1,45,0,1);

      ftextout("Lieferant",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
      ftextout(text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("Ident","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
/*    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Ident vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else */if (((fehlerflag == FALSE) /*&& (errorcode != 98)*/) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: IDENT",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Steuergeräte-Adresse",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultInt(ganz_zahl,"ID_SG_ADR",1);
      inttohexstring(ganz_zahl,4,text_var);
      //Führende Nullen ausblenden
      if (ganz_zahl <= 255) midstr(text_var,text_var,2,2);
      ftextout("0x"+text_var,1,45,0,1);

      ftextout("SGBD-Index",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultBinary("_RESPONSE",1);
      GetBinaryDataString (text_var,i);
      midstr(text_var,text_var,6,11);

      ftextout("0x"+text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("SVK","")
  {
    INPAapiJob(sgbd,"SVK_LESEN","","");
    //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
    sets=0;
    INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) || (sets <= 1))
    {
      ftextout("Fehler beim Lesen von Job: SVK_LESEN",1,0,0,0);
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
        ftextout(error_text ,2,0,0,0);
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        ftextout(error_text,2,0,0,0);
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
      ftextout("" ,3,0,0,0);
    }
    else
    {
      INPAapiResultText(text_var,"PROG_DATUM",sets,"");
      ftextout("Programm-Datum",0,0,0,0);
      ftextout(":",0,41,0,0);
      ftextout(text_var,0,45,0,1);

      INPAapiResultText(text_var,"PROG_KM",sets,"");
      if (text_var == "-1") text_var= "- - -";
      ftextout("Programm-km",1,0,0,0);
      ftextout(":",1,41,0,0);
      ftextout(text_var,1,45,0,1);

      INPAapiResultText(text_var,"ANZAHL_EINHEITEN",sets,"");
      INPAapiResultInt(einheiten_anz,"ANZAHL_EINHEITEN",sets);
      ftextout("Anzahl Prozeßklassen",2,0,0,0);
      ftextout(":",2,41,0,0);
      ftextout(text_var,2,45,0,1);

      ftextout("Prozeßklasse",5,2,0,1);
      ftextout("SGBM Identifier ",5,43,0,1);
      ftextout("Version",5,62,0,1);

      i=1;
      offset=0;
      while(i<=einheiten_anz)
      {
        inttostring(i,text_var2);
        INPAapiResultText(text_var,"PROZESSKLASSE_TEXT",i,"");
        ftextout(text_var2+") "+text_var,6+offset,0,0,0);

        //SGBM Identifier
        ftextout(":",6+offset,41,0,0);
        INPAapiResultText(text_var,"SGBM_IDENTIFIER",i,"");
        ftextout(text_var,6+offset,45,0,1);

        //Version
        INPAapiResultText(text_var,"VERSION",i,"");
        ftextout(text_var,6+offset,62,0,1);
        i=i+1;//um nächsten Set zu laden
        offset=offset+1;
      }
    }
  }
}

// **************************
// *** Speicherscreen     ***
// **************************
SCREEN s_speicher()
{
  ftextout("Speicher lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (speicher_lesen_lar_flag==TRUE)    ftextout("< F1 >  LAR lesen"               , 4,5,0,1);
    if (speicher_lesen_flash_flag==TRUE)  ftextout("< F2 >  FLASH lesen"             , 6,5,0,1);
    if (speicher_lesen_uifm_flag==TRUE)   ftextout("< F3 >  UIFM lesen"              , 8,5,0,1);
    if (speicher_lesen_romi_flag==TRUE)   ftextout("< F4 >  ROMI lesen"              ,10,5,0,1);
    if (speicher_lesen_ramis_flag==TRUE)  ftextout("< F5 >  RAMIS lesen"             ,12,5,0,1);
    if (speicher_lesen_ramil_flag==TRUE)  ftextout("< F6 >  RAMIL lesen"             ,14,5,0,1);
    if (speicher_lesen_nvram_flag==TRUE)  ftextout("< F7 >  NVRAM lesen"             ,16,5,0,1);
    if (speicher_lesen_romx_flag==TRUE)   ftextout("<Shift> + < F4 >  ROMX lesen"    ,10,45,0,1);
    if (speicher_lesen_ramxx_flag==TRUE)  ftextout("<Shift> + < F5 >  RAMXX lesen"   ,12,45,0,1);

    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Speicherscreen     ***
// *** Ausgabe            ***
// **************************
SCREEN s_speicher_ausgabe()
{
  string text_var;
  string job_state;

  ftextout(speicher_lesen_text,1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"SPEICHER_LESEN",speicher_lesen_seg_adr_anz,"");
  INPAapiResultText(job_state,"JOB_STATUS",1,"");
  LINE("","")
  {
    ftextout("Startadresse",1,0,0,0);
    ftextout(":",1,18,0,1);
    ftextout(speicher_lesen_adresse,1,20,0,1);
    ftextout("Anzahl",3,0,0,0);
    ftextout(":",3,18,0,1);
    inttostring(speicher_lesen_anzahl,text_var);
    ftextout(text_var,3,20,0,1);
    ftextout("Daten",5,0,0,0);
    ftextout(":",5,18,0,1);
    if(job_state != "OKAY")
      ftextout(job_state,5,20,0,1);
    else
    {
      INPAapiResultBinary("DATEN",1);
      hexdump(speicher_lesen_adresse,speicher_lesen_anzahl,5,20);
    }
  }
}

// **************************
// *** Fehlerscreen       ***
// **************************
SCREEN s_fehler()
{
  ftextout("Fehlerspeicher",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (fs_lesen_flag == TRUE)
    {
      ftextout("< F1 >  Fehlerspeicher lesen"      , 4,5,0,1);
      ftextout("< F2 >  Fehlerspeicher löschen"    , 6,5,0,1);
      ftextout("< F9 >  Fehlerspeicher drucken"    ,20,5,0,1);
      if (fs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F9 >  Fehlerspeicher speichern"   ,20,45,0,1);
    }

    if (is_lesen_flag == TRUE)
    {
      ftextout("< F3 >  Infospeicher lesen"        , 8,5,0,1);
      if (is_loeschen_flag == TRUE) ftextout("< F4 >  Infospeicher löschen"      ,10,5,0,1);
      ftextout("< F8 >  Infospeicher drucken"      ,18,5,0,1);
      if (is_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F8 >  Infospeicher speichern"     ,18,45,0,1);
    }

    if (hs_lesen_flag == TRUE)
    {
      ftextout("< F5 >  Historienspeicher lesen"   ,12,5,0,1);
      if (hs_loeschen_flag == TRUE) ftextout("< F6 >  Historienspeicher löschen" ,14,5,0,1);
      ftextout("< F7 >  Historienspeicher drucken" ,16,5,0,1);
      if (hs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F7 >  Historienspeicher speichern",16,45,0,1);
    }
    ftextout("< F10>  Zurück"                    ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"            ,22,45,0,1);
  }
}
// -- EOF --
// end of :#include "bmw_std.src"

// Inbetriebnahmeablauf
// start of :#include "inb_70.src"
//**********************************************************************
// diese Datei wird als 'include' File in 'ARS_E65.SRC' aufgerufen
// diese Datei wird als 'include' File in 'ARS_60.SRC' aufgerufen
// diese Datei wird als 'include' File in 'ARS_70.SRC' aufgerufen
//
//* 16.02.2004 rd V1.00 Umstellung auf 32-Bit INPA
//*                     ELDI-Funktionen entfernt
//* 28.06.2005 sh V2.00 Kompletten Ablauf geaendert, wie unter CASCADE
//* 04.07.2005 ss V2.10 Ablauf entsprechend Entwickler angepasst
//* 07.07.2005 ss V2.11 Reset wieder eingefügt
//* 19.07.2005 sh V2.12 Motorsteuergerät "MSV80" hinzu
//* 01.12.2005 sh V2.13 Motorsteuergerät "D60M57A0" hinzu
//* 05.12.2005 sh V2.14 Motorsteuergerät "MSD80" hinzu
//* 16.12.2005 sh V2.15 Motorsteuergerät "N62_TUE2" hinzu
//* 16.01.2006 sh V2.16 Motorsteuergerät "D62M57A0" hinzu
//* 10.04.2006 sj V2.17 Motorsteuergerät "N73TU_R0" ergänzt           
//* 25.04.2006 an V2.18 Standwanken Ausgabe angepasst
//* 26.04.2006 an V2.19 F10 zurück verschoben und Rücksprungmenü geändert
//* 30.08.2006 sh V2.20 Neue Motorvariante hinzu, N73H_R0, 12 Zyl. Wasserstoff
//* 39.09.2006 sh V2.21 Neue Motorvariante hinzu, MSD85 (N63 8-Zylinder)
//* 11.05.2007 sh V2.22 Start/ Staop_Systemcheck für N73 Wasserstoffmotor hinzu
//* 19.10.2007 sh V1.30 Drehzahl auf 800 U/min reduziert , wegen Problemen bei der Inbetriebnahme, Kennlinienfehler
//* 23.01.2008 sh V1.31 Drehzahl wieder auf 905 U/min erhöht. Identisch mit Cascade.
//**********************************************************************
string fehler_inbetriebnahme = "";
string warnung_inbetriebnahme = "";
string zusatzinfo_inbetriebnahme = "";

string z1,z4;
string leer_string = "";

string fehlertext_1;
string fehlertext_2;
string zusatzinfotext;

// *****************************************************
// ********      Fuer Statistikfile        *************
// *****************************************************

string FG_NR   = "";
string FZG_TYP = "XX11";
string statistik_daten;
string statistik_file = "C:\ars_doku.dat";
string Uhrzeit = "hh:mm:ss";
string Datum = "dd.mm.yyyy";    

// *****************************************************

// Stringarrayvariablen
// Zusatzinfo bei der Inbetriebnahme
int handleStringArr_Zusatzinfo;
//
int    s1,s4;
int view_flag=0;

int farbe,hintergrund;
int state=0;
int sets;
int ErrorCode;
int APIBUSY  = 0;
int APIREADY = 1;
int APIBREAK = 2;
int APIERROR = 3;

// Stringarrayvariablen
// konnte Stringarry erfolgreich angelegt werden
bool b_handleStringArr_Zusatzinfo;
//
bool zuendung_ein_test = FALSE;
bool fehlerspeicher_loeschen = FALSE;

bool werte_va_lernen = FALSE;
bool werte_ha_lernen = FALSE;
bool werte_quer_lernen = FALSE;
/*
bool offset_werte_va = FALSE;
bool offset_werte_ha = FALSE;
bool offset_werte_quer = FALSE;
*/
bool status_leerlauf = FALSE;
bool motordrehzahl_vorgeben = FALSE;
bool status_erhoehte_drehzahl = FALSE;
bool start_inbetriebnahme_okay = FALSE;
bool inbetriebnahme= FALSE;
bool status_motor_aus = FALSE;            //DGF 16Jan2001
bool sg_reset = FALSE;                    // DGF 03Apr2001
bool ehc_bandmodus      = FALSE;    // wenn Fahrzeug mit EHC, dann Bandmodus setzen 
bool keine_luftfederung = FALSE;    
bool werte_va_schreiben = FALSE;    // Werte schreiben VA
bool werte_ha_schreiben = FALSE;    // Werte schreiben HA
bool werte_quer_schreiben = FALSE;  // Werte schreiben Querbeschleunigungssensor

bool ARS_TEST_OK = FALSE;
bool WEITER      = FALSE;

//
// externe Deklaration von Funktionen
//
meldung_1(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,7,5,1,1);     // Ausgabe Text Ablaufschritte
}

meldung_2(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,10,5,1,1);     // Ausgabe Text Ablaufschritte
}
meldung_3(in: string text)
{
  text = text+"                                                                                ";  // Platzhalter fuer Text
  ftextout(text,13,5,1,1);     // Ausgabe Text Ablaufschritte
}

meldung_4(in: string text)
{
  text = text+"  sec.    ";     // Platzhalter fuer Text
  ftextout(text,26,20,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}

//start DGF 16 Jan 2001
meldung_5(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,16,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}

meldung_6(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,19,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}
// ende DGF 16jan2001

meldung_7(in: string text)
{
  text = text+"             ";  // Platzhalter fuer Text
  ftextout(text,22,5,1,1);     // Ausgabe Laufzeit dynamische Pruefung
}


print_line(in: string text, in: int zeile, in: int spalte)
{
   if (zeile == 1) { z1 = text;   s1 = spalte; }
   if (zeile == 4) { z4 = text;   s4 = spalte; }
}


delete_line(in: int zeile)
{
   if (zeile == 1) { z1 = leer_string; }
   if (zeile == 4) { z4 = leer_string; }
}



action_box_open(in: string text1, in: string text2, in: string text3)
{
   userboxopen(1,8,0,14,89,"Arbeitshinweis", "");
   userboxftextout(1,text1,1,3,2,2);
   userboxftextout(1,text2,4,3,2,2);
   userboxftextout(1,text3,7,3,2,2);

}

action_box_meldung(in: string text1, in: string text2)
{
   userboxopen(1,8,0,14,89,"Meldung", "");
   userboxsetcolor(1,0,9);
   userboxftextout(1,text1,1,18,2,0);
   userboxftextout(1,text2,4,18,2,0);
}


//                                                                    
//                                Fehler            Warnungen         
action_box_meldung_inbetriebnahme(in: string text1, in: string text2 )
{
   int i = 0;
   int j = 0;
   int count;
//   string zusatzinfo_text = "";
   string zusatzinfo_text_action_box = "";
   StrArrayGetElementCount( handleStringArr_Zusatzinfo, count );


   userboxopen( 1, 4, 0, 30, 89, "Inbetriebnahme Meldungen", "" );
   userboxsetcolor( 1, 0, 9 );

   userboxftextout( 1, "Fehler:", 1, 1, 1, 0 );
   userboxftextout( 1, text1, 3, 1, 1, 0 );

   userboxftextout( 1, "Warnung:", 8, 1, 1, 0 );
   userboxftextout( 1, text2, 10, 1, 1, 0 );

   userboxftextout( 1, "Inbetriebnahme Zusatzinformation:", 15, 1, 1, 0 );

   while( i < count ) 
   {
     StrArrayRead( handleStringArr_Zusatzinfo, i, zusatzinfo_text_action_box );
     userboxftextout( 1, zusatzinfo_text_action_box, j + 16 , 1, 1, 0 );

     zusatzinfo_text_action_box = "";
     i = i + 1;
     j = j + 2;
   }
}


message_box_open(in: string meldetext1,in: string meldetext2,in: string meldetext3)
{
   userboxopen(2,8,0,14,89,"Meldung", "");
   userboxsetcolor(2,1,12);
   userboxftextout(2,meldetext1,1,3,2,1);
   userboxftextout(2,meldetext2,4,3,2,1);
   userboxftextout(2,meldetext3,7,3,2,1);
}

message_box_iO()
{
   farbe=10;   // hellgruen
   userboxopen(2,17,0,7,89,"Meldung", "");
   userboxsetcolor(2,1,farbe);
   userboxftextout(2,"i. O.",1,36,2,1);
   delay(300);
}

message_box_niO()
{
   farbe=4;    // rot
   start();
   userboxopen(2,17,0,7,89,"Meldung", "");
   userboxsetcolor(2,1,farbe);
   userboxftextout(2,"n. i. O.",1,36,2,1);
   delay(500);
}


action_box_close()
{
   userboxclose(1);
}

message_box_close()
{
   userboxclose(2);
}


delete_screen()
{
   action_box_close();
   message_box_close();
}

endebehandlung()
{

bool rc;              // return code vom Drucker
real drehzahl = 0;
string dh = "";
string sgbd_name = "";
string help_api_job0 = "";
string fg_nr = "";

int zustand=0;

// noch nicht aktiviert, erst testen

//    INPAapiJob(sgbd,"C_FG_LESEN",";0","");    
//    INPAapiResultText(fg_nr,"FG_NR",1,"");
 
    gettime(Uhrzeit);
    getdate(Datum);
    statistik_daten = Datum+","+Uhrzeit+","+FZG_TYP+","+fg_nr+","+fehlertext_1+","+fehlertext_2+","+zusatzinfotext+",";
    //fileopen(statistik_file,"a");
     
    if ( ARS_TEST_OK == TRUE )
    {
       fehlertext_1="";                         // Loeschen
       fehlertext_2="";                         // Loeschen
       statistik_daten = statistik_daten+"i.O";
    }
    else
    {
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "ARS Inbetriebnahme und Prüfung");
       PEMProtokollZeile (rc, "");
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_1);
       PEMProtokollZeile (rc, "Fehlertext :" + fehlertext_2);
       PEMProtokollZeile (rc, "Fehlertext :" + zusatzinfotext);
       PEMProtokollZeile (rc, "");

       statistik_daten = statistik_daten+"n.i.O";
    }

   //filewrite(statistik_daten);
   //fileclose();
   delay(500);
  
//  ***************************************************
//  ***     Motordrehzahl wieder zurücksetzen       ***
//  ***************************************************

    INPAapiJob("D_MOTOR","INITIALISIERUNG","","");
    INPAapiResultText(sgbd_name,"VARIANTE",0,"");         // Satz 0 ist richtig!

    if (( sgbd_name == "ME9E65_6" ) || ( sgbd_name == "N73_R0" ))      // Abfrage, ob 8 oder 12 Zylinder Benziner
    {         
       //infobox(sgbd_name,"ENDE_SYSTEMCHECK_LLERH");     // kann zu Testzwecken aktiviert werden

       help_api_job0 = "ENDE_SYSTEMCHECK_LLERH";          // Jobname für 8 Zylinder oder 12 Zylinder Benziner als Variable 
    }  
    else 
    {
      if (( sgbd_name == "MS450DS0" ) || ( sgbd_name == "ME9N62" )  || ( sgbd_name == "MSV70" ) ||     // 6 Zylinder, 8 Zylinder u. 6 Zyl. N52 VVT (NG6)
          ( sgbd_name == "ME9N62_2" ) || ( sgbd_name == "N62_TUE" ) || ( sgbd_name == "MSV80" ) ||     // Benziner
          ( sgbd_name == "MSD80" )    || ( sgbd_name == "N62_TUE2" )|| ( sgbd_name == "N73TU_R0" ) ||
          ( sgbd_name == "MSD85" )    || ( sgbd_name == "N73H_R0" ))                                    
      {                                                                                               
         //infobox(sgbd_name,"STOP_SYSTEMCHECK_LLERH");   // kann zu Testzwecken aktiviert werden

         help_api_job0 = "STOP_SYSTEMCHECK_LLERH";        // Jobname für 6 und 8 Zylinder Benziner als Variable 
      }
      else
      {
        if (( sgbd_name == "D50M57A0" ) || ( sgbd_name == "D50M57C0" ) || ( sgbd_name == "D50M57D0" ) ||   // 6 oder 8 Zylinder Diesel und Euro 4
            ( sgbd_name == "D51MM670" ) || ( sgbd_name == "D62M57B0" ) || ( sgbd_name == "D50M57E0" ) ||   // E65 und E60
            ( sgbd_name == "D63MM670" ) || ( sgbd_name == "D60M57D0" ) || ( sgbd_name == "D60M57A0" ) ||
            ( sgbd_name == "D62M57A0" ))
        {                                                                  

           //infobox(sgbd_name,"ABGLEICH_VERSTELLEN");    // kann zu Testzwecken aktiviert werden

           help_api_job0 = "ABGLEICH_VERSTELLEN";         // Jobname für Diesel als Variable   
           drehzahl = 0;                                  // Leerlaufdrehzahl 660 U/min, Differenz 0 vorgeben
           realtostring ( drehzahl, "3.0", dh );         
           dh = "LLA"+";"+dh;                             // es müssen 2 Argumente übergeben werden, LLA;0 
        } 
      }
    }
    //infobox(sgbd_name,help_api_job0);   // kann zu Testzwecken aktiviert werden

    job_state = "";  
    INPAapiJob( sgbd_name, help_api_job0, dh, "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");
    message_box_close();
    
    if (job_state == "OKAY")
    {
       message_box_open("Motordrehzahl zurücksetzen i.O.","","");
    }
    else  // *********** Jobstatus nicht OKAY   *************
    {
       message_box_open("Motordrehzahl zurücksetzen n.i.O.",help_api_job0,job_state);
    }
}    
   

//
//       **********************************************************
//       ***               S c r e e n a u f b a u              ***
//       ***   Darstellung und Aktualisierung des Bildschirms   ***
//       **********************************************************
SCREEN s_inbetriebnahme()
{
  ftextout( "ARS Inbetriebnahme und Pruefung", 2, 5, 2, 5 );
  delay ( 500 );
}   
//       **************************
//       ***    Pruefscreen      ***
//       **************************
SCREEN s_pruefung()
{
   ftextout("ARS Dynamische Funktionspruefung",2,5,2,5);
   setcolor(1, 8);   // gelb  mit schwarzer Schrift

}
//       ****************************************************
//       ***             M e n ü a u f b a u              ***
//       ****************************************************
// ***********************************
// *** ueber Menuepkt ANSTEUERN F6 ***
// ***********************************
// wird ueber F1 aktiviert in ARS_E65.SRC
// 
MENU m_inbetriebnahme()
 {
  INIT 
  {
    setmenutitle( "Auswahlmenue Funktion");
  }

  ITEM( 1, "Info" )  
  {
    infobox("Information","Programm zur Inbetriebnahme des ARS-Systems");
  }
  
  ITEM( 2, "Start" )  
  {
    setstatemachine( ARS_INBETRIEBNAHME );
  }
  
  ITEM( 3, "Stop" )  
  {
    setstatemachine( F10_ABBRUCH );
  }

  ITEM( 9, "Zurück" )
  {
     delete_screen();
     setcolor(1,0);
     setmenu (m_main);
     setscreen(s_steuern,TRUE);
         setmenu( m_steuern );
  }
  
  ITEM( 20, "Ende" )  
  {
    exit();
  }
}
//       ****************************************************
//       ****************************************************
//       ****************************************************
STATEMACHINE  F10_ABBRUCH()
{
  INIT
   {
     delete_screen();
     setcolor(1,4);
     message_box_open("Abbruch ARS Inbetriebnahme","","");
//     delay (2000);
     ARS_TEST_OK = FALSE;
     fehlertext_1 = "Abbruchtaste F10 gedrueckt";  
     endebehandlung();
   }
}

//   ************************************************************************
//   ***  S t a r t   S t a t e m a c h i n e   A b l a u f  G E S A M T  ***
//   ***                     Statemachine 1. Ebene                        ***
//   *************************************************************************


//
// Aufruf in MENU 'm_inbetriebnahme'
//
STATEMACHINE ARS_INBETRIEBNAHME()
{
  INIT
  {
    setstate ( ZUENDUNG );
  }

  // Schritt 1 - Abfrage, ob Zündung Ein 
  ZUENDUNG
  {
    // fehlerhafte Motordrehzahl verhindern
    meldung_1( "Zuendung Ein?" );

    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( IST_MOTOR_AUS );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 2
  // definiertes Druckniveau an den Ventilen herstellen
  IST_MOTOR_AUS
  {
    callstatemachine( MOTOR_STATUS_AUS );

    // Motor ist aus
    // Motordrehzahl ist korrekt
    // d.h. KEINE fehlerhafte Motordrehzahl
    if ( status_motor_aus == TRUE )
    {
      setstate ( SG_NICHT_EINSCHLAFEN );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3
  // vermeidet das Einschlafen des SG's am Bus
  SG_NICHT_EINSCHLAFEN
  {
    meldung_1( "Zuendung Ein?" );
    callstatemachine( STATUS_KL15 );                                    

    if ( zuendung_ein_test == TRUE )
    {
       setstate ( FEHLERSPEICHER_LOESCHEN_LESEN );
    }
    else
    {
       setstate ( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 3b
  FEHLERSPEICHER_LOESCHEN_LESEN
  {
     meldung_2( "Fehlerspeicher Loeschen" );  // DGF 16Jan2001
     callstatemachine( FEHLERSPEICHER );

     // Programmablauf wird um 5sec verzoegert
     //delay (5000);

     if (fehlerspeicher_loeschen == TRUE)
      {
        setstate( WERTE_VA_SCHREIBEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 4
  WERTE_VA_SCHREIBEN
  {
     callstatemachine( OFFSET_WERTE_VA_SCHREIBEN );

     if ( werte_va_schreiben == TRUE )
      {
         setstate( WERTE_HA_SCHREIBEN );
      }
     else
      {
         setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 5
  WERTE_HA_SCHREIBEN
  {
     callstatemachine( OFFSET_WERTE_HA_SCHREIBEN );

     if ( werte_ha_schreiben == TRUE )
      {
        setstate( WERTE_QUERBESCHL_SCHREIBEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 6
  WERTE_QUERBESCHL_SCHREIBEN
  {
     callstatemachine( QUERBESCHLEUNIGUNG_SCHREIBEN );

     if ( werte_quer_schreiben == TRUE )
     {
       setstate( OFFSET_WERTE_VA_LERNEN );
     }
     else
     {
       setstate( PRUEFUNG_AUSWERTUNG );
     }
  }

  //////////////////////////////////////////////////////////////////////////////////
  //        Beginn Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 7
  OFFSET_WERTE_VA_LERNEN
  {
     meldung_3( "Offsetwerte Vorderachse lernen" );
     callstatemachine( OFFSET_WERTE_VA );

     if ( werte_va_lernen == TRUE )
      {
         setstate( OFFSET_WERTE_HA_LERNEN );
      }
     else
      {
         setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 8
  OFFSET_WERTE_HA_LERNEN
  {
     meldung_5( "Offsetwerte Hinterachse lernen" );
     callstatemachine( OFFSET_WERTE_HA );

     if ( werte_ha_lernen == TRUE )
      {
        setstate( OFFSET_WERTE_QUERBESCHL_LERNEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 9
  OFFSET_WERTE_QUERBESCHL_LERNEN
  {
     meldung_6( "Offsetwerte Querbeschleunigung lernen" );
     callstatemachine( QUERBESCHLEUNIGUNG );

     if ( werte_quer_lernen == TRUE )
     {
       // Programmablauf wird um 2sec verzoegert
       //delay (2000);
       setstate( STEUERGERAETE_RESET ); 
     }
     else
     {
       setstate( PRUEFUNG_AUSWERTUNG );
     }
  }
  //////////////////////////////////////////////////////////////////////////////////
  //        Ende Sensorwerte lernen
  //////////////////////////////////////////////////////////////////////////////////

  // Schritt 10
  STEUERGERAETE_RESET
  {
    meldung_7( "Steuergeraete Reset erfolgt" );

    callstatemachine( SG_RESET );       // DGF 03.04.2001
    if ( sg_reset == TRUE )
    {
      setstate( STATUS_ABFRAGE_MOTOR );
    }
    else
    {
      setstate( PRUEFUNG_AUSWERTUNG );
    }
  }

  // Schritt 11
  //FEHLERSPEICHER_LOESCHEN_LESEN
  //{
  //   meldung_7( "Fehlerspeicher Loeschen" );  // DGF 16Jan2001
  //   callstatemachine( FEHLERSPEICHER );

     // Programmablauf wird um 5sec verzoegert
     //delay (5000);

  //   if (fehlerspeicher_loeschen == TRUE)
  //    {
  //      setstate( STATUS_ABFRAGE_MOTOR );
  //    }
  //   else
  //    {
  //      setstate( PRUEFUNG_AUSWERTUNG );
  //    }
  //}

  // Schritt 12
  STATUS_ABFRAGE_MOTOR
  {
     callstatemachine( MOTOR_STATUS );

     if ( status_leerlauf == TRUE )
     {
       setstate( MOTORDREHZAHL_VORGEBEN );
     }
    else
     {
       setstate( PRUEFUNG_AUSWERTUNG );
     }
  }


  // Schritt 13
  MOTORDREHZAHL_VORGEBEN
  {
     callstatemachine( MOTORDREHZAHL );

     if ( status_erhoehte_drehzahl == TRUE )
      {
         setstate( PRUEFUNG_STARTEN );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 14
  PRUEFUNG_STARTEN
  {
     callstatemachine( STANDWANKEN );

     if ( start_inbetriebnahme_okay == TRUE )
      {
        setstate( ABFRAGE_PRUEFABLAUF );
      }
     else
      {
        setstate( PRUEFUNG_AUSWERTUNG );
      }
  }

  // Schritt 15
  ABFRAGE_PRUEFABLAUF
  {
     callstatemachine( STATUS_STANDWANKEN );

     setstate( PRUEFUNG_AUSWERTUNG );
  }

  
  PRUEFUNG_AUSWERTUNG
  {
     callstatemachine( AUSWERTUNG );

     setstate( ENDE_PRUEFUNG );
  }
      
  ENDE_PRUEFUNG
  {
     endebehandlung();      // Dokumentation und Fehlerausdruck
  }
}

// Ende Statemachine "ARS_Inbetriebnahme", 1. Ebene, Pruefablauf gesamt 


// **********************************************************************
// **********  Statemachines  ARS_Inbetriebnahme 2. Ebene  **************
// **********      Aufruf Job's und Auswertungen           **************
// **********************************************************************

STATEMACHINE MOTOR_STATUS_AUS()
{

  real motor_laeuft;
//  int zaehler = 0;
  // Ausschaltzeit 30 sec.
  int zaehler = 30;  
  string zaehler_txt = "";
  string fehler_drehzahl_motor_wert_z = "";
  int fehler_drehzahl_motor_wert ;

  int zaehler_fehler_motor_drehzahl = 0;

  INIT
  {
     setcolor(1,8);   // gelb mit schwarzer Schrift
     action_box_open("Motor MUSS AUS sein!","","");
     setstate( STATUS_MOTORDREHZAHL_NULL );
  }


  STATUS_MOTORDREHZAHL_NULL
  {
    job_state="";
    INPAapiJob( sgbd ,"STATUS_CAN_DREHZAHL_ARS", "", "" );
    INPAapiResultAnalog(motor_laeuft,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout ( motor_laeuft, 24, 5, 0, 1500, 500, 1000, "4" );

    // Plausibilitaet der Motordrehzahl abpruefen
    // Ergebnis liegt nur als Zeichenkette vor

    if ( sgbd == "ARS_e65" ) 
    {
       INPAapiResultText( fehler_drehzahl_motor_wert_z, "FEHLER_DREHZAHL_MOTOR_WERT", 1, "");
       stringtoint( fehler_drehzahl_motor_wert_z, fehler_drehzahl_motor_wert );
    }
    else
    {
      if (( sgbd == "ARS_60" ) || ( sgbd == "ARS_70" )) 
      {
         INPAapiResultText( fehler_drehzahl_motor_wert_z, "STAT_FEHLER_DREHZAHL_MOTOR_WERT", 1, "");
         stringtoint( fehler_drehzahl_motor_wert_z, fehler_drehzahl_motor_wert );
      }
    }
    // Motordrehzahl ist korrekt
    // d.h. KEINE fehlerhafte Motordrehzahl
    if ( fehler_drehzahl_motor_wert == 0 )
    {
      // Motor ist AUS
      // keine Drehzahl, Wert '0' problematisch, daher 10 U/min
      if ( motor_laeuft < 10 ) 
      {
        status_motor_aus = TRUE;
        action_box_close();
        //delay(1500);
        returnstatemachine();
      }
      // Motoer laeuft
      else
      {           
        if ( zaehler > 0 )    // wenn Motor nach 30 sec. nicht aus ist, dann Ende
        {
          zaehler = zaehler - 1;
          delay(1000);
          setstate( STATUS_MOTORDREHZAHL_NULL );
  
          inttostring( zaehler, zaehler_txt );
          ftextout( "verbleibende Ausschaltzeit", 26, 40, 1, 1 );     
          meldung_4( zaehler_txt );
  
        }
        else
        {
          status_motor_aus = FALSE;
          fehlertext_1 = "Motor wurde nicht abgeschaltet";
          action_box_close();
          delay(5000);
          returnstatemachine();
        }   
      }
    }
    // fehlerhafte Motordrehzahl
    else
    {
      // Wartezeit ob das Motordrehzahlsignal noch gueltig wird
      // maximale Wartezeit 20 sec
      // 20 sec = 20 * 1000 msec
      if ( zaehler_fehler_motor_drehzahl < 20 )
      {
        // 1000 msec warten
        // 1 sec warten
        delay( 1000 );
        zaehler_fehler_motor_drehzahl = zaehler_fehler_motor_drehzahl + 1;

        // Statemachine nochmal durchlaufen
        setstate ( STATUS_MOTORDREHZAHL_NULL ); 
      }
      // Wartezeit 20 sec ist abgelaufen
      else
      {
        status_motor_aus = FALSE;
        fehlertext_1 = "Motordrehzahlsignal war ungueltig";
        action_box_close();
        delay(1000);
        returnstatemachine();

      }
    }
  }    
}

////////////////////////////////////////////////////////////////////////////////////////////////

//*******************************************************************************************
//  Werte werden mit dem Job ins SG geschrieben.
//  Uebergabe an SGBD... SG sensorwerte als --> '631;19250'
//*******************************************************************************************

STATEMACHINE OFFSET_WERTE_VA_SCHREIBEN()  // Schritt 1
{
  string sensorwerte_va   = "631;19250";    // Einheit [mV;mueV/bar]

    INIT
    {

       // Vorderachsewerte lernen
       // '631' --> Sensor Nullpkt.
       // '19250' --> Sensor Steigung
       INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_VA",sensorwerte_va, "" );
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");
       
       if (job_state == "OKAY")
        {
           werte_va_schreiben = TRUE;
           //delay(500);
           returnstatemachine();
        }
       else   // *****  Job Status nicht OKAY ***********
        {
           werte_va_schreiben = FALSE;
           fehlertext_1 = "Job Status Werte VA schreiben nicht OKAY";
           fehlertext_1 = job_state;
           returnstatemachine();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE OFFSET_WERTE_HA_SCHREIBEN()   // Schritt 2      
{
  string sensorwerte_ha   = "631;19250";     // Einheit [mV;mueV/bar]

    INIT
    {

       // Hinterachsewerte lernen
       // '631' --> Sensor Nullpkt.
       // '19250' --> Sensor Steigung
       INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HA",sensorwerte_ha, "" );
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");
       
       if (job_state == "OKAY")
        {
           werte_ha_schreiben = TRUE;
           //delay(500);
           returnstatemachine();
        }
       else   // *****  Job Status nicht OKAY ***********
        {
           werte_ha_schreiben = FALSE;
           fehlertext_1 = "Job Status Werte HA schreiben nicht OKAY";
           fehlertext_1 = job_state;
           returnstatemachine();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE QUERBESCHLEUNIGUNG_SCHREIBEN()   // Schritt 3
{
  string sensorwert_aquer = "2500;1750";        // Einheit [mV;mV/g] 

    INIT
    {

       // Querbeschleunigungswerte lernen
       // '2500' --> Sensor Nullpkt.
       // '1750' --> Sensor Steigung
       INPAapiJob( sgbd, "START_LERNEN_NEUE_WERTE_QUERBESCH",sensorwert_aquer, "" );
       INPAapiResultText(job_state, "JOB_STATUS", 1, "");
       
       if (job_state == "OKAY")
        {
           werte_quer_schreiben = TRUE;
           //delay(500);
           returnstatemachine();
        }
       else   // *****  Job Status nicht OKAY ***********
        {
           werte_quer_schreiben = FALSE;
           fehlertext_1 = "Job Status Werte Querbeschl. schreiben nicht OKAY";
           fehlertext_1 = job_state;
           returnstatemachine();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE OFFSET_WERTE_VA()  // Schritt 4, Sensorwerte lernen
{

    string error_job_state = "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR";

    INIT
    {

        job_state="";

        INPAapiJob(sgbd, "START_OFFSET_WERTE_VA", "", "" );
        INPAapiResultText(job_state,"JOB_STATUS",1,"");

        if (job_state == "OKAY")
         {
            werte_va_lernen = TRUE;
            digitalout(FALSE,13,62,"","i.O.");
            //delay(1000);
            returnstatemachine();
         }
        else  // *********** Jobstatus nicht OKAY   *************
         {
            werte_va_lernen = FALSE;
            if (job_state == error_job_state)
             {
                fehlertext_1 = "Job Status START_OFFSET_WERTE_VA nicht OKAY";
                fehlertext_2 = "Radgeschwind.(DSC), Offsetpegel oder Sensorwerte n.i.O.";
                returnstatemachine();
             }
            else
             { 
                fehlertext_1 = "Job Status START_OFFSET_WERTE_VA nicht OKAY";
                fehlertext_2 = job_state;
                returnstatemachine();
             }
         }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE OFFSET_WERTE_HA()  // Schritt 5, Sensorwerte lernen
{

  string error_job_state = "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR";

    INIT
    {

          job_state="";

          INPAapiJob( sgbd, "START_OFFSET_WERTE_HA", "", "" );
          INPAapiResultText(job_state,"JOB_STATUS",1,"");

          if (job_state == "OKAY")
           {
             werte_ha_lernen = TRUE;
             digitalout(FALSE,16,62,"","i.O.");
             //delay(1000);
             returnstatemachine();
           }
          else  // *********** Jobstatus nicht OKAY   *************
           {
             werte_ha_lernen = FALSE;

             if (job_state == error_job_state)
              {
                 fehlertext_1 = "Job Status START_OFFSET_WERTE_HA nicht OKAY";
                 fehlertext_2 = "Radgeschwind.(DSC), Offsetpegel oder Sensorwerte n.i.O.";
                 returnstatemachine();
              }
             else
              { 
                 fehlertext_1 = "Job Status START_OFFSET_WERTE_HA nicht OKAY";
                 fehlertext_2 = job_state;
                 returnstatemachine();
              }
           }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE QUERBESCHLEUNIGUNG()   // Schritt 6, Sensorwerte lernen
{

  string error_job_state = "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR";

    INIT
    {

        job_state="";

        INPAapiJob( sgbd, "START_OFFSET_QUERBESCH", "", "" );
        INPAapiResultText(job_state,"JOB_STATUS",1,"");

        if (job_state == "OKAY")
         {
            werte_quer_lernen = TRUE;
            digitalout(FALSE,19,62,"","i.O.");
            //delay(2000);
            returnstatemachine();
         }
        else  // *********** Jobstatus nicht OKAY   *************
         {
            werte_quer_lernen = FALSE;

            if (job_state == error_job_state)
             {
                fehlertext_1 = "Job Status START_OFFSET_QUERBESCH nicht OKAY";
                fehlertext_2 = "Radgeschwind.(DSC), Offsetpegel oder Sensorwerte  n.i.O.";
                returnstatemachine();
             }
            else
             { 
                fehlertext_1 = "Job Status START_OFFSET_QUERBESCH nicht OKAY";
                fehlertext_2 = job_state;
                returnstatemachine();
             }
         }
    }  
}

////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE SG_RESET()
{
  INIT
  {
    INPAapiJob( sgbd, "STEUERGERAETE_RESET", "", "" );
    INPAapiResultText(job_state, "JOB_STATUS", 1, "");
        
    if (job_state == "OKAY")
    {
      sg_reset = TRUE;
      digitalout(FALSE,22,62,"","i.O.");

      // Programmablauf wird um 3sec verzoegert
      delay (3000);

      returnstatemachine();

    } 
    else   // *****  Jobstatus nicht OKAY ***********
    {
      sg_reset = FALSE;
      fehlertext_1 = "Steuergeraete RESET NICHT OKAY";
      fehlertext_2 = job_state;
      returnstatemachine();
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE FEHLERSPEICHER()
{

  INIT
  {
//        infobox("Fehlerspeicher","loeschen");   // kann zu Testzwecken aktiviert werden
     
    INPAapiJob(sgbd,"FS_LOESCHEN","","");
    INPAapiResultText(job_state, "JOB_STATUS", 1, "");
          
    if (job_state == "OKAY")
    {
      fehlerspeicher_loeschen = TRUE;
      digitalout(FALSE,10,62,"","i.O.");
      //delay(1500);
      returnstatemachine();
    } 
    else   // *****  Jobstatus nicht OKAY ***********
    {
      fehlerspeicher_loeschen = FALSE;
      fehlertext_1 = "Fehlerspeicher loeschen NICHT OKAY";
      fehlertext_2 = job_state;
      returnstatemachine();
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

STATEMACHINE MOTOR_STATUS()
{

  real motor_laeuft;
  int zaehler = 120;
  string zaehler_txt = "";
 
  INIT
  {
    setcolor(1,8);   // gelb mit schwarzer Schrift
    ftextout("ARS Inbetriebnahme und Prüfung", 2,5,2,5);
    action_box_open("Bitte den Motor starten!","","");
    setstate(STATUS_MOTORDREHZAHL);
  }

  STATUS_MOTORDREHZAHL
  {
    job_state="";

    INPAapiJob(sgbd, "STATUS_CAN_DREHZAHL_ARS", "", "" );
    INPAapiResultAnalog(motor_laeuft,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout ( motor_laeuft, 26, 40, 0, 1500, 500, 1000, "4" );

    if ((motor_laeuft > 500) && (motor_laeuft < 1000))
    {
      status_leerlauf = TRUE;
      action_box_close();
      //delay(1500);
      returnstatemachine();
    }
    else
    {           
      if ( zaehler > 1 )    // wenn Motor nach 2 min. nicht laeuft, dann Ende
      {
        zaehler = zaehler - 1;
        inttostring( zaehler, zaehler_txt );
        ftextout ( "Wartezeit : ", 26, 5, 1 ,1 );
        ftextout ( "sec", 26, 27, 1 ,1 );
        meldung_4 ( zaehler_txt );
        delay(1000);
        setstate(STATUS_MOTORDREHZAHL);
      }
      else
      {
        status_leerlauf = FALSE;
        fehlertext_1 = "Motor laeuft nicht mit Leerlaufdrehzahl";
        action_box_close();
        returnstatemachine();
      }
    }   
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE MOTORDREHZAHL()
{
  real drehzahl = 0;
  string dh = "";
  string sgbd_name = "";
  string help_api_job0 = "";
  int zaehler = 0;
    
  INIT
  {
    message_box_open("Automatische Drehzahlerhöhung","","Motordrehzahl wird erhöht");
  
    setstate(MOTORDREHZAHL_VORGEBEN);
  }
        
  MOTORDREHZAHL_VORGEBEN
  {        
    INPAapiJob("D_MOTOR","INITIALISIERUNG","","");
    INPAapiResultText(sgbd_name,"VARIANTE",0,"");          // Satz 0 ist richtig!
//  infobox("DME Steuergeraet",sgbd_name);                 // kann zu Testzwecken aktiviert werden

//  "MSV70"        für 6 Zylinder N52 (NG6 VVT)
//  "MS450DS0"     für 6 Zylinder M54
//  "ME9E65_6"     für 8 Zylinder N62
//  "ME9N62"       für 8 Zylinder N62 neu ab 09/2003
//  "ME9N62_2"     für 8 Zylinder N62 ab 09/2004 E53, E6x 
//  "N73_R0"       für 12 Zylinder N73
//  "N73TU_R0"     für 8 Zylinder N73
//  "D50M57A0"     für 6 Zylinder Diesel M57 E65
//  "D50M57C0"     für 6 Zylinder Diesel M57 E6x
//  "D50M57D0"     für 6 Zylinder Diesel M57 E6x Euro 4
//  "D50M57E0"     für 6 Zylinder Diesel M57 E6x Euro 4
//  "D60M57D0"     für 6 Zylinder Diesel M57 E6x Euro 4
//  "D62M57B0"     für 6 Zylinder Diesel M57 TUE
//  "D51MM670"     für 8 Zylinder Diesel M67
//  "D62M57A0"     für 6 Zylinder Diesel M57 
//  "N73H_R0"      für 12 Zylinder E68 Wasserstoff

// ****************** 8 Zylinder und 12 Zylinder Benziner *******************

    if(  sgbd_name == "ME9E65_6" )  // unten eingefuegt  || ( sgbd_name == "N73_R0" ) || ( sgbd_name == "N73H_R0" ) )   // N62 oder N73 und Wasserstoff
    {
       help_api_job0 = "STEUERN_LL_ERH";            // Solldrehzahl 800 U/min 
       drehzahl = 80;                               // Faktor 10, max. 255 = 2550 U/min
       realtostring ( drehzahl, "3.0", dh );        
    }  

// ****************** 8 Zylinder Benziner N73_TU****************

    if( (sgbd_name == "N73TU_R0" ) || ( sgbd_name == "N73_R0" ) || ( sgbd_name == "N73H_R0" ) )   // N73 und N73 Wasserstoff
    {
       help_api_job0 = "START_SYSTEMCHECK_LLERH";            // Leerlaufdrehzahl erhöhen 
       drehzahl = 800;                                       // Solldrehzahl 800 U/min
       realtostring ( drehzahl, "3.0", dh );        
    }  
// ****************** 8 Zylinder Benziner N62 TUE *******************

    if( (sgbd_name == "ME9N62" ) || ( sgbd_name == "ME9N62_2" ) || ( sgbd_name == "N62_TUE" ) ||
        ( sgbd_name == "N62_TUE2" ) || ( sgbd_name == "MSD85" ))
    {
       help_api_job0 = "START_SYSTEMCHECK_LLERH";   // Leerlaufdrehzahl erhöhen                
       drehzahl = 800;                              // Solldrehzahl 800 U/min
       realtostring ( drehzahl, "3.0", dh );
    }  

// ****************** nur 6 Zylinder Benziner M54 *******************

    if( sgbd_name == "MS450DS0" )   // M54, 6 Zylinder Benziner 
    {
       help_api_job0 = "START_SYSTEMCHECK_LLERH";   // Leerlaufdrehzahl erhöhen               
       drehzahl = 850;                              // Solldrehzahl 850 U/min
       realtostring ( drehzahl, "3.0", dh );
    }  

// ****************** nur 6 Zylinder Benziner N52 (NG6 VVT) *******************

    if( ( sgbd_name == "MSV70" ) || ( sgbd_name == "MSV80" ) || ( sgbd_name == "MSD80" )) 
    {
       help_api_job0 = "START_SYSTEMCHECK_LLERH";   // Leerlaufdrehzahl erhöhen               
       drehzahl = 905;                              // Solldrehzahl 905 U/min
//       drehzahl = 800;                                // Drehzahl auf 800 U/min reduziert, 19.10.2007
                                                        // H. Kronbeck TD-426 wird die Motordrehzahl bei den betreffenden
                                                        // Varianten während der Inbetriebnahme auf 800/min absenken,
                                                        // bis eine entsprechende Korrektur der Codierdaten im Steuergerät stattgefunden hat.

       realtostring ( drehzahl, "3.0", dh );
    }  


// ****************** nur 6 Zylinder Diesel M57 *******************

    if( ( sgbd_name == "D50M57A0" ) || ( sgbd_name == "D50M57C0" )  || ( sgbd_name == "D50M57D0" )  ||  // 6 Zylinder Diesel E65, E6x
        ( sgbd_name == "D62M57B0" ) || ( sgbd_name == "D50M57E0" )  || ( sgbd_name == "D60M57D0" )  ||  // E70
        ( sgbd_name == "D60M57A0" ) || ( sgbd_name == "D62M57A0" )  )
    {
       help_api_job0 = "ABGLEICH_VERSTELLEN";
//     es müssen 2 Argumente übergeben werden, LLA;150 
       drehzahl = 250;                               // Leerlaufdrehzahl 660 U/min  plus 267 Umdrehungen
       realtostring ( drehzahl, "3.0", dh );         // Solldrehzahl 927 U/min
       dh = "LLA"+";"+dh;
    }

// ****************** nur 8 Zylinder Diesel M67 *******************

    if( ( sgbd_name == "D51MM670" ) || ( sgbd_name == "D63MM670" ) )  //  8 Zylinder Diesel/ 8 Zylinder Diesel 03/05
    {
       help_api_job0 = "ABGLEICH_VERSTELLEN";
//     es müssen 2 Argumente übergeben werden, LLA;150 
       drehzahl = 85;                                // Leerlaufdrehzahl 660 plus 85 Umdrehungen
       realtostring ( drehzahl, "3.0", dh );         // Solldrehzahl 745 U/min 
       dh = "LLA"+";"+dh;
    }

//  ****************************************************************
//  ***     Job aus Variablen zusammensetzen und abschicken      ***
//  ****************************************************************

    job_state = "";  
    INPAapiJob( sgbd_name, help_api_job0, dh, "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state == "OKAY")
    {
      message_box_close();
      delay(500);
      setstate (MOTORDREHZAHL_ABFRAGEN);
    }
    else  // *********** Jobstatus nicht OKAY   *************
    {
      status_erhoehte_drehzahl = FALSE;
      fehlertext_1 = "Drehzahl vorgeben";
      fehlertext_2 = job_state;
      returnstatemachine();
    }
  }


  MOTORDREHZAHL_ABFRAGEN
  { 
    //INPAapiJob("ARS_E65","STATUS_CAN_DREHZAHL_ARS","","");
    INPAapiJob( sgbd, "STATUS_CAN_DREHZAHL_ARS", "", "" );
    INPAapiResultAnalog(drehzahl,"STAT_DREHZAHL_MOTOR_WERT",1);
    analogout (drehzahl, 24, 5, 500, 2000, 700, 1000, "4" );

//    realtostring ( drehzahl, "4.0", dh );
//    infobox("aktuelle Motordrehzahl", dh);   // kann zu Testzwecken aktiviert werden

    if ((drehzahl > 700) && (drehzahl < 1000))     
    {
      status_erhoehte_drehzahl = TRUE;
      message_box_close();
  
      returnstatemachine();
    }
    else   // ***********   Motor hat Drehzahl noch nicht erreicht   *************
    {
      if (zaehler < 10)    // 10 sec warten 
      {
        zaehler = zaehler+1;
        delay (1000);
  
        setstate( MOTORDREHZAHL_ABFRAGEN);
      }
      else
      {
        status_erhoehte_drehzahl = FALSE;
        message_box_close();
        fehlertext_1 = "Erforderlche Drehzahl nicht erreicht";
        returnstatemachine();
      }
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE STANDWANKEN()
{

  INIT
  {
    message_box_open("Achtung!","Dynamische Pruefung","Fahrzeug bewegt sich");
  
    setstate(PRUEFUNG_STARTEN);
  }

  PRUEFUNG_STARTEN
  {
    job_state="";

    INPAapiJob( sgbd, "START_INBETRIEBNAHME", "", "" );
    INPAapiResultText(job_state,"JOB_STATUS",1,"");

    if (job_state == "OKAY")
    {
      start_inbetriebnahme_okay = TRUE;
      //delay(1500);
      returnstatemachine();
    }
    else  // *********** Jobstatus nicht OKAY   *************
    {
      start_inbetriebnahme_okay = FALSE;
      fehlertext_1 = "Start Inbetriebnahme";
      fehlertext_2 = job_state;
      message_box_close();
      returnstatemachine();
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE STATUS_STANDWANKEN()
{

  int zustand = 0;
  int fehler_code = 0;
  int zaehler = 0;
  int anzahl_zusatzinfo = 0;
  int i = 1;
  int warn_code_hex = 0;
 
  int length_of_string = 0;
  int pos = 0;
  int ab = 0;
  int aktpos = 0;
  int ende_von_string = 0;
  string zusatzinfo_ausgabe     = "";
  
  string zaehler_txt = "";
  //string fehler_inbetriebnahme = "";
  //string warnung_inbetriebnahme = "";
  string fehler_code_txt = "";
  string warn_code_hex_text = "";
  string var_result_text = "STAT_INBETRIEBNAHME_ZUSATZINFO_TEXT_";
  string zusatzinfotext_x = "";
  string result_zusatzinfotext_x = "";
  string fehlertext_zw = "";
  string result_var = "";

  INIT
  {
    setstate( STATUS_INBETRIEBNAHME );
  }


  STATUS_INBETRIEBNAHME
  {
    job_state = "";
    INPAapiJob( sgbd, "STATUS_INBETRIEBNAHME_ABFRAGEN", "", "" );
    INPAapiResultText( job_state, "JOB_STATUS", 1, "" );

    if ( job_state == "OKAY" )
    {
      delay( 100 );   // Verzoegerungszeit
      setstate ( STATUS_LESEN_BYTE_1 ); 
    }
    else  // *********** Jobstatus nicht OKAY  *************
    {
      inbetriebnahme = FALSE;
      fehlertext_1 = "Status Inbetriebnahme abfragen";
      fehlertext_2 = job_state;
      message_box_close();
      delay( 1500 );

      returnstatemachine();
    }
  } 


  STATUS_LESEN_BYTE_1      // ****** Abfrage, ob Test noch laeuft ******
  {
     INPAapiJob( sgbd, "STATUS_INBETRIEBNAHME_ABFRAGEN", "", "" );
//   Result E65: "ZUSTAND" / E60 und E70 anderer Resultname "STAT_ZUSTAND"

     if (sgbd == "ARS_E65")
     {
       result_var =  "ZUSTAND";
     }
     else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
     {
       result_var =  "STAT_ZUSTAND";
     }
     INPAapiResultInt( zustand, result_var, 1 );   

     if ( zustand == 0 )         // 0 = Pruefung laeuft, 1 = Pruefung fertig
     {
         if ( zaehler < 60 )     // max. Zeit vorgeben, dann Abbruch (1 min)
         {
           zaehler = zaehler + 1;
           inttostring( zaehler, zaehler_txt );
           ftextout("Pruefzeit",26,40,1,1);     
           meldung_4(zaehler_txt);
           delay(1000);                     // 1 sec warten, dann wieder lesen 
           setstate(STATUS_LESEN_BYTE_1);   // Inbetriebnahme ist fertig, Ergebnisse abfragen
         }
         else
         {
           inbetriebnahme = FALSE;
           fehlertext_1 = "Zeitueberschreitung Dynamische Pruefung";
           message_box_close();
           returnstatemachine();
         }
     }                
     else
     {
       INPAapiJob( sgbd, "STATUS_INBETRIEBNAHME_ABFRAGEN", "", "" );
       // E65 "FA_CODE_WERT" / E60 und E70 anderer Resultname "STAT_FA_CODE_WERT"

       if ( sgbd == "ARS_E65" )
       {
          result_var =  "FA_CODE_WERT";
       }
       else if (( sgbd == "ARS_60" ) || ( sgbd == "ARS_70" ))
       {
          result_var =  "STAT_FA_CODE_WERT";
       }
       INPAapiResultInt(fehler_code,result_var,1);   // Fehlercode auslesen
       
       result_var = "";

       if ( sgbd == "ARS_E65" )
       {
         result_var =  "WA_CODE_HEX";
       }
       else  if (( sgbd == "ARS_60" ) || ( sgbd == "ARS_70" ))
       {
         result_var =  "STAT_WA_CODE_HEX";
       }                                        
 
       INPAapiResultText( warn_code_hex_text, result_var, 1, "" );     
       stringtoint( warn_code_hex_text, warn_code_hex );

          // 0 = Pruefung i.O., 1 = Pruefung n.i.O.  
          // if ( fehler_code == 0 ) 
          //              siehe SGBD       daten[2] mit Filter verUNDen

          // alte Konvention bis VS1 FSV 6.3.0
          //
          //             daten[2]   daten[3]
          // 2 Byte ---> xxxx xxxZ  WWEEEEEE
          // alte i.o Version 'zustand = 1'
        
          // neue Konvention ab VS2 FSV 6.5.0
          //              daten[2]    daten[3]
          // 2 Byte ---> Zxxx PxUO  WWEE EEEE
          // neue i.o Version 'zustand = 128'
          // if ( ( fehler_code == 0 ) && (( zustand == 1 ) || ( zustand == 128 )) )    
          //
          if ( ( fehler_code == 0 ) && ( ( zustand == 1 ) || (( zustand >= 128 ) && ( zustand <= 139 )) ) )    
          {
             inttostring ( fehler_code , fehler_code_txt );
             //infobox ( "Inbetriebnahme IO", fehler_code_txt );

             // keine Warnungen nur Zusatzinfos vorhanden
             // keine Anzeige auf der Oberflaeche, die Zusatzinfo wird in die Datei
             // 'ARS_E65.DAT' eingetragen
             if ( warn_code_hex == 0 && zustand > 128 )
             {
                           if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_FEHLER_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_FEHLER_TEXT";
               }                                        
               
               INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
               fehlertext_1 = fehler_inbetriebnahme;

               if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_WARNUNG_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_WARNUNG_TEXT";
               }                                        
               
               INPAapiResultText( warnung_inbetriebnahme, result_var, 1, "" );
               fehlertext_2 = warnung_inbetriebnahme;

                if (sgbd == "ARS_E65")
                {
                   result_var =  "ANZ_ZUSATZINFOS";
                }
                else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
                {
                   result_var =  "STAT_ANZ_ZUSATZINFOS";
                }                                        
                
             INPAapiResultInt( anzahl_zusatzinfo, result_var, 1 );
             zusatzinfotext = "";
                
                //              bool Varible out            , int Variable out
                //              erzeugen erfolgreich        , HANDLE auf Array
                StrArrayCreate( b_handleStringArr_Zusatzinfo, handleStringArr_Zusatzinfo );
                // Speicherplatz erfolgreich reserviert ?
                if ( b_handleStringArr_Zusatzinfo == FALSE )
                  exit();

                                // Zusatzinformation als string abholen
                                INPAapiResultText( zusatzinfo_inbetriebnahme, "STAT_INBETRIEBNAHME_ZUSATZINFO_TEXT" , 1, "" );                   
                
                                // Länge des Zusatztextes
                strlen(length_of_string, zusatzinfo_inbetriebnahme);
                                
                                // Lesen der ersten Zusatzinfo
                                instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                aktpos = pos;
                                ab = pos + 1;
                                
                                // Lesen weiterer Zusatzinfos
                                while (ende_von_string < length_of_string)
                                {       
                            instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                    // Text Zusatzinfo gefunden und zeilenweise ausgeben
                                    if ( pos != -1)
                                    {
                                        ab = pos + 1; 
                                        ende_von_string = pos-2;
                                
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos, ende_von_string);
                        StrArrayWrite( handleStringArr_Zusatzinfo, i, zusatzinfo_ausgabe);

                                    aktpos = pos;
                                    }
                                        // Text Zusatzinfo nicht gefunden bzw. nicht mehr gefunden, letzten Kommentar ausgeben
                                    else
                                    {
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos , length_of_string);
                                    StrArrayWrite( handleStringArr_Zusatzinfo, i+1, zusatzinfo_ausgabe);
                                        ende_von_string = length_of_string;
                                    }
                                 
                                }
               
                           // 10 sec Anzeige auf dem Schirm
               callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );
               // StringArray wird geloescht
               StrArrayDestroy ( handleStringArr_Zusatzinfo );

             }   
             // nur in diesen beiden Faellen soll eine Anzeige auf dem 
             // Bildschirm erfolgen.
             //
             // vorhandene Warnungen werden angezeigt ( z.B. Luft im VA System )
             // es sind KEINE Zusatzinfos vorhanden d.h. 'zustand = 128'
             else if ( warn_code_hex != 0 && zustand == 128 )
             {
                            //              bool Varible out            , int Variable out
                //              erzeugen erfolgreich        , HANDLE auf Array
                StrArrayCreate( b_handleStringArr_Zusatzinfo, handleStringArr_Zusatzinfo );

                // Speicherplatz erfolgreich reserviert ?
                if ( b_handleStringArr_Zusatzinfo == FALSE )
                  exit();

               if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_FEHLER_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_FEHLER_TEXT";
               }                                        
               INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
               fehlertext_1 = fehler_inbetriebnahme;
           
               if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_WARNUNG_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_WARNUNG_TEXT";
               }                                        

               INPAapiResultText( warnung_inbetriebnahme, result_var, 1, "" );
               fehlertext_2 = warnung_inbetriebnahme;

                           // Ausgabe keine Zusatzinfo vorhanden
                           StrArrayWrite( handleStringArr_Zusatzinfo, 1, "keine Zusatzinfo bei Inbetriebnahme");

               // 10 sec Anzeige auf dem Schirm
               callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );
             
               // StringArray wird geloescht
               StrArrayDestroy ( handleStringArr_Zusatzinfo );

             }
             // vorhandene Warnungen werden angezeigt ( z.B. Luft im VA System )
             // es werden die vorhandenen Zusatzinfos angezeigt; d.h. 'zustand > 128'
             else if ( warn_code_hex != 0 && zustand > 128 )
             {

               if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_FEHLER_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_FEHLER_TEXT";
               }                                        
               
               INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
               fehlertext_1 = fehler_inbetriebnahme;

               if (sgbd == "ARS_E65")
               {
                 result_var =  "INBETRIEBNAHME_WARNUNG_TEXT";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
               result_var =  "STAT_INBETRIEBNAHME_WARNUNG_TEXT";
               }                                        
               
               INPAapiResultText( warnung_inbetriebnahme, result_var, 1, "" );
               fehlertext_2 = warnung_inbetriebnahme;

               if (sgbd == "ARS_E65")
               {
                 result_var =  "ANZ_ZUSATZINFOS";
               }
               else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
               {
                 result_var =  "STAT_ANZ_ZUSATZINFOS";
               }                                        
 
                /*  Zusatzinfoauswertung fuer Bildschirmdarstellung */
                INPAapiResultInt( anzahl_zusatzinfo, result_var, 1 );
                zusatzinfotext = "";
                
                //              bool Varible out            , int Variable out
                //              erzeugen erfolgreich        , HANDLE auf Array
                StrArrayCreate( b_handleStringArr_Zusatzinfo, handleStringArr_Zusatzinfo );
                // Speicherplatz erfolgreich reserviert ?
                if ( b_handleStringArr_Zusatzinfo == FALSE )
                  exit();
                
                                // Zusatzinformation als string abholen
                                INPAapiResultText( zusatzinfo_inbetriebnahme, "STAT_INBETRIEBNAHME_ZUSATZINFO_TEXT" , 1, "" );                   
                
                                // Länge des Zusatztextes
                strlen(length_of_string, zusatzinfo_inbetriebnahme);
                                
                                // Lesen der ersten Zusatzinfo
                                instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                aktpos = pos;
                                ab = pos + 1;
                                
                                // Lesen weiterer Zusatzinfos
                                while (ende_von_string < length_of_string)
                                {       
                            instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                    // Text Zusatzinfo gefunden und zeilenweise ausgeben
                                    if ( pos != -1)
                                    {
                                        ab = pos + 1; 
                                        ende_von_string = pos-2;
                                
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos, ende_von_string);
                        StrArrayWrite( handleStringArr_Zusatzinfo, i, zusatzinfo_ausgabe);

                                    aktpos = pos;
                                    }
                                        // Text Zusatzinfo nicht gefunden bzw. nicht mehr gefunden, letzten Kommentar ausgeben
                                    else
                                    {
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos , length_of_string);
                                    StrArrayWrite( handleStringArr_Zusatzinfo, i+1, zusatzinfo_ausgabe);
                                        ende_von_string = length_of_string;
                                    }

                                }
 
               // 10 sec Anzeige auf dem Schirm
               callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );
               // StringArray wird geloescht
               StrArrayDestroy ( handleStringArr_Zusatzinfo );
             }

             // fuer DEBUG Zwecke 
             //infobox("Inb Kurzmeldung","Inbetriebnahme TRUE");

             inbetriebnahme = TRUE;
             message_box_close();
             delay(1500);
             returnstatemachine();

          }
          // fehlerhafte Inbetriebnahme
          else
          {
             // fuer DEBUG Zwecke 
             //infobox("Inb Kurzmeldung","Inbetriebnahme FALSE");

             inbetriebnahme = FALSE;

             if (sgbd == "ARS_E65")
             {
               result_var =  "INBETRIEBNAHME_FEHLER_TEXT";
             }
             else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
             {
               result_var =  "STAT_INBETRIEBNAHME_FEHLER_TEXT";
             }                                        
 
             INPAapiResultText( fehler_inbetriebnahme, result_var , 1, "");      
             //infobox ( "Inbetriebnahmefehler", fehler_inbetriebnahme );
             fehlertext_1 = fehler_inbetriebnahme;
     
             if (sgbd == "ARS_E65")
             {
               result_var =  "INBETRIEBNAHME_WARNUNG_TEXT";
             }
             else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
             {
               result_var =  "STAT_INBETRIEBNAHME_WARNUNG_TEXT";
             }                                        

             INPAapiResultText( warnung_inbetriebnahme, result_var, 1, "" );
//                   infobox ( "Inbetriebnahmewarnung", warnung_inbetriebnahme );
             fehlertext_2 = warnung_inbetriebnahme;

              // ab VS2 Software --> FSV Stand 6.5.0
              // zusaetzliche Ausgabe fuer Fehlerspeicher
              // 'INBETRIEBNAHME_FEHLER_ERWEITERT_TEXT'
              if ( zustand > 1 )
              {
                if (sgbd == "ARS_E65")
                {
                  result_var =  "ANZ_ZUSATZINFOS";
                }
                else if ((sgbd == "ARS_60") || ( sgbd == "ARS_70" ))
                {
                  result_var =  "STAT_ANZ_ZUSATZINFOS";
                }                                        
 
                INPAapiResultInt( anzahl_zusatzinfo, result_var, 1 );
                zusatzinfotext = "";
                
                //              bool Varible out            , int Variable out
                //              erzeugen erfolgreich        , HANDLE auf Array
                StrArrayCreate( b_handleStringArr_Zusatzinfo, handleStringArr_Zusatzinfo );
                // Speicherplatz erfolgreich reserviert ?
                if ( b_handleStringArr_Zusatzinfo == FALSE )
                  exit();

                                // Zusatzinformation als string abholen
                                INPAapiResultText( zusatzinfo_inbetriebnahme, "STAT_INBETRIEBNAHME_ZUSATZINFO_TEXT" , 1, "" );                   
                
                                // Länge des Zusatztextes
                strlen(length_of_string, zusatzinfo_inbetriebnahme);
                                
                                // Lesen der ersten Zusatzinfo
                                instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                aktpos = pos;
                                ab = pos + 1;
                                
                                // Lesen weiterer Zusatzinfos
                                while (ende_von_string < length_of_string)
                                {       
                            instr(pos, ab, zusatzinfo_inbetriebnahme, "Zusatzinfo:");
                                    // Text Zusatzinfo gefunden und zeilenweise ausgeben
                                    if ( pos != -1)
                                    {
                                        ab = pos + 1; 
                                        ende_von_string = pos-2;
                                
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos, ende_von_string);
                        StrArrayWrite( handleStringArr_Zusatzinfo, i, zusatzinfo_ausgabe);

                                    aktpos = pos;
                                    }
                                        // Text Zusatzinfo nicht gefunden bzw. nicht mehr gefunden, letzten Kommentar ausgeben
                                    else
                                    {
                                        midstr(zusatzinfo_ausgabe, zusatzinfo_inbetriebnahme, aktpos , length_of_string);
                                    StrArrayWrite( handleStringArr_Zusatzinfo, i+1, zusatzinfo_ausgabe);
                                        ende_von_string = length_of_string;
                                    }

                                }
              //zusatzinfo_inbetriebnahme = "";
              //zusatzinfo_inbetriebnahme = zusatzinfotext;

              //infobox ( "Zusatzinfo Inbetriebnahme", zusatzinfotext );

              // 10 sec Anzeige auf dem Schirm
              callstatemachine ( WARNUNG_FEHLER_DARSTELLUNG );

              // StringArray wird geloescht
              StrArrayDestroy ( handleStringArr_Zusatzinfo );



             message_box_close();
             returnstatemachine();
          }
     }
  }
}
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE WARNUNG_FEHLER_DARSTELLUNG()
{
  INIT
  {
//    setcolor( 1, 4 );   // rot mit schwarzer Schrift
//    action_box_open( fehler_inbetriebnahme, warnung_inbetriebnahme, "" );
    action_box_meldung_inbetriebnahme ( fehler_inbetriebnahme, warnung_inbetriebnahme );
    // 10 sec. Anzeige auf dem Schirm
    delay ( 10000 );
    action_box_close();
    returnstatemachine();
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
STATEMACHINE AUSWERTUNG()     // Schritt 13, Prüfablauf auswerten
{
    INIT
    {
        
      if (( zuendung_ein_test == TRUE ) && ( status_motor_aus == TRUE ) && 
          ( werte_va_schreiben == TRUE ) && ( werte_ha_schreiben == TRUE ) && ( werte_quer_schreiben == TRUE ) &&
          ( werte_va_lernen == TRUE ) && ( werte_ha_lernen == TRUE ) && ( werte_quer_lernen == TRUE ) &&
          ( sg_reset == TRUE ) && ( fehlerspeicher_loeschen == TRUE ) && ( status_leerlauf == TRUE ) &&
          ( status_erhoehte_drehzahl == TRUE ) && ( start_inbetriebnahme_okay == TRUE ) &&
          ( inbetriebnahme == TRUE ))
       {
           ARS_TEST_OK = TRUE;
           setcolor(1,10);      // Bildschirm grün
           message_box_open("Ende Püfablauf","","Prüfung i.O.");
           delay(1500);
           returnstatemachine();
       }
      else  // *********** Pruefung nicht OKAY   *************
       {
           ARS_TEST_OK = FALSE;
           setcolor(1,4);       // Bildschirm rot

           message_box_open("Ende Püfablauf","","Prüfung n.i.O.");
           delay(1500);
           returnstatemachine();
       }
    }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///
///
////////////////////////////////////////////////////////////////////////////////////////////////
///

// Zuendung an/aus
STATEMACHINE STATUS_KL15()
{
  bool kl_15_ein = FALSE;
  // Ausschaltzeit 30 sec.
  int zaehler = 30;  
  string zaehler_txt = "";

  INIT
  {
//     setcolor( 1, 8 );   // gelb mit schwarzer Schrift
//     action_box_open( "Bitte Zuendung einschalten" ,"" ,"" );
     setstate( STATUS_KLEMME15_AUS );
  }

  STATUS_KLEMME15_AUS
  {
    INPAapiJob( "UTILITY", "STATUS_ZUENDUNG", "", "" );
    INPAapiResultDigital( kl_15_ein, "STAT_ZUENDUNG", 1 );
         
    if ( kl_15_ein == TRUE )
    {
      zuendung_ein_test = TRUE;
      digitalout(FALSE,7,62,"","i.O.");
      action_box_close();
      //delay( 1500 );
      returnstatemachine();
    }
    else   // *****  Zuendung ist faelschlicherweise aus ***********
    {
      setcolor( 1, 8 );   // gelb mit schwarzer Schrift
      action_box_open( "Bitte Zuendung einschalten" ,"" ,"" );

      if ( zaehler > 0 )    // wenn Zuendung nach 30 sec. nicht ein ist, dann Ende
      {
        zaehler = zaehler - 1;
        delay(1000);
        setstate( STATUS_KLEMME15_AUS );

        inttostring( zaehler, zaehler_txt );
        ftextout( "verbleibende Einschaltzeit", 26, 40, 1, 1 );     
        meldung_4( zaehler_txt );

      }
      else
      {
       zuendung_ein_test = FALSE;
       fehlertext_1 = "Zuendung ist aus";
       delay( 2000 );
       action_box_close();
       returnstatemachine();
      }
    }
  }
}
///
////////////////////////////////////////////////////////////////////////////////////////////////
///

// end of :#include "inb_70.src"

// *****************************************************
// ********   Bildschirm-Manager-Funktionen*************
// *****************************************************

ScriptInit()
{}

// ****************************************************
// ***             M e n ue a u f b a u              ***
// ****************************************************
// **************************
// *** Statusmenue         ***
// **************************
// wird ueber F5 aktiviert 'Status lesen'
MENU m_status()
{
  INIT 
  {
    setmenutitle("Status lesen");
  }
  
  ITEM( 1 ,"SG Reset")  
  {
    setscreen( s_sgreset, TRUE );
    setmenu( m_sgreset ) ;
  }

  ITEM( 2 ,"erw. Ident")  
  {
    toggle_1 = 1;
    setscreen( s_ars_ident, TRUE );
    setmenu( m_ars_ident );
  }

  ITEM( 3 ,"CAN Sig")  
  {
    setscreen( s_can_signale_uebersicht, TRUE );
    setmenu( m_can_signale ) ;
  }


  ITEM( 4 ,"Ventile")  
  {

    setscreen( s_ventile_status, TRUE );
    setmenu( m_ventile_status ) ;
  }

  ITEM( 5 ,"Sensorabgl.")  
  {
    setscreen( s_sensorabgleich, TRUE );
    setmenu( m_sensorabgleich_status ) ;
  }

  ITEM( 6 ,"Sensoren")  
  {
    setscreen( s_stati_sensor, TRUE);
    setmenu(  m_stati_sensor ) ;
  }


  ITEM( 7 ,"Versorgungen")  
  {
    setscreen( s_versorgungen, TRUE);
    setmenu(  m_stati_versorgungen ) ;
  }

  ITEM( 11 ,"AIF aktuell")  
  {
    setscreen( s_aif_aktuell_lesen, TRUE );
    setmenu( m_aif_aktuell_lesen ) ;
  }

  ITEM( 12 ,"AIF Tabelle")  
  {
    setscreen( s_aif_tabelle_lesen, TRUE );
    setmenu( m_aif_tabelle_lesen ) ;
  }


  ITEM( 13 ,"PAF DAF")  
  {
    setscreen( s_paf_daf_indizes, TRUE );
    setmenu( m_paf_daf_indizes ) ;
  }

  ITEM( 14 ,"Höhenst.abgl.")  
  {
    setscreen( s_hoehenstandabgleich,TRUE);
    setmenu( m_hoehenstandabgleich_status ) ;
  }

  ITEM( 8 ,"Drucken")  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_main, TRUE );
    setmenu( m_main );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// **************************
// *** Steuernmenue        ***
// **************************
// wird ueber F6 aktiviert 'Ansteuern'
MENU m_steuern()
{
  INIT 
  {
    setmenutitle("Steuern");
  }
 
  ITEM( 1 ,"Inbetriebnahme")  
  {
    // Implementierung des Screens und des Menues
    // siehe include File 'INB_ARS.SRC'
    setscreen( s_inbetriebnahme,TRUE);
    setmenu( m_inbetriebnahme ) ;
  }

  ITEM( 2 ,"Cockpit")  
  {
    setscreen( s_cockpit, TRUE );
    setmenu( m_cockpit ) ;
  }

  ITEM( 3 ,"Mehr Ventile")  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    setscreen( s_mehr_ventile_steuern, TRUE );
    setmenu( m_mehr_ventile_steuern ) ;
  }
  
  ITEM( 4 ,"Ventile bestr." )  
  {
    setscreen( s_ventile_steuern, TRUE );
    setmenu( m_ventile_steuern ) ;
  }

  ITEM( 5 ,"Rampenlogik")  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    setscreen( s_rampen_steuern, TRUE );
    setmenu( m_rampen_steuern ) ;
  }

  ITEM( 6 ,"Sensorabgl.")  
  {
    setscreen( s_sensorabgleich, TRUE );
    setmenu( m_sensorabgleich_steuern ) ;
  }

  ITEM( 7 ,"Höhenst.abgl.")  
  {
    setscreen( s_hoehenstandabgleich,TRUE);
    setmenu( m_hoehenstandabgleich_steuern ) ;
  }

  ITEM( 8 ,"Drucken")  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_main, TRUE );
    setmenu( m_main );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }

}

// *****************************************************
// *********************************
// *** ueber Menuepkt status F5 ***
// *********************************
// *******************************
// *** Steuergeraete Reset     ***
// *******************************
// wird ueber F1 aktiviert 
MENU m_sgreset()
{
  INIT 
  {
    setmenutitle( "Steuergeraete Reset" );
  }

  ITEM( 1, "SG reset")  
  {
      sg_reset_einmal = TRUE;
      setscreen( s_sgreset, TRUE );
  }


  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// **************************
// *** Identifikation     ***
// **************************
// wird ueber F2 aktiviert 
MENU m_ars_ident()
{
  INIT 
  {
    setmenutitle( "Identifikation Nacharbeitung" );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** PT CAN Signale          ***
// *******************************
// wird ueber F3 aktiviert 
MENU m_can_signale()
{
  INIT 
  {
    setmenutitle( "PT CAN Signale" );
  }

  ITEM( 1, "Allgemein" )  
  {
    allgemein = 1;
    geschw = 0;
    drehzahl = 0;
    beschl = 0;
    temperatur = 0;
    diverses = 0;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 2, "Geschw." )  
  {
    allgemein = 0;
    geschw = 1;
    drehzahl = 0;
    beschl = 0;
    temperatur = 0;
    diverses = 0;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 3, "Drehzahl" )  
  {
    allgemein = 0;
    geschw = 0;
    drehzahl = 1;
    beschl = 0;
    temperatur = 0;
    diverses = 0;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 4, "Beschl." )  
  {
    allgemein = 0;
    geschw = 0;
    drehzahl = 0;
    beschl = 1;
    temperatur = 0;
    diverses = 0;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 5, "Temp." )  
  {
    allgemein = 0;
    geschw = 0;
    drehzahl = 0;
    beschl = 0;
    temperatur = 1;
    diverses = 0;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 6, "Diverses" )  
  {
    allgemein = 0;
    geschw = 0;
    drehzahl = 0;
    beschl = 0;
    temperatur = 0;
    diverses = 1;
    hoehenstand = 0;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 7, "Höhenstände" )  
  {
    allgemein = 0;
    geschw = 0;
    drehzahl = 0;
    beschl = 0;
    temperatur = 0;
    diverses = 0;
    hoehenstand = 1;
    setscreen( s_can_signale, TRUE );
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *******************************
// *** Ventilemenue status     ***
// *******************************
// wird ueber F4 aktiviert 
MENU m_ventile_status()
{
  INIT 
  {
    setmenutitle("Ventile");
  }

  // Lesen
  ITEM( 1 ,"SV lesen")  
  {
    setscreen( s_sv_ventil, TRUE);
  }
  
  ITEM( 2 ,"RV lesen")  
  {
    setscreen( s_rv_ventil, TRUE);
  }

  ITEM( 3 ,"Prop VA lesen")  
  {
    setscreen( s_va_ventil, TRUE);
  }
  
  ITEM( 4 ,"Prop HA lesen")  
  {
    setscreen( s_ha_ventil, TRUE);
  }
  
  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// ************************************
// *** Sensorabgleichmenue 'STATUS' ***
// ************************************
// wird ueber F5 aktiviert 
MENU m_sensorabgleich_status()
{
  INIT 
  {
    setmenutitle("Sensorabgleichwerte auslesen");
  }

  // Lesen
  ITEM( 1 ,"Offsets lesen")  
  {
    setscreen( s_sensorabgleich , TRUE);
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
// ************************************
// *** Sensorabgleichmenue 'STATUS' ***
// ************************************
// wird ueber Shift F4 aktiviert 
MENU m_hoehenstandabgleich_status()
{
  INIT 
  {
    setmenutitle("Höhenstandswerte auslesen");
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}
// *******************************
// *** Stati Sensoren          ***
// *******************************
// wird ueber F6 aktiviert 
MENU m_stati_sensor()
{
  INIT 
  {
    setmenutitle( "Sensoren Status" );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *******************************
// *** Versorgungen            ***
// *******************************
// wird ueber F7 aktiviert 
MENU m_stati_versorgungen()
{
  INIT 
  {
    setmenutitle( "Versorgungen" );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** AIF UIF Aktuell lesen   ***
// *******************************
// wird ueber 'Shift F1' aktiviert 
MENU m_aif_aktuell_lesen()
{
  INIT 
  {
    setmenutitle( "Aktuelles AIF Info; ausgelesen ueber '1A 86'" );
  }

  ITEM( 8, "Print" )  
  {
    printscreen();
  }

  ITEM( 9, "zurueck" )  
  {
    userboxclose(0);
    viewclose();

    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *******************************
// *** AIF UIF Detail lesen    ***
// *******************************
// wird ueber 'Shift F2' aktiviert 
MENU m_aif_tabelle_lesen()
{
  INIT 
  {
    setmenutitle( "AIF Tabelle der bereits bestehenden Eintraege" );
  }

  ITEM( 1, "AIF 1" )  
  {
    aif_nr = 1;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 2, "AIF 2" )  
  {
    aif_nr = 2;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 3, "AIF 3" )  
  {
    aif_nr = 3;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }

  ITEM( 4, "AIF 4" )  
  {
    aif_nr = 4;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 5, "AIF 5" )  
  {
    aif_nr = 5;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 6, "AIF 6" )  
  {
    aif_nr = 6;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }

  ITEM( 7, "AIF 7" )  
  {
    aif_nr = 7;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 8, "AIF 8" )  
  {
    aif_nr = 8;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 9, "AIF 9" )  
  {
    aif_nr = 9;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }

  ITEM( 10, "AIF 10" )  
  {
    aif_nr = 10;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 11, "AIF 11" )  
  {
    aif_nr = 11;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }

  ITEM( 12, "AIF 12" )  
  {
    aif_nr = 12;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 13, "AIF 13" )  
  {
    aif_nr = 13;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }
  
  ITEM( 14, "AIF 14" )  
  {
    aif_nr = 14;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }


  ITEM( 15, "AIF 15" )  
  {
    aif_nr = 15;
    setscreen( s_aif_detail_lesen, TRUE );
    setmenu( m_aif_detail_lesen );
  }


  ITEM( 18, "Print" )  
  {
    printscreen();
  }

  ITEM( 19, "zurueck" )  
  {
    userboxclose(0);
    viewclose();

    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );
  }

  ITEM( 20, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** AIF UIF Detail lesen    ***
// *******************************
MENU m_aif_detail_lesen()
{
  INIT 
  {
    if ( aif_nr != 0 )
      setmenutitle( "Anwender Info Feld Detail lesen" );
    else
      setmenutitle( "Aktuelles AIF Info" );
    
  }

  ITEM( 8, "Print" )  
  {
    printscreen();
  }

  ITEM( 9, "zurueck" )  
  {
    userboxclose(0);
    viewclose();

    if ( aif_nr != 0 )
    {
//      setscreen( s_aif_lesen, TRUE );
//      setmenu( m_aif_lesen );
      setscreen( s_aif_tabelle_lesen, TRUE );
      setmenu( m_aif_tabelle_lesen );
    }
    else
    {
      setscreen( s_status, TRUE );
      setmenu( m_status );
    }

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ********************************************
// ***  PAF DAF Indizes darstellen (lesen)  ***
// ********************************************
// wird ueber 'Shift F3' aktiviert 
MENU m_paf_daf_indizes()
{
  INIT 
  {
    setmenutitle( "PAF und DAF Filenamen" );
  }


  ITEM( 8, "Print" )  
  {
    printscreen();
  }

  ITEM( 9, "zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_status, TRUE );
    setmenu( m_status );

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// **************************
// *** Cockpit Meldungen  ***
// **************************
// wird ueber F2 aktiviert 
MENU m_cockpit()
{
  INIT 
  {
    setmenutitle( "Cockpit Meldungen" );
  }


  ITEM( 1, "Ueb. ein" )  
  {
    toggle_1 = 1;
    setscreen( s_cockpit_anzeige, TRUE );
    setmenu( m_cockpit );
  }

  ITEM( 2, "Regel. ein" )  
  {
    toggle_2 = 2;
    setscreen( s_cockpit_anzeige, TRUE );
    setmenu( m_cockpit );
  }

  ITEM( 3, "Fail Safe" )  
  {
    toggle_3 = 3;
    setscreen( s_cockpit_anzeige, TRUE );
    setmenu( m_cockpit );
  }

  ITEM( 4, "Oelverlust" )  
  {
    toggle_4 = 4;
    setscreen( s_cockpit_anzeige, TRUE );
    setmenu( m_cockpit );
  }

  ITEM( 5, "FS temp" )  
  {
    toggle_5 = 5;
    setscreen( s_cockpit_anzeige, TRUE );
    setmenu( m_cockpit );
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Ventilemenue steuern    ***
// *** Mehrfachbestromung      ***
// *******************************
// wird ueber F3 aktiviert 
MENU m_mehr_ventile_steuern()
{
  INIT 
  {
    setmenutitle( "Simultanbestromung von SV,RV,PropVA,PropHA");
  }
  
  // Sicherheitsventil
  ITEM( 1, "SV EIN" )  
  {
    sv_ein_aus = TRUE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  ITEM( 2, "SV AUS" )  
  {
    sv_ein_aus = FALSE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  // Richtungsventil
  ITEM( 3, "RV EIN" )  
  {
    rv_ein_aus = TRUE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  ITEM( 4, "RV AUS" )  
  {
    rv_ein_aus = FALSE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  // Propventil Voderachse (VA) bestromen
  // Eingabe von Stromwert erforderlich
  ITEM( 5, "PropVA EIN" )  
  {
    // fuer einmaligen Aufruf der SGBD
    strom_va_1 = 1;
    PropVA_ein_aus = TRUE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  ITEM( 6, "PropVA AUS" )  
  {
    // fuer einmaligen Aufruf der SGBD
    strom_va_1 = 0;
    PropVA_ein_aus = FALSE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  // Propventil Voderachse (HA)
  // Eingabe von Stromwert erforderlich
  ITEM( 7, "PropHA EIN" )  
  {
    strom_ha_1 = 1;
    PropHA_ein_aus = TRUE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  ITEM( 8, "PropHA AUS" )  
  {
    strom_ha_1 = 0;
    PropHA_ein_aus = FALSE;
    setscreen( s_mehr_ventile_steuern, TRUE );
  }

  // Shift F8
  ITEM( 18, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    PropVA_ein_aus = FALSE;
    PropHA_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *******************************
// *** Ventilemenue steuern    ***
// ***      Rampenlogik        ***
// *******************************
// wird ueber F3 aktiviert 
MENU m_rampen_steuern()
{
  int int_eingabe_tmp;
  int int_eingabe_tmp2;

  INIT 
  {
    setmenutitle( "Rampenlogik fuer Ventilansteuerung");
  }
  
  // Sicherheitsventil
  ITEM( 1, "SV EIN" )  
  {
    sv_ein_aus = TRUE;
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 2, "SV AUS" )  
  {
    sv_ein_aus = FALSE;
    setscreen( s_rampen_steuern, TRUE );
  }

  // Richtungsventil
  ITEM( 3, "RV EIN" )  
  {
    rv_ein_aus = TRUE;
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 4, "RV AUS" )  
  {
    rv_ein_aus = FALSE;
    setscreen( s_rampen_steuern, TRUE );
  }

  // Propventil Voderachse (VA) bestromen
  // Eingabe von Rampenrichtung erforderlich
  ITEM( 5, "PropVA EIN" )  
  {
    // fuer einmaligen Aufruf der SGBD
    PropVA_ein_aus = TRUE;

    int_eingabe_tmp = va_ramp_art;
    inputint( int_eingabe_tmp, "Proportionalventil VA", 
             "Rampenrichtung (0 = Halt, 1 = Auf, 2 = Ab)", 0, 2 );
    getinputstate( input_state_VA );
    if ( input_state_VA == 0 ) {   va_ramp_art  = int_eingabe_tmp; }
    // Dialog schliessen
    userboxclose( 0 );
    viewclose();

    if(0 == va_ramp_zeit)
    {
        inputint( int_eingabe_tmp, "Proportionalventil VA", 
                  "Zeit ist Null, Neueingabe in 0.01 s", 0, 6000 );
        getinputstate( input_state_VA );
        if ( input_state_VA == 0 ) {   va_ramp_zeit  = int_eingabe_tmp; }
        userboxclose( 0 );
        viewclose();
    }
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 6, "PropVA AUS" )  
  {
    // fuer einmaligen Aufruf der SGBD
    PropVA_ein_aus = FALSE;
    va_ramp_art = 0;
    setscreen( s_rampen_steuern, TRUE );
  }

  // Propventil Voderachse (HA)
  // Eingabe von Stromwert erforderlich
  ITEM( 7, "PropHA EIN" )  
  {
    PropHA_ein_aus = TRUE;

    int_eingabe_tmp = ha_ramp_art;
    inputint( int_eingabe_tmp, "Proportionalventil HA", 
             "Rampenrichtung (0 = Halt, 1 = Auf, 2 = Ab)", 0, 2 );
    getinputstate( input_state_VA );
    if ( input_state_VA == 0 ) {   ha_ramp_art  = int_eingabe_tmp; }
    // Dialog schliessen
    userboxclose( 0 );
    viewclose();

    if(0 == ha_ramp_zeit)
    {
        inputint( int_eingabe_tmp, "Proportionalventil HA", 
                  "Zeit ist Null, Neueingabe in 0.01 s", 0, 6000 );
        getinputstate( input_state_VA );
        if ( input_state_VA == 0 ) {   ha_ramp_zeit  = int_eingabe_tmp; }
        userboxclose( 0 );
        viewclose();
    }

    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 8, "PropHA AUS" )  
  {
    PropHA_ein_aus = FALSE;
    ha_ramp_art = 0;
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 11, "Rampe EIN" )  
  {
    ramp_mode_ein_aus = TRUE;
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 12, "Rampe AUS" )  
  {
    ramp_mode_ein_aus = FALSE;
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 13, "Vorgabe Strom" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(0 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Strom", 
                    "Steuerstrom in mA, Rampe wird automatisch deaktiviert!", 
                    "Proportionalventil VA", "Proportionalventil HA", 0, 3000, 0, 3000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 0;
              warnung_erfolgt = FALSE;
              ramp_mode_ein_aus = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 0;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Strom", 
                    "Steuerstrom in mA", "Proportionalventil VA", "Proportionalventil HA",
                    0, 3000, 0, 3000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 14, "Vorgabe Druck" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(1 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Druck", 
                    "Steuerdruck in 0.1 bar, Rampe wird automatisch deaktiviert!",
                    "Proportionalventil VA", "Proportionalventil HA", 0, 2500, 0, 2500);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 1;
              ramp_mode_ein_aus = FALSE;
              warnung_erfolgt = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 1;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Druck", 
                    "Steuerdruck in 0.1 bar", "Proportionalventil VA", "Proportionalventil HA",
                    0, 2500, 0, 2500);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }

  ITEM( 15, "Vorgabe TV" )  
  {
    int_eingabe_tmp = va_ramp_wert;
    int_eingabe_tmp2 = ha_ramp_wert;
    if ((TRUE == ramp_mode_ein_aus)&&(2 != rampenvorgabe))
    {    // Vorgabenwechsen --> Warnung mit ausgeben!
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Tastverhältnis", 
                    "Tastverhältnis in 0.1 %, Rampe wird automatisch deaktiviert!", 
                    "Proportionalventil VA", "Proportionalventil HA", 0, 1000, 0, 1000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              rampenvorgabe = 2;
              ramp_mode_ein_aus = FALSE;
              warnung_erfolgt = FALSE;
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
         }
    }
    else
    {
         rampenvorgabe = 2;
         input2int( int_eingabe_tmp, int_eingabe_tmp2, "Rampenvorgabe Tastverhältnis", 
                    "Tastverhältnis in 0.1 %", "Proportionalventil VA", "Proportionalventil HA",
                    0, 1000, 0, 1000);
         getinputstate( input_state_VA );
         if ( input_state_VA == 0 )
         { // Eingabe wurde mit OK abgeschlossen, Eingabe uebernehmen
              va_ramp_wert = int_eingabe_tmp;
              ha_ramp_wert = int_eingabe_tmp2;
              warnung_erfolgt = FALSE;
         }
    }
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
    setscreen( s_rampen_steuern, TRUE );
  }
  
  ITEM( 16, "Rampenzeit" )  
  {
    int_eingabe_tmp = va_ramp_zeit;
    int_eingabe_tmp2 = ha_ramp_zeit;
    input2int( int_eingabe_tmp, int_eingabe_tmp2, "Vorgabe Rampenzeit",
                   "Rampenzeit in 0.01 s", "Proportionalventil VA", "Proportionalventil HA",
                   0, 6000, 0, 6000);

    getinputstate( input_state_VA );
    if ( input_state_VA == 0 )
    { // Eingabe uebernehmen
     va_ramp_zeit = int_eingabe_tmp;
     ha_ramp_zeit = int_eingabe_tmp2;
    }
    // Dialog schliessen
    userboxclose( 0 );
    viewclose();
    
    setscreen( s_rampen_steuern, TRUE );
  }
  // Shift F8
  ITEM( 18, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    sv_ein_aus = FALSE;
    rv_ein_aus = FALSE;
    ramp_mode_ein_aus = FALSE;
    PropVA_ein_aus = FALSE;
    PropHA_ein_aus = FALSE;
    strom_va_1 = 0;
    strom_ha_1 = 0;
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *******************************
// *** Ventilemenue steuern    ***
// *** Einzelbestromung        ***
// *******************************
// wird ueber F4 aktiviert 
MENU m_ventile_steuern()
{
  INIT 
  {
    setmenutitle("Ventile konstant und dauerhaft bestromen");
  }


  // Ventile ansteuern, bestromen
  ITEM( 4 ,"SV bestrom")  
  {
    strom_sv_ventil = 0;
    setscreen( s_sv_schreiben, TRUE);
    setmenu( m_sv_ventil_schreiben );
  }
  
  ITEM( 5 ,"RV bestrom")  
  {
    strom_rv_ventil = 0;
    setscreen( s_rv_schreiben, TRUE);
    setmenu( m_rv_ventil_schreiben );
  }

  ITEM( 6 ,"PropVA bestrom")  
  {
    strom_va_ventil = 0;
    setscreen( s_va_schreiben, TRUE);
    setmenu( m_va_ventil_schreiben );
  }
  
  ITEM( 7 ,"PropHA bestrom")  
  {
    strom_ha_ventil = 0;
    setscreen( s_ha_schreiben, TRUE);
    setmenu( m_ha_ventil_schreiben );
  }
  
  ITEM( 1, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// ************************************
// *** Sicherheitsventil schreiben  ***
// ************************************
MENU m_sv_ventil_schreiben()
{
  INIT 
  {
    setmenutitle( "Sicherheitsventil bestromen" );
  }

  // 
  ITEM( 1 ,"Strom mF")  
  {
    strom_sv_1 = 1;
    setscreen( s_sv1_ventil_schreiben, TRUE);
  }
  
  ITEM( 2 ,"Strom oF")  
  {
    strom_sv_2 = 1;
    setscreen( s_sv2_ventil_schreiben, TRUE);
  }

  ITEM( 3 ,"Hochlauf")  
  {
    strom_sv_3 = 1;
    setscreen( s_sv3_ventil_schreiben, TRUE);
  }
  
  ITEM( 4 ,"PushHold")  
  {
    // Sicherheitsventil wird nur einmal aufgerufen
    // wird nach nochmaligem Druecken erneut ausgefuehrt
    // nach 2 sec. wird die Bestromung eingestellt
    strom_sv_4 = 1;
    setscreen( s_sv4_ventil_schreiben, TRUE);
  }

  ITEM( 5 ,"Dauer PH")  
  {
    // Sicherheitsventil wird immer wieder zyklisch aufgerufen
    setscreen( s_sv_ventil_pushhold_dauer_schreiben, TRUE);
    setmenu( m_sv_ventil_pushhold_dauer_schreiben );
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_ventile_steuern, TRUE );
    setmenu( m_ventile_steuern );

    strom_sv_1 = 0;
    strom_sv_2 = 0;
    strom_sv_3 = 0;
    strom_sv_4 = 0;
    
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ************************************
// *** Sicherheitsventil schreiben  ***
// ************************************
MENU m_sv_ventil_pushhold_dauer_schreiben()
{
  INIT 
  {
    setmenutitle( "Sicherheitsventil wird dauerbestromt" );
  }

  ITEM( 1, "EIN" )  
  {
    sv_ein_aus = TRUE;
    setscreen( s_sv_ventil_pushhold_dauer_schreiben, TRUE );
  }

  ITEM( 2, "AUS" )  
  {
    sv_ein_aus = FALSE;
    setscreen( s_sv_ventil_pushhold_dauer_schreiben, TRUE );
  }


  ITEM( 8, "Print" )  
  {
    printscreen();
  }

  ITEM( 9, "zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_sv_schreiben, TRUE );
    setmenu( m_sv_ventil_schreiben );

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ************************************
// ***  Richtungsventil schreiben   ***
// ************************************
MENU m_rv_ventil_schreiben()
{
  INIT 
  {
    setmenutitle( "Richtungsventil bestromen" );
  }

  // 
  ITEM( 1 ,"Strom mF")  
  {
    strom_rv_1 = 1;
    setscreen( s_rv1_ventil_schreiben, TRUE);
  }
  
  ITEM( 2 ,"Strom oF")  
  {
    strom_rv_2 = 1;
    setscreen( s_rv2_ventil_schreiben, TRUE);
  }

  ITEM( 3 ,"Hochlauf")  
  {
    strom_rv_3 = 1;
    setscreen( s_rv3_ventil_schreiben, TRUE);
  }
  
  ITEM( 4 ,"PushHold")  
  {
    strom_rv_4 = 1;
    setscreen( s_rv4_ventil_schreiben, TRUE);
  }

  ITEM( 5 ,"Dauer PH")  
  {
    // Sicherheitsventil wird immer wieder zyklisch aufgerufen
    setscreen( s_rv_ventil_pushhold_dauer_schreiben, TRUE);
    setmenu( m_rv_ventil_pushhold_dauer_schreiben );
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_ventile_steuern, TRUE );
    setmenu( m_ventile_steuern );

    strom_rv_1 = 0;
    strom_rv_2 = 0;
    strom_rv_3 = 0;
    strom_rv_4 = 0;
    
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// ************************************
// *** Sicherheitsventil schreiben  ***
// ************************************
MENU m_rv_ventil_pushhold_dauer_schreiben()
{
  INIT 
  {
    setmenutitle( "Richtungsventil wird dauerbestromt" );
  }

  ITEM( 1, "EIN" )  
  {
    rv_ein_aus = TRUE;
    setscreen( s_rv_ventil_pushhold_dauer_schreiben, TRUE );
  }

  ITEM( 2, "AUS" )  
  {
    rv_ein_aus = FALSE;
    setscreen( s_rv_ventil_pushhold_dauer_schreiben, TRUE );
  }


  ITEM( 8, "Print" )  
  {
    printscreen();
  }

  ITEM( 9, "zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_rv_schreiben, TRUE );
    setmenu( m_rv_ventil_schreiben );

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ************************************
// ***  Propventil VA schreiben   ***
// ************************************
MENU m_va_ventil_schreiben()
{
  INIT 
  {
    setmenutitle( "Proportionalventil VA bestromen" );
  }

  // 
  ITEM( 1 ,"Strom mF")  
  {
    strom_va_1 = 1;
    setscreen( s_va1_ventil_schreiben, TRUE);
  }
  
  ITEM( 2 ,"Strom oF")  
  {
    strom_va_2 = 1;
    setscreen( s_va2_ventil_schreiben, TRUE);
  }

  ITEM( 3 ,"Hochlauf")  
  {
    strom_va_3 = 1;
    setscreen( s_va3_ventil_schreiben, TRUE);
  }
  

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_ventile_steuern, TRUE );
    setmenu( m_ventile_steuern );

    strom_va_1 = 0;
    strom_va_2 = 0;
    strom_va_3 = 0;
    
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// ************************************
// ***  Propventil HA schreiben   ***
// ************************************
MENU m_ha_ventil_schreiben()
{
  INIT 
  {
    setmenutitle( "Proportionalventil HA bestromen" );
  }

  // 
  ITEM( 1 ,"Strom mF")  
  {
    strom_ha_1 = 1;
    setscreen( s_ha1_ventil_schreiben, TRUE);
  }
  
  ITEM( 2 ,"Strom oF")  
  {
    strom_ha_2 = 1;
    setscreen( s_ha2_ventil_schreiben, TRUE);
  }

  ITEM( 3 ,"Hochlauf")  
  {
    strom_ha_3 = 1;
    setscreen( s_ha3_ventil_schreiben, TRUE);
  }
  

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_ventile_steuern, TRUE );
    setmenu( m_ventile_steuern );

    strom_ha_1 = 0;
    strom_ha_2 = 0;
    strom_ha_3 = 0;
    
  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}

// *************************************
// *** Sensorabgleichmenue 'STEUERN' ***
// *************************************
// wird ueber F6 aktiviert 
MENU m_sensorabgleich_steuern()
{
  INIT 
  {
    setmenutitle("Sensorabgleichwerte festlegen");
  }

  // Lesen
  ITEM( 1 ,"Offsets lesen")  
  {
    setscreen( s_sensorabgleich , TRUE);
  }


  // Lernen mit Grenzwertueberwachung
  ITEM( 3 ,"Null mG")  
  {
    toggle_1 = 0;
    toggle_2 = 0;
    toggle_3 = 0;

    setscreen( s_nullpkt_lernen , TRUE);
    setmenu( m_nullpkt_lernen );
  }
 
  ITEM( 11 ,"Para HA")  
  {
    para_lernen_4 = 1;
    setscreen( s_sensorabgleich , TRUE);
  }

  ITEM( 12 ,"Para VA")  
  {
    para_lernen_5 = 1;
    setscreen( s_sensorabgleich , TRUE);
  }

  ITEM( 13 ,"Para AQuer")  
  {
    para_lernen_6 = 1;
    setscreen( s_sensorabgleich , TRUE);
  }


  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }

  ITEM( 9, "Zurueck" )  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern, TRUE );
    setmenu( m_steuern );

    para_lernen_4 = 0;
    para_lernen_5 = 0;
    para_lernen_6 = 0;

  }

  ITEM( 10, "Ende" )  
  {
    exit();
  }
}


// *****************************************
// *** Höhenstandabgleichmenue 'STEUERN' ***
// *****************************************
// wird ueber F7 aktiviert 
MENU m_hoehenstandabgleich_steuern()
{
  INIT 
  {
    setmenutitle("Höhenstandslernwerte Abgleichen");
  }

  ITEM( 1 ,"Abgl vorne li")  
  {
    hs_abgleichen_1 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 2 ,"Abgl vorne re")  
  {
    hs_abgleichen_2 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 3 ,"Abgl hinten li")  
  {
    hs_abgleichen_3 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 4 ,"Abgl hinten re")  
  {
    hs_abgleichen_4 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 11 ,"Para vorne li")  
  {
    hs_abgleichen_5 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 12 ,"Para vorne re")  
  {
    hs_abgleichen_6 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 13 ,"Para hinten li")  
  {
    hs_abgleichen_7 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 14 ,"Para hinten re")  
  {
    hs_abgleichen_8 = 1;
    setscreen( s_hoehenstandabgleich , TRUE);
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }
  
  ITEM( 9 ,"Zurueck")  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_steuern ,TRUE);
    setmenu( m_steuern );

    hs_abgleichen_1 = 0;
    hs_abgleichen_2 = 0;
    hs_abgleichen_3 = 0;
    hs_abgleichen_4 = 0;
    hs_abgleichen_5 = 0;
    hs_abgleichen_6 = 0;
    hs_abgleichen_7 = 0;
    hs_abgleichen_8 = 0;


  }
}



// ****************************************
// *** Nullpunkte der Sensoren lernen   ***
// *** mit Grenzwertueberwachung        ***
// ****************************************
MENU m_nullpkt_lernen()
{
  INIT 
  {
    setmenutitle("Nullpunkte der Drucksensoren lernen");
  }

  ITEM( 1 ,"VA lernen")  
  {
    toggle_1 = 1;
    
    setscreen( s_nullpkt_lernen , TRUE);
  }

  // Lernen
  ITEM( 2 ,"HA lernen")  
  {
    toggle_2 = 1;

    setscreen( s_nullpkt_lernen , TRUE);
  }

  // Lernen
  ITEM( 3 ,"Quer lernen")  
  {
    toggle_3 = 1;

    setscreen( s_nullpkt_lernen , TRUE);
  }

  ITEM( 8, "Drucken" )  
  {
    printscreen();
  }
  
  ITEM( 9 ,"Zurueck")  
  {
    userboxclose(0);
    viewclose();
    setscreen( s_sensorabgleich ,TRUE);
    setmenu( m_sensorabgleich_steuern );

    toggle_1 = 0;
    toggle_2 = 0;
    toggle_3 = 0;

  }

  ITEM( 10 ,"Ende")  
  {
    exit();
  }
}


// *****************************************************
// *****************************************************


// ****************************************************
// ***             S c r e e n a u f b a u          ***
// ****************************************************
// **************************
// *** Statusscreen       ***
// **************************
// wird ueber F5 aktiviert 'STATUS'
SCREEN s_status()
{
  // Initialisierung
  string text_var = "";
  int status_ars;
  real stat_alive;

  ftextout("Status lesen", 1, 0, 1, 0 );
  ftextout("",2,0,0,0);

  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );


  INPAapiJob( sgbd, "IDENT", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

   LINE("","")
   {
      ftextout( "BMW Teilenummer", 1, 0, 0, 0 );
      ftextout( ":", 1, 19, 0, 0 );
      INPAapiResultText( text_var, "ID_BMW_NR", 1, "" );
      ftextout( text_var, 1, 20, 0, 1 );

      ftextout( "Herstelldatum", 1, 43, 0, 0 );
      ftextout( ":", 1, 53, 0, 0 );
      ftextout( "Tag / Monat / Jahr", 1, 68, 0, 0 );
//    ftextout( "/", 1, 55, 0, 1 );
    
      INPAapiResultText( text_var, "ID_DATUM_TAG", 1, "" );
      ftextout( text_var, 1, 55, 0, 1 );

      INPAapiResultText(text_var,"ID_DATUM_MONAT",1,"");
      ftextout(text_var, 1, 58, 0, 1 );

      INPAapiResultText( text_var, "ID_DATUM_JAHR", 1, "" );
      ftextout( text_var, 1, 61, 0, 1 );

      // linke Seite des Bildschirms
      ftextout( "< F1 >  SG Reset"                            ,  3, 5, 0, 1 );
      ftextout( "< F2 >  erweiterte Identifikation"           ,  5, 5, 0, 1 );
      ftextout( "< F3 >  CAN Signale"     
                          ,  7, 5, 0, 1 );
      ftextout( "< F4 >  Ventile"                             ,  9, 5, 0, 1 );
      ftextout( "< F5 >  Sensorabgleichwerte ( lesen )"       , 11, 5 ,0 ,1 );
      //
      ftextout( "< F6 >  Sensoren"                            , 13, 5, 0, 1 );
      ftextout( "< F7 >  Versorgungen"                        , 15, 5, 0, 1 );
      //
      ftextout( "< F8 >  Bildschirmdruck"                     , 19, 5, 0, 1 );
      ftextout( "< F9 >  Zurueck"                             , 21, 5, 0, 1 );
      ftextout( "< F10 > Ende"                                , 23, 5, 0, 1 );
      //
      //
      // rechte Seite des Bildschirms
      ftextout( "<Shift> + < F1 >  AIF aktuell (1A 86)"       , 3, 45, 0, 1 );
      ftextout( "<Shift> + < F2 >  AIF Tabelle"               , 5, 45, 0, 1 );
      ftextout( "<Shift> + < F3 >  PAF DAF"                   , 7, 45, 0, 1 );

      INPAapiCheckJobStatus( "OKAY" );

   }
}

// **************************
// *** Steuernscreen      ***
// **************************
// wurde ueber F6 aktiviert 'Ansteuern'
SCREEN s_steuern()
{
//  ftextout("ARS Inbetriebnahme und Pruefung", 2,5,2,5);
  // Initialisierung
  string text_var = "";
  int status_ars;
  real stat_alive;

  ftextout("Ansteuern",1,0,1,0);
  ftextout("",2,0,0,0);

  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );


  INPAapiJob( sgbd, "IDENT", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

   LINE("","")
   {
      ftextout( "BMW Teilenummer", 1, 0, 0, 0 );
      ftextout( ":", 1, 19, 0, 0 );
      INPAapiResultText( text_var, "ID_BMW_NR", 1, "" );
      ftextout( text_var, 1, 20, 0, 1 );

      ftextout( "Herstelldatum:", 1, 43, 0, 0 );
      ftextout( "Tag / Monat / Jahr", 1, 68, 0, 0 );
//    ftextout( "/", 1, 55, 0, 1 );
    
      INPAapiResultText( text_var, "ID_DATUM_TAG", 1, "" );
      ftextout( text_var, 1, 55, 0, 1 );

      INPAapiResultText(text_var,"ID_DATUM_MONAT",1,"");
      ftextout(text_var, 1, 58, 0, 1 );

      INPAapiResultText( text_var, "ID_DATUM_JAHR", 1, "" );
      ftextout( text_var, 1, 61, 0, 1 );

      ftextout( "< F1 >  Inbetriebnahmeablauf"                   ,  3, 5, 0, 1 );
      ftextout( "< F2 >  Cockpit Meldungen"                      ,  5, 5, 0, 1 );
      ftextout( "< F3 >  Ventile Mehrfachbestromung"           ,  7, 5, 0, 1 );
      ftextout( "< F4 >  Ventile Einzelbestromung"             ,  9, 5, 0, 1 );
      ftextout( "< F5 >  Rampenlogik fuer Ventilansteuerung" , 11, 5 ,0 ,1 );
      ftextout( "< F6 >  Sensorabgleichwerte ( lernen )"         , 13, 5 ,0 ,1 );
      ftextout( "< F7 >  Höhenstandabgleichwerte ( lernen )"     , 15, 5, 0, 1 );
      //
      ftextout( "< F8 >  Bildschirmdruck"                        , 19, 5, 0, 1 );
      ftextout( "< F9 >  Zurueck"                                , 21, 5, 0, 1 );
      ftextout( "< F10 > Ende"                                   , 23, 5, 0, 1 );

      INPAapiCheckJobStatus( "OKAY" );
   }
}


// *****************************
// *** Statusscreen Anzeigen ***
// *****************************
// ******************************
// *** Steuergeraete Reset    ***
// ******************************
// wird ueber F1 aktiviert 'SG reset'
SCREEN s_sgreset()
{
  int status_ars;
  real stat_alive;
  string text_var = "";
    
  ftextout( "Steuergeraete Reset durchfuehren", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0 ,0 );

  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );


  LINE( "","" )
  {
      if ( sg_reset_einmal == TRUE )
      {
        sg_reset_einmal = FALSE;
        INPAapiJob( sgbd, "STEUERGERAETE_RESET", "", "" );
        INPAapiCheckJobStatus( "OKAY" );
  
        ftextout( "Reset war erfolgreich", 1, 0, 1, 1 );
        ftextout( "", 3, 0, 0 ,0 );

        delay(2000);
      }
  }
}

// **************************
// *** Identscreen        ***
// **************************
// wird ueber F2 aktiviert 'erw. Ident'
SCREEN s_ars_ident()
{
  string text_1A87 = "";
  string text_1A91 = "";
  string text_zus = "";
  ftextout( "erweiterte Identifikations Informationen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  LINE( "","" )
  {

    // Linke Seite auf dem Bildschirm
//////////////////////////////////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "IDENT_HWNR_PHYS_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "physikalische Hardwarenummer (1A 87)", 0, 0, 0, 0 );
    ftextout( ":", 0, 29, 0, 0 );
    INPAapiResultText( text_1A87, "HWNR_PHYS", 1, "" );
    ftextout( text_1A87, 0, 31, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Herstelldatum
    INPAapiJob( sgbd, "IDENT", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "SG-Herstelldatum (1A 9D)", 2, 0, 0, 0 );
    ftextout( ":", 2, 29, 0, 0 );

    INPAapiResultText( text_var, "ID_DATUM_TAG", 1, "" );
    ftextout( text_var, 2, 31, 0, 0 );
    ftextout( ".", 2, 33, 0, 0 );

    INPAapiResultText( text_var, "ID_DATUM_MONAT", 1, "" );
    ftextout( text_var, 2, 35, 0, 0 );
    ftextout( ".", 2, 37, 0, 0 );

    INPAapiResultText( text_var, "ID_DATUM_JAHR", 1, "" );
    ftextout( text_var, 2, 39, 0, 0 );
    

//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Hardware Referenz auslesen
    INPAapiJob( sgbd, "HARDWARE_REFERENZ_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "gelesene HW Ref.(22 2502)", 4, 0, 0, 0 );
    ftextout( ":", 4, 29, 0, 0 );
    INPAapiResultText( text_var, "HARDWARE_REFERENZ", 1, "" );
    ftextout( text_var, 4, 31, 0, 0 );



//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Varaintenindex, BMW Teilenummer; Hardware* Nummer
    INPAapiJob( sgbd, "IDENT", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Varianten-Index (1A 97)", 6, 0, 0, 0 );
    ftextout( ":", 6, 29, 0, 0 );
    INPAapiResultText( text_var, "ID_VAR_INDEX", 1, "" );
    ftextout( text_var, 6, 31, 0, 0 );


    ftextout( "BMW Teilenummer = HW*Nr (1A 91)", 8, 0, 0, 0 );
    ftextout( ":", 8, 29, 0, 0 );
    INPAapiResultText( text_1A91, "ID_BMW_NR", 1, "" );
    ftextout( text_1A91, 8, 31, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Programm Refz. auslesen
    INPAapiJob( sgbd, "PROGRAMM_REFERENZ_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "gelesene Prg. Ref.(22 2503)", 10, 0, 0, 0 );
    ftextout( ":", 10, 29, 0, 0 );
    INPAapiResultText( text_var, "PROGRAMM_REFERENZ", 1, "" );
    ftextout( text_var, 10, 31, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Versionsnummers MCV, OSV, FSV, RES
    INPAapiJob( sgbd, "IDENT", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "MCV (1A 9F)", 12, 0, 0, 0 );
    ftextout( ":", 12, 29, 0, 0 );
    INPAapiResultText( text_var, "ID_SW_NR_MCV", 1, "" );
    ftextout( text_var, 12, 31, 0, 0 );
    ftextout( "Nachrichtenkatalog", 12, 36, 0, 0 );

    ftextout( "FSV (1A 9F)", 14, 0, 0, 0 );
    ftextout( ":", 14, 29, 0, 0 );
    INPAapiResultText( text_var, "ID_SW_NR_FSV", 1, "" );
    ftextout( text_var, 14, 31, 0, 0 );
    ftextout( "Funktionssoftware", 14, 36, 0, 0 );

    ftextout( "OSV (1A 9F)", 16, 0, 0, 0 );
    ftextout( ":", 16, 29, 0, 0 );
    INPAapiResultText( text_var, "ID_SW_NR_OSV", 1, "" );
    ftextout( text_var, 16, 31, 0, 0 );
    ftextout( "Betriebssystem", 16, 36, 0, 0 );

    ftextout( "RES (1A 9F)", 18, 0, 0, 0 );
    ftextout( ":", 18, 29, 0, 0 );
    INPAapiResultText( text_var, "ID_SW_NR_RES", 1, "" );
    ftextout( text_var, 18, 31, 0, 0 );
    ftextout( "SoftwareNummer", 18, 36, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Zusbaunummer
    INPAapiJob( sgbd, "AIF_LESEN", "0", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "ZusBauNummer (23 xx xx xx 07 40)", 20, 0, 0, 0 );
    ftextout( ":", 20, 29, 0, 0 );
    ftextout( "Teilergebnis des AnwenderInfoFeldes", 21, 0, 0, 0 );

    INPAapiResultText( text_zus, "AIF_ZB_NR", 1, "" );
    ftextout( text_zus, 20, 31, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Daten Referenz auslesen
    INPAapiJob( sgbd, "DATEN_REFERENZ_LESEN", "", "" );
    INPAapiCheckJobStatus( "ERROR_NO_DREF" );

    ftextout( "gelesene Daten Ref.(22 2504)", 23, 0, 0, 0 );
    ftextout( ":", 23, 29, 0, 0 );

    //INPAapiResultText( text_var, "DATEN_REFERENZ", 1, "" );
    ftextout( "ERROR_NO_DREF", 23, 31, 0, 0 );


    // Rechte Seite auf dem Bildschirm
    //
    //
//////////////////////////////////////////////////////////////////////////////////////////////////////
    // letztes Progrmmierdatum
    INPAapiJob( sgbd, "IDENT_PD_LESEN", "", "" );
    // TT.MM.JJJJ
    ftextout( "letztes Prog.datum (1A 99)", 0, 53, 0, 0 );
    ftextout( ":", 0, 73, 0, 0 );

    INPAapiResultText( text_var, "ID_DATUM", 1, "" );
    ftextout( text_var, 0, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Tag an dem mit Cabi und CBD Codierdatensatz progra. wurde
    INPAapiJob( sgbd, "DATENSATZ_COD_DATUM", "", "" );
    // TT.MM.JJ
    ftextout( "CBD Codierdatum vom", 2, 53, 0, 0 );
    ftextout( ":", 2, 73, 0, 0 );

    INPAapiResultText( text_var, "COD_DATUM_TAG", 1, "" );
    ftextout( text_var, 2, 75, 0, 0 );
    ftextout( ".", 2, 77, 0, 0 );

    INPAapiResultText( text_var, "COD_DATUM_MONAT", 1, "" );
    ftextout( text_var, 2, 78, 0, 0 );
    ftextout( ".", 2, 80, 0, 0 );

    INPAapiResultText( text_var, "COD_DATUM_JAHR", 1, "" );
    ftextout( text_var, 2, 81, 0, 0 );

    // Datensatzdatum
    // TT.MM.JJJJ
    ftextout( "Codierdatensatz vom", 4, 53, 0, 0 );
    ftextout( ":", 4, 73, 0, 0 );

    INPAapiResultText( text_var, "DATENSATZ_DATUM_TAG", 1, "" );
    ftextout( text_var, 4, 75, 0, 0 );
    ftextout( ".", 4, 77, 0, 0 );

    INPAapiResultText( text_var, "DATENSATZ_DATUM_MONAT", 1, "" );
    ftextout( text_var, 4, 78, 0, 0 );
    ftextout( ".", 4, 80, 0, 0 );

    INPAapiResultText( text_var, "DATENSATZ_DATUM_JAHR", 1, "" );
    ftextout( text_var, 4, 81, 0, 0 );

    

//////////////////////////////////////////////////////////////////////////////////////////////////////
    // SGBD Version
    INPAapiJob( sgbd, "INFO", "", "" );
  
    ftextout( "SGBD-Version", 6, 53, 0, 0 );
    ftextout( ":", 6, 73, 0, 0 );
    ftextout( sgbd_revision, 6, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lieferantenindex, Codierindex, Diagnoseindex
    INPAapiJob( sgbd, "IDENT", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Lieferant", 8, 53, 0, 0 );
    ftextout( ":", 8, 73, 0, 0 );
    INPAapiResultText( text_var, "ID_LIEF_TEXT", 1, "" );
    ftextout( text_var, 8, 75, 0, 0 );

    ftextout( "Lieferantennummer (1A 9E)", 10, 53, 0, 0 );
    ftextout( ":", 10, 73, 0, 0 );
    INPAapiResultText( text_var, "ID_LIEF_NR", 1, "" );
    ftextout( text_var, 10, 75, 0, 0 );

    ftextout( "Codier-Index (1A 9B)", 12, 53, 0, 0 );
    ftextout( ":", 12, 73, 0, 0 );
    INPAapiResultText( text_var, "ID_COD_INDEX", 1, "" );
    ftextout( text_var, 12, 75, 0, 0 );

    ftextout( "Diagnose-Index (1A 9C)", 14, 53, 0, 0 );
    ftextout( ":", 14, 73, 0, 0 );
    INPAapiResultText( text_var, "ID_DIAG_INDEX", 1, "" );
    ftextout( text_var, 14, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Aenderungsindex auslesen
    INPAapiJob( sgbd, "C_AEI_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Aenderungsindex (22 3FFF)", 16, 53, 0, 0 );
    ftextout( ":", 16, 73, 0, 0 );
    INPAapiResultText( text_var, "COD_AE_INDEX", 1, "" );
    ftextout( text_var, 16, 75, 0, 0 );
    
//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Fahrgestellnummer lesen
    INPAapiJob( sgbd, "C_FG_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    ftextout( "Fahrgestellnr. (7 stellig)", 18, 53, 0, 0 );
    ftextout( ":", 18, 73, 0, 0 );

    INPAapiResultText( text_var, "FG_NR", 1, "" );
    ftextout( text_var, 18, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Seriennummernummer lesen
    INPAapiJob( sgbd, "SERIENNUMMER_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    ftextout( "Seriennr. (1A 89) (9 stellig)", 20, 53, 0, 0 );
    ftextout( ":", 20, 73, 0, 0 );

    INPAapiResultText( text_var, "SERIENNUMMER", 1, "" );
    ftextout( text_var, 20, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Hardwaremusternummer auslesen
    INPAapiJob( sgbd, "IDENT_VMECUHVN_LESEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "HardwareNr.(1A 9A)", 23, 53, 0, 0 );
    ftextout( ":", 23, 73, 0, 0 );
    INPAapiResultText( text_var, "ID_HW_NR", 1, "" );
    ftextout( text_var, 23, 75, 0, 0 );


//////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nummerngleichheit pruefen
/*    if ( ( text_1A87 != text_1A91 || text_1A87 != text_zus || text_1A91 != text_zus ) && toggle_1 == 1 )
    {
      infobox( "Einnummernstrategie", "Nummern sind NICHT identisch; 1A87 <--> 1A91 <--> ZusBau" );
      // mehrmaligen Aufruf verhindern
      toggle_1 = 0;
    }*/
    
    
  }
}

// *********************************
// *** PT CAN Signale Uebersicht ***
// *********************************
// wird ueber F3 aktiviert 
SCREEN s_can_signale_uebersicht()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "PT CAN Signale", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0, 0 );
  
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  INPAapiResultText( text_var, "STAT_ALIVE_ZAEHLER_TEXT", 1, "" );
  ftextout( text_var, 3, 50, 0, 0 );


  ftextout( "SG Status", 5, 50, 0, 0 );
  ftextout( ":", 5, 58 , 0, 0 );

  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
     
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 5, 60, 0, 0 );

  LINE( "","" )
  {
    ftextout( "< F1 Allgemein>"                                  ,1, 5, 0, 0 );
    ftextout( "Zuendung, Anlasser, EDCK, ABS, DSC"             ,1, 25, 0, 0 );
 
    ftextout( "< F2 Geschwindigkeit>"                            ,3, 5, 0, 0 );
    ftextout( "Fahrzeuggeschw., Radgeschw. VL, VR, HL, HR"     ,3, 25, 0, 0 );
    
    ftextout( "< F3 Drehzahl>"                                   ,5, 5, 0, 0 );
    ftextout( "Motordrehzahl, Fehler Motordrehzahl"            ,5, 25, 0, 0 );

    ftextout( "< F4 Beschleunigung>"                             ,7, 5, 0, 0 );
    ftextout( "DSC Querbeschl., DSC Winkelbeschl."             ,7, 25, 0, 0 );
                                                                 
    ftextout( "< F5 Temperatur>"                           ,9, 5, 0, 0 );
    ftextout( "Außen-,Motor-, Innentemperatur"           ,9, 25, 0, 0 );

    ftextout( "< F6 Diverses>"                                             ,11, 5, 0, 0 );
    ftextout( "Kilometerstand, Lenkradwinkel, Rotorposition, Codierung"  ,11, 25, 0, 0 );

    ftextout( "< F7 Höhenstände>"                                          ,13, 5, 0, 0 );
    ftextout( "Höhenstände"                                              ,13, 25, 0, 0 );
  }
}

// **************************
// *** PT CAN Signale     ***
// **************************
// wird ueber F3 aktiviert 
SCREEN s_can_signale()
{
  int    offset_vl = 0;
  int    offset_vr = 0;
  int    offset_hl = 0;
  int    offset_hr = 0;
  int    steigung_vl = 0;
  int    steigung_vr = 0;
  int    steigung_hl = 0;
  int    steigung_hr = 0;
  int    nullpunkt_vl = 0;
  int    nullpunkt_vr = 0;
  int    nullpunkt_hl = 0;
  int    nullpunkt_hr = 0;
  int    abw_vl = 0;
  int    abw_vr = 0;
  int    abw_hl = 0;
  int    abw_hr = 0;
  real   tmpr = 0;
  real   tmpr_steig = 0;
  real   tmpr_null  = 0;
  string tmps = "";
  string tmpn = "";
  string offset_einh    = "no response";
  string offset_einh2   = "Einheitenfehler";
  string steigung_einh  = "no response";
  string nullpunkt_einh = "no response";
  
  string chk_jobstatus="";
  string err_jobstatus  = "none";

  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "PT CAN Signale", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0, 0 );
  
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  INPAapiResultText( text_var, "STAT_ALIVE_ZAEHLER_TEXT", 1, "" );
  ftextout( text_var, 3, 50, 0, 0 );


  ftextout( "SG Status", 5, 50, 0, 0 );
  ftextout( ":", 5, 58 , 0, 0 );

  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
     
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 5, 60, 0, 0 );


  LINE( "","" )
  {
    if ( allgemein == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_SIGNALE_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );


      ftextout( "CAN Wert Zuendung", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_KL15_NR_WERT", 1, "" );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_KL15_TEXT", 1, "" );
      ftextout( text_var, 1, 35, 0, 0 );


      ftextout( "CAN Wert Anlasser", 2, 1, 0, 0 );
      ftextout( ":", 2, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_KL50_NR_WERT", 1, "" );
      ftextout( text_var, 2, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_KL50_TEXT", 1, "" );
      ftextout( text_var, 2, 35, 0, 0 );


      ftextout( "CAN Wert Status DSC", 3, 1, 0, 0 );
      ftextout( ":", 3, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_DSC_WERT", 1, "" );
      ftextout( text_var, 3, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_DSC_EINH", 1, "" );
      ftextout( text_var, 3, 35, 0, 0 );


      /*  CAN Fehler Darstellung  */
/*      ftextout( "CAN Fehler Status Quitt Mot. ARS", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "FEHLER_QUITT_MOTOR_ARS_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "FEHLER_QUITT_MOTOR_ARS_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );*/

      ftextout( "CAN Fehler Klemme 15 (Zuendung)", 11, 1, 0, 0 );
      ftextout( ":", 11, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KL15_WERT", 1, "" );
      ftextout( text_var, 11, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KL15_TEXT", 1, "" );
      ftextout( text_var, 11, 42, 0, 0 );
      
      ftextout( "CAN Fehler Klemme 50 (Anlasser)", 12, 1, 0, 0 );
      ftextout( ":", 12, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KL50_WERT", 1, "" );
      ftextout( text_var, 12, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KL50_TEXT", 1, "" );
      ftextout( text_var, 12, 42, 0, 0 );

      ftextout( "CAN Fehler Status DSC", 13, 1, 0, 0 );
      ftextout( ":", 13, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DSC_WERT", 1, "" );
      ftextout( text_var, 13, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DSC_TEXT", 1, "" );
      ftextout( text_var, 13, 42, 0, 0 );
    }    

    if ( geschw == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_GESCHWINDIGKEIT_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert Fahrzeuggeschwindigkeit", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_GESCHWINDIGKEIT_FZG_WERT", 1, "" );
      // 
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "3.1" , text_var );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_GESCHWINDIGKEIT_FZG_EINH", 1, "" );
      ftextout( text_var, 1, 50, 0, 0 );


      /*  CAN Fehler Darstellung  */
      ftextout( "CAN Fehler Geschw. Fzg.", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_GESCHWINDIGKEIT_FZG_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_GESCHWINDIGKEIT_FZG_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );

    }

    if ( drehzahl == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_DREHZAHL_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert Motordrehzahl", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_DREHZAHL_MOTOR_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "4.1" , text_var );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_DREHZAHL_MOTOR_EINH", 1, "" );
      ftextout( text_var, 1, 50, 0, 0 );


      ftextout( "CAN Wert Fehler Motordrehzahl", 2, 1, 0, 0 );
      ftextout( ":", 2, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_DREHZAHL_MOTOR_FEHLER_WERT", 1, "" );
      ftextout( text_var, 2, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_DREHZAHL_MOTOR_FEHLER_EINH", 1, "" );
      ftextout( text_var, 2, 50, 0, 0 );

      /*  CAN Fehler Darstellung  */
      ftextout( "CAN Fehler Drehzahl Motor", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DREHZAHL_MOTOR_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DREHZAHL_MOTOR_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );

      ftextout( "CAN Fehler Drehzahl Motor Fehler", 11, 1, 0, 0 );
      ftextout( ":", 11, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DREHZAHL_MOTOR_FEHLER_WERT", 1, "" );
      ftextout( text_var, 11, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_DREHZAHL_MOTOR_FEHLER_TEXT", 1, "" );
      ftextout( text_var, 11, 42, 0, 0 );
    
    }    
    
    if ( beschl == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_BESCHLEUNIGUNG_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert DSC Querbeschl.", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_QUERBESCHL_DSC_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "1.3" , text_var );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_QUERBESCHL_DSC_EINH", 1, "" );
      ftextout( text_var, 1, 50, 0, 0 );


      ftextout( "CAN Wert DSC Winkelbeschl.", 2, 1, 0, 0 );
      ftextout( ":", 2, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_WINKELGESCHW_DSC_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "3.3" , text_var );
      ftextout( text_var, 2, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_WINKELGESCHW_DSC_EINH", 1, "" );
      ftextout( text_var, 2, 50, 0, 0 );

      /*  CAN Fehler Darstellung  */
      ftextout( "CAN Fehler Beschl.FZG Quer DSC", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_QUERBESCHL_DSC_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_QUERBESCHL_DSC_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );

      ftextout( "CAN Fehler Winkelgeschw. Gier DSC", 11, 1, 0, 0 );
      ftextout( ":", 11, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_WINKELGESCHW_DSC_WERT", 1, "" );
      ftextout( text_var, 11, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_WINKELGESCHW_DSC_TEXT", 1, "" );
      ftextout( text_var, 11, 42, 0, 0 );

      INPAapiJob( sgbd, "STATUS_ROSE_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Fehler STATUS ROSE ARS", 12, 1, 0, 0 );
      ftextout( ":", 12, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_QUERBESCHL_ROSE_WERT", 1, "" );
      ftextout( text_var, 12, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_QUERBESCHL_ROSE_TEXT", 1, "" );
      ftextout( text_var, 12, 42, 0, 0 );

      ftextout( "CAN Wert ROSE Querbeschl.", 3, 1, 0, 0 );
      ftextout( ":", 3, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_QUERBESCHL_ROSE_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "1.3" , text_var );
      ftextout( text_var, 3, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_QUERBESCHL_ROSE_EINH", 1, "" );
      ftextout( text_var, 3, 50, 0, 0 );

    }

    if ( temperatur == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_TEMP_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert Aussentemperatur", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_AUSSENTEMPERATUR_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 2 Vorkommastellen, 2 Nachkommastellen
      realtostring ( zahl_var, "2.2" , text_var );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_AUSSENTEMPERATUR_EINH", 1, "" );
      ftextout( text_var, 1, 50, 0, 0 );
    
      ftextout( "CAN Wert Motortemperatur", 2, 1, 0, 0 );
      ftextout( ":", 2, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_MOTORTEMPERATUR_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 2 Vorkommastellen, 2 Nachkommastellen
      realtostring ( zahl_var, "2.2" , text_var );
      ftextout( text_var, 2, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_MOTORTEMPERATUR_EINH", 1, "" );
      ftextout( text_var, 2, 50, 0, 0 );

      /*  CAN Fehler Darstellung  */
      ftextout( "CAN Fehler Aussentemperatur", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_AUSSENTEMPERATUR_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_AUSSENTEMPERATUR_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );

      ftextout( "CAN Fehler Motortemperatur", 11, 1, 0, 0 );
      ftextout( ":", 11, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_MOTORTEMPERATUR_WERT", 1, "" );
      ftextout( text_var, 11, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_MOTORTEMPERATUR_TEXT", 1, "" );
      ftextout( text_var, 11, 42, 0, 0 );

      /* zusätzlich Steuergeräte Innentemperatur */
      INPAapiJob( sgbd, "STATUS_SG_TEMP", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Steuergerät Innentemperatur", 4, 1, 0, 0 );
      ftextout( ":", 4, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_SG_TEMP_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 2 Vorkommastellen, 2 Nachkommastellen
      realtostring ( zahl_var, "2.2" , text_var );
      ftextout( text_var, 4, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_SG_TEMP_EINH", 1, "" );
      ftextout( text_var, 4, 50, 0, 0 );
    }    
    
    if ( diverses == 1 )
    {
      INPAapiJob( sgbd, "STATUS_CAN_DIVERSES_ARS", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert Kilometerstand", 1, 1, 0, 0 );
      ftextout( ":", 1, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_KILOMETERSTAND_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "6.1" , text_var );
      ftextout( text_var, 1, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_KILOMETERSTAND_EINH", 1, "" );
      ftextout( text_var, 1, 42, 0, 0 );


      ftextout( "CAN Wert Lenkradwinkel", 2, 1, 0, 0 );
      ftextout( ":", 2, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_LENKRADWINKEL_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "3.1" , text_var );
      ftextout( text_var, 2, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_LENKRADWINKEL_EINH", 1, "" );
      ftextout( text_var, 2, 42, 0, 0 );


      ftextout( "CAN Wert Fehler Lenkradwinkel", 3, 1, 0, 0 );
      ftextout( ":", 3, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_LENKRADWINKEL_FEHLER_NR", 1, "" );
      ftextout( text_var, 3, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_LENKRADWINKEL_FEHLER_TEXT", 1, "" );
      clearrect(9,40,1,40);
      ftextout( text_var, 3, 42, 0, 0 );

      /*  CAN Fehler Darstellung  */
      ftextout( "CAN Fehler Kilometerstand", 10, 1, 0, 0 );
      ftextout( ":", 10, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KILOMETERSTAND_WERT", 1, "" );
      ftextout( text_var, 10, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_KILOMETERSTAND_TEXT", 1, "" );
      ftextout( text_var, 10, 42, 0, 0 );


      ftextout( "CAN Fehler Lenkradwinkel", 11, 1, 0, 0 );
      ftextout( ":", 11, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_LENKRADWINKEL_WERT", 1, "" );
      ftextout( text_var, 11, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_LENKRADWINKEL_TEXT", 1, "" );
      ftextout( text_var, 11, 42, 0, 0 );


      ftextout( "CAN Fehler Lenkradwinkel Fehler", 12, 1, 0, 0 );
      ftextout( ":", 12, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_LENKRADWINKEL_FEHLER_WERT", 1, "" );
      ftextout( text_var, 12, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_LENKRADWINKEL_FEHLER_TEXT", 1, "" );
      ftextout( text_var, 12, 42, 0, 0 );


      /*zusätzlich Rotor Position */
      INPAapiJob( sgbd, "STATUS_CAN_ROTOR_POSITION", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "CAN Wert Rotorposition", 4, 1, 0, 0 );
      ftextout( ":", 4, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_ROTOR_POSITION_ACTUAL_VALUE_WERT", 1, "" );
      stringtoreal( text_var, zahl_var );
      // 4 Vorkommastellen, 1 Nachkommastellen
      realtostring ( zahl_var, "6.1" , text_var );
      ftextout( text_var, 4, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_ROTOR_POSITION_ACTUAL_VALUE_EINH", 1, "" );
      ftextout( text_var, 4, 42, 0, 0 );

      ftextout( "CAN Wert Status Rotorposition", 5, 1, 0, 0 );
      ftextout( ":", 5, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_ROTOR_POSITION_STAT_AFS_WERT", 1, "" );
      ftextout( text_var, 5, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_ROTOR_POSITION_STAT_AFS_TEXT", 1, "" );
      clearrect(11,40,1,40);
      ftextout( text_var, 5, 42, 0, 0 );

      ftextout( "CAN Wert Codierstring 2", 6, 1, 0, 0 );
      ftextout( ":", 6, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_CODSTR2_WERT", 1, "" );
      ftextout( text_var, 6, 32, 0, 0 );

      INPAapiResultText( text_var, "STAT_CODSTR2_TEXT", 1, "" );
      ftextout( text_var, 6, 42, 0, 0 );


      ftextout( "CAN Fehler Rotorposition", 13, 1, 0, 0 );
      ftextout( ":", 13, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_ROTOR_POSITION_ACTUAL_VALUE_WERT", 1, "" );
      ftextout( text_var, 13, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_ROTOR_POSITION_ACTUAL_VALUE_TEXT", 1, "" );
      ftextout( text_var, 13, 42, 0, 0 );

      ftextout( "CAN Fehler Status Rotorposition", 14, 1, 0, 0 );
      ftextout( ":", 14, 30, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_ROTOR_POSITION_STAT_WERT", 1, "" );
      ftextout( text_var, 14, 32, 0, 0 );
      INPAapiResultText( text_var, "STAT_FEHLER_ROTOR_POSITION_STAT_TEXT", 1, "" );
      ftextout( text_var, 14, 42, 0, 0 );

    }

    if ( hoehenstand == 1 )
    {

       INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "1", "" );
       INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
       if(chk_jobstatus == "OKAY")
       {
           INPAapiResultInt(  steigung_vl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
           INPAapiResultInt(  nullpunkt_vl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
           INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
           INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
       }
       else {
           err_jobstatus = chk_jobstatus;
       }

       INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "2", "" );
       INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
       if(chk_jobstatus == "OKAY")
       {
           INPAapiResultInt(  steigung_vr,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
           INPAapiResultInt(  nullpunkt_vr,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
       }
       else {
           err_jobstatus = chk_jobstatus;
       }

       INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "3", "" );
       INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
       if(chk_jobstatus == "OKAY")
       {
           INPAapiResultInt(  steigung_hl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
           INPAapiResultInt(  nullpunkt_hl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
       }
       else {
           err_jobstatus = chk_jobstatus;
       }

       INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "4", "" );
       INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
       if(chk_jobstatus == "OKAY")
       {
           INPAapiResultInt(  steigung_hr,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
           INPAapiResultInt(  nullpunkt_hr,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
       }

       INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_HGLV", "", "" );
       INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
       if(chk_jobstatus == "OKAY")
       {
           INPAapiResultInt(  offset_vl,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_FLH_WERT", 1 );
           INPAapiResultInt(  offset_vr,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_FRH_WERT", 1 );
           INPAapiResultInt(  offset_hl,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_RLH_WERT", 1 );
           INPAapiResultInt(  offset_hr,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_RRH_WERT", 1 );
           INPAapiResultText( offset_einh, "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_EINH", 1, "" );
       }
       else {
           err_jobstatus = chk_jobstatus;
       }

       // Ausgabe der Sensorwerte
       ftextout( "Sensornullpunkt Höhenstand VR", 6, 1, 0, 0 );
       ftextout( ":", 6, 22, 0, 0 );
       inttoreal(nullpunkt_vr, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 6, 24, 0, 0 );
       ftextout( nullpunkt_einh, 6, 30, 0, 0 );

       ftextout( "Sensorsteigung Höhenstand VR", 7, 1, 0, 0 );
       ftextout( ":", 7, 22, 0, 0 );
       inttoreal(steigung_vr, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 7, 24, 0, 0 );
       ftextout( steigung_einh, 7, 30, 0, 0 );

       ftextout( "Sensornullpunkt Höhenstand VL", 3, 1, 0, 0 );
       ftextout( ":", 3, 22, 0, 0 );
       inttoreal(nullpunkt_vl, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 3, 24, 0, 0 );
       ftextout( nullpunkt_einh, 3, 30, 0, 0 );

       ftextout( "Sensorsteigung Höhenstand VL", 4, 1, 0, 0 );
       ftextout( ":", 4, 22, 0, 0 );
       inttoreal(steigung_vl, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 4, 24, 0, 0 );
       ftextout( steigung_einh, 4, 30, 0, 0 );

       ftextout( "Sensornullpunkt Höhenstand HR", 12, 1, 0, 0 );
       ftextout( ":", 12, 22, 0, 0 );
       inttoreal(nullpunkt_hr, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 12, 24, 0, 0 );
       ftextout( nullpunkt_einh, 12, 30, 0, 0 );

       ftextout( "Sensorsteigung Höhenstand HR", 13, 1, 0, 0 );
       ftextout( ":", 13, 22, 0, 0 );
       inttoreal(steigung_hr, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 13, 24, 0, 0 );
       ftextout( steigung_einh, 13, 30, 0, 0 );

       ftextout( "Sensornullpunkt Höhenstand HL", 9, 1, 0, 0 );
       ftextout( ":", 9, 22, 0, 0 );
       inttoreal(nullpunkt_hl, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 9, 24, 0, 0 );
       ftextout( nullpunkt_einh, 9, 30, 0, 0 );

       ftextout( "Sensorsteigung Höhenstand HL", 10, 1, 0, 0 );
       ftextout( ":", 10, 22, 0, 0 );
       inttoreal(steigung_hl, tmpr);
       realtostring( tmpr, "5.0",text_var );
       ftextout( text_var, 10, 24, 0, 0 );
       ftextout( steigung_einh, 10, 30, 0, 0 );

       // Ausgabe Offsetwerte
       ftextout( "Offset VL", 3, 55, 0, 0 );
       ftextout( ":", 3, 62, 0, 0 );
       inttoreal(offset_vl, tmpr);
       inttoreal(steigung_vl, tmpr_steig);
       inttoreal(nullpunkt_vl, tmpr_null);
       offset_einh2 = offset_einh;
       if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
       {   // umskalieren von mV auf mm
           tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
           offset_einh2 = "mm";
       }
       realtostring (tmpr, "4.2", tmps);
       ftextout( tmps+" "+offset_einh2, 3, 64, 0, 0 );

       ftextout( "Offset VR",6, 55, 0, 0 );
       ftextout( ":", 6, 62, 0, 0 );
       inttoreal(offset_vr, tmpr);
       inttoreal(steigung_vr, tmpr_steig);
       inttoreal(nullpunkt_vr, tmpr_null);
       offset_einh2 = offset_einh;
       if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
       {   // umskalieren von mV auf mm
           tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
           offset_einh2 = "mm";
       }
       realtostring (tmpr, "4.2", tmps);
       ftextout( tmps+" "+offset_einh2, 6, 64, 0, 0 );

       ftextout( "Offset HL", 9, 55, 0, 0 );
       ftextout( ":", 9, 62, 0, 0 );
       inttoreal(offset_hl, tmpr);
       inttoreal(steigung_hl, tmpr_steig);
       inttoreal(nullpunkt_hl, tmpr_null);
       offset_einh2 = offset_einh;
       if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
       {   // umskalieren von mV auf mm
           tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
           offset_einh2 = "mm";
       }
       realtostring (tmpr, "4.2", tmps);
       ftextout( tmps+" "+offset_einh2, 9, 64, 0, 0 );

       ftextout( "Offset HR", 12, 55, 0, 0 );
       ftextout( ":", 12, 62, 0, 0 );
       inttoreal(offset_hr, tmpr);
       inttoreal(steigung_hr, tmpr_steig);
       inttoreal(nullpunkt_hr, tmpr_null);
       offset_einh2 = offset_einh;
       if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
       {   // umskalieren von mV auf mm
           tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
           offset_einh2 = "mm";
       }
       realtostring (tmpr, "4.2", tmps);
       ftextout( tmps+" "+offset_einh2, 12, 64, 0, 0 );
       }
  }
}

// ******************************
// ***   Ventile Status       ***
// ******************************
SCREEN s_ventile_status()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "Ventile", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0, 0 );
  
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  INPAapiResultText( text_var, "STAT_ALIVE_ZAEHLER_TEXT", 1, "" );
  ftextout( text_var, 3, 50, 0, 0 );


  ftextout( "SG Status", 5, 50, 0, 0 );
  ftextout( ":", 5, 58 , 0, 0 );

  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
     
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 5, 60, 0, 0 );

  LINE( "","" )
  {
  
    ftextout( "< F1 >  Sicherheitsventil lesen"         ,3, 5, 0, 1 );
    ftextout( "< F2 >  Richtungsventil lesen"           ,5, 5, 0, 1 );
    ftextout( "< F3 >  Proportionalventil VA lesen"        ,7, 5, 0, 1 );
    ftextout( "< F4 >  Proportionalventil HA lesen"        ,9, 5, 0, 1 );
  
  }
}

// ******************************
// ***   SV Ventil            ***
// ******************************
SCREEN s_sv_ventil()
{
  real strom_sv_ventil;
  real stat_querbesch;
  real stat_pwm_ventil;
  string text_var = "";

  ftextout( "Sicherheitsventil", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
    ftextout( ":", 5, 27, 0, 0 );
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
    ftextout( text_var, 5, 30, 0, 0 );

    // 'Fehlerzustaende' des Sicherheitsventils
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );


    ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
    ftextout( ":", 7, 27, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );

    ftextout( "Soll Strom Sicherheitsventil", 10, 5, 0, 0 );
    ftextout( ":", 10, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_SOLLSTROM_SICHVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_SICHVENT_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );

    ftextout( "Status PWM Sicherheitsventil", 13, 5, 0, 0 );
    ftextout( ":", 13, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_SICHVENT_WERT", 1 );
    //                         Zl, Sp, min  max          Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_SICHVENT_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );


    //************************************************************
    // physikalischer Wert
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Querbeschleunigung
    ftextout( "Querbeschleunigung (physik.)", 17, 5, 0, 0 );
    ftextout( ":", 17, 27, 0, 0 );
    // Querbeschleunigung auslesen
    INPAapiResultAnalog( stat_querbesch, "STAT_QUERBESCHL_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    analogout( stat_querbesch, 17, 30, -20, 20, -20, 20, "5.3" );

    // Einheit [g] / [m/s2]
    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_EINH", 1, "" );
    ftextout( text_var, 17, 65, 0, 0 );

/*
    //************************************************************
    // Rohwert
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Querbeschleunigung
    ftextout( "Querbeschleunigung (Roh)", 20, 5, 0, 0 );
    ftextout( ":", 20, 27, 0, 0 );
    // Querbeschleunigung auslesen
    INPAapiResultText( text_var, "STAT_QUERBESCHLSEN_WERT", 1, "" );
    ftextout( text_var, 20, 30, 0, 0 );

    // Einheit [10bit] Rohwert
    INPAapiResultText( text_var, "STAT_QUERBESCHLSEN_TEXT", 1, "" );
    ftextout( text_var, 20, 40, 0, 0 );
*/
  }
}

// ******************************
// ***   RV Ventil            ***
// ******************************
SCREEN s_rv_ventil()
{
  real strom_rv_ventil;
  real stat_pwm_ventil;
  real stat_querbesch;
  real stat_schaltstellung_RV;
  string text_var = "";

  ftextout( "Richtungsventile", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {

    //************************************************************
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
    ftextout( ":", 5, 27, 0, 0 );
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );    
    ftextout( text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );


    ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
    ftextout( ":", 7, 27, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Richtungsventil", 10, 5, 0, 0 );
    ftextout( ":", 10, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_SOLLSTROM_RICHTVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_RICHTVENT_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "Status PWM Richtungsventil", 13, 5, 0, 0 );
    ftextout( ":", 13, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_RICHTVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_RICHTVENT_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );

    //************************************************************


    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Querbeschleunigung
    ftextout( "Querbeschleunigung (physik.)", 17, 5, 0, 0 );
    ftextout( ":", 17, 27, 0, 0 );
    // Querbeschleunigung auslesen
    INPAapiResultAnalog( stat_querbesch, "STAT_QUERBESCHL_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    analogout( stat_querbesch, 17, 30, -20, 20, -20, 20, "5.3" );

    // Einheit [g] / [m/s2]
    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_EINH", 1, "" );
    ftextout( text_var, 17, 65, 0, 0 );



    //************************************************************
    // Schaltstellung RV [ -1, 0, 1 ]
    ftextout( "Schaltstellung RV", 21, 5, 0, 0 );
    ftextout( ":", 21, 27, 0, 0 );
    // Schaltstellung RV auslesen
    INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
    analogout( stat_schaltstellung_RV, 21, 30, -1.5, 1.5, -1, 1, "1" );

    // Einheit [Zustand]
    INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
    ftextout( text_var, 21, 65, 0, 0 );


  }
}


// ******************************
// ***   VA Ventil            ***
// ******************************
SCREEN s_va_ventil()
{
  real stat_istdruck_ventil;
  real stat_pwm_ventil;
  real strom_va_ventil;
  real stat_querbesch;
  string text_var = "";


  ftextout( "Proportionalventil VA", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil VA", 5, 5, 0, 0 );
    ftextout( ":", 5, 27, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
    ftextout( text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );



    ftextout( "Steuerstrom Propventil VA", 7, 5, 0, 0 );
    ftextout( ":", 7, 27, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_va_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Propventil VA", 10, 5, 0, 0 );
    ftextout( ":", 10, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_va_ventil, "STAT_SOLLSTROM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_va_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_VA_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "PWM Propventil VA", 13, 5, 0, 0 );
    ftextout( ":", 13, 27, 0, 0 );
    //
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_VA_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );

    //************************************************************


    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );


    // Ist Druck VA
    ftextout( "Ist Druck VA", 16, 5, 0, 0 );
    ftextout( ":", 16, 27, 0, 0 );
    //
    INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_VA_SW_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_istdruck_ventil, 16, 30, -2, 250, -2, 250, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCK_VA_SW_EINH", 1, "" );
    ftextout( text_var, 16, 65, 0, 0 );




    // Querbeschleunigung
    ftextout( "Querbeschleunigung (physik.)", 23, 5, 0, 0 );
    ftextout( ":", 23, 27, 0, 0 );
    // Querbeschleunigung auslesen
    INPAapiResultAnalog( stat_querbesch, "STAT_QUERBESCHL_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    analogout( stat_querbesch, 23, 30, -20, 20, -20, 20, "5.3" );

    // Einheit [g] / [m/s2]
    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_EINH", 1, "" );
    ftextout( text_var, 23, 65, 0, 0 );

  }
}

// ******************************
// ***   HA Ventil            ***
// ******************************
SCREEN s_ha_ventil()
{
  real stat_istdruck_ventil;
  real stat_pwm_ventil;
  real strom_ha_ventil;
  real stat_querbesch;
  string text_var = "";

  ftextout( "Proportionalventil HA", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );


  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil HA", 5, 5, 0, 0 );
    ftextout( ":", 5, 27, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
    ftextout( text_var, 5, 30, 0, 0 );

    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
    ftextout( text_var, 5, 40, 0, 0 );



    ftextout( "Steuerstrom Propventil HA", 7, 5, 0, 0 );
    ftextout( ":", 7, 27, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_ha_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
    ftextout( text_var, 7, 65, 0, 0 );



    ftextout( "Soll Strom Propventil VA", 10, 5, 0, 0 );
    ftextout( ":", 10, 27, 0, 0 );
    //Soll Stromwert auslesen
    INPAapiResultAnalog( strom_ha_ventil, "STAT_SOLLSTROM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_ha_ventil, 10, 30, 0, 3, 0, 3, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_SOLLSTROM_HA_EINH", 1, "" );
    ftextout( text_var, 10, 65, 0, 0 );



    ftextout( "PWM Propventil HA", 13, 5, 0, 0 );
    ftextout( ":", 13, 27, 0, 0 );
    //
    INPAapiResultAnalog( stat_pwm_ventil, "STAT_PWM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_pwm_ventil, 13, 30, 0, 100, 0, 100, "3.1" );

    // Einheit [%]
    INPAapiResultText( text_var, "STAT_PWM_HA_EINH", 1, "" );
    ftextout( text_var, 13, 65, 0, 0 );


    //************************************************************


    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );


    // Ist Druck HA
    ftextout( "Ist Druck HA", 16, 5, 0, 0 );
    ftextout( ":", 16, 27, 0, 0 );
    //
    INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_HA_SW_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_istdruck_ventil, 16, 30, -2, 250, -2, 250, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCK_HA_SW_EINH", 1, "" );
    ftextout( text_var, 16, 65, 0, 0 );



    // Querbeschleunigung
    ftextout( "Querbeschleunigung (physik.)", 23, 5, 0, 0 );
    ftextout( ":", 23, 27, 0, 0 );
    // Querbeschleunigung auslesen
    INPAapiResultAnalog( stat_querbesch, "STAT_QUERBESCHL_SW_WERT", 1 );
    //                         Zl, Sp, min  max           Format
    analogout( stat_querbesch, 23, 30, -20, 20, -20, 20, "5.3" );

    // Einheit [g] / [m/s2]
    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_EINH", 1, "" );
    ftextout( text_var, 23, 65, 0, 0 );

  }
}

// ******************************
// ***    Ventilabgleich      ***
// ******************************
SCREEN s_sensorabgleich()
{
  real stat_offsetdruck_ventil;
  real stat_offsetquerbesch;
  real stat_dynoffsetquerbesch;
  real stat_sensorpara;
  real tmpr = 0;
  int stat_steigung;
  string text_var = "";

  int sensor_nullpunkt = 0;
  int sensor_steigung = 0;
  int input_state_key_1 = 0;
  
  string err_jobstatus = "";
  string chk_jobstatus = "";
  string sensor_nullpunkt_einh = "";
  string sensor_steigung_einh = "";
  string tmpn = "";
  string tmps = "";

        
  ftextout( "Sensorabgleich", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {

    // gelernter Offset Wert lesen fuer Nullpunkt Druck VA
    INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_VA", "", "" );
    INPAapiCheckJobStatus( "OKAY" );


    // Druck VA
    ftextout( "Arbeitsnullpunkt fuer Druck VA", 1, 1, 0, 0 );
    ftextout( ":", 1, 35, 0, 0 );
    //
    INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_NULLPUNKT_OFFSET_DRUCK_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_offsetdruck_ventil, 1, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_DRUCK_VA_EINH", 1, "" );
    ftextout( text_var, 1, 75, 0, 0 );



    // gelernter Offset Wert lesen fuer Nullpunkt Druck HA
    INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_HA", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
    // Druck HA
    ftextout( "Arbeitsnullpunkt fuer Druck HA", 3, 1, 0, 0 );
    ftextout( ":", 3, 35, 0, 0 );
    //
    INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_NULLPUNKT_OFFSET_DRUCK_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_offsetdruck_ventil, 3, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_DRUCK_HA_EINH", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );

    // gelernter Offset Wert lesen fuer Querbeschleunigung
    INPAapiJob( sgbd, "STATUS_OFFSET_QUERBESCH", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Querbeschleunigung
    ftextout( "Arbeitsnullpunkt fuer Querbeschleunigung", 5, 1, 0, 0 );
    ftextout( ":", 5, 35, 0, 0 );

    // Querbeschleunigung
    ftextout( "Dynamischer Nullpunkt für Querbeschleunigung",7, 1, 0, 0 );
    ftextout( ":", 7, 35, 0, 0 );

    //
    INPAapiResultAnalog( stat_offsetquerbesch, "STAT_NULLPUNKT_OFFSET_QUERBESCH_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_offsetquerbesch, 5, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [mV]
    INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_QUERBESCH_EINH", 1, "" );
    ftextout( text_var, 5, 75, 0, 0 );

    INPAapiResultAnalog( stat_dynoffsetquerbesch, "STAT_DYN_OFFSET_QUERBESCH_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_dynoffsetquerbesch, 7, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [mV]
    INPAapiResultText( text_var, "STAT_DYN_OFFSET_QUERBESCH_EINH", 1, "" );
    ftextout( text_var, 7, 75, 0, 0 );

    // Sensorparameter Druck VA lesen
    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_VA", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    // 
    ftextout( "Sensornullpunkt Druck VA", 10, 1, 0, 0 );
    ftextout( ":", 10, 35, 0, 0 );
    //
    INPAapiResultAnalog( stat_sensorpara, "STAT_SENSOR_NULLPKT_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_sensorpara, 10, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [mV]
    INPAapiResultText( text_var, "STAT_SENSOR_NULLPKT_VA_EINH", 1, "" );
    ftextout( text_var, 10, 75, 0, 0 );

    ftextout( "Sensorsteigung Druck VA", 12, 1, 0, 0 );
    ftextout( ":", 12, 35, 0, 0 );
    //
    INPAapiResultInt( stat_steigung, "STAT_SENSOR_STEIGUNG_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    //analogout( stat_sensorpara, 12, 37, 0, 32000, 0, 32000, "5.1" );
    inttoreal(stat_steigung, tmpr);
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 12, 37, 0, 0 );

    // Einheit [mueVolt/bar]
    INPAapiResultText( text_var, "STAT_SENSOR_STEIGUNG_VA_EINH", 1, "" );
    ftextout( text_var, 12, 42, 0, 0 );

    // Sensorparameter Druck HA lesen
    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HA", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    // 
    ftextout( "Sensornullpunkt Druck HA", 16, 1, 0, 0 );
    ftextout( ":", 16, 35, 0, 0 );
    //
    INPAapiResultAnalog( stat_sensorpara, "STAT_SENSOR_NULLPKT_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_sensorpara, 16, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [mV]
    INPAapiResultText( text_var, "STAT_SENSOR_NULLPKT_HA_EINH", 1, "" );
    ftextout( text_var, 16, 75, 0, 0 );

    ftextout( "Sensorsteigung Druck HA", 18, 1, 0, 0 );
    ftextout( ":", 18, 35, 0, 0 );
    //
    INPAapiResultInt( stat_steigung, "STAT_SENSOR_STEIGUNG_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
   // analogout( stat_sensorpara, 18, 37, 0, 32000, 0, 32000, "5.1" );
    inttoreal(stat_steigung, tmpr);
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 18, 37, 0, 0 );


    // Einheit [mueVolt/bar]
    INPAapiResultText( text_var, "STAT_SENSOR_STEIGUNG_HA_EINH", 1, "" );
    ftextout( text_var, 18, 42, 0, 0 );

    // gelernter Offset Wert lesen fuer Querbeschleunigung
    INPAapiJob( sgbd, "STATUS_NEUE_WERTE_QUERBESCH", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    // 
    ftextout( "Sensornullpkt Querbesch", 22, 1, 0, 0 );
    ftextout( ":", 22, 35, 0, 0 );
    //
    INPAapiResultAnalog( stat_sensorpara, "STAT_SENSOR_NULLPKT_AQUER_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_sensorpara, 22, 37, 0, 3000, 0, 3000, "5.1" );

    // Einheit [mV]
    INPAapiResultText( text_var, "STAT_SENSOR_NULLPKT_AQUER_EINH", 1, "" );
    ftextout( text_var, 22, 75, 0, 0 );

    ftextout( "Sensorsteigung Querbesch", 24, 1, 0, 0 );
    ftextout( ":", 24, 35, 0, 0 );
    //
    INPAapiResultInt( stat_steigung, "STAT_SENSOR_STEIGUNG_AQUER_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    //analogout( stat_sensorpara, 24, 37, 0, 32000, 0, 32000, "5.1" );
    inttoreal(stat_steigung, tmpr);
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 24, 37, 0, 0 );

    // Einheit [mVolt/g]
    INPAapiResultText( text_var, "STAT_SENSOR_STEIGUNG_AQUER_EINH", 1, "" );
    ftextout( text_var, 24, 42, 0, 0 );

    if ( para_lernen_4 == 1 )
    {
      para_lernen_4 = 0;

      INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_VA", "", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
              INPAapiResultInt( sensor_nullpunkt, "STAT_SENSOR_NULLPKT_VA_WERT", 1 );
          INPAapiResultText( sensor_nullpunkt_einh, "STAT_SENSOR_NULLPKT_VA_EINH", 1, "" );
          INPAapiResultInt( sensor_steigung, "STAT_SENSOR_STEIGUNG_VA_WERT", 1 );
          INPAapiResultText( sensor_steigung_einh, "STAT_SENSOR_STEIGUNG_VA_EINH", 1, "" );     
      }
      else {
          err_jobstatus = chk_jobstatus;
      }
      input2int( sensor_nullpunkt, sensor_steigung, "VA Sensorabgleich", "Parameter schreiben:", "Sensornullpunkt:", "Sensorsteigung:", 0, 1500 , 0, 25000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(sensor_nullpunkt, tmpn);
        inttostring(sensor_steigung, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_VA", tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Werte ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

    if ( para_lernen_5 == 1 )
    {
      para_lernen_5 = 0;

      INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HA", "", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
              INPAapiResultInt( sensor_nullpunkt, "STAT_SENSOR_NULLPKT_HA_WERT", 1 );
          INPAapiResultText( sensor_nullpunkt_einh, "STAT_SENSOR_NULLPKT_HA_EINH", 1, "" );
          INPAapiResultInt( sensor_steigung, "STAT_SENSOR_STEIGUNG_HA_WERT", 1 );
          INPAapiResultText( sensor_steigung_einh, "STAT_SENSOR_STEIGUNG_HA_EINH", 1, "" );     
      }
      else {
          err_jobstatus = chk_jobstatus;
      }
      input2int( sensor_nullpunkt, sensor_steigung, "HA Sensorabgleich", "Parameter schreiben:", "Sensornullpunkt:", "Sensorsteigung:", 0, 1500 , 0, 25000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(sensor_nullpunkt, tmpn);
        inttostring(sensor_steigung, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HA", tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Werte ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

    if ( para_lernen_6 == 1 )
    {
      para_lernen_6 = 0;

      INPAapiJob( sgbd, "STATUS_NEUE_WERTE_QUERBESCH", "", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
              INPAapiResultInt( sensor_nullpunkt, "STAT_SENSOR_NULLPKT_AQUER_WERT", 1 );
          INPAapiResultText( sensor_nullpunkt_einh, "STAT_SENSOR_NULLPKT_AQUER_EINH", 1, "" );
          INPAapiResultInt( sensor_steigung, "STAT_SENSOR_STEIGUNG_AQUER_WERT", 1 );
          INPAapiResultText( sensor_steigung_einh, "STAT_SENSOR_STEIGUNG_AQUER_EINH", 1, "" );     
      }
      else {
          err_jobstatus = chk_jobstatus;
      }
      input2int( sensor_nullpunkt, sensor_steigung, "AQuer Sensorabgleich", "Parameter schreiben:", "Sensornullpunkt:", "Sensorsteigung:", 0, 4000 , 0, 5000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(sensor_nullpunkt, tmpn);
        inttostring(sensor_steigung, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_WERTE_QUERBESCH", tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Werte ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

  }
}

// ******************************
// ***    Höhenstandabgleich  ***
// ******************************
SCREEN s_hoehenstandabgleich()
{
  int    offset_vl = 0;
  int    offset_vr = 0;
  int    offset_hl = 0;
  int    offset_hr = 0;
  int    steigung_vl = 0;
  int    steigung_vr = 0;
  int    steigung_hl = 0;
  int    steigung_hr = 0;
  int    nullpunkt_vl = 0;
  int    nullpunkt_vr = 0;
  int    nullpunkt_hl = 0;
  int    nullpunkt_hr = 0;
  int    abw_vl = 0;
  int    abw_vr = 0;
  int    abw_hl = 0;
  int    abw_hr = 0;
  real   tmpr = 0;
  real   tmpr_steig = 0;
  real   tmpr_null  = 0;
  string tmps = "";
  string tmpn = "";
  string offset_einh    = "no response";
  string offset_einh2   = "Einheitenfehler";
  string steigung_einh  = "no response";
  string nullpunkt_einh = "no response";
  

  string text_var= "";
  string chk_jobstatus="";
  string err_jobstatus  = "none";
  int    input_state_key_1 = 0;
  int    input_state_key_2 = 0;
  int    input_state_key_3 = 0;
  int    input_state_key_4 = 0;
  
  ftextout("Höhenstandabgleichwerte",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("aktuelle Abgleichwerte",1,0,0,1);
    // aktuelle Werte lesen
    INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_HGLV", "", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus == "OKAY")
    {
        INPAapiResultInt(  offset_vl,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_FLH_WERT", 1 );
        INPAapiResultInt(  offset_vr,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_FRH_WERT", 1 );
        INPAapiResultInt(  offset_hl,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_RLH_WERT", 1 );
        INPAapiResultInt(  offset_hr,   "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_RRH_WERT", 1 );
        INPAapiResultText( offset_einh, "STAT_NULLPUNKT_OFFSET_DRUCK_HGLV_EINH", 1, "" );
    }
    else {
        err_jobstatus = chk_jobstatus;
    }

    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "1", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus == "OKAY")
    {
        INPAapiResultInt(  steigung_vl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
        INPAapiResultInt(  nullpunkt_vl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
        INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
        INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
    }
    else {
        err_jobstatus = chk_jobstatus;
    }

    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "2", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus == "OKAY")
    {
        INPAapiResultInt(  steigung_vr,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
        INPAapiResultInt(  nullpunkt_vr,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
    }
    else {
        err_jobstatus = chk_jobstatus;
    }

    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "3", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus == "OKAY")
    {
        INPAapiResultInt(  steigung_hl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
        INPAapiResultInt(  nullpunkt_hl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
    }
    else {
        err_jobstatus = chk_jobstatus;
    }

    INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "4", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
    if(chk_jobstatus == "OKAY")
    {
        INPAapiResultInt(  steigung_hr,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
        INPAapiResultInt(  nullpunkt_hr,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
    }
    // Aktuelle Werte darstellen
    // Parameter
    ftextout( "Wert Sensornullpunkt VL", 3, 1, 0, 0 );
        ftextout( "Offset: ", 2, 55, 0, 0 );
        ftextout( "Differenz zw. Sensornullpunkt", 2, 60, 0, 0 );
    ftextout( "und gelernter Nulllage", 3, 60, 0, 0 );
    ftextout( ":", 3, 17, 0, 0 );
    inttoreal(nullpunkt_vl, tmpr);
    analogout( tmpr, 3, 18, 0, 5000, 0, 5000, "" );
    ftextout( nullpunkt_einh, 3, 49, 0, 0 );

    ftextout( "Steigung VL", 5, 1, 0, 0 );
    ftextout( ":", 5, 17, 0, 0 );
    inttoreal(steigung_vl, tmpr);
//    analogout( tmpr, 5, 27, -32767, 32767, -32767, 32767, "" );
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 5, 18, 0, 0 );
    ftextout( steigung_einh, 5, 23, 0, 0 );

    ftextout( "Wert Sensornullpunkt VR", 8, 1, 0, 0 );
    ftextout( ":", 8, 17, 0, 0 );
    inttoreal(nullpunkt_vr, tmpr);
    analogout( tmpr, 8, 18, 0, 5000, 0, 5000, "" );
    ftextout( nullpunkt_einh, 8, 49, 0, 0 );

    ftextout( "Steigung VR", 10, 1, 0, 0 );
    ftextout( ":", 10, 17, 0, 0 );
    inttoreal(steigung_vr, tmpr);
//    analogout( tmpr, 10, 27, -32767, 32767, -32767, 32767, "" );
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 10, 18, 0, 0 );
    ftextout( steigung_einh, 10, 23, 0, 0 );

    ftextout( "Wert Sensornullpunkt HL", 13, 1, 0, 0 );
    ftextout( ":", 13, 17, 0, 0 );
    inttoreal(nullpunkt_hl, tmpr);
    analogout( tmpr, 13, 18, 0, 5000, 0, 5000, "" );
    ftextout( nullpunkt_einh, 13, 49, 0, 0 );

    ftextout( "Steigung HL", 15, 1, 0, 0 );
    ftextout( ":", 15, 17, 0, 0 );
    inttoreal(steigung_hl, tmpr);
//    analogout( tmpr, 15, 27, -32767, 32767, -32767, 32767, "" );
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 15, 18, 0, 0 );
        ftextout( steigung_einh, 15, 23, 0, 0 );

    ftextout( "Wert Sensornullpunkt HR", 18, 1, 0, 0 );
    ftextout( ":", 18, 17, 0, 0 );
    inttoreal(nullpunkt_hr, tmpr);
    analogout( tmpr, 18, 18, 0, 5000, 0, 5000, "" );
    ftextout( nullpunkt_einh, 18, 49, 0, 0 );

    ftextout( "Steigung HR", 20, 1, 0, 0 );
    ftextout( ":", 20, 17, 0, 0 );
    inttoreal(steigung_hr, tmpr);
//    analogout( tmpr, 20, 27, -32767, 32767, -32767, 32767, "" );
//    tmpr= tmpr/1000;
    realtostring( tmpr, "5.0",text_var );
    ftextout( text_var, 20, 18, 0, 0 );
    ftextout( steigung_einh, 20, 23, 0, 0 );

    // Offsetwerte
    ftextout( "Offset VL", 5, 55, 0, 0 );
    ftextout( ":", 5, 62, 0, 0 );
    inttoreal(offset_vl, tmpr);
    inttoreal(steigung_vl, tmpr_steig);
    inttoreal(nullpunkt_vl, tmpr_null);
    offset_einh2 = offset_einh;
    if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
    {   // umskalieren von mV auf mm
        tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
        offset_einh2 = "mm";
    }
    realtostring (tmpr, "4.2", tmps);
    ftextout( tmps+" "+offset_einh2, 5, 64, 0, 0 );

    ftextout( "Offset VR",10, 55, 0, 0 );
    ftextout( ":", 10, 62, 0, 0 );
    inttoreal(offset_vr, tmpr);
    inttoreal(steigung_vr, tmpr_steig);
    inttoreal(nullpunkt_vr, tmpr_null);
    offset_einh2 = offset_einh;
    if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
    {   // umskalieren von mV auf mm
        tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
        offset_einh2 = "mm";
    }
    realtostring (tmpr, "4.2", tmps);
    ftextout( tmps+" "+offset_einh2, 10, 64, 0, 0 );

    ftextout( "Offset HL", 15, 55, 0, 0 );
    ftextout( ":", 15, 62, 0, 0 );
    inttoreal(offset_hl, tmpr);
    inttoreal(steigung_hl, tmpr_steig);
    inttoreal(nullpunkt_hl, tmpr_null);
    offset_einh2 = offset_einh;
    if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
    {   // umskalieren von mV auf mm
        tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
        offset_einh2 = "mm";
    }
    realtostring (tmpr, "4.2", tmps);
    ftextout( tmps+" "+offset_einh2, 15, 64, 0, 0 );

    ftextout( "Offset HR", 20, 55, 0, 0 );
    ftextout( ":", 20, 62, 0, 0 );
    inttoreal(offset_hr, tmpr);
    inttoreal(steigung_hr, tmpr_steig);
    inttoreal(nullpunkt_hr, tmpr_null);
    offset_einh2 = offset_einh;
    if ((steigung_einh == "mV/m") && (offset_einh == "mV"))
    {   // umskalieren von mV auf mm
        tmpr = (tmpr - tmpr_null)/ tmpr_steig * 1000;
        offset_einh2 = "mm";
    }
    realtostring (tmpr, "4.2", tmps);
    ftextout( tmps+" "+offset_einh2, 20, 64, 0, 0 );

    if(err_jobstatus != "none")
    {
        ftextout( "Diagnosefehler", 8, 70, 0, 0);
        ftextout( err_jobstatus, 10, 70, 0, 0);
        ftextout( "Codierung prüfen!", 12, 70, 0, 0 );
    }
  }
  LINE ( "","" )
  {
    if(hs_abgleichen_1 == 1)
    {
           hs_abgleichen_1 = 0; 
      inputint( abw_vl, "Höhenstandabgleich", "aktuelle Abweichung von Nulllage (Ausgefedert positiv) vorne links:", -200, 200 );
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(abw_vl, tmps);
        INPAapiJob( sgbd, "START_OFFSET_WERTE_HGLV", "1;"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "Nulllagenabweichung zu groß! Spannung bei Nulllage außerhalb des Sensorbereichs" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }
        if(hs_abgleichen_2 == 1)
    {
          hs_abgleichen_2 = 0;  
      inputint( abw_vr, "Höhenstandabgleich", "aktuelle Abweichung von Nulllage (Ausgefedert positiv) vorne rechts:", -200, 200 );
      getinputstate( input_state_key_2 );
      if ( input_state_key_2 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_2  == 0 )
      {
        inttostring(abw_vr, tmps);
        INPAapiJob( sgbd, "START_OFFSET_WERTE_HGLV", "2;"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" ){} 

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "Nulllagenabweichung zu groß! Spannung bei Nulllage außerhalb des Sensorbereichs" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

        if(hs_abgleichen_3 == 1)
    {
      hs_abgleichen_3 = 0; 
      inputint( abw_hl, "Höhenstandabgleich", "aktuelle Abweichung von Nulllage (Ausgefedert positiv) hinten links:", -200, 200 );
      getinputstate( input_state_key_3 );
      if ( input_state_key_3 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_3  == 0 )
      {
        inttostring(abw_hl, tmps);
        INPAapiJob( sgbd, "START_OFFSET_WERTE_HGLV", "3;"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" ) {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "Nulllagenabweichung zu groß! Spannung bei Nulllage außerhalb des Sensorbereichs" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

        if(hs_abgleichen_4 == 1)
    {
          hs_abgleichen_4 = 0;  
      inputint( abw_hr, "Höhenstandabgleich", "aktuelle Abweichung von Nulllage (Ausgefedert positiv) hinten rechts:", -200, 200 );
      getinputstate( input_state_key_4 );
      if ( input_state_key_4 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_4  == 0 )
      {
        inttostring(abw_hr, tmps);
        INPAapiJob( sgbd, "START_OFFSET_WERTE_HGLV", "4;"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "Nulllagenabweichung zu groß! Spannung bei Nulllage außerhalb des Sensorbereichs" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

    if(hs_abgleichen_5 == 1)
    {
          hs_abgleichen_5 = 0; 

          INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "1", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
          INPAapiResultInt(  steigung_vl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
          INPAapiResultInt(  nullpunkt_vl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
          INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
          INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
      }
      else {
          err_jobstatus = chk_jobstatus;
      }

      input2int( nullpunkt_vl, steigung_vl, "Höhenstandabgleich", "vorne links:", "Sensornullpunkt:", "Sensorsteigung:", 0, 5000 , -30000, 30000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(nullpunkt_vl, tmpn);
        inttostring(steigung_vl, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HGLV", "1;"+tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }


    if(hs_abgleichen_6 == 1)
    {
          hs_abgleichen_6 = 0; 

          INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "2", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
          INPAapiResultInt(  steigung_vr,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
          INPAapiResultInt(  nullpunkt_vr,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
          INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
          INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
      }
      else {
          err_jobstatus = chk_jobstatus;
      }

      input2int( nullpunkt_vr, steigung_vr, "Höhenstandabgleich", "vorne rechts:", "Sensornullpunkt:", "Sensorsteigung:", 0, 5000 , -30000, 30000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(nullpunkt_vr, tmpn);
        inttostring(steigung_vr, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HGLV", "2;"+tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }

    if(hs_abgleichen_7 == 1)
    {
          hs_abgleichen_7 = 0; 

          INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "3", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
          INPAapiResultInt(  steigung_hl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
          INPAapiResultInt(  nullpunkt_hl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
          INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
          INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
      }
      else {
          err_jobstatus = chk_jobstatus;
      }

      input2int( nullpunkt_hl, steigung_hl, "Höhenstandabgleich", "hinten links:", "Sensornullpunkt:", "Sensorsteigung:", 0, 5000 , -30000, 30000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(nullpunkt_hl, tmpn);
        inttostring(steigung_hl, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HGLV", "3;"+tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }
    if(hs_abgleichen_8 == 1)
    {
          hs_abgleichen_8 = 0; 

          INPAapiJob( sgbd, "STATUS_NEUE_SENSOR_WERTE_HGLV", "4", "" );
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
      if(chk_jobstatus == "OKAY")
      {
          INPAapiResultInt(  steigung_vl,   "STAT_SENSOR_STEIGUNG_HGLV_WERT", 1 );
          INPAapiResultInt(  nullpunkt_vl,  "STAT_SENSOR_NULLPKT_HGLV_WERT", 1 );
          INPAapiResultText( steigung_einh, "STAT_SENSOR_STEIGUNG_HGLV_EINH", 1, "" );
          INPAapiResultText( nullpunkt_einh, "STAT_SENSOR_NULLPKT_HGLV_EINH", 1, "" );
      }
      else {
          err_jobstatus = chk_jobstatus;
      }

      input2int( nullpunkt_hr, steigung_hr, "Höhenstandabgleich", "hinten rechts:", "Sensornullpunkt:", "Sensorsteigung:", 0, 5000 , -30000, 30000);
      getinputstate( input_state_key_1 );
      if ( input_state_key_1 == 1 )
      {   // Eingabe 1 wurde mit Abbruch abgeschlossen
          userboxclose( 0 );
          viewclose();
      }
      // nur bei OK ausfuehren
      if ( input_state_key_1  == 0 )
      {
        inttostring(nullpunkt_hr, tmpn);
        inttostring(steigung_hr, tmps);
        INPAapiJob( sgbd, "START_LERNEN_NEUE_SENSOR_WERTE_HGLV", "4;"+tmpn+";"+tmps, "" );
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )  {}

        else if( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        infobox ( "Wert ausserhalb zulässigen Bereichs", "" );  

        else 
        {
            infobox ( "Fehler", "Fehlertyp: "+chk_jobstatus );
            userboxclose( 0 );
            viewclose();
        }
      }
    }





  }
}
// ***************************
// *** Stati Sensoren ARS  ***
// ***************************
// wird ueber F6 aktiviert 'Sensoren'
SCREEN s_stati_sensor()
{
  int status_ars;
  real stat_alive;
  string text_var = "";
  real zahl_var;  

  // 5 Volt / 10bit --> 5 Volt /1024
  real EinBitVoltWert = 0.0048828125;
  real SensorWert_VA_roh;
  real SensorWert_VA;
  real SensorWert_HA_roh;
  real SensorWert_HA;

  real SensorWert_RV_roh;
  real SensorWert_RV;
  real SensorWert_QU_roh;
  real SensorWert_QU;


  ftextout( "Status Sensoren", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Drucksensor VA", 1, 1, 0, 0 );
    ftextout( ":", 1, 35, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultText( text_var, "STAT_DRUCK_VA_WERT", 1, "" );
    ftextout( text_var, 1, 37, 0, 0 );
    
    // Fehlertext fuer den Sensor
    INPAapiResultText( text_var, "STAT_DRUCK_VA_TEXT", 1, "" );
    ftextout( text_var, 1, 45, 0, 0 );

    ftextout( "Status Drucksensor HA", 3, 1, 0, 0 );
    ftextout( ":", 3, 35, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultText( text_var, "STAT_DRUCK_HA_WERT", 1, "" );
    ftextout( text_var, 3, 37, 0, 0 );
    
    // Fehlertext fuer den Sensor
    INPAapiResultText( text_var, "STAT_DRUCK_HA_TEXT", 1, "" );
    ftextout( text_var, 3, 45, 0, 0 );

    ftextout( "Status Schaltstellungssensor", 5, 1, 0, 0 );
    ftextout( ":", 5, 35, 0, 0 );
    // Ausgabe des Telegrammwertes
    INPAapiResultText( text_var, "STAT_POSITION_WERT", 1, "" );
    ftextout( text_var, 5, 37, 0, 0 );

    // Fehlertext fuer den Sensor
    INPAapiResultText( text_var, "STAT_POSITION_TEXT", 1, "" );
    ftextout( text_var, 5, 45, 0, 0 );

    ftextout( "Status Querbeschleunigungssensor", 7, 1, 0, 0 );
    ftextout( ":", 7, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_QUERBESCHLSEN_WERT", 1, "" );
    ftextout( text_var, 7, 37, 0, 0 );
    
    // Fehlertext fuer den Sensor
    INPAapiResultText( text_var, "STAT_QUERBESCHLSEN_TEXT", 1, "" );
    ftextout( text_var, 7, 45, 0, 0 );
    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////

    // Ausgabe des Telegrammwertes
    // Druck VA
    ftextout( "Druck VA (Spg. Roh)", 9, 1, 0, 0 );
    ftextout( ":", 9, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_DRUCK_VA_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "3.3" , text_var );
    ftextout( text_var, 9, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_VA_SW_EINH", 1, "" );
    ftextout( text_var, 9, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_VA_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 9, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_VA_HW_EINH", 1, "" );
    ftextout( text_var, 9, 71, 0, 0 );

    
    ////////////////////////////////////////////////////////////////////////////////

    // Druck HA
    ftextout( "Druck HA (Spg. Roh)", 11, 1, 0, 0 );
    ftextout( ":", 11, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_DRUCK_HA_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "3.3" , text_var );
    ftextout( text_var, 11, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_HA_SW_EINH", 1, "" );
    ftextout( text_var, 11, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_HA_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 11, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_DRUCK_HA_HW_EINH", 1, "" );
    ftextout( text_var, 11, 71, 0, 0 );
    ////////////////////////////////////////////////////////////////////////////////

    // Schaltstellung RV
    ftextout( "Schaltstellung RV (Spg. Roh)", 13, 1, 0, 0 );
    ftextout( ":", 13, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_POSITION_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    ftextout( text_var, 13, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
    ftextout( text_var, 13, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_POSITION_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 13, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
    ftextout( text_var, 13, 71, 0, 0 );
    ////////////////////////////////////////////////////////////////////////////////

    // Querbeschleunigung
    ftextout( "Querbeschleunigung (Spg. Roh)", 15, 1, 0, 0 );
    ftextout( ":", 15, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 15, 37, 0, 0 );

    INPAapiResultText( text_var, "STAT_QUERBESCHL_SW_EINH", 1, "" );
    ftextout( text_var, 15, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_QUERBESCHL_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 15, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_QUERBESCHL_HW_EINH", 1, "" );
    ftextout( text_var, 15, 71, 0, 0 );
    ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
    
    // Oelstand
    ftextout( "Oelstand (Spg. Roh)", 17, 1, 0, 0 );
    ftextout( ":", 17, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_OELSTAND_SW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    ftextout( text_var, 17, 37, 0, 0 );
    
    INPAapiResultText( text_var, "STAT_OELSTAND_SW_EINH", 1, "" );
    ftextout( text_var, 17, 45, 0, 0 );

    INPAapiResultText( text_var, "STAT_OELSTAND_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 17, 65, 0, 0 );

    INPAapiResultText( text_var, "STAT_OELSTAND_HW_EINH", 1, "" );
    ftextout( text_var, 17, 71, 0, 0 );

    // Weckleitung
    ftextout( "Weckleitung", 19, 1, 0, 0 );
    ftextout( ":", 19, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_WECKLEITUNG_HW_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    realtostring ( zahl_var, "1.0" , text_var );
    ftextout( text_var, 19, 37, 0, 0 );
    
    // Pegel
    INPAapiResultText( text_var, "STAT_WECKLEITUNG_HW_EINH", 1, "" );
    ftextout( text_var, 19, 45, 0, 0 );
  }
}

// ****************************
// ***  Stati Versorgungen  ***
// ****************************
// wird ueber F7 aktiviert 'Versorgungen'
SCREEN s_versorgungen()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "Versorgungen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );
  
  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );

  LINE( "","" )
  {
    INPAapiJob( sgbd, "STATUS_VERSORGUNGEN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Versorgung Klemme 30 (Batterie)", 1, 1, 0, 0 );
    ftextout( ":", 1, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_KLEMME30_WERT", 1, "" );
    // 
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 1, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_KLEMME30_EINH", 1, "" );
    ftextout( text_var, 1, 50, 0, 0 );


    ftextout( "Versorgung Schaltstellungssensor", 3, 1, 0, 0 );
    ftextout( ":", 3, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_SCHALTSEN_WERT", 1, "" );

    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 3, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_SCHALTSEN_EINH", 1, "" );
    ftextout( text_var, 3, 50, 0, 0 );



    ftextout( "Versorgung Drucksensor VA", 5, 1, 0, 0 );
    ftextout( ":", 5, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_VA_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 5, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_VA_EINH", 1, "" );
    ftextout( text_var, 5, 50, 0, 0 );



    ftextout( "Versorgung Drucksensor HA", 7, 1, 0, 0 );
    ftextout( ":", 7, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_HA_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 7, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_HA_EINH", 1, "" );
    ftextout( text_var, 7, 50, 0, 0 );



    ftextout( "Versorgung Querbeschleunigungssensor", 9, 1, 0, 0 );
    ftextout( ":", 9, 35, 0, 0 );
    INPAapiResultText( text_var, "STAT_VERSORGUNG_QUERBESCHL_WERT", 1, "" );
    stringtoreal( text_var, zahl_var );
    // 2 Vorkommastellen, 3 Nachkommastellen
    realtostring ( zahl_var, "2.3" , text_var );
    ftextout( text_var, 9, 37, 0, 0 );
    
    // Einheit [Volt]
    INPAapiResultText( text_var, "STAT_VERSORGUNG_QUERBESCHL_EINH", 1, "" );
    ftextout( text_var, 9, 50, 0, 0 );

  }
}


// *****************************
// *** Steuerscreen Anzeigen ***
// *****************************
// ********************************
// *** Cockpit Auswahl Screen   ***
// ********************************
// wird ueber F2 aktiviert 'Cockpit'
SCREEN s_cockpit()
{
  string text_var = "";
  int status_ars;
  real stat_alive;

  ftextout("Cockpit Meldungen absetzen",1,0,1,0);
  ftextout("",2,0,0,0);

  // zeigt Alive Zaehler an
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  ftextout( "SG Status", 3, 50, 0, 0 );
  ftextout( ":", 3, 58 , 0, 0 );
  
  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
   
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 3, 60, 0, 0 );

  LINE("","")
  {
    ftextout( "< F1 >  Ueberwachung eingeschraenkt"        ,3, 5, 0, 1 );
    ftextout( "< F2 >  eingeschraenkter Regelkomfort"      ,5, 5, 0, 1 );
    ftextout( "< F3 >  Fail Safe"                          ,7, 5, 0, 1 );
    ftextout( "< F4 >  Oelverlust"                         ,9, 5, 0, 1 );
    ftextout( "< F5 >  Fail Safe temporaer"               ,11, 5, 0, 1 );
  }
}


// *********************************
// *** Cockpit Meldungsanzeige   ***
// *********************************
SCREEN s_cockpit_anzeige()
{
  string chk_jobstatus = "";

  // Ueberwachung eingeschraenkt
  if ( toggle_1 == 1 )
  {
    INPAapiJob( sgbd, "FS_SPERREN", "JA","" );
    INPAapiCheckJobStatus( "OKAY" );

    INPAapiJob( sgbd, "STEUERN_ARS_CHECKCONTROL", "1", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
    if ( chk_jobstatus == "OKAY" )
    {
      INPAapiResultText( text_var, "CHECK_CONTROL_MELDUNG_TEXT", 1, "" );
      // ( Text in der Menueleiste, auszugebender Text )
      infobox ( text_var, "Meldung wurde erfolgreich ans Cockpit gesendet" );
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );  
    else
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );

    INPAapiJob( sgbd, "FS_SPERREN", "NEIN","" );
    INPAapiCheckJobStatus( "OKAY" );

    toggle_1 = 0;
  }

  // eingeschraaenkter Regelkomfort
  if ( toggle_2 == 2 )
  {
    INPAapiJob( sgbd, "FS_SPERREN", "JA","" );
    INPAapiCheckJobStatus( "OKAY" );

    INPAapiJob( sgbd, "STEUERN_ARS_CHECKCONTROL", "2", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
    if ( chk_jobstatus == "OKAY" )
    {
      INPAapiResultText( text_var, "CHECK_CONTROL_MELDUNG_TEXT", 1, "" );
      // ( Text in der Menueleiste, auszugebender Text )
      infobox ( text_var, "Meldung wurde erfolgreich ans Cockpit gesendet" );
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
    else
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );

    INPAapiJob( sgbd, "FS_SPERREN", "NEIN","" );
    INPAapiCheckJobStatus( "OKAY" );
 
    toggle_2 = 0;
  }
  
  // Fail Safe
  if ( toggle_3 == 3 )
  {
    INPAapiJob( sgbd, "FS_SPERREN", "JA","" );
    INPAapiCheckJobStatus( "OKAY" );

    INPAapiJob( sgbd, "STEUERN_ARS_CHECKCONTROL", "3", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
    if ( chk_jobstatus == "OKAY" )
    {
      INPAapiResultText( text_var, "CHECK_CONTROL_MELDUNG_TEXT", 1, "" );
      // ( Text in der Menueleiste, auszugebender Text )
      infobox ( text_var, "Meldung wurde erfolgreich ans Cockpit gesendet" );
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
    else
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );

    INPAapiJob( sgbd, "FS_SPERREN", "NEIN","" );
    INPAapiCheckJobStatus( "OKAY" );

    toggle_3 = 0;
  }

  // Oelverlust
  if ( toggle_4 == 4 )
  {
    INPAapiJob( sgbd, "FS_SPERREN", "JA","" );
    INPAapiCheckJobStatus( "OKAY" );

    INPAapiJob( sgbd, "STEUERN_ARS_CHECKCONTROL", "4", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
    if ( chk_jobstatus == "OKAY" )
    {
      INPAapiResultText( text_var, "CHECK_CONTROL_MELDUNG_TEXT", 1, "" );
      // ( Text in der Menueleiste, auszugebender Text )
      infobox ( text_var, "Meldung wurde erfolgreich ans Cockpit gesendet" );
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
    else
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );

    INPAapiJob( sgbd, "FS_SPERREN", "NEIN","" );
    INPAapiCheckJobStatus( "OKAY" );
    
    toggle_4 = 0;
  }

  // Fail Safe temporaer
  if ( toggle_5 == 5 )
  {
    INPAapiJob( sgbd, "FS_SPERREN", "JA","" );
    INPAapiCheckJobStatus( "OKAY" );

    INPAapiJob( sgbd, "STEUERN_ARS_CHECKCONTROL", "5", "" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
    if ( chk_jobstatus == "OKAY" )
    {
      INPAapiResultText( text_var, "CHECK_CONTROL_MELDUNG_TEXT", 1, "" );
      // ( Text in der Menueleiste, auszugebender Text )
      infobox ( text_var, "Meldung wurde erfolgreich ans Cockpit gesendet" );
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
    else
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );

    INPAapiJob( sgbd, "FS_SPERREN", "NEIN","" );
    INPAapiCheckJobStatus( "OKAY" );
    
    toggle_5 = 0;
  }

  setscreen( s_cockpit, TRUE );

}

// ******************************
// ***   Ventile Steuern      ***
// *** Mehrfachbestromung     ***
// ******************************
// wird ueber F3 aktiviert 'Ansteuern'
SCREEN s_mehr_ventile_steuern()
{
  int status_ars;
  bool warnung_va_erfolgt = FALSE;
  bool warnung_ha_erfolgt = FALSE;
  
  real stat_alive;
  real zahl_var;  
  real stat_istdruck_va;
  real stat_istdruck_ha;
  real mgl_restdruck;
  real mgl_reststrom;
  real eingabe_tmp;
  
  //string strom_var = "";
  string text_var = "";
  string chk_jobstatus = "";

  ftextout( "Simultanbestromung der Ventile SV, RV, PropVA, PropHA", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 1, 0 );
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Sicherheitsventil und Richtungsventil
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  LINE( "","" )
  {
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sicherheitsventil
    ftextout( "Sicherheitsventil wird dauerbestromt", 1, 0, 0, 0 );
    digitalout( sv_ein_aus, 1, 30, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
    ftextout( "Status Sicherheitsventil", 3, 0, 0, 0 );
    ftextout( ":", 3, 22, 0, 0 );
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
    ftextout( text_var, 3, 23, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );
  
    ftextout( "Steuerstrom Sicherheitsventil", 5, 0, 0, 0 );
    ftextout( ":", 5, 22, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 6, 0, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
    ftextout( text_var, 6, 35, 0, 0 );
  
  
    // Sicherheitsventil
    // Taste 'EIN' wurde gedrueckt
    if ( sv_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 9, 1, 0, 0 );
      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_SV_PUSHHOLD", "", "" );
  //      INPAapiCheckJobStatus( "OKAY" );
  
  
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        sv_ein_aus = TRUE;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt (SV)", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL" );
        userboxclose( 0 );
        viewclose();
//          setscreen( s_sv_schreiben, TRUE );
        setscreen( s_steuern, TRUE );
        setmenu( m_steuern );
        sv_ein_aus = FALSE;
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt (SV) --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
//          setscreen( s_sv_schreiben, TRUE );
        setscreen( s_steuern, TRUE );
        setmenu( m_steuern );
        sv_ein_aus = FALSE;
      }
    }

  
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Richtungsventil
    ftextout( "Richtungsventil wird dauerbestromt", 1, 45, 0, 0 );
    //ftextout( "", 3, 0, 0, 0 );
    digitalout( rv_ein_aus, 1, 75, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
  
    ftextout( "Status Richtungsventil", 3, 45, 0, 0 );
    ftextout( ":", 3, 67, 0, 0 );
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
    ftextout( text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
  
    ftextout( "Steuerstrom Richtungsventil", 5, 45, 0, 0 );
    ftextout( ":", 5, 67, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 6, 45, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
    ftextout( text_var, 6, 80, 0, 0 );
  

    if ( rv_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 9, 45, 0, 0 );

      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_RV_PUSHHOLD", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        rv_ein_aus = TRUE;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt (RV)", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_steuern, TRUE );
        setmenu( m_steuern );
        rv_ein_aus = FALSE;
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt (RV) --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_steuern, TRUE );
        setmenu( m_steuern );
        rv_ein_aus = FALSE;
      }
    }
 
  }
  //ende Line Sicherheitsventil und Richtungsventil

  LINE( "","" )
  {
    ftextout( "", 0, 0, 1, 0 );
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Propventil VA mit Fehlerpruefung UND
  // Propventil HA mit Fehlerpruefung
  LINE( "","" )
  {
    // vorab alle notwendigen Grenzen berechnen:
    //
    // Roter Bereich VA abhaengig vom Istdruck HA
    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultAnalog( stat_istdruck_ha, "STAT_DRUCK_HA_SW_WERT", 1 );
    INPAapiResultAnalog( stat_istdruck_va, "STAT_DRUCK_VA_SW_WERT", 1 );
    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    mgl_restdruck = 180;
    mgl_reststrom = 0.453 + (0.0069375 * (180 - stat_istdruck_ha));
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil VA mit Fehlerpruefung 
    ftextout( "Proportionalventil VA wird dauerbestromt", 1, 0, 0, 0 );
    digitalout( PropVA_ein_aus, 1, 30, "Ein", "Aus" );
    ftextout( "Status Propventil VA", 3, 0, 0, 0 );
    ftextout( ":", 3, 22, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
    ftextout( text_var, 3, 23, 0, 0 );
    
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );


    ftextout( "Steuerstrom Propventil VA", 5, 0, 0, 0 );
    ftextout( ":", 5, 22, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    // Beschriftungen loeschen, neu ausgeben
    clearrect (20,0,2,30);
    analogout( strom_va_ventil, 6, 0, 0, 3, 0, mgl_reststrom, "5.3" );

    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
    ftextout( text_var, 6, 35, 0, 0 );
    ///////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Ist Druck VA
    ftextout( "Ist Druck VA", 9, 0, 0, 0 );
    ftextout( ":", 9, 22, 0, 0 );
    //                         Zl, Sp, min  max    Format
    analogout( stat_istdruck_va, 10, 0, -2, 250, -2, mgl_restdruck, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCK_VA_SW_EINH", 1, "" );
    ftextout( text_var, 10, 35, 0, 0 );
    ///////////////////////////////////////////////////////////////////////////

    
    // Taste 'EIN' wurde gedrueckt
    if ( PropVA_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 14, 0, 0, 0 );
    
      if ( strom_va_1 == 1 )
      {
        //strom_var = "";
        strom_var_va = "";
        // zweimaliger Aufruf wird verhindert, Eingabe darf nur einmal aufgerufen werden
        strom_va_1 = 0;
        inputint( strom_va_mA, "Proportionalventil VA", "Steuerstrom in mA", 0, 3000 );
        //
        getinputstate( input_state_VA );
        // Eingabe wurde mit Abbruch abgeschlossen
        if ( input_state_VA == 1 )
        {
          userboxclose( 0 );
          viewclose();
        }
        // Eingabe wurde mit OK abgeschlossen
        else if ( input_state_VA == 0 )
        {
          // Variablenumwandlung int --> string
          //inttostring( strom_va_mA, strom_var );        
          inttostring( strom_va_mA, strom_var_va );        
          // Dialog schliessen
          userboxclose( 0 );
          viewclose();
        }
      }
    
      // nur bei OK ausfuehren
      if ( input_state_VA == 0 )
      {
        ftextout( "Proportionalventil VA bestromen MIT Fehlerpruefung", 13, 1, 0, 0 );
        // Ventil faellt nach 2 sec wieder auf '0' Ampere zurueck
        // Dauerbestromung sicherstellen bei Taste 'EIN'
        // Strom Ausgabe mit Fehlerpruefung
        //INPAapiJob( sgbd, "STEUERN_PVVA_PWM_MIT_FP", strom_var, "" );
        INPAapiJob( sgbd, "STEUERN_PVVA_PWM_MIT_FP", strom_var_va, "" );
      
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )
        {
          strom_va_1 = 0;
          PropVA_ein_aus = TRUE;
        }
        else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        {
          infobox ( "Randbedingungen wurden verletzt (PropVA)", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
          userboxclose( 0 );
          viewclose();
          setscreen( s_steuern, TRUE );
          setmenu( m_steuern );
          PropVA_ein_aus = FALSE;
        }
        else
        {
          infobox ( "Randbedingungen wurden verletzt (PropVA) --> unbekannter Fehlerfall", chk_jobstatus );
          userboxclose( 0 );
          viewclose();
          setscreen( s_steuern, TRUE );
          setmenu( m_steuern );
          PropVA_ein_aus = FALSE;
  
        }
      }
      strom_va_1 = 0;

      if (( sv_ein_aus == TRUE ) && ( PropVA_ein_aus == TRUE ) && ( PropHA_ein_aus == TRUE ))
      {
        stringtoreal( strom_var_va , eingabe_tmp );
        if(eingabe_tmp > (mgl_reststrom*1000))
        {
           if(warnung_va_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_va_erfolgt = TRUE;
           }
        }
        else
        {
              warnung_va_erfolgt = FALSE;
        }
      }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    // konstante Werte fuer Hinterachsgrenzen
    mgl_restdruck = 180 - (stat_istdruck_va - stat_istdruck_ha);
    mgl_reststrom = 0.453 + (0.0069375 * mgl_restdruck );

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil HA mit Fehlerpruefung

    ftextout( "Proportionalventil HA wird dauerbestromt", 1, 45, 0, 0 );
    digitalout( PropHA_ein_aus, 1, 75, "Ein", "Aus" );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil HA", 3, 45, 0, 0 );
    ftextout( ":", 3, 67, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
    ftextout( text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
  
    ftextout( "Steuerstrom Propventil HA", 5, 45, 0, 0 );
    ftextout( ":", 5, 67, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    // Beschriftungen loeschen, neu ausgeben
    clearrect (20,45,2,30);
    analogout( strom_ha_ventil, 6, 45, 0, 3, 0, mgl_reststrom, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
    ftextout( text_var, 6, 80, 0, 0 );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    // Ist Druck HA
    ftextout( "Ist Druck HA", 9, 45, 0, 0 );
    ftextout( ":", 9, 67, 0, 0 );

    //                         Zl, Sp, min  max    Format
    // Beschriftungen loeschen, neu ausgeben
    clearrect (25,45,2,30);
    analogout( stat_istdruck_ha, 10, 45, -2, 250, -2, mgl_restdruck, "3.3" );

    // Einheit [bar]
    INPAapiResultText( text_var, "STAT_DRUCK_HA_SW_EINH", 1, "" );
    ftextout( text_var, 10, 80, 0, 0 );
    ///////////////////////////////////////////////////////////////////////////
    
    if ( PropHA_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 14, 45, 0, 0 );

      if ( strom_ha_1 == 1 )
      {
        strom_var_ha = "";
        strom_ha_1 = 0;
        inputint( strom_ha_mA, "Proportionalventil HA", "Steuerstrom in mA", 0, 3000 );
        //
        getinputstate( input_state_HA );
        // Eingabe wurde mit Abbruch abgeschlossen
        if ( input_state == 1 )
        {
          userboxclose( 0 );
          viewclose();
        }
        // Eingabe wurde mit OK abgeschlossen
        else if ( input_state_HA == 0 )
        {
          // Variablenumwandlung int --> string
          //inttostring( strom_ha_mA, strom_var );        
          inttostring( strom_ha_mA, strom_var_ha );        
          // Dialog schliessen
          userboxclose( 0 );
          viewclose();
        }
      }

      // nur bei OK ausfuehren
      if ( input_state_HA == 0 )
      {
        ftextout( "Proportionalventil HA bestromen MIT Fehlerpruefung", 13, 45, 0, 0 );
        // Strom Ausgabe mit Fehlerpruefung
        //INPAapiJob( sgbd, "STEUERN_PVHA_PWM_MIT_FP", strom_var, "" );
        INPAapiJob( sgbd, "STEUERN_PVHA_PWM_MIT_FP", strom_var_ha, "" );
  
        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
        if ( chk_jobstatus == "OKAY" )
        {
          strom_ha_1 = 0;
          PropHA_ein_aus = TRUE;
        }
        else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
        {
          infobox ( "Randbedingungen wurden verletzt (PropHA)", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
          userboxclose( 0 );
          viewclose();
          setscreen( s_steuern, TRUE );
          setmenu( m_steuern );
          PropHA_ein_aus = FALSE;
        }
        else
        {
          infobox ( "Randbedingungen wurden verletzt (PropHA) --> unbekannter Fehlerfall", chk_jobstatus );
          userboxclose( 0 );
          viewclose();
          setscreen( s_steuern, TRUE );
          setmenu( m_steuern );
          PropHA_ein_aus = FALSE;
        }
      }
  
      strom_ha_1 = 0;

      if (( sv_ein_aus == TRUE ) && ( PropVA_ein_aus == TRUE ) && ( PropHA_ein_aus == TRUE ))
      {
        stringtoreal( strom_var_ha , eingabe_tmp );
        if(eingabe_tmp > (mgl_reststrom*1000))
        {
           if(warnung_ha_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_ha_erfolgt = TRUE;
           }
        }
        else
        {
              warnung_ha_erfolgt = FALSE;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    
  }
  // Ende 'Line' PropVA und PropHA
  

  
}

// ******************************
// ***   Ventile Steuern      ***
// ***    Rampenlogik         ***
// ******************************
// wird ueber F5 aktiviert 'Ansteuern'
SCREEN s_rampen_steuern()
{
  int status_ars;

  real stat_alive;
  real zahl_var;  
  real stat_istdruck_va;
  real stat_istdruck_ha;
  real mgl_restdruck;
  real mgl_reststrom;
  real eingabe_tmp;
  real r_min = 0;
  real r_max = 0;
  
  int int_eingabe_tmp;
  
  string text_var = "";
  string text_var2 = "";
  string chk_jobstatus = "";
  string job_parameter = "";
  string text_tmp = "";
  string text_va_druck_einh = "";
  string text_ha_druck_einh = "";

  ftextout( "Rampenlogik fuer Ventilansteuerung", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 1, 0 );
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Sicherheitsventil und Richtungsventil
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  LINE( "","" )
  {
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sicherheitsventil
    ftextout( "Sicherheitsventil bei Rampe", 1, 0, 0, 0 );
    digitalout( sv_ein_aus, 1, 30, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
  
    ftextout( "Status Sicherheitsventil", 3, 0, 0, 0 );
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
    ftextout( text_var, 3, 23, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );
  
    ftextout( "Steuerstrom Sicherheitsventil:", 5, 0, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_sv_ventil, 6, 0, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
    ftextout( text_var, 6, 35, 0, 0 );
  
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Richtungsventil
    ftextout( "Richtungsventil bei Rampe", 1, 45, 0, 0 );
    //ftextout( "", 3, 0, 0, 0 );
    digitalout( rv_ein_aus, 1, 75, "Ein", "Aus" );
  
    INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Richtungsventil:", 3, 45, 0, 0 );
    ftextout( ":", 3, 67, 0, 0 );
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
    ftextout( text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
  
    ftextout( "Steuerstrom Richtungsventil:", 5, 45, 0, 0 );
    // Stromwert auslesen
    INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
    //                         Zl, Sp, min  max    Format
    analogout( strom_rv_ventil, 6, 45, 0, 3, 0, 3, "5.3" );
  
    // Einheit [Ampere]
    INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
    ftextout( text_var, 6, 80, 0, 0 );
  }
  //ende Line Sicherheitsventil und Richtungsventil

  LINE( "","" )
  {
    ftextout( "", 0, 0, 1, 0 );
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Propventil VA UND
  // Propventil HA
  LINE( "","" )
  {
    // vorab alle notwendigen Grenzen berechnen:
    //
    // Roter Bereich VA abhaengig vom Istdruck HA
    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultAnalog( stat_istdruck_ha, "STAT_DRUCK_HA_SW_WERT", 1 );
    INPAapiResultAnalog( stat_istdruck_va, "STAT_DRUCK_VA_SW_WERT", 1 );
    INPAapiResultText( text_va_druck_einh, "STAT_DRUCK_VA_SW_EINH", 1, "" );
    INPAapiResultText( text_ha_druck_einh, "STAT_DRUCK_HA_SW_EINH", 1, "" );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    mgl_restdruck = 180;
    mgl_reststrom = 0.453 + (0.0069375 * (180 - stat_istdruck_ha));
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil VA 
    ftextout( "Proportionalventil VA bei Rampe", 1, 0, 0, 0 );
    digitalout( PropVA_ein_aus, 1, 30, "Ein", "Aus" );
    ftextout( "Status Propventil VA:", 3, 0, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
    ftextout( text_var, 3, 23, 0, 0 );
    
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
    ftextout( text_var, 3, 30, 0, 0 );

    ftextout("Rampenzeit:", 4, 0,0,0);
    inttoreal(va_ramp_zeit, eingabe_tmp);
    eingabe_tmp= eingabe_tmp/100;
    realtostring( eingabe_tmp, "3.2",text_var );
    strcat(text_var2, text_var, " s");
    ftextout( text_var2, 4, 23,0,0);
    if(0 == va_ramp_art) { ftextout( "Stop            ", 4, 30,0,0); }
    else if(1 == va_ramp_art) { ftextout("Aufwaerts   ", 4, 30,0,0); }
    else if(2 == va_ramp_art) { ftextout("Abwaerts    ", 4, 30,0,0); }
    else { ftextout("Ungueltig    ", 4, 30,0,0); }

    if(0 == rampenvorgabe) 
    {    // Vorgabe ueber Strom
         ftextout( "Rampenobergrenze (Strom):", 5, 0, 0, 0);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/1000;
         realtostring( eingabe_tmp, "3.3",text_var );
         ftextout( text_var, 5, 23,0,0);
         ftextout( "Ampere", 5,30,0,0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_va_ventil, 6, 0, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
         ftextout( text_var, 6, 35, 0, 0 );

         // Ist Druck VA
         ftextout( "Ist Druck VA:", 8, 0, 0, 0 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_va, 9, 0, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_va_druck_einh, 9, 35, 0, 0 );
    }
    else if(1 == rampenvorgabe)
    {    // Vorgabe ueber Druck
         ftextout( "Rampenobergrenze (Druck):", 5, 0, 0, 0);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/10;
         realtostring( eingabe_tmp, "3.1",text_var );
         ftextout( text_var, 5, 23,0,0);
         ftextout( "[bar]", 5,30,0,0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_va, 6, 0, -2, 250, -2, mgl_restdruck, "3.3" );
         // Einheit [bar]
         ftextout( text_va_druck_einh, 6, 35, 0, 0 );
    }
    else if(2 == rampenvorgabe)
    {    // Vorgabe ueber TV
         ftextout( "Rampenobergrenze (Tastverhaeltnis):", 5, 0, 0, 0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,0,2,30);
         inttoreal(va_ramp_wert, eingabe_tmp);
         eingabe_tmp = eingabe_tmp/10;
         analogout( eingabe_tmp, 6, 0, 0, 100, 0, 100, "3.3" );
         // Einheit [%]
         ftextout( "[%]", 6, 35, 0, 0 );
    }

    if(0 != rampenvorgabe) 
    {    // fuer Druck und TV:
         INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
         INPAapiCheckJobStatus( "OKAY" );
         // Stromwert auslesen
         INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
         ftextout( "Steuerstrom Propventil VA:", 8, 0, 0, 0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,0,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_va_ventil, 9, 0, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
         ftextout( text_var,9, 35, 0, 0 );
    }
    if(2 == rampenvorgabe)
    {    // nur bei TV:
         // Ist Druck VA
         ftextout( "Ist Druck VA:", 11, 0, 0, 0 );
         //                         Zl, Sp, min  max    Format
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,0,2,30);
         analogout( stat_istdruck_va, 12, 0, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_va_druck_einh, 12, 35, 0, 0 );
    }

    ///////////////////////////////////////////////////////////////////////////

    // Taste 'EIN' wurde gedrueckt
    if ( PropVA_ein_aus == TRUE )
    {
      if (TRUE == ramp_mode_ein_aus)
      {
        inttoreal(va_ramp_wert, eingabe_tmp);
        if((0 == rampenvorgabe) && (eingabe_tmp > (mgl_reststrom*1000)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if((1 == rampenvorgabe) && (eingabe_tmp > (mgl_restdruck*10)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if(2 == rampenvorgabe)
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil VA: Vorsicht!",
                         "Keine Ueberpruefung der Grenzwerte bei Vorgabe TV");
              warnung_erfolgt = TRUE;
           }
        }
      }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    // konstante Werte fuer Hinterachsgrenzen
    mgl_restdruck = 180 - (stat_istdruck_va - stat_istdruck_ha);
    mgl_reststrom = 0.453 + (0.0069375 * mgl_restdruck );

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    // Propventil HA mit Fehlerpruefung

    ftextout( "Proportionalventil HA bei Rampe", 1, 45, 0, 0 );
    digitalout( PropHA_ein_aus, 1, 75, "Ein", "Aus" );

    ///////////////////////////////////////////////////////////////////////////
    INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
    INPAapiCheckJobStatus( "OKAY" );

    ftextout( "Status Propventil HA:", 3, 45, 0, 0 );
    INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
    ftextout( text_var, 3, 68, 0, 0 );
  
    // Einheit [Zustand (ein/aus)]
    INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
    ftextout( text_var, 3, 75, 0, 0 );
  
    ftextout("Rampenzeit", 4, 45,0,0);
    inttoreal(ha_ramp_zeit, eingabe_tmp);
    eingabe_tmp= eingabe_tmp/100;
    realtostring( eingabe_tmp, "3.2",text_var );
    strcat(text_var2, text_var, " s");
    ftextout( text_var2, 4, 68,0,0);
    if(0 == ha_ramp_art) { ftextout( "Stop            ", 4, 75,0,0); }
    else if(1 == ha_ramp_art) { ftextout("Aufwaerts   ", 4, 75,0,0); }
    else if(2 == ha_ramp_art) { ftextout("Abwaerts    ", 4, 75,0,0); }
    else { ftextout("Ungueltig    ", 4, 75,0,0); }

    ftextout( "Rampenwert Propventil HA:", 5, 45, 0, 0);
    
    if(0 == rampenvorgabe) 
    {    // Vorgabe ueber Strom
         ftextout( "Rampenobergrenze (Strom):", 5, 45, 0, 0);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/1000;
         realtostring( eingabe_tmp, "3.3",text_var );
         ftextout( text_var, 5, 68,0,0);
         ftextout( "Ampere", 5,75,0,0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_ha_ventil, 6, 45, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
         ftextout( text_var, 6, 80, 0, 0 );

         // Ist Druck VA
         ftextout( "Ist Druck HA:", 8, 45, 0, 0 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_ha, 9, 45, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_ha_druck_einh, 9, 80, 0, 0 );
    }
    else if(1 == rampenvorgabe)
    {    // Vorgabe ueber Druck
         ftextout( "Rampenobergrenze (Druck):", 5, 45, 0, 0);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp= eingabe_tmp/10;
         realtostring( eingabe_tmp, "3.1",text_var );
         ftextout( text_var, 5, 68,0,0);
         ftextout( "[bar]", 5,75,0,0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( stat_istdruck_ha, 6, 45, -2, 250, -2, mgl_restdruck, "3.3" );
         // Einheit [bar]
         ftextout( text_ha_druck_einh, 6, 80, 0, 0 );
    }
    else if(2 == rampenvorgabe)
    {    // Vorgabe ueber TV
         ftextout( "Rampenobergrenze (Tastverhaeltnis):", 5, 75, 0, 0);
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (20,45,2,30);
         inttoreal(ha_ramp_wert, eingabe_tmp);
         eingabe_tmp = eingabe_tmp/10;
         analogout( eingabe_tmp, 6, 45, 0, 100, 0, 100, "3.3" );
         // Einheit [%]
         ftextout( "[%]", 6, 80, 0, 0 );
    }

    if(0 != rampenvorgabe) 
    {    // fuer Druck und TV:
         INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
         INPAapiCheckJobStatus( "OKAY" );
         // Stromwert auslesen
         INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
         ftextout( "Steuerstrom Propventil HA:", 8, 45, 0, 0);
         // Stromwert auslesen
         INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (23,45,2,30);
         //                         Zl, Sp, min  max    Format
         analogout( strom_ha_ventil, 9, 45, 0, 3, 0, mgl_reststrom, "5.3" );
         // Einheit [Ampere]
         INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
         ftextout( text_var,9, 80, 0, 0 );
    }
    if(2 == rampenvorgabe)
    {    // nur bei TV:
         // Ist Druck HA
         ftextout( "Ist Druck HA:", 11, 45, 0, 0 );
         //                         Zl, Sp, min  max    Format
         // Loeschen der Einheitentexte um 'verschmieren' zu verhindern
         clearrect (26,45,2,30);
         analogout( stat_istdruck_ha, 12, 45, -2, 250, -2, mgl_restdruck, "3.3" );

         // Einheit [bar]
         ftextout( text_ha_druck_einh, 12, 80, 0, 0 );
    }

    ///////////////////////////////////////////////////////////////////////////

    // Sicherheitsventil oder Richtungsventil
    if (   (sv_ein_aus == TRUE)     || (rv_ein_aus == TRUE)
         ||(PropVA_ein_aus == TRUE) || (PropHA_ein_aus == TRUE))
    {
      if( FALSE == ramp_mode_ein_aus )
      {
         ftextout( "Rampe aktivieren durch <Shift> + <F1>", 14, 25, 0, 0 );
         // Ansteuerung durch Rampenlogik Job spaeter
      }
      else
      {
         ftextout( "Rampenansteuerung aktiv!", 14, 30, 0, 0 );
      }
    }

    // Taste 'EIN' wurde gedrueckt
    if ( PropHA_ein_aus == TRUE )
    {
      if (TRUE == ramp_mode_ein_aus)
      {
        inttoreal(ha_ramp_wert, eingabe_tmp);
        if((0 == rampenvorgabe) && (eingabe_tmp > (mgl_reststrom*1000)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if((1 == rampenvorgabe) && (eingabe_tmp > (mgl_restdruck*10)))
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Vorgeschriebene Grenzwerte ueberschritten, "+CRLF+
                         "Schaedigung des Fahrwerks moeglich");
              warnung_erfolgt = TRUE;
           }
        }
        else if(2 == rampenvorgabe)
        {
           if(warnung_erfolgt == FALSE)
           {  // falls noch nicht erfolgt, dann warnung ausgeben
              messagebox("Proportionalventil HA: Vorsicht!",
                         "Keine Ueberpruefung der Grenzwerte bei Vorgabe TV");
              warnung_erfolgt = TRUE;
           }
        }
      }

    }

//      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 14, 45, 0, 0 );

    // Eigentlichen Diagnoseaufruf starten
    if(TRUE == ramp_mode_ein_aus)
    {
       // Parameter1: Diag Ramp Ctrl Status
       int_eingabe_tmp = 0;
       if(0==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  1; } // HA Halt
       if(1==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  4; } // HA Auf
       if(2==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  2; } // HA Ab
       if(0==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp +  8; } // VA Halt
       if(1==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 32; } // VA Auf
       if(2==va_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 16; } // VA Ab
       if(4==ha_ramp_art) {  int_eingabe_tmp = int_eingabe_tmp + 64; } // HA zusammen mit VA
       inttostring(int_eingabe_tmp, text_tmp);
       strcat(job_parameter, text_tmp, ";");
       // Parameter2,3: Diag Ramp Time VA, HA
       inttostring(va_ramp_zeit, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);
       strcat(job_parameter, job_parameter, ";");
       inttostring(ha_ramp_zeit, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);
       strcat(job_parameter, job_parameter, ";");
       // Parameter4,5: Diag Ramp Time VA, HA
       inttostring(va_ramp_wert, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);
       strcat(job_parameter, job_parameter, ";");
       inttostring(ha_ramp_wert, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);
       strcat(job_parameter, job_parameter, ";");
       // Parameter6: Diag Ramp RV FS Status
       int_eingabe_tmp = 0;
       if(TRUE == sv_ein_aus) {  int_eingabe_tmp = int_eingabe_tmp +  4; } // HA Halt
       if(TRUE == rv_ein_aus) {  int_eingabe_tmp = int_eingabe_tmp + 16; } // HA Halt
       inttostring(int_eingabe_tmp, text_tmp);
       strcat(job_parameter, job_parameter, text_tmp);

       INPAapiJob( sgbd, "STEUERN_RAMPE_PARAMETER", job_parameter, "OKAY" );
       // Momentan kein Errorhandling
       // Parameter: Status Wort
       int_eingabe_tmp = 8;  // Rampenmode aktiv
       if(0==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 32; } // Strom
       if(1==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 16; } // Druck
       if(2==rampenvorgabe) {  int_eingabe_tmp = int_eingabe_tmp + 64; } // TV
       inttostring(int_eingabe_tmp, job_parameter);
       INPAapiJob( sgbd, "STEUERN_RAMPE_DIAGSTAT_SETZEN", job_parameter, "OKAY" );
    }
  }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Ende 'Line' Rampenlogik
}


// ******************************
// ***   Ventile Steuern      ***
// ******************************
// wird ueber F4 aktiviert 'Steuern'
SCREEN s_ventile_steuern()
{
  int status_ars;
  real stat_alive;
  real zahl_var;  
  string text_var = "";

  ftextout( "Ventile", 1, 0, 1, 0 );
  ftextout( "", 2, 0, 0, 0 );
  
  INPAapiJob( sgbd, "STATUS_CAN_ALIVE_ARS", "", "" );
  INPAapiCheckJobStatus( "OKAY" );
  
  ftextout( "SG AliveZaehler", 3, 2, 0, 0 );
  ftextout( ":", 3, 15 , 0, 0 );
  INPAapiResultAnalog( stat_alive, "STAT_ALIVE_ZAEHLER_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_alive, 3, 17, 0, 15, 0, 15, "2" );
  
  INPAapiResultText( text_var, "STAT_ALIVE_ZAEHLER_TEXT", 1, "" );
  ftextout( text_var, 3, 50, 0, 0 );


  ftextout( "SG Status", 5, 50, 0, 0 );
  ftextout( ":", 5, 58 , 0, 0 );

  INPAapiResultInt( status_ars , "STAT_ARS_WERT", 1 );
     
  INPAapiResultText( text_var, "STAT_ARS_TEXT", 1, "" );
  ftextout( text_var, 5, 60, 0, 0 );

  LINE( "","" )
  {
    ftextout( "< F4 >  Sicherheitsventil bestromen"     ,12, 5, 0, 1 );
    ftextout( "< F5 >  Richtungsventil bestromen"       ,14, 5, 0, 1 );
    ftextout( "< F6 >  Proportionalventil VA bestromen"    ,16, 5, 0, 1 );
    ftextout( "< F7 >  Proportionalventil HA bestromen"    ,18, 5, 0, 1 );
  }
}

// *************************************
// ***  Basisscreen zur Bestromung   ***
// ***  des Sicherheitsventils       ***
// *************************************
SCREEN s_sv_schreiben()
{
  ftextout( "Sicherheitsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
  
    ftextout( "< F1 >  Sicherheitsventil bestromen MIT Fehlerpruefung(2 sec.)"           ,3, 5, 0, 1 );
    ftextout( "< F2 >  Sicherheitsventil bestromen OHNE Fehlerpruefung(2 sec.)"           ,5, 5, 0, 1 );
    ftextout( "< F3 >  Sicherheitsventil Hochlauf"                                        ,7, 5, 0, 1 );
    ftextout( "< F4 >  Sicherheitsventil Pushhold"                                        ,9, 5, 0, 1 );
 
    ftextout( "< F5 >  Dauerbestromung Sicherheitsventil Pushhold"                 ,15, 5, 0, 1 );
  }
}
// *************************************
// ***  Basisscreen zur Bestromung   ***
// ***  des Richtungsventils         ***
// *************************************
SCREEN s_rv_schreiben()
{
  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
  
    ftextout( "< F1 >  Richtungsventil bestromen MIT Fehlerpruefung(2 sec.)"           ,3, 5, 0, 1 );
    ftextout( "< F2 >  Richtungsventil bestromen OHNE Fehlerpruefung(2 sec.)"           ,5, 5, 0, 1 );
    ftextout( "< F3 >  Richtungsventil Hochlauf"                                        ,7, 5, 0, 1 );
    ftextout( "< F4 >  Richtungsventil Pushhold"                                        ,9, 5, 0, 1 );
 
    ftextout( "< F5 >  Dauerbestromung Richtungsventil Pushhold"                 ,15, 5, 0, 1 );
  }
}

// *************************************
// ***  Basisscreen zur Bestromung   ***
// ***  des Propventils VA           ***
// *************************************
SCREEN s_va_schreiben()
{
  ftextout( "Proportionalventil VA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
  
    ftextout( "< F1 >  Proportionalventil VA bestromen MIT Fehlerpruefung(2 sec.)"           ,3, 5, 0, 1 );
    ftextout( "< F2 >  Proportionalventil VA OHNE Fehlerpruefung(2 sec.)"                     ,5, 5, 0, 1 );
    ftextout( "< F3 >  Proportionalventil HA Hochlauf"                                        ,7, 5, 0, 1 );
 
  }
}


// *************************************
// ***  Basisscreen zur Bestromung   ***
// ***  des Propventils VA           ***
// *************************************
SCREEN s_ha_schreiben()
{
  ftextout( "Proportionalventil HA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0 ,0 );

  LINE( "","" )
  {
  
    ftextout( "< F1 >  Proportionalventil HA bestromen MIT Fehlerpruefung(2 sec.)"           ,3, 5, 0, 1 );
    ftextout( "< F2 >  Proportionalventil HA OHNE Fehlerpruefung(2 sec.)"                     ,5, 5, 0, 1 );
    ftextout( "< F3 >  Proportionalventil HA Hochlauf"                                        ,7, 5, 0, 1 );
 
  }
}

// ******************************************
// ***   Sicherheitsventile beschreiben   ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_sv1_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string chk_jobstatus = "";

  ftextout( "Sicherheitsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );



  LINE( "","" )
  {
    if ( strom_sv_1 == 1 )
    {
      strom_var = "";
      strom_sv_1 = 0;
      inputint( strom_sv_mA, "Sicherheitsventil", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_sv_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Sicherheitsventil bestromen MIT Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_SV_PWM_MIT_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_sv_1 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
    }

    strom_sv_1 = 0;
    
  }
}

// ******************************************
// ***   Sicherheitsventile beschreiben   ***
// ***   ohne Fehlerpruefung              ***
// ******************************************
SCREEN s_sv2_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string chk_jobstatus = "";

  ftextout( "Sicherheitsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );


  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );


  LINE( "","" )
  {
    if ( strom_sv_2 == 1 )
    {
      strom_var = "";
      strom_sv_2 = 0;
      inputint( strom_sv_mA, "Sicherheitsventil", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_sv_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Sicherheitsventil bestromen OHNE Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe ohne Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_SV_PWM_OHNE_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_sv_2 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
    }
  
    strom_sv_2 = 0;

  }
}

// ******************************************
// ***   Sicherheitsventile beschreiben   ***
// ***   Hochlaufpruefung                 ***
// ******************************************
SCREEN s_sv3_ventil_schreiben()
{
  string text_var = "";
  string chk_jobstatus = "";

  ftextout( "Sicherheitsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );


  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );


  LINE( "","" )
  {
    if ( strom_sv_3 == 1 )
    {

      ftextout( "Sicherheitsventil Hochlaufpruefung", 1, 1, 0, 0 );
      // Hochlaufpruefung Pruefimpuls
      INPAapiJob( sgbd, "STEUERN_SV_HOCHLAUFPRUEFUNG", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_sv_3 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
    }

    ftextout( "Sicherheitsventil Hochlaufpruefung", 1, 1, 0, 0 );
    
  }
  
}

// ******************************************
// ***   Sicherheitsventile beschreiben   ***
// ***   Push Hold Ansteuerung            ***
// ******************************************
SCREEN s_sv4_ventil_schreiben()
{
  string text_var = "";
  string chk_jobstatus = "";

  ftextout( "Sicherheitsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );


  LINE( "","" )
  {
    if ( strom_sv_4 == 1 )
    {

      ftextout( "Sicherheitsventil Push Hold Ansteuerung", 1, 1, 0, 0 );
      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_SV_PUSHHOLD", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_sv_4 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
      }
    }

    ftextout( "Sicherheitsventil Push Hold Ansteuerung", 1, 1, 0, 0 );
    
  }
  
}

// ******************************************
// ***   Sicherheitsventile beschreiben   ***
// ***   Push Hold Ansteuerung            ***
// ***   Dauerbestromung                  ***
// ******************************************
SCREEN s_sv_ventil_pushhold_dauer_schreiben()
{

  string chk_jobstatus = "";


  ftextout( "Sicherheitsventil wird dauerbestromt", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Sicherheitsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_SICHERHEITSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Sicherheitsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_sv_ventil, "STAT_STROM_SICHVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_sv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_SICHVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );


  ftextout( "Daueransteuerung", 12, 1, 1, 0 );
  digitalout( sv_ein_aus, 12, 30, "Ein", "Aus" );


  LINE( "","" )
  {

    if ( sv_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 1, 1, 0, 0 );
      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_SV_PUSHHOLD", "", "" );
  //      INPAapiCheckJobStatus( "OKAY" );
  
  
      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        sv_ein_aus = TRUE;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
        sv_ein_aus = FALSE;
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_sv_schreiben, TRUE );
        sv_ein_aus = FALSE;
      }
    }
  }
}



// ******************************************
// ***   Richtungsventil beschreiben      ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_rv1_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string chk_jobstatus = "";

  real stat_schaltstellung_RV;
  real spg_rv_sensor;
  
  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Schaltventilsensor ( RV )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Richtungsventil", 9, 5, 0, 0 );
  ftextout( ":", 9, 27, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_rv_sensor, "STAT_POSITION_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_rv_sensor, 9, 30, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
  ftextout( text_var, 9, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Schaltstellung RV [ -1, 0, 1 ]
  ftextout( "Schaltstellung RV", 11, 5, 0, 0 );
  ftextout( ":", 11, 27, 0, 0 );
  // Schaltstellung RV auslesen
  INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
  //                         Zl, Sp, min  max           Format
  //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
  analogout( stat_schaltstellung_RV, 11, 30, -1.5, 1.5, -1, 1, "1" );

  // Einheit [Zustand]
  INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
  ftextout( text_var, 11, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  LINE( "","" )
  {
    if ( strom_rv_1 == 1 )
    {
      strom_var = "";
      strom_rv_1 = 0;
      inputint( strom_rv_mA, "Richtungsventil", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_rv_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Richtungsventil bestromen MIT Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_RV_PWM_MIT_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_rv_1 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
    }

    strom_rv_1 = 0;
    
  }
}

// ******************************************
// ***   Richtungsventil beschreiben      ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_rv2_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string chk_jobstatus = "";

  real spg_rv_sensor;
  real stat_schaltstellung_RV;

  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Schaltventilsensor ( RV )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Richtungsventil", 9, 5, 0, 0 );
  ftextout( ":", 9, 27, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_rv_sensor, "STAT_POSITION_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_rv_sensor, 9, 30, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
  ftextout( text_var, 9, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Schaltstellung RV [ -1, 0, 1 ]
  ftextout( "Schaltstellung RV", 11, 5, 0, 0 );
  ftextout( ":", 11, 27, 0, 0 );
  // Schaltstellung RV auslesen
  INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
  //                         Zl, Sp, min  max           Format
  //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
  analogout( stat_schaltstellung_RV, 11, 30, -1.5, 1.5, -1, 1, "1" );

  // Einheit [Zustand]
  INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
  ftextout( text_var, 11, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_rv_2 == 1 )
    {
      strom_var = "";
      strom_rv_2 = 0;
      inputint( strom_rv_mA, "Richtungsventil", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_rv_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Richtungsventil bestromen OHNE Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_RV_PWM_OHNE_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_rv_2 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
    }

    strom_rv_2 = 0;
    
  }
}


// ******************************************
// ***   Richtungsventil beschreiben   ***
// ***   Hochlaufpruefung                 ***
// ******************************************
SCREEN s_rv3_ventil_schreiben()
{
  string text_var = "";
  string chk_jobstatus = "";

  real spg_rv_sensor;
  real stat_schaltstellung_RV;
  
  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Schaltventilsensor ( RV )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Richtungsventil", 9, 5, 0, 0 );
  ftextout( ":", 9, 27, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_rv_sensor, "STAT_POSITION_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_rv_sensor, 9, 30, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
  ftextout( text_var, 9, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Schaltstellung RV [ -1, 0, 1 ]
  ftextout( "Schaltstellung RV", 11, 5, 0, 0 );
  ftextout( ":", 11, 27, 0, 0 );
  // Schaltstellung RV auslesen
  INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
  //                         Zl, Sp, min  max           Format
  //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
  analogout( stat_schaltstellung_RV, 11, 30, -1.5, 1.5, -1, 1, "1" );

  // Einheit [Zustand]
  INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
  ftextout( text_var, 11, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_rv_3 == 1 )
    {

      ftextout( "Richtungsventil Hochlaufpruefung", 1, 1, 0, 0 );
      // Hochlaufpruefung Pruefimpuls
      INPAapiJob( sgbd, "STEUERN_RV_HOCHLAUFPRUEFUNG", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_rv_3 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
    }
    ftextout( "Richtungsventil Hochlaufpruefung", 1, 1, 0, 0 );

  }
  
}

// ******************************************
// ***   Richtungsventil    beschreiben   ***
// ***   Push Hold Ansteuerung            ***
// ******************************************
SCREEN s_rv4_ventil_schreiben()
{
  string text_var = "";
  string chk_jobstatus = "";

  real spg_rv_sensor;
  real stat_schaltstellung_RV;
  
  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Schaltventilsensor ( RV )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Richtungsventil", 9, 5, 0, 0 );
  ftextout( ":", 9, 27, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_rv_sensor, "STAT_POSITION_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_rv_sensor, 9, 30, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
  ftextout( text_var, 9, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Schaltstellung RV [ -1, 0, 1 ]
  ftextout( "Schaltstellung RV", 11, 5, 0, 0 );
  ftextout( ":", 11, 27, 0, 0 );
  // Schaltstellung RV auslesen
  INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
  //                         Zl, Sp, min  max           Format
  //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
  analogout( stat_schaltstellung_RV, 11, 30, -1.5, 1.5, -1, 1, "1" );

  // Einheit [Zustand]
  INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
  ftextout( text_var, 11, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_rv_4 == 1 )
    {

      ftextout( "Richtungsventil Push Hold Ansteuerung", 1, 1, 0, 0 );
      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_RV_PUSHHOLD", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_rv_4 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
      }
    }
    ftextout( "Richtungsventil Push Hold Ansteuerung", 1, 1, 0, 0 );

  }
  
}

// ******************************************
// ***   Richtungsventil    beschreiben   ***
// ***   Push Hold Ansteuerung            ***
// ******************************************
SCREEN s_rv_ventil_pushhold_dauer_schreiben()
{
  string chk_jobstatus = "";

  real spg_rv_sensor;
  real stat_schaltstellung_RV;
  
  ftextout( "Richtungsventil bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_SCHALTVENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Richtungsventil", 5, 5, 0, 0 );
  ftextout( ":", 5, 27, 0, 0 );
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_WERT", 1, "" );
  ftextout( text_var, 5, 30, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_RICHTUNGSVENTIL_TEXT", 1, "" );
  ftextout( text_var, 5, 45, 0, 0 );


  ftextout( "Steuerstrom Richtungsventil", 7, 5, 0, 0 );
  ftextout( ":", 7, 27, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_rv_ventil, "STAT_STROM_RICHTVENT_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_rv_ventil, 7, 30, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STROM_RICHTVENT_EINH", 1, "" );
  ftextout( text_var, 7, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Schaltventilsensor ( RV )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Richtungsventil", 9, 5, 0, 0 );
  ftextout( ":", 9, 27, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_rv_sensor, "STAT_POSITION_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_rv_sensor, 9, 30, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_POSITION_HW_EINH", 1, "" );
  ftextout( text_var, 9, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Schaltstellung RV [ -1, 0, 1 ]
  ftextout( "Schaltstellung RV", 11, 5, 0, 0 );
  ftextout( ":", 11, 27, 0, 0 );
  // Schaltstellung RV auslesen
  INPAapiResultAnalog( stat_schaltstellung_RV, "STAT_POSITION_SW_WERT", 1 );
  //                         Zl, Sp, min  max           Format
  //analogout( stat_schaltstellung_RV, 21, 30, -1, 1, -1, 1, "7.5" );
  analogout( stat_schaltstellung_RV, 11, 30, -1.5, 1.5, -1, 1, "1" );

  // Einheit [Zustand]
  INPAapiResultText( text_var, "STAT_POSITION_SW_EINH", 1, "" );
  ftextout( text_var, 11, 65, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  ftextout( "Daueransteuerung", 16, 1, 1, 0 );
  digitalout( rv_ein_aus, 16, 30, "Ein", "Aus" );

  LINE( "","" )
  {
    if ( rv_ein_aus == TRUE )
    {
      ftextout( "Nach Taste AUS wird der Strom noch 2 sec. gehalten", 1, 1, 0, 0 );

      // Push Hold Ansteuerung
      INPAapiJob( sgbd, "STEUERN_RV_PUSHHOLD", "", "" );
//      INPAapiCheckJobStatus( "OKAY" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        rv_ein_aus = TRUE;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
        rv_ein_aus = FALSE;
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_rv_schreiben, TRUE );
        rv_ein_aus = FALSE;
      }
    }
  }
  
}



// ******************************************
// ***   Propventil VA beschreiben        ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_va1_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";

  real spg_va_sensor;
  real stat_istdruck_ventil;



  ftextout( "Proportionalventil VA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Propventil VA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil VA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_va_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( VA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor VA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_va_sensor, "STAT_DRUCK_VA_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_va_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_VA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  // Ist Druck VA
  ftextout( "Ist Druck VA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_VA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_VA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////

  LINE( "","" )
  {
    if ( strom_va_1 == 1 )
    {
      strom_var = "";
      strom_va_1 = 0;
      inputint( strom_va_mA, "Proportionalventil VA", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_va_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Proportionalventil VA bestromen MIT Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_PVVA_PWM_MIT_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_va_1 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
    }

    strom_va_1 = 0;
    
  }
}

// ******************************************
// ***   Propventil VA beschreiben      ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_va2_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";

  real spg_va_sensor;
  real stat_istdruck_ventil;


  ftextout( "Proportionalventil VA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Proportionalventil VA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil VA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_va_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////
  

  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( VA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor VA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_va_sensor, "STAT_DRUCK_VA_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_va_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_VA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  // Ist Druck VA
  ftextout( "Ist Druck VA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_VA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_VA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_va_2 == 1 )
    {
      strom_var = "";
      strom_va_2 = 0;
      inputint( strom_va_mA, "Proportionalventil VA", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_va_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Proportionalventil VA bestromen OHNE Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_PVVA_PWM_OHNE_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_va_2 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
    }

    strom_va_2 = 0;
    
  }
}


// **********************************************
// ***   Proportionalventil VA  beschreiben   ***
// ***   Hochlaufpruefung                     ***
// **********************************************
SCREEN s_va3_ventil_schreiben()
{
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";

  real spg_va_sensor;
  real stat_istdruck_ventil;

  ftextout( "Proportionalventil VA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );


  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Proportionalventil VA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_VA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_VA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil VA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_va_ventil, "STAT_STEUERSTROM_VA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_va_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_VA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( VA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor VA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_va_sensor, "STAT_DRUCK_VA_HW_WERT", 1 );
  //                       Zl, Sp, min  max    Format
  analogout( spg_va_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_VA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  // Ist Druck VA
  ftextout( "Ist Druck VA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_VA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_VA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////

  LINE( "","" )
  {
    if ( strom_va_3 == 1 )
    {

      ftextout( "Proportionalventil VA Hochlaufpruefung", 1, 1, 0, 0 );
      // Hochlaufpruefung Pruefimpuls
      INPAapiJob( sgbd, "STEUERN_PVVA_HOCHLAUFPRUEFUNG", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_va_3 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_va_schreiben, TRUE );
      }
    }
    ftextout( "Proportionalventil VA Hochlaufpruefung", 1, 1, 0, 0 );

  }
  
}

// ******************************************
// ***   Propventil HA beschreiben        ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_ha1_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";
  
  real spg_ha_sensor;
  real stat_istdruck_ventil;

  ftextout( "Proportionalventil HA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Propventil HA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil HA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_ha_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( HA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor HA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_ha_sensor, "STAT_DRUCK_HA_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_ha_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_HA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Ist Druck HA
  ftextout( "Ist Druck HA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_HA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_HA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_ha_1 == 1 )
    {
      strom_var = "";
      strom_ha_1 = 0;
      inputint( strom_ha_mA, "Proportionalventil HA", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_ha_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Proportionalventil HA bestromen MIT Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_PVHA_PWM_MIT_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_ha_1 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
    }

    strom_ha_1 = 0;
    
  }
}

// ******************************************
// ***   Propventil HA beschreiben      ***
// ***   mit Fehlerpruefung               ***
// ******************************************
SCREEN s_ha2_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";

  real spg_ha_sensor;
  real stat_istdruck_ventil;


  ftextout( "Proportionalventil HA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );

  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );


  ftextout( "Status Proportionalventil HA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil HA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_ha_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( HA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor HA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_ha_sensor, "STAT_DRUCK_HA_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_ha_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_HA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Ist Druck HA
  ftextout( "Ist Druck HA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_HA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_HA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////


  LINE( "","" )
  {
    if ( strom_ha_2 == 1 )
    {
      strom_var = "";
      strom_ha_2 = 0;
      inputint( strom_ha_mA, "Proportionalventil HA", "Steuerstrom in mA", 0, 3000 );
      //
      getinputstate( input_state );
      // Eingabe wurde mit Abbruch abgeschlossen
      if ( input_state == 1 )
      {
        userboxclose( 0 );
        viewclose();
      }
      // Eingabe wurde mit OK abgeschlossen
      else if ( input_state == 0 )
      {
        // Variablenumwandlung int --> string
        inttostring( strom_ha_mA, strom_var );        
        // Dialog schliessen
        userboxclose( 0 );
        viewclose();
      }
    }

    // nur bei OK ausfuehren
    if ( input_state == 0 )
    {
      ftextout( "Proportionalventil HA  bestromen OHNE Fehlerpruefung", 1, 1, 0, 0 );
      // Strom Ausgabe mit Fehlerpruefung
      INPAapiJob( sgbd, "STEUERN_PVHA_PWM_OHNE_FP", strom_var, "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_ha_2 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
    }

    strom_ha_2 = 0;
    
  }
}


// **********************************************
// ***   Proportionalventil HA  beschreiben   ***
// ***   Hochlaufpruefung                     ***
// **********************************************
SCREEN s_ha3_ventil_schreiben()
{
  string strom_var = "";
  string text_var = "";
  string text_var_einh = "";
  string chk_jobstatus = "";

  real spg_ha_sensor;
  real stat_istdruck_ventil;

  ftextout( "Proportionalventil HA bestromen", 1, 0, 1, 0 );
  ftextout( "", 3, 0, 0, 0 );


  INPAapiJob( sgbd, "STATUS_PROPORTIONAL_VENTILE", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Status Proportionalventil HA", 5, 5, 0, 0 );
  ftextout( ":", 5, 35, 0, 0 );
  INPAapiResultText( text_var, "STAT_VENTIL_HA_WERT", 1, "" );
  ftextout( text_var, 5, 37, 0, 0 );

  // Einheit [Zustand (ein/aus)]
  INPAapiResultText( text_var, "STAT_VENTIL_HA_TEXT", 1, "" );
  ftextout( text_var, 5, 50, 0, 0 );


  ftextout( "Steuerstrom Proportionalventil HA", 7, 5, 0, 0 );
  ftextout( ":", 7, 35, 0, 0 );
  // Stromwert auslesen
  INPAapiResultAnalog( strom_ha_ventil, "STAT_STEUERSTROM_HA_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( strom_ha_ventil, 7, 37, 0, 3, 0, 3, "5.3" );

  // Einheit [Ampere]
  INPAapiResultText( text_var, "STAT_STEUERSTROM_HA_EINH", 1, "" );
  ftextout( text_var, 7, 70, 0, 0 );


  //////////////////////////////////////////////////////////////////////////
  // anzeigen der aktuell anliegenden Spannung am Drucksensor ( HA )
  // umgerechneter 10 bit Wert
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Spannung am Drucksensor HA", 9, 5, 0, 0 );
  ftextout( ":", 9, 35, 0, 0 );
  // Spannung auslesen
  INPAapiResultAnalog( spg_ha_sensor, "STAT_DRUCK_HA_HW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( spg_ha_sensor, 9, 37, 0, 6, 0, 6, "2.3" );

  // Einheit [Volt]
  INPAapiResultText( text_var, "STAT_DRUCK_HA_HW_EINH", 1, "" );
  ftextout( text_var, 9, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  //////////////////////////////////////////////////////////////////////////
  INPAapiJob( sgbd, "STATUS_ARS_SENSOREN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  // Ist Druck HA
  ftextout( "Ist Druck HA", 11, 5, 0, 0 );
  ftextout( ":", 11, 35, 0, 0 );
  //
  INPAapiResultAnalog( stat_istdruck_ventil, "STAT_DRUCK_HA_SW_WERT", 1 );
  //                         Zl, Sp, min  max    Format
  analogout( stat_istdruck_ventil, 11, 37, -2, 250, -2, 250, "3.3" );

  // Einheit [bar]
  INPAapiResultText( text_var_einh, "STAT_DRUCK_HA_SW_EINH", 1, "" );
  ftextout( text_var_einh, 11, 70, 0, 0 );
  //////////////////////////////////////////////////////////////////////////



  LINE( "","" )
  {
    if ( strom_ha_3 == 1 )
    {

      ftextout( "Proportionalventil HA Hochlaufpruefung", 1, 1, 0, 0 );
      // Hochlaufpruefung Pruefimpuls
      INPAapiJob( sgbd, "STEUERN_PVHA_HOCHLAUFPRUEFUNG", "", "" );

      INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
      if ( chk_jobstatus == "OKAY" )
      {
        strom_ha_3 = 0;
      }
      else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
      {
        infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
      else
      {
        infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
        userboxclose( 0 );
        viewclose();
        setscreen( s_ha_schreiben, TRUE );
      }
    }
    ftextout( "Proportionalventil HA Hochlaufpruefung", 1, 1, 0, 0 );

  }
  
}

// ***************************************
// ***  Nullpunkte der Sensoren lernen ***
// ***  mit Grenzwertueberwachung      ***
// ***  Anfangsbildschirm              ***
// ***************************************
SCREEN s_nullpkt_mitGrenz_lernen()
{

  ftextout( "MIT GRENZWERTUEBERWACHUNG"                  ,1, 1, 0, 1 );
  ftextout( "< F1 >  Arbeitsnullpunkt Drucksensor VA lernen"                  ,3, 5, 0, 1 );
  ftextout( "< F2 >  Arbeitsnullpunkt Drucksensor HA lernen"                  ,5, 5, 0, 1 );
  ftextout( "< F3 >  Arbeitsnullpunkt Querbeschleunigungssensor lernen"        ,7, 5, 0, 1 );

}

// ***************************************
// ***  Nullpunkte der Sensoren lernen ***
// ***  mit Grenzwertueberwachung      ***
// ***************************************
SCREEN s_nullpkt_lernen()
{
  real stat_offsetdruck_ventil;
  real stat_offsetquerbesch;

  string chk_jobstatus = "";
    
  ftextout( "MIT GRENZWERTUEBERWACHUNG"                                        ,1, 1, 0, 1 );
  ftextout( "< F1 >  Arbeitsnullpunkt Drucksensor VA lernen"                  ,3, 5, 0, 1 );
  ftextout( "< F2 >  Arbeitsnullpunkt Drucksensor HA lernen"                  ,5, 5, 0, 1 );
  ftextout( "< F3 >  Arbeitsnullpunkt Querbeschleunigungssensor lernen"        ,7, 5, 0, 1 );

  if ( toggle_1 == 1 )
  {
    INPAapiJob( sgbd, "START_OFFSET_WERTE_VA", "", "" );
//    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

    if ( chk_jobstatus == "OKAY" )
    {
      // gelernter Offset Wert lesen fuer Nullpunkt Druck VA
      INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_VA", "", "" );
      INPAapiCheckJobStatus( "OKAY" );
  
      // Druck VA
      ftextout( "Arbeitsnullpunkt fuer Druck VA", 10, 1, 0, 0 );
      ftextout( ":", 10, 35, 0, 0 );
      //
      INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_NULLPUNKT_OFFSET_DRUCK_VA_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( stat_offsetdruck_ventil, 10, 37, 0, 3000, 0, 3000, "5.1" );
  
      // Einheit [bar]
      INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_DRUCK_VA_EINH", 1, "" );
      ftextout( text_var, 10, 75, 0, 0 );

      toggle_1 = 0;
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else
    {
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    toggle_1 = 0;
  }
    
  if ( toggle_2 == 1 )
  {
    INPAapiJob( sgbd, "START_OFFSET_WERTE_HA", "", "" );
//    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

    if ( chk_jobstatus == "OKAY" )
    {
      // gelernter Offset Wert lesen fuer Nullpunkt Druck HA
      INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_HA", "", "" );
      INPAapiCheckJobStatus( "OKAY" );
    
      // Druck HA
      ftextout( "Arbeitsnullpunkt fuer Druck HA", 15, 1, 0, 0 );
      ftextout( ":", 15, 35, 0, 0 );
      //
      INPAapiResultAnalog( stat_offsetdruck_ventil, "STAT_NULLPUNKT_OFFSET_DRUCK_HA_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( stat_offsetdruck_ventil, 15, 37, 0, 3000, 0, 3000, "5.1" );
  
      // Einheit [bar]
      INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_DRUCK_HA_EINH", 1, "" );
      ftextout( text_var, 15, 75, 0, 0 );

      toggle_2 = 0;
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else
    {
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }

    toggle_2 = 0;
  }

  if ( toggle_3 == 1 )
  {
    INPAapiJob( sgbd, "START_OFFSET_QUERBESCH", "", "" );
//    INPAapiCheckJobStatus( "OKAY" );
    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );

    if ( chk_jobstatus == "OKAY" )
    {
      // gelernter Offset Wert lesen fuer Querbeschleunigung
      INPAapiJob( sgbd, "STATUS_OFFSET_QUERBESCH", "", "" );
      INPAapiCheckJobStatus( "OKAY" );
  
      // Querbeschleunigung
      ftextout( "Arbeitsnullpunkt fuer Querbeschleunigung", 20, 1, 0, 0 );
      ftextout( ":", 20, 35, 0, 0 );
      //
      INPAapiResultAnalog( stat_offsetquerbesch, "STAT_NULLPUNKT_OFFSET_QUERBESCH_WERT", 1 );
      //                         Zl, Sp, min  max    Format
      analogout( stat_offsetquerbesch, 20, 37, 0, 3000, 0, 3000, "5.1" );
  
      // Einheit [bar]
      INPAapiResultText( text_var, "STAT_NULLPUNKT_OFFSET_QUERBESCH_EINH", 1, "" );
      ftextout( text_var, 20, 75, 0, 0 );
    
      toggle_3 = 0; 
    }
    else if ( chk_jobstatus == "ERROR_ECU_CONDITIONS_NOT_CORRECT_OR_REQUEST_SEQUENCE_ERROR" )
    {
      infobox ( "Randbedingungen wurden verletzt", "Fahrzeug muss stehen, ==> FZGgeschw. gleich NULL oder DSC inaktiv" );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }
    else
    {
      infobox ( "Randbedingungen wurden verletzt --> unbekannter Fehlerfall", chk_jobstatus );
      userboxclose( 0 );
      viewclose();
      setscreen( s_nullpkt_mitGrenz_lernen, TRUE );
    }

    toggle_3 = 0;
  }  

}



// ***************************************************
// *** AIF UIF Felder Aktuell lesen ueber '1A 86'  ***
// ***************************************************
// ueber Taste 'Shift F1'
SCREEN s_aif_aktuell_lesen()
{
  int offset;
  int temp;
  int aif_adresse;
  int spalte_beschreibung = 10;
  int spalte_speicherwerte = 55;
  int spalte_anzeigewerte = 40;
  int spalte_doppelpkt = 38;

  INPAapiJob( sgbd, "AIF_AKTUELL_LESEN", "", "" );
  INPAapiCheckJobStatus( "OKAY" );

  ftextout( "Aktuelles AIF Info; ausgelesen ueber '1A 86'", 1, 0, 0, 1 );


  ftextout( "Anzeigendarstellung", 3, spalte_doppelpkt, 0, 0 );
  ftextout( "Telegrammdarstellung", 3, spalte_speicherwerte, 0, 0 );
  //
  //
  // 2te Zeile 'Fahrgestellnummer'; 7 Byte
  ftextout( "VIN", 7, 0, 0, 0 );
  ftextout( "Fahrgestellnummer", 7, spalte_beschreibung, 0, 0 );
  ftextout( ":", 7, spalte_doppelpkt, 0, 0 );


  INPAapiResultText( text_var, "AIF_FAHRGESTELL_NR", 1, "" );
  ftextout( text_var, 7, spalte_anzeigewerte, 0, 0 );

  // Speicherwerte / Telegrammdaten
  INPAapiResultText( text_var, "AIF_FAHRGESTELL_NR_HEX", 1, "" );
  ftextout( text_var, 7, spalte_speicherwerte, 0, 0 );

 
  //
  //
  // 3te Zeile 'Programmierdatum'; 4 Byte
  ftextout( "PD", 9, 0, 0, 0 );
  ftextout( "Programmierdatum", 9, spalte_beschreibung, 0, 0 );
  ftextout( ":", 9, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_PD_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_PROGRAMMIER_DATUM", 1, "" );
  ftextout( text_var, 9, spalte_anzeigewerte, 0, 0 );

  // Speicherwerte / Telegrammdaten
  INPAapiResultText( text_var, "AIF_PROGRAMMIER_DATUM_HEX", 1, "" );
  ftextout( text_var, 9, spalte_speicherwerte, 0, 0 );


  //
  //
  // 4te Zeile 'Zusammenbaunummer'; 6 Byte
  ftextout( "AN", 11, 0, 0, 0 );
  ftextout( "Zusammenbaunummer", 11, spalte_beschreibung, 0, 0 );
  ftextout( ":", 11, spalte_doppelpkt, 0, 0 );

  //INPAapiJob( sgbd, "AIF_MPC555_AN_LESEN", aif_block_nr, "" );
  //INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_ZUSAMMENBAU_NR", 1, "" );
  ftextout( text_var, 11, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_ZUSAMMENBAU_NR_HEX", 1, "" );
  ftextout( text_var, 11, spalte_speicherwerte, 0, 0 );


  //
  //
  // 5te Zeile 'Codierdatensatznummer'; 6 Byte
  ftextout( "CDSN", 13, 0, 0, 0 );
  ftextout( "Codierdatensatznummer", 13, spalte_beschreibung, 0, 0 );
  ftextout( ":", 13, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_CDSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_DATENSATZ_NR", 1, "" );
  ftextout( text_var, 13, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_DATENSATZ_NR_HEX", 1, "" );
  ftextout( text_var, 13, spalte_speicherwerte, 0, 0 );


  //
  //
  // 6te Zeile 'Behoerdennummer'; 6 Byte
  ftextout( "EROTAN", 15, 0, 0, 0 );
  ftextout( "Behoerdennummer/Abgasnummer", 15, spalte_beschreibung, 0, 0 );
  ftextout( ":", 15, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_EROTAN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_BEHOERDEN_NR", 1, "" );
  ftextout( text_var, 15, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_BEHOERDEN_NR_HEX", 1, "" );
  ftextout( text_var, 15, spalte_speicherwerte, 0, 0 );


  //
  //
  // 7te Zeile 'Haendlernummer'; 3 Byte
  ftextout( "RSCOTSN", 17, 0, 0, 0 );
  ftextout( "Werkscode bzw HaendlerNr.", 17, spalte_beschreibung, 0, 0 );
  ftextout( ":", 17, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_RSCOTSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_HAENDLER_NR", 1, "" );
  ftextout( text_var, 17, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_HAENDLER_NR_HEX", 1, "" );
  ftextout( text_var, 17, spalte_speicherwerte, 0, 0 );

  //
  //
  // 8te Zeile 'Testernummer'; 5 Byte
  ftextout( "RSCOTSN", 19, 0, 0, 0 );
  ftextout( "Tester-SerienNr.", 19, spalte_beschreibung, 0, 0 );
  ftextout( ":", 19, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_RSCOTSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_TESTER_NR", 1, "" );
  ftextout( text_var, 19, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_TESTER_NR_HEX", 1, "" );
  ftextout( text_var, 19, spalte_speicherwerte, 0, 0 );



  //
  //
  // 9te Zeile 'KM Stand' mit Faktor 600 multipli.; 1 Byte
  ftextout( "KM", 21, 0, 0, 0 );
  ftextout( "km Stand bei Programmierung", 21, spalte_beschreibung, 0, 0 );
  ftextout( ":", 21, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_KMPD_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_KM_STAND", 1, "" );
  ftextout( text_var, 21, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_KM_STAND_HEX", 1, "" );
  ftextout( text_var, 21, spalte_speicherwerte, 0, 0 );


  //
  //
  // 10te Zeile 'Programmstand als Programmreferenz'; 12 Byte
  ftextout( "PRGREF", 23, 0, 0, 0 );
  ftextout( "Programmstand als Programmreferenz", 23, spalte_beschreibung, 0, 0 );
  ftextout( ":", 23, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_PRGREF_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_PROGRAMM_STAND", 1, "" );
  ftextout( text_var, 23, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_PROGRAMM_STAND_HEX", 1, "" );
  ftextout( text_var, 23, spalte_speicherwerte, 0, 0 );


  //
  //
  // 11te Zeile 'Fahrgestellnummer lang'; 10 Byte
  //
  ftextout( "VINLONG", 25, 0, 0, 0 );
  ftextout( "Fahrgestellnummer lang", 25, spalte_beschreibung, 0, 0 );
  ftextout( ":", 25, spalte_doppelpkt, 0, 0 );

  INPAapiResultText( text_var, "AIF_FG_NR_LANG", 1, "" );
  ftextout( text_var, 25, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_FG_NR_LANG_HEX", 1, "" );
  ftextout( text_var, 25, spalte_speicherwerte, 0, 0 );



  //
  //
  // 12te Zeile 'Reserve'; 3 Byte
  ftextout( "Reserve", 27, 0, 0, 0 );
  ftextout( "3 Byte Reserve bei Power PC", 27, spalte_beschreibung, 0, 0 );
  ftextout( ":", 27, spalte_doppelpkt, 0, 0 );

  INPAapiResultText( text_var, "AIF_RESERVE", 1, "" );
  ftextout( text_var, 27, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_RESERVE_HEX", 1, "" );
  ftextout( text_var, 27, spalte_speicherwerte, 0, 0 );

}


// *********************************
// *** AIF UIF Felder lesen      ***
// *********************************
// ueber Taste 'Shift F2'
SCREEN s_aif_tabelle_lesen()
{
  int aifblocknr = 1;
  int offset;
  int belegteAIF = 0;
  int unbelegteAIF = 0;
  int ndAIF = 0;
  int belegt;
  string aif_block_nr = "";
  string logische_adresse = "";
  string physikalische_adresse = "";
  
  // Spaltenheader
  // erste Spalte
  ftextout( "AIF Nr.", 1, 0, 0, 0 );
  //
  // 2 Spalte
  ftextout( "freie AIF's", 1, 8, 0, 0 );
  ftextout( "(0xFF)oder(0x00)", 2, 8, 0, 0 );
  //
  // 3te Spalte 
  ftextout( "kl. AIF", 1, 23, 0, 0 );
  ftextout( "(18,0x12)", 2, 23, 0, 0 );
  //
  // 4te Spalte 
  ftextout( "gr. AIF", 1, 32, 0, 0 );
  ftextout( "(51,0x33)", 2, 32, 0, 0 );
  //
  // 5te Spalte 
  ftextout( "gr. AIF PowPC", 1, 42, 0, 0 );
  ftextout( "(64,0x40)", 2, 42, 0, 0 );
  //
  // 6te Spalte 
  ftextout( "undef. AIF", 1, 55, 0, 0 );
  ftextout( "(??,0x??)", 2, 55, 0, 0 );
  //
  // 7te Spalte 'Zusammenbaunummer'
  ftextout( "log. Adresse", 1, 65, 0, 0 );
  //
  // 8te Spalte 'Codierdatensatznummer'
  ftextout( "phys. Adresse", 1, 75, 0, 0 );

  ftextout( "----------------------------------------------------------------------------------------------------------------------------------------------------------", 3, 0, 0, 0 );

  //while ( aifblocknr < 15 )
  // Schleife fuer 16 AIF Felder
  while ( aifblocknr < 16 )
  {

    inttostring( aifblocknr, aif_block_nr );
    INPAapiJob( sgbd, "AIF_TABELLE_LESEN", aif_block_nr, "" );
    INPAapiCheckJobStatus( "OKAY" );

    //        Zeichenkette       Zeile           Spalte
    ftextout( aif_block_nr, aifblocknr + 3, 1, 0, 0 );

    // Telegrammwert in Hex --> 0x40;
    INPAapiResultText( text_var, "AIF_ANZ_DATEN_HEX", 1, "" );
    // Dezimalwertdarstellung 0x40 hex --> 64 dez
    INPAapiResultInt( offset, "AIF_ANZ_DATEN", 1 );
    INPAapiResultInt( belegt, "BELEGT", 1 );

    
    if ( offset == 255 && belegt == 0 )
    {
      // freie AIF's alle Bytes sind mit 0xFF belegt
      ftextout( text_var, aifblocknr + 3, 8, 0, 0 );
      inttostring( offset, text_var );
      ftextout( text_var, aifblocknr + 3, 15, 0, 0 );
      unbelegteAIF = unbelegteAIF + 1;
    }
    else if ( offset == 18  )
    {
      // kleines AIF nur 3 Felder belegt ( VIN, PD, AN ) 
      ftextout( text_var, aifblocknr + 3, 23, 0, 0 );
      inttostring( offset, text_var );
      ftextout( text_var, aifblocknr + 3, 28, 0, 0 );
      belegteAIF = belegteAIF + 1;
    }
    else if ( offset == 51  )
    {
      // grosses AIF 
      ftextout( text_var, aifblocknr + 3, 32, 0, 0 );
      inttostring( offset, text_var );
      ftextout( text_var, aifblocknr + 3, 37, 0, 0 );
      belegteAIF = belegteAIF + 1;
    }
    else if ( offset == 64  )
    {
      // grosses AIF Powewr PC belegte AIF's 
      ftextout( text_var, aifblocknr + 3, 42, 0, 0 );
      inttostring( offset, text_var );
      ftextout( text_var, aifblocknr + 3, 47, 0, 0 );
      belegteAIF = belegteAIF + 1;
    }
    else
    {
      // undefinierte AIF's
      ftextout( text_var, aifblocknr + 3, 55, 0, 0 );
      inttostring( offset, text_var );
      ftextout( text_var, aifblocknr + 3, 60, 0, 0 );
      ndAIF = ndAIF + 1;
    }

    INPAapiResultText( logische_adresse, "LOGISCHE_ADRESSE", 1, "" );
    ftextout( logische_adresse, aifblocknr + 3, 65, 0, 0 );

    INPAapiResultText( physikalische_adresse, "PHYSIKALISCHE_ADRESSE", 1, "" );
    ftextout( physikalische_adresse, aifblocknr + 3, 75, 0, 0 );


    aifblocknr = aifblocknr + 1;
  }
  ftextout( "----------------------------------------------------------------------------------------------------------------------------------------------------------", aifblocknr + 4, 0, 0, 0 );

  ftextout( "Summe", aifblocknr + 6 , 0, 0, 0 );

  inttostring ( unbelegteAIF, text_var );
  //                  Zeile           Sp
  ftextout( text_var, aifblocknr + 6 , 8, 0, 0 );
  
  //
  inttostring ( belegteAIF, text_var );
  //                  Zeile           Sp
  ftextout( text_var, aifblocknr + 6 , 42, 0, 0 );

  //
  inttostring ( ndAIF, text_var );
  //                  Zeile           Sp
  ftextout( text_var, aifblocknr + 6 , 55, 0, 0 );

//ftextout( "Detail Info's zu jedem AIF Feld mit F1....<Shift> F4", 25 , 1, 1, 1 );

}

// *************************************
// *** AIF UIF Felder Detail lesen   ***
// *************************************
SCREEN s_aif_detail_lesen()
{
  int offset;
  int temp;
  int aif_adresse;
  int spalte_beschreibung = 10;
  int spalte_speicherwerte = 55;
  int spalte_anzeigewerte = 40;
  int spalte_doppelpkt = 38;
  string aif_block_nr = "";

  inttostring( aif_nr, aif_block_nr );
  //
  ftextout( "Anzeigendarstellung", 3, spalte_doppelpkt, 0, 0 );
  ftextout( "Telegrammdarstellung", 3, spalte_speicherwerte, 0, 0 );
  //
  //

  // 
  // erste Zeile; 1 Byte
  ftextout( "Offset auf naechsten gueltigen Blockeintrag", 5, 0, 0, 0 );
  ftextout( ":", 5, spalte_doppelpkt, 0, 0 );

 // INPAapiJob( sgbd, "AIF_MPC555_OFFSET_LESEN", aif_block_nr, "" );
  INPAapiJob( sgbd, "AIF_TABELLE_LESEN", aif_block_nr, "" );
  INPAapiCheckJobStatus( "OKAY" );

  // letzter, damit aktuell gueltiger Datensatz
  if ( aif_nr == 0 )
  {
    INPAapiResultInt( aif_adresse, "AIF_ADRESSE", 1 );
    temp = ( aif_adresse / 64 ) + 1;
    inttostring( temp, aif_block_nr );
    strcat( text_var, "aktueller AIF Block ", aif_block_nr );
  }
  else
    strcat( text_var, "AIF Block ", aif_block_nr );

  ftextout( text_var, 1, 1, 1, 1 );
  
  // Dezimalwertdarstellung 0x40 hex --> 64 dez
  // Anzahl der DAten im AIF
  INPAapiResultInt( offset, "AIF_ANZ_DATEN", 1 );
  inttostring( offset, text_var );
  ftextout( text_var, 5, spalte_anzeigewerte, 0, 0 );

  // Speicherwerte / Telegrammdaten
  INPAapiResultText( text_var, "AIF_ANZ_DATEN_HEX", 1, "" );
  ftextout( text_var, 5, spalte_speicherwerte, 0, 0 );

  //
  //
  // 2te Zeile 'Fahrgestellnummer'; 7 Byte
  ftextout( "VIN", 7, 0, 0, 0 );
  ftextout( "Fahrgestellnummer", 7, spalte_beschreibung, 0, 0 );
  ftextout( ":", 7, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_VIN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_FAHRGESTELL_NR", 1, "" );
  ftextout( text_var, 7, spalte_anzeigewerte, 0, 0 );

  // Speicherwerte / Telegrammdaten
  INPAapiResultText( text_var, "AIF_FAHRGESTELL_NR_HEX", 1, "" );
  ftextout( text_var, 7, spalte_speicherwerte, 0, 0 );

 
  //
  //
  // 3te Zeile 'Programmierdatum'; 4 Byte
  ftextout( "PD", 9, 0, 0, 0 );
  ftextout( "Programmierdatum", 9, spalte_beschreibung, 0, 0 );
  ftextout( ":", 9, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_PD_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_PROGRAMMIER_DATUM", 1, "" );
  ftextout( text_var, 9, spalte_anzeigewerte, 0, 0 );

  // Speicherwerte / Telegrammdaten
  INPAapiResultText( text_var, "AIF_PROGRAMMIER_DATUM_HEX", 1, "" );
  ftextout( text_var, 9, spalte_speicherwerte, 0, 0 );


  //
  //
  // 4te Zeile 'Zusammenbaunummer'; 6 Byte
  ftextout( "AN", 11, 0, 0, 0 );
  ftextout( "Zusammenbaunummer", 11, spalte_beschreibung, 0, 0 );
  ftextout( ":", 11, spalte_doppelpkt, 0, 0 );

  //INPAapiJob( sgbd, "AIF_MPC555_AN_LESEN", aif_block_nr, "" );
  //INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_ZUSAMMENBAU_NR", 1, "" );
  ftextout( text_var, 11, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_ZUSAMMENBAU_NR_HEX", 1, "" );
  ftextout( text_var, 11, spalte_speicherwerte, 0, 0 );


  //
  //
  // 5te Zeile 'Codierdatensatznummer'; 6 Byte
  ftextout( "CDSN", 13, 0, 0, 0 );
  ftextout( "Codierdatensatznummer", 13, spalte_beschreibung, 0, 0 );
  ftextout( ":", 13, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_CDSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_DATENSATZ_NR", 1, "" );
  ftextout( text_var, 13, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_DATENSATZ_NR_HEX", 1, "" );
  ftextout( text_var, 13, spalte_speicherwerte, 0, 0 );


  //
  //
  // 6te Zeile 'Behoerdennummer'; 6 Byte
  ftextout( "EROTAN", 15, 0, 0, 0 );
  ftextout( "Behoerdennummer/Abgasnummer", 15, spalte_beschreibung, 0, 0 );
  ftextout( ":", 15, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_EROTAN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_BEHOERDEN_NR", 1, "" );
  ftextout( text_var, 15, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_BEHOERDEN_NR_HEX", 1, "" );
  ftextout( text_var, 15, spalte_speicherwerte, 0, 0 );


  //
  //
  // 7te Zeile 'Haendlernummer'; 3 Byte
  ftextout( "RSCOTSN", 17, 0, 0, 0 );
  ftextout( "Werkscode bzw HaendlerNr.", 17, spalte_beschreibung, 0, 0 );
  ftextout( ":", 17, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_RSCOTSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_HAENDLER_NR", 1, "" );
  ftextout( text_var, 17, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_HAENDLER_NR_HEX", 1, "" );
  ftextout( text_var, 17, spalte_speicherwerte, 0, 0 );

  //
  //
  // 8te Zeile 'Testernummer'; 5 Byte
  ftextout( "RSCOTSN", 19, 0, 0, 0 );
  ftextout( "Tester-SerienNr.", 19, spalte_beschreibung, 0, 0 );
  ftextout( ":", 19, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_RSCOTSN_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_TESTER_NR", 1, "" );
  ftextout( text_var, 19, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_TESTER_NR_HEX", 1, "" );
  ftextout( text_var, 19, spalte_speicherwerte, 0, 0 );



  //
  //
  // 9te Zeile 'KM Stand' mit Faktor 600 multipli.; 1 Byte
  ftextout( "KM", 21, 0, 0, 0 );
  ftextout( "km Stand bei Programmierung", 21, spalte_beschreibung, 0, 0 );
  ftextout( ":", 21, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_KMPD_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_KM_STAND", 1, "" );
  ftextout( text_var, 21, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_KM_STAND_HEX", 1, "" );
  ftextout( text_var, 21, spalte_speicherwerte, 0, 0 );


  //
  //
  // 10te Zeile 'Programmstand als Programmreferenz'; 12 Byte
  ftextout( "PRGREF", 23, 0, 0, 0 );
  ftextout( "Programmstand als Programmreferenz", 23, spalte_beschreibung, 0, 0 );
  ftextout( ":", 23, spalte_doppelpkt, 0, 0 );

//  INPAapiJob( sgbd, "AIF_MPC555_PRGREF_LESEN", aif_block_nr, "" );
//  INPAapiCheckJobStatus( "OKAY" );

  INPAapiResultText( text_var, "AIF_PROGRAMM_STAND", 1, "" );
  ftextout( text_var, 23, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_PROGRAMM_STAND_HEX", 1, "" );
  ftextout( text_var, 23, spalte_speicherwerte, 0, 0 );


  //
  //
  // 11te Zeile 'Fahrgestellnummer lang'; 10 Byte
  //
  ftextout( "VINLONG", 25, 0, 0, 0 );
  ftextout( "Fahrgestellnummer lang", 25, spalte_beschreibung, 0, 0 );
  ftextout( ":", 25, spalte_doppelpkt, 0, 0 );

  INPAapiResultText( text_var, "AIF_FG_NR_LANG", 1, "" );
  ftextout( text_var, 25, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_FG_NR_LANG_HEX", 1, "" );
  ftextout( text_var, 25, spalte_speicherwerte, 0, 0 );



  //
  //
  // 12te Zeile 'Reserve'; 3 Byte
  ftextout( "Reserve", 27, 0, 0, 0 );
  ftextout( "3 Byte Reserve bei Power PC", 27, spalte_beschreibung, 0, 0 );
  ftextout( ":", 27, spalte_doppelpkt, 0, 0 );

  INPAapiResultText( text_var, "AIF_RESERVE", 1, "" );
  ftextout( text_var, 27, spalte_anzeigewerte, 0, 0 );

  INPAapiResultText( text_var, "AIF_RESERVE_HEX", 1, "" );
  ftextout( text_var, 27, spalte_speicherwerte, 0, 0 );
}



// ***************************************
// ***  PAF DAF Indizes                ***
// ***************************************
// ueber Taste 'Shift F3'
SCREEN s_paf_daf_indizes()
{
  string text_var_paf_ppp = "";
  string text_var_paf_v = "";
  string text_var_paf_bb = "";
  string text_var_paf_x = "";
  string text_var_paf_h = "";
  string text_var_daf_d = "";
  string text_var_daf_xxxx = "";


  LINE( "","" )
  {
      // Hardware Referenz auslesen
      INPAapiJob( sgbd, "HARDWARE_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Hardware Ref. (22 2502) ZZZ PPPx", 2, 1, 0, 0 );
      ftextout( ":", 2, 40, 0, 0 );
      INPAapiResultText( text_var, "HARDWARE_ZZZ", 1, "" );
      ftextout( text_var, 2, 42, 0, 0 );

      INPAapiResultText( text_var_paf_ppp, "HARDWARE_PPP", 1, "" );
      ftextout( text_var_paf_ppp, 2, 46, 0, 0 );

      INPAapiResultText( text_var, "HARDWARE_X", 1, "" );
      ftextout( text_var, 2, 50, 0, 0 );


      // Programm Refz. auslesen
      INPAapiJob( sgbd, "PROGRAMM_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Progamm Ref. (22 2503) ZZZ PPPx V BBxh", 4, 1, 0, 0 );
      ftextout( ":", 4, 40, 0, 0 );
      INPAapiResultText( text_var, "HARDWARE_REFERENZ", 1, "" );
      ftextout( text_var, 4, 42, 0, 0 );

      INPAapiResultText( text_var_paf_v, "PROGRAMM_V", 1, "" );
      ftextout( text_var_paf_v, 4, 50, 0, 0 );

      INPAapiResultText( text_var_paf_bb, "PROGRAMM_BB", 1, "" );
      ftextout( text_var_paf_bb, 4, 52, 0, 0 );

      INPAapiResultText( text_var_paf_x, "PROGRAMM_X", 1, "" );
      ftextout( text_var_paf_x, 4, 56, 0, 0 );

      INPAapiResultText( text_var_paf_h, "PROGRAMM_H", 1, "" );
      ftextout( text_var_paf_h, 4, 58, 0, 0 );



      // PAF File Namen darstellen
/*      ftextout( "PPP  V  BB  x  h", 11, 15, 0, 0 );
      ftextout( "PAF Name:     ", 12, 1, 0, 0 );

      ftextout( text_var_paf_ppp, 12, 15, 0, 0 );
      ftextout( text_var_paf_v, 12, 19, 0, 0 );
      ftextout( text_var_paf_bb, 12, 21, 0, 0 );
      ftextout( text_var_paf_x, 12, 24, 0, 0 );
      ftextout( text_var_paf_h, 12, 26, 0, 0 );
*/
      ftextout( "PPP  V  BB  x  h", 13, 25, 1, 1 );
      ftextout( "PAF Name:     ", 15, 1, 1, 1 );

      ftextout( text_var_paf_ppp, 15, 25, 1, 1 );
      ftextout( text_var_paf_v, 15, 33, 1, 1 );
      ftextout( text_var_paf_bb, 15, 37, 1, 1 );
      ftextout( text_var_paf_x, 15, 43, 1, 1 );
      ftextout( text_var_paf_h, 15, 46, 1, 1 );




      // Daten Referenz auslesen
      INPAapiJob( sgbd, "DATEN_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Daten Ref. (22 2504) ZZZ PPPx V BBxh d xxxx", 8, 1, 0, 0 );
      ftextout( ":", 8, 40, 0, 0 );

      INPAapiResultText( text_var, "PROGRAMM_REFERENZ", 1, "" );
      ftextout( text_var, 8, 42, 0, 0 );
      // Hardware Referenz auslesen
      INPAapiJob( sgbd, "HARDWARE_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "PROGRAMMREFERENZ und DATENREFERENZ", 2, 1, 0, 1 );
      ftextout( "Hardware Ref. (22 2502) ZZZ PPPx", 4, 1, 0, 0 );
      ftextout( ":", 4, 40, 0, 0 );
      INPAapiResultText( text_var, "HARDWARE_ZZZ", 1, "" );
      ftextout( text_var, 4, 42, 0, 0 );

      INPAapiResultText( text_var_paf_ppp, "HARDWARE_PPP", 1, "" );
      ftextout( text_var_paf_ppp, 4, 46, 0, 0 );

      INPAapiResultText( text_var, "HARDWARE_X", 1, "" );
      ftextout( text_var, 4, 50, 0, 0 );


      // Programm Refz. auslesen
      INPAapiJob( sgbd, "PROGRAMM_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Progamm Ref. (22 2503) ZZZ PPPx V BBxh", 6, 1, 0, 0 );
      ftextout( ":", 6, 40, 0, 0 );
      INPAapiResultText( text_var, "HARDWARE_REFERENZ", 1, "" );
      ftextout( text_var, 6, 42, 0, 0 );

      INPAapiResultText( text_var_paf_v, "PROGRAMM_V", 1, "" );
      ftextout( text_var_paf_v, 6, 50, 0, 0 );

      INPAapiResultText( text_var_paf_bb, "PROGRAMM_BB", 1, "" );
      ftextout( text_var_paf_bb, 6, 52, 0, 0 );

      INPAapiResultText( text_var_paf_x, "PROGRAMM_X", 1, "" );
      ftextout( text_var_paf_x, 6, 56, 0, 0 );

      INPAapiResultText( text_var_paf_h, "PROGRAMM_H", 1, "" );
      ftextout( text_var_paf_h, 6, 58, 0, 0 );



      // PAF File Namen darstellen
      ftextout( "PAF Name PPP  V  BB  x  h", 10, 1, 0, 0 );
      ftextout( ":", 10, 20, 0, 0 );
      ftextout( text_var_paf_ppp, 10, 22, 0, 0 );
      ftextout( text_var_paf_v, 10, 26, 0, 0 );
      ftextout( text_var_paf_bb, 10, 28, 0, 0 );
      ftextout( text_var_paf_x, 10, 30, 0, 0 );
      ftextout( text_var_paf_h, 10, 32, 0, 0 );

      // Daten Referenz auslesen
      INPAapiJob( sgbd, "DATEN_REFERENZ_LESEN_PAF_DAF", "", "" );
      INPAapiCheckJobStatus( "OKAY" );

      ftextout( "Daten Ref. (22 2504) ZZZ PPPx V BBxh d xxxx", 8, 1, 0, 0 );
      ftextout( ":", 8, 40, 0, 0 );

      INPAapiResultText( text_var, "PROGRAMM_REFERENZ", 1, "" );
      ftextout( text_var, 8, 42, 0, 0 );

      INPAapiResultText( text_var_daf_d, "DATEN_D", 1, "" );
      ftextout( text_var_daf_d, 8, 60, 0, 0 );

      INPAapiResultText( text_var_daf_xxxx, "DATEN_XXXX", 1, "" );
      ftextout( text_var_daf_xxxx, 8, 62, 0, 0 );
      
      // DAF File Namen darstellen
      ftextout( "DAF Name V  BB  d  xxxx", 12, 1, 0, 0 );
      ftextout( ":", 12, 20, 0, 0 );
      ftextout( text_var_paf_v, 12, 22, 0, 0 );
      ftextout( text_var_paf_bb, 12, 24, 0, 0 );
      ftextout( text_var_daf_d, 12, 26, 0, 0 );
      ftextout( text_var_daf_xxxx, 12, 28, 0, 0 );   
      
  }
}

//// ****************************************
//// *** Steuernscreen Höhenstandabgleich ***
//// ****************************************
//SCREEN s_steuern_abgleich_hs()
//{
//  int    offset_vl;
//  int    offset_vr;
//  int    offset_hl;
//  int    offset_hr;
//  real   steigung_vl;
//  real   steigung_vr;
//  real   steigung_hl;
//  real   steigung_hr;
//  real   steigung_vl_phys;
//  real   steigung_vr_phys;
//  real   steigung_hl_phys;
//  real   steigung_hr_phys;
//  int    abw_vl;
//  int    abw_vr;
//  int    abw_hl;
//  int    abw_hr;
//  string str_abw_vl;
//  string str_abw_vr;
//  string str_abw_hl;
//  string str_abw_hr;
//  string text_var= "";
//  string chk_jobstatus="";
//  
//  ftextout("Steuern Höhenstandabgleich",1,0,1,0);
//  ftextout("",3,0,0,0);
//  LINE("","")
//  {
//    ftextout("aktuelle Abgleichwerte",1,0,0,1);
//    // aktuelle Werte lesen
//    INPAapiJob( sgbd, "STATUS_OFFSET_WERTE_HGLV", "", "" );
//    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
//    
//
//    INPAapiJob( sgbd, "STATUS_ABGLEICH_HOEHENSTAND", "", "" );
//    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
//    
//    if(chk_jobstatus == "OKAY")
//    {
//        // AD Wert Sensornullpunkt VL
//        ftextout( "AD-Wert Sensornullpunkt VL", 3, 1, 0, 0 );
//        ftextout( ":", 3, 25, 0, 0 );
//        // Wert
//        INPAapiResultAnalog( ad_null_vl, "STAT_AD_0_VL_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        analogout( ad_null_vl, 3, 27, 0, 1024, 0, 1024, "" );
//        // Einheit [digits]
//        INPAapiResultText( text_var, "STAT_AD_0_VL_EINH", 1, "" );
//        ftextout( text_var, 3, 60, 0, 0 );
//
//        // Steigung VL
//        ftextout( "Steigung VL", 5, 1, 0, 0 );
//        ftextout( ":", 5, 25, 0, 0 );
//        // Steigung
//        INPAapiResultAnalog( steigung_vl, "STAT_STEIGUNG_VL_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        //analogout( steigung_vl, 5, 27, -32767, 32767, -32767, 32767, "" );
//        // Einheit [digits/m]
//        steigung_vl_phys = (steigung_vl * 5)/1023;
//        analogout( steigung_vl_phys, 5, 27, -200, 200, -200, 200, "3.2" );
//        ftextout( "mV/mm", 5, 60, 0, 0 );
//        realtostring(steigung_vl,"5.0",text_var);
//        ftextout( text_var, 5, 70, 0, 0 );
//        INPAapiResultText( text_var, "STAT_STEIGUNG_VL_EINH", 1, "" );
//        ftextout( text_var, 5, 75, 0, 0 );
//
//        // AD Wert Sensornullpunkt VR
//        ftextout( "AD-Wert Sensornullpunkt VR", 7, 1, 0, 0 );
//        ftextout( ":", 7, 25, 0, 0 );
//        // Wert
//        INPAapiResultAnalog( ad_null_vr, "STAT_AD_0_VR_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        analogout( ad_null_vr, 7, 27, 0, 1024, 0, 1024, "" );
//        // Einheit [digits]
//        INPAapiResultText( text_var, "STAT_AD_0_VR_EINH", 1, "" );
//        ftextout( text_var, 7, 60, 0, 0 );
//
//        // Steigung VR
//        ftextout( "Steigung VR", 9, 1, 0, 0 );
//        ftextout( ":", 9, 25, 0, 0 );
//        // Steigung
//        INPAapiResultAnalog( steigung_vr, "STAT_STEIGUNG_VR_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        //analogout( steigung_vr, 9, 27, -32767, 32767, -32767, 32767, "" );
//        // Einheit [digits/m]
//        steigung_vr_phys = (steigung_vr * 5)/1023;
//        analogout( steigung_vr_phys, 9, 27, -200, 200, -200, 200, "3.2" );
//        ftextout( "mV/mm", 9, 60, 0, 0 );
//        realtostring(steigung_vr,"5.0",text_var);
//        ftextout( text_var, 9, 70, 0, 0 );
//        INPAapiResultText( text_var, "STAT_STEIGUNG_VR_EINH", 1, "" );
//        ftextout( text_var, 9, 75, 0, 0 );
//
//        // AD Wert Sensornullpunkt HL
//        ftextout( "AD-Wert Sensornullpunkt HL", 11, 1, 0, 0 );
//        ftextout( ":", 11, 25, 0, 0 );
//        // Wert
//        INPAapiResultAnalog( ad_null_hl, "STAT_AD_0_HL_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        analogout( ad_null_hl, 11, 27, 0, 1024, 0, 1024, "" );
//        // Einheit [digits]
//        INPAapiResultText( text_var, "STAT_AD_0_HL_EINH", 1, "" );
//        ftextout( text_var, 11, 60, 0, 0 );
//
//        // Steigung HL
//        ftextout( "Steigung HL", 13, 1, 0, 0 );
//        ftextout( ":", 13, 25, 0, 0 );
//        // Steigung
//        INPAapiResultAnalog( steigung_hl, "STAT_STEIGUNG_HL_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        //analogout( steigung_hl, 13, 27, -32767, 32767, -32767, 32767, "" );
//        // Einheit [digits/m]
//        steigung_hl_phys = (steigung_hl * 5)/1023;
//        analogout( steigung_hl_phys, 13, 27, -200, 200, -200, 200, "3.2" );
//        ftextout( "mV/mm", 13, 60, 0, 0 );
//        realtostring(steigung_hl,"5.0",text_var);
//        ftextout( text_var, 13, 70, 0, 0 );
//        INPAapiResultText( text_var, "STAT_STEIGUNG_HL_EINH", 1, "" );
//        ftextout( text_var, 13, 75, 0, 0 );
//
//        // AD Wert Sensornullpunkt HR
//        ftextout( "AD-Wert Sensornullpunkt HR", 15, 1, 0, 0 );
//        ftextout( ":", 15, 25, 0, 0 );
//        // Wert
//        INPAapiResultAnalog( ad_null_hr, "STAT_AD_0_HR_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        analogout( ad_null_hr, 15, 27, 0, 1024, 0, 1024, "" );
//        // Einheit [digits]
//        INPAapiResultText( text_var, "STAT_AD_0_HR_EINH", 1, "" );
//        ftextout( text_var, 15, 60, 0, 0 );
//
//        // Steigung HR
//        ftextout( "Steigung HR", 17, 1, 0, 0 );
//        ftextout( ":", 17, 25, 0, 0 );
//        // Steigung
//        INPAapiResultAnalog( steigung_hr, "STAT_STEIGUNG_HR_WERT", 1 );
//        //                         Zl, Sp, min  max    Format
//        //analogout( steigung_hr, 17, 27, -32767, 32767, -32767, 32767, "" );
//        // Einheit [digits/m]
//        steigung_hr_phys = (steigung_hr * 5)/1023;
//        analogout( steigung_hr_phys, 17, 27, -200, 200, -200, 200, "3.2" );
//        ftextout( "mV/mm", 17, 60, 0, 0 );
//        realtostring(steigung_hr,"5.0",text_var);
//        ftextout( text_var, 17, 70, 0, 0 );
//        INPAapiResultText( text_var, "STAT_STEIGUNG_HR_EINH", 1, "" );
//        ftextout( text_var, 17, 75, 0, 0 );
//    }
//    else if(chk_jobstatus == "ERROR: Steigung ist Null")
//    {
//        ftextout( chk_jobstatus, 2, 1, 2, 0 );
//        ftextout( "Codierung prüfen", 5, 1, 2, 0 );
//    }
//
//    ftextout("aktuelle Fahrzeughöhe",20,0,0,1);
//    // aktuelle Werte lesen
//    INPAapiJob( sgbd, "STATUS_FAHRZEUGHOEHE", "", "" );
//    INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "");
//    
//    if(chk_jobstatus == "OKAY")
//    {
//      // Wert Höhe VL
//      ftextout( "Höhenwert VL", 21, 1, 0, 0 );
//      ftextout( ":", 21, 20, 0, 0 );
//      // Wert
//      INPAapiResultText( text_var, "STAT_HOEHE_VL_WERT", 1, "" );
//      clearrect(25,27,1,10);
//      ftextout( text_var, 21, 25, 0, 0 );
//      // Einheit [mm]
//      INPAapiResultText( text_var, "STAT_HOEHE_VL_EINH", 1, "" );
//      ftextout( text_var, 21, 30, 0, 0 );
//
//      // Wert Höhe VR
//      ftextout( "Höhenwert VR", 22, 1, 0, 0 );
//      ftextout( ":", 22, 20, 0, 0 );
//      // Wert
//      INPAapiResultText( text_var, "STAT_HOEHE_VR_WERT", 1, "" );
//      clearrect(26,27,1,10);
//      ftextout( text_var, 22, 25, 0, 0 );
//      // Einheit [mm]
//      INPAapiResultText( text_var, "STAT_HOEHE_VR_EINH", 1, "" );
//      ftextout( text_var, 22, 30, 0, 0 );
//
//      // Wert Höhe HL
//      ftextout( "Höhenwert HL", 23, 1, 0, 0 );
//      ftextout( ":", 23, 20, 0, 0 );
//      // Wert
//      INPAapiResultText( text_var, "STAT_HOEHE_HL_WERT", 1, "" );
//      clearrect(27,27,1,10);
//      ftextout( text_var, 23, 25, 0, 0 );
//      // Einheit [mm]
//      INPAapiResultText( text_var, "STAT_HOEHE_HL_EINH", 1, "" );
//      ftextout( text_var, 23, 30, 0, 0 );
//
//      // Wert Höhe HR
//      ftextout( "Höhenwert HR", 24, 1, 0, 0 );
//      ftextout( ":", 24, 20, 0, 0 );
//      // Wert
//      INPAapiResultText( text_var, "STAT_HOEHE_HR_WERT", 1, "" );
//      clearrect(28,27,1,10);
//      ftextout( text_var, 24, 25, 0, 0 );
//      // Einheit [mm]
//      INPAapiResultText( text_var, "STAT_HOEHE_HR_EINH", 1, "" );
//      ftextout( text_var, 24, 30, 0, 0 );
//    }
//    else if(chk_jobstatus == "ERROR: Steigung ist Null")
//    {
//      ftextout( chk_jobstatus, 2, 1, 0, 0 );
//      ftextout( "Codierung prüfen", 5, 1, 2, 0 );
//    }
//  }
//
//  LINE( "","" )
//  {
//    if(ABGLEICHEN == TRUE)
//    {
//      ABGLEICHEN = FALSE;
//
//      input2int( abw_vl, abw_vr, "Höhenstandabgleich", "Abweichung Vorderachse:", "vorne links in mm:", "vorne rechts in mm:",-200, 200 , -200, 200);
//      getinputstate( input_state_key );
//      // Eingabe wurde mit Abbruch abgeschlossen
//      if ( input_state_key == 1 )
//      {
//        userboxclose( 0 );
//        viewclose();
//      }
//      // Eingabe wurde mit OK abgeschlossen
//      else if ( input_state_key == 0 )
//      {
//        input2int( abw_hl, abw_hr, "Höhenstandabgleich", "Abweichung Hinterachse:", "hinten links in mm:", "hinten rechts in mm:",-200, 200 , -200, 200);
//        getinputstate( input_state_key_2 );
//        // Eingabe 2 wurde mit Abbruch abgeschlossen
//        if ( input_state_key_2 == 1 )
//        {
//          userboxclose( 0 );
//          viewclose();
//        }
//        // Eingabe 2 wurde mit OK abgeschlossen
//        else if ( input_state_key_2 == 0 )
//        {
//          // Dialog schliessen
//          userboxclose( 0 );
//          viewclose();
//        }
//        // Dialog schliessen
//        userboxclose( 0 );
//        viewclose();
//      }
//
//      // nur bei OK ausfuehren
//      if ( input_state_key   == 0 
//         &&input_state_key_2 == 0)
//      {
//        inttostring(abw_vl, str_abw_vl);
//        inttostring(abw_vr, str_abw_vr);
//        inttostring(abw_hl, str_abw_hl);
//        inttostring(abw_hr, str_abw_hr);
//        INPAapiJob( sgbd, "STEUERN_ABGLEICH_HOEHENSTAND", str_abw_vl+";"+str_abw_vr+";"+str_abw_hl+";"+str_abw_hr, "" );
//      
//        INPAapiResultText( chk_jobstatus, "JOB_STATUS", 1, "" );
//        if ( chk_jobstatus == "OKAY" )
//        {
//          infobox ( "Info", "Höhenstand abgeglichen");
//          userboxclose( 0 );
//          viewclose();
//        }
//        else
//        {
//          infobox ( "Fehler", chk_jobstatus );
//          userboxclose( 0 );
//          viewclose();
//        }
//      }
//    }
//  }
//
//}


// -- EOF --
